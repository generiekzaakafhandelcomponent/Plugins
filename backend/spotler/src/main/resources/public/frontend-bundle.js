/******/ var __webpack_modules__ = ({

/***/ "../../../node_modules/@carbon/icon-helpers/es/index.js":
/*!**************************************************************!*\
  !*** ../../../node_modules/@carbon/icon-helpers/es/index.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   defaultAttributes: () => (/* binding */ defaultAttributes),
/* harmony export */   formatAttributes: () => (/* binding */ formatAttributes),
/* harmony export */   getAttributes: () => (/* binding */ getAttributes),
/* harmony export */   toSVG: () => (/* binding */ toSVG),
/* harmony export */   toString: () => (/* binding */ toString)
/* harmony export */ });
function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }

  return target;
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

function _objectWithoutProperties(source, excluded) {
  if (source == null) return {};

  var target = _objectWithoutPropertiesLoose(source, excluded);

  var key, i;

  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);

    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }

  return target;
}

var _excluded = ["width", "height", "viewBox"],
    _excluded2 = ["tabindex"];

/**
 * Copyright IBM Corp. 2018, 2018
 *
 * This source code is licensed under the Apache-2.0 license found in the
 * LICENSE file in the root directory of this source tree.
 */
var defaultAttributes = {
  // Reference:
  // https://github.com/IBM/carbon-components-react/issues/1392
  // https://github.com/PolymerElements/iron-iconset-svg/pull/47
  // `focusable` is a string attribute which is why we do not use a boolean here
  focusable: 'false',
  preserveAspectRatio: 'xMidYMid meet'
};
/**
 * Get supplementary HTML attributes for a given <svg> element based on existing
 * attributes.
 */

function getAttributes() {
  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      width = _ref.width,
      height = _ref.height,
      _ref$viewBox = _ref.viewBox,
      viewBox = _ref$viewBox === void 0 ? "0 0 ".concat(width, " ").concat(height) : _ref$viewBox,
      attributes = _objectWithoutProperties(_ref, _excluded);

  var tabindex = attributes.tabindex,
      rest = _objectWithoutProperties(attributes, _excluded2);

  var iconAttributes = _objectSpread2(_objectSpread2(_objectSpread2({}, defaultAttributes), rest), {}, {
    width: width,
    height: height,
    viewBox: viewBox
  }); // TODO: attributes.title assumes that the consumer will implement <title> and
  // correctly set `aria-labelledby`.


  if (iconAttributes['aria-label'] || iconAttributes['aria-labelledby'] || iconAttributes.title) {
    iconAttributes.role = 'img'; // Reference:
    // https://allyjs.io/tutorials/focusing-in-svg.html

    if (tabindex !== undefined && tabindex !== null) {
      iconAttributes.focusable = 'true';
      iconAttributes.tabindex = tabindex;
    }
  } else {
    iconAttributes['aria-hidden'] = true;
  }

  return iconAttributes;
}

/**
 * Copyright IBM Corp. 2018, 2018
 *
 * This source code is licensed under the Apache-2.0 license found in the
 * LICENSE file in the root directory of this source tree.
 */
/**
 * Convert an icon descriptor to a String
 */

function toString(descriptor) {
  var _descriptor$elem = descriptor.elem,
      elem = _descriptor$elem === void 0 ? 'svg' : _descriptor$elem,
      _descriptor$attrs = descriptor.attrs,
      attrs = _descriptor$attrs === void 0 ? {} : _descriptor$attrs,
      _descriptor$content = descriptor.content,
      content = _descriptor$content === void 0 ? [] : _descriptor$content;
  var children = content.map(toString).join('');

  if (elem !== 'svg') {
    return "<".concat(elem, " ").concat(formatAttributes(attrs), ">").concat(children, "</").concat(elem, ">");
  }

  return "<".concat(elem, " ").concat(formatAttributes(getAttributes(attrs)), ">").concat(children, "</").concat(elem, ">");
}
function formatAttributes(attrs) {
  return Object.keys(attrs).reduce(function (acc, key, index) {
    var attribute = "".concat(key, "=\"").concat(attrs[key], "\"");

    if (index === 0) {
      return attribute;
    }

    return acc + ' ' + attribute;
  }, '');
}

/**
 * Copyright IBM Corp. 2018, 2018
 *
 * This source code is licensed under the Apache-2.0 license found in the
 * LICENSE file in the root directory of this source tree.
 */
/**
 * Convert an icon descriptor to a DOM node.
 */

function toSVG(descriptor) {
  var _descriptor$elem = descriptor.elem,
      elem = _descriptor$elem === void 0 ? 'svg' : _descriptor$elem,
      _descriptor$attrs = descriptor.attrs,
      attrs = _descriptor$attrs === void 0 ? {} : _descriptor$attrs,
      _descriptor$content = descriptor.content,
      content = _descriptor$content === void 0 ? [] : _descriptor$content;
  var node = document.createElementNS('http://www.w3.org/2000/svg', elem);
  var attributes = elem !== 'svg' ? attrs : getAttributes(attrs);
  Object.keys(attributes).forEach(function (key) {
    node.setAttribute(key, attrs[key]);
  });

  for (var i = 0; i < content.length; i++) {
    node.appendChild(toSVG(content[i]));
  }

  return node;
}




/***/ }),

/***/ "../../../node_modules/carbon-components-angular/node_modules/@carbon/icons/es/add/16.js":
/*!***********************************************************************************************!*\
  !*** ../../../node_modules/carbon-components-angular/node_modules/@carbon/icons/es/add/16.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ _16)
/* harmony export */ });
/**
 * Copyright IBM Corp. 2016, 2020
 *
 * This source code is licensed under the Apache-2.0 license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * Code generated by @carbon/icon-build-helpers. DO NOT EDIT.
 */
var _16 = {
  "elem": "svg",
  "attrs": {
    "xmlns": "http://www.w3.org/2000/svg",
    "viewBox": "0 0 32 32",
    "fill": "currentColor",
    "width": 16,
    "height": 16
  },
  "content": [{
    "elem": "path",
    "attrs": {
      "d": "M17 15L17 8 15 8 15 15 8 15 8 17 15 17 15 24 17 24 17 17 24 17 24 15z"
    }
  }],
  "name": "add",
  "size": 16
};




/***/ }),

/***/ "../../../node_modules/carbon-components-angular/node_modules/@carbon/icons/es/add/20.js":
/*!***********************************************************************************************!*\
  !*** ../../../node_modules/carbon-components-angular/node_modules/@carbon/icons/es/add/20.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ _20)
/* harmony export */ });
/**
 * Copyright IBM Corp. 2016, 2020
 *
 * This source code is licensed under the Apache-2.0 license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * Code generated by @carbon/icon-build-helpers. DO NOT EDIT.
 */
var _20 = {
  "elem": "svg",
  "attrs": {
    "xmlns": "http://www.w3.org/2000/svg",
    "viewBox": "0 0 32 32",
    "fill": "currentColor",
    "width": 20,
    "height": 20
  },
  "content": [{
    "elem": "path",
    "attrs": {
      "d": "M17 15L17 8 15 8 15 15 8 15 8 17 15 17 15 24 17 24 17 17 24 17 24 15z"
    }
  }],
  "name": "add",
  "size": 20
};




/***/ }),

/***/ "../../../node_modules/carbon-components-angular/node_modules/@carbon/icons/es/bee/16.js":
/*!***********************************************************************************************!*\
  !*** ../../../node_modules/carbon-components-angular/node_modules/@carbon/icons/es/bee/16.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ _16)
/* harmony export */ });
/**
 * Copyright IBM Corp. 2016, 2020
 *
 * This source code is licensed under the Apache-2.0 license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * Code generated by @carbon/icon-build-helpers. DO NOT EDIT.
 */
var _16 = {
  "elem": "svg",
  "attrs": {
    "xmlns": "http://www.w3.org/2000/svg",
    "viewBox": "0 0 32 32",
    "fill": "currentColor",
    "width": 16,
    "height": 16
  },
  "content": [{
    "elem": "path",
    "attrs": {
      "d": "M16 10a6 6 0 00-6 6v8a6 6 0 0012 0V16A6 6 0 0016 10zm-4.25 7.87h8.5v4.25h-8.5zM16 28.25A4.27 4.27 0 0111.75 24v-.13h8.5V24A4.27 4.27 0 0116 28.25zm4.25-12.13h-8.5V16a4.25 4.25 0 018.5 0zM30.66 19.21L24 13v9.1a4 4 0 008 0A3.83 3.83 0 0030.66 19.21zM28 24.35a2.25 2.25 0 01-2.25-2.25V17l3.72 3.47h0A2.05 2.05 0 0130.2 22 2.25 2.25 0 0128 24.35zM0 22.1a4 4 0 008 0V13L1.34 19.21A3.88 3.88 0 000 22.1zm2.48-1.56h0L6.25 17v5.1a2.25 2.25 0 01-4.5 0A2.05 2.05 0 012.48 20.54zM15 5.5A3.5 3.5 0 1011.5 9 3.5 3.5 0 0015 5.5zm-5.25 0A1.75 1.75 0 1111.5 7.25 1.77 1.77 0 019.75 5.5zM20.5 2A3.5 3.5 0 1024 5.5 3.5 3.5 0 0020.5 2zm0 5.25A1.75 1.75 0 1122.25 5.5 1.77 1.77 0 0120.5 7.25z"
    }
  }],
  "name": "bee",
  "size": 16
};




/***/ }),

/***/ "../../../node_modules/carbon-components-angular/node_modules/@carbon/icons/es/bee/20.js":
/*!***********************************************************************************************!*\
  !*** ../../../node_modules/carbon-components-angular/node_modules/@carbon/icons/es/bee/20.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ _20)
/* harmony export */ });
/**
 * Copyright IBM Corp. 2016, 2020
 *
 * This source code is licensed under the Apache-2.0 license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * Code generated by @carbon/icon-build-helpers. DO NOT EDIT.
 */
var _20 = {
  "elem": "svg",
  "attrs": {
    "xmlns": "http://www.w3.org/2000/svg",
    "viewBox": "0 0 32 32",
    "fill": "currentColor",
    "width": 20,
    "height": 20
  },
  "content": [{
    "elem": "path",
    "attrs": {
      "d": "M16 10a6 6 0 00-6 6v8a6 6 0 0012 0V16A6 6 0 0016 10zm-4.25 7.87h8.5v4.25h-8.5zM16 28.25A4.27 4.27 0 0111.75 24v-.13h8.5V24A4.27 4.27 0 0116 28.25zm4.25-12.13h-8.5V16a4.25 4.25 0 018.5 0zM30.66 19.21L24 13v9.1a4 4 0 008 0A3.83 3.83 0 0030.66 19.21zM28 24.35a2.25 2.25 0 01-2.25-2.25V17l3.72 3.47h0A2.05 2.05 0 0130.2 22 2.25 2.25 0 0128 24.35zM0 22.1a4 4 0 008 0V13L1.34 19.21A3.88 3.88 0 000 22.1zm2.48-1.56h0L6.25 17v5.1a2.25 2.25 0 01-4.5 0A2.05 2.05 0 012.48 20.54zM15 5.5A3.5 3.5 0 1011.5 9 3.5 3.5 0 0015 5.5zm-5.25 0A1.75 1.75 0 1111.5 7.25 1.77 1.77 0 019.75 5.5zM20.5 2A3.5 3.5 0 1024 5.5 3.5 3.5 0 0020.5 2zm0 5.25A1.75 1.75 0 1122.25 5.5 1.77 1.77 0 0120.5 7.25z"
    }
  }],
  "name": "bee",
  "size": 20
};




/***/ }),

/***/ "../../../node_modules/carbon-components-angular/node_modules/@carbon/icons/es/calendar/16.js":
/*!****************************************************************************************************!*\
  !*** ../../../node_modules/carbon-components-angular/node_modules/@carbon/icons/es/calendar/16.js ***!
  \****************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ _16)
/* harmony export */ });
/**
 * Copyright IBM Corp. 2016, 2020
 *
 * This source code is licensed under the Apache-2.0 license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * Code generated by @carbon/icon-build-helpers. DO NOT EDIT.
 */
var _16 = {
  "elem": "svg",
  "attrs": {
    "xmlns": "http://www.w3.org/2000/svg",
    "viewBox": "0 0 32 32",
    "fill": "currentColor",
    "width": 16,
    "height": 16
  },
  "content": [{
    "elem": "path",
    "attrs": {
      "d": "M26,4h-4V2h-2v2h-8V2h-2v2H6C4.9,4,4,4.9,4,6v20c0,1.1,0.9,2,2,2h20c1.1,0,2-0.9,2-2V6C28,4.9,27.1,4,26,4z M26,26H6V12h20\tV26z M26,10H6V6h4v2h2V6h8v2h2V6h4V10z"
    }
  }],
  "name": "calendar",
  "size": 16
};




/***/ }),

/***/ "../../../node_modules/carbon-components-angular/node_modules/@carbon/icons/es/carbon/16.js":
/*!**************************************************************************************************!*\
  !*** ../../../node_modules/carbon-components-angular/node_modules/@carbon/icons/es/carbon/16.js ***!
  \**************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ _16)
/* harmony export */ });
/**
 * Copyright IBM Corp. 2016, 2020
 *
 * This source code is licensed under the Apache-2.0 license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * Code generated by @carbon/icon-build-helpers. DO NOT EDIT.
 */
var _16 = {
  "elem": "svg",
  "attrs": {
    "xmlns": "http://www.w3.org/2000/svg",
    "viewBox": "0 0 32 32",
    "fill": "currentColor",
    "width": 16,
    "height": 16
  },
  "content": [{
    "elem": "path",
    "attrs": {
      "d": "M13.5,30.8149a1.0011,1.0011,0,0,1-.4927-.13l-8.5-4.815A1,1,0,0,1,4,25V15a1,1,0,0,1,.5073-.87l8.5-4.815a1.0013,1.0013,0,0,1,.9854,0l8.5,4.815A1,1,0,0,1,23,15V25a1,1,0,0,1-.5073.87l-8.5,4.815A1.0011,1.0011,0,0,1,13.5,30.8149ZM6,24.417l7.5,4.2485L21,24.417V15.583l-7.5-4.2485L6,15.583Z"
    }
  }, {
    "elem": "path",
    "attrs": {
      "d": "M28,17H26V7.583L18.5,3.3345,10.4927,7.87,9.5073,6.13l8.5-4.815a1.0013,1.0013,0,0,1,.9854,0l8.5,4.815A1,1,0,0,1,28,7Z"
    }
  }],
  "name": "carbon",
  "size": 16
};




/***/ }),

/***/ "../../../node_modules/carbon-components-angular/node_modules/@carbon/icons/es/carbon/20.js":
/*!**************************************************************************************************!*\
  !*** ../../../node_modules/carbon-components-angular/node_modules/@carbon/icons/es/carbon/20.js ***!
  \**************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ _20)
/* harmony export */ });
/**
 * Copyright IBM Corp. 2016, 2020
 *
 * This source code is licensed under the Apache-2.0 license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * Code generated by @carbon/icon-build-helpers. DO NOT EDIT.
 */
var _20 = {
  "elem": "svg",
  "attrs": {
    "xmlns": "http://www.w3.org/2000/svg",
    "viewBox": "0 0 32 32",
    "fill": "currentColor",
    "width": 20,
    "height": 20
  },
  "content": [{
    "elem": "path",
    "attrs": {
      "d": "M13.5,30.8149a1.0011,1.0011,0,0,1-.4927-.13l-8.5-4.815A1,1,0,0,1,4,25V15a1,1,0,0,1,.5073-.87l8.5-4.815a1.0013,1.0013,0,0,1,.9854,0l8.5,4.815A1,1,0,0,1,23,15V25a1,1,0,0,1-.5073.87l-8.5,4.815A1.0011,1.0011,0,0,1,13.5,30.8149ZM6,24.417l7.5,4.2485L21,24.417V15.583l-7.5-4.2485L6,15.583Z"
    }
  }, {
    "elem": "path",
    "attrs": {
      "d": "M28,17H26V7.583L18.5,3.3345,10.4927,7.87,9.5073,6.13l8.5-4.815a1.0013,1.0013,0,0,1,.9854,0l8.5,4.815A1,1,0,0,1,28,7Z"
    }
  }],
  "name": "carbon",
  "size": 20
};




/***/ }),

/***/ "../../../node_modules/carbon-components-angular/node_modules/@carbon/icons/es/caret--down/16.js":
/*!*******************************************************************************************************!*\
  !*** ../../../node_modules/carbon-components-angular/node_modules/@carbon/icons/es/caret--down/16.js ***!
  \*******************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ _16)
/* harmony export */ });
/**
 * Copyright IBM Corp. 2016, 2020
 *
 * This source code is licensed under the Apache-2.0 license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * Code generated by @carbon/icon-build-helpers. DO NOT EDIT.
 */
var _16 = {
  "elem": "svg",
  "attrs": {
    "xmlns": "http://www.w3.org/2000/svg",
    "viewBox": "0 0 32 32",
    "fill": "currentColor",
    "width": 16,
    "height": 16
  },
  "content": [{
    "elem": "path",
    "attrs": {
      "d": "M24 12L16 22 8 12z"
    }
  }],
  "name": "caret--down",
  "size": 16
};




/***/ }),

/***/ "../../../node_modules/carbon-components-angular/node_modules/@carbon/icons/es/caret--left/16.js":
/*!*******************************************************************************************************!*\
  !*** ../../../node_modules/carbon-components-angular/node_modules/@carbon/icons/es/caret--left/16.js ***!
  \*******************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ _16)
/* harmony export */ });
/**
 * Copyright IBM Corp. 2016, 2020
 *
 * This source code is licensed under the Apache-2.0 license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * Code generated by @carbon/icon-build-helpers. DO NOT EDIT.
 */
var _16 = {
  "elem": "svg",
  "attrs": {
    "xmlns": "http://www.w3.org/2000/svg",
    "viewBox": "0 0 32 32",
    "fill": "currentColor",
    "width": 16,
    "height": 16
  },
  "content": [{
    "elem": "path",
    "attrs": {
      "d": "M20 24L10 16 20 8z"
    }
  }],
  "name": "caret--left",
  "size": 16
};




/***/ }),

/***/ "../../../node_modules/carbon-components-angular/node_modules/@carbon/icons/es/caret--right/16.js":
/*!********************************************************************************************************!*\
  !*** ../../../node_modules/carbon-components-angular/node_modules/@carbon/icons/es/caret--right/16.js ***!
  \********************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ _16)
/* harmony export */ });
/**
 * Copyright IBM Corp. 2016, 2020
 *
 * This source code is licensed under the Apache-2.0 license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * Code generated by @carbon/icon-build-helpers. DO NOT EDIT.
 */
var _16 = {
  "elem": "svg",
  "attrs": {
    "xmlns": "http://www.w3.org/2000/svg",
    "viewBox": "0 0 32 32",
    "fill": "currentColor",
    "width": 16,
    "height": 16
  },
  "content": [{
    "elem": "path",
    "attrs": {
      "d": "M12 8L22 16 12 24z"
    }
  }],
  "name": "caret--right",
  "size": 16
};




/***/ }),

/***/ "../../../node_modules/carbon-components-angular/node_modules/@carbon/icons/es/caret--up/16.js":
/*!*****************************************************************************************************!*\
  !*** ../../../node_modules/carbon-components-angular/node_modules/@carbon/icons/es/caret--up/16.js ***!
  \*****************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ _16)
/* harmony export */ });
/**
 * Copyright IBM Corp. 2016, 2020
 *
 * This source code is licensed under the Apache-2.0 license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * Code generated by @carbon/icon-build-helpers. DO NOT EDIT.
 */
var _16 = {
  "elem": "svg",
  "attrs": {
    "xmlns": "http://www.w3.org/2000/svg",
    "viewBox": "0 0 32 32",
    "fill": "currentColor",
    "width": 16,
    "height": 16
  },
  "content": [{
    "elem": "path",
    "attrs": {
      "d": "M8 20L16 10 24 20z"
    }
  }],
  "name": "caret--up",
  "size": 16
};




/***/ }),

/***/ "../../../node_modules/carbon-components-angular/node_modules/@carbon/icons/es/checkmark--filled/16.js":
/*!*************************************************************************************************************!*\
  !*** ../../../node_modules/carbon-components-angular/node_modules/@carbon/icons/es/checkmark--filled/16.js ***!
  \*************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ _16)
/* harmony export */ });
/**
 * Copyright IBM Corp. 2016, 2020
 *
 * This source code is licensed under the Apache-2.0 license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * Code generated by @carbon/icon-build-helpers. DO NOT EDIT.
 */
var _16 = {
  "elem": "svg",
  "attrs": {
    "xmlns": "http://www.w3.org/2000/svg",
    "viewBox": "0 0 16 16",
    "fill": "currentColor",
    "width": 16,
    "height": 16
  },
  "content": [{
    "elem": "path",
    "attrs": {
      "d": "M8,1C4.1,1,1,4.1,1,8c0,3.9,3.1,7,7,7s7-3.1,7-7C15,4.1,11.9,1,8,1z M7,11L4.3,8.3l0.9-0.8L7,9.3l4-3.9l0.9,0.8L7,11z"
    }
  }, {
    "elem": "path",
    "attrs": {
      "d": "M7,11L4.3,8.3l0.9-0.8L7,9.3l4-3.9l0.9,0.8L7,11z",
      "data-icon-path": "inner-path",
      "opacity": "0"
    }
  }],
  "name": "checkmark--filled",
  "size": 16
};




/***/ }),

/***/ "../../../node_modules/carbon-components-angular/node_modules/@carbon/icons/es/checkmark--filled/20.js":
/*!*************************************************************************************************************!*\
  !*** ../../../node_modules/carbon-components-angular/node_modules/@carbon/icons/es/checkmark--filled/20.js ***!
  \*************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ _20)
/* harmony export */ });
/**
 * Copyright IBM Corp. 2016, 2020
 *
 * This source code is licensed under the Apache-2.0 license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * Code generated by @carbon/icon-build-helpers. DO NOT EDIT.
 */
var _20 = {
  "elem": "svg",
  "attrs": {
    "xmlns": "http://www.w3.org/2000/svg",
    "viewBox": "0 0 20 20",
    "fill": "currentColor",
    "width": 20,
    "height": 20
  },
  "content": [{
    "elem": "path",
    "attrs": {
      "d": "M10,1c-4.9,0-9,4.1-9,9s4.1,9,9,9s9-4,9-9S15,1,10,1z M8.7,13.5l-3.2-3.2l1-1l2.2,2.2l4.8-4.8l1,1L8.7,13.5z"
    }
  }, {
    "elem": "path",
    "attrs": {
      "fill": "none",
      "d": "M8.7,13.5l-3.2-3.2l1-1l2.2,2.2l4.8-4.8l1,1L8.7,13.5z",
      "data-icon-path": "inner-path",
      "opacity": "0"
    }
  }],
  "name": "checkmark--filled",
  "size": 20
};




/***/ }),

/***/ "../../../node_modules/carbon-components-angular/node_modules/@carbon/icons/es/checkmark--outline/16.js":
/*!**************************************************************************************************************!*\
  !*** ../../../node_modules/carbon-components-angular/node_modules/@carbon/icons/es/checkmark--outline/16.js ***!
  \**************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ _16)
/* harmony export */ });
/**
 * Copyright IBM Corp. 2016, 2020
 *
 * This source code is licensed under the Apache-2.0 license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * Code generated by @carbon/icon-build-helpers. DO NOT EDIT.
 */
var _16 = {
  "elem": "svg",
  "attrs": {
    "xmlns": "http://www.w3.org/2000/svg",
    "viewBox": "0 0 32 32",
    "fill": "currentColor",
    "width": 16,
    "height": 16
  },
  "content": [{
    "elem": "path",
    "attrs": {
      "d": "M14 21.414L9 16.413 10.413 15 14 18.586 21.585 11 23 12.415 14 21.414z"
    }
  }, {
    "elem": "path",
    "attrs": {
      "d": "M16,2A14,14,0,1,0,30,16,14,14,0,0,0,16,2Zm0,26A12,12,0,1,1,28,16,12,12,0,0,1,16,28Z"
    }
  }],
  "name": "checkmark--outline",
  "size": 16
};




/***/ }),

/***/ "../../../node_modules/carbon-components-angular/node_modules/@carbon/icons/es/checkmark/16.js":
/*!*****************************************************************************************************!*\
  !*** ../../../node_modules/carbon-components-angular/node_modules/@carbon/icons/es/checkmark/16.js ***!
  \*****************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ _16)
/* harmony export */ });
/**
 * Copyright IBM Corp. 2016, 2020
 *
 * This source code is licensed under the Apache-2.0 license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * Code generated by @carbon/icon-build-helpers. DO NOT EDIT.
 */
var _16 = {
  "elem": "svg",
  "attrs": {
    "xmlns": "http://www.w3.org/2000/svg",
    "viewBox": "0 0 32 32",
    "fill": "currentColor",
    "width": 16,
    "height": 16
  },
  "content": [{
    "elem": "path",
    "attrs": {
      "d": "M13 24L4 15 5.414 13.586 13 21.171 26.586 7.586 28 9 13 24z"
    }
  }],
  "name": "checkmark",
  "size": 16
};




/***/ }),

/***/ "../../../node_modules/carbon-components-angular/node_modules/@carbon/icons/es/chevron--down/16.js":
/*!*********************************************************************************************************!*\
  !*** ../../../node_modules/carbon-components-angular/node_modules/@carbon/icons/es/chevron--down/16.js ***!
  \*********************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ _16)
/* harmony export */ });
/**
 * Copyright IBM Corp. 2016, 2020
 *
 * This source code is licensed under the Apache-2.0 license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * Code generated by @carbon/icon-build-helpers. DO NOT EDIT.
 */
var _16 = {
  "elem": "svg",
  "attrs": {
    "xmlns": "http://www.w3.org/2000/svg",
    "viewBox": "0 0 16 16",
    "fill": "currentColor",
    "width": 16,
    "height": 16
  },
  "content": [{
    "elem": "path",
    "attrs": {
      "d": "M8 11L3 6 3.7 5.3 8 9.6 12.3 5.3 13 6z"
    }
  }],
  "name": "chevron--down",
  "size": 16
};




/***/ }),

/***/ "../../../node_modules/carbon-components-angular/node_modules/@carbon/icons/es/chevron--right/16.js":
/*!**********************************************************************************************************!*\
  !*** ../../../node_modules/carbon-components-angular/node_modules/@carbon/icons/es/chevron--right/16.js ***!
  \**********************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ _16)
/* harmony export */ });
/**
 * Copyright IBM Corp. 2016, 2020
 *
 * This source code is licensed under the Apache-2.0 license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * Code generated by @carbon/icon-build-helpers. DO NOT EDIT.
 */
var _16 = {
  "elem": "svg",
  "attrs": {
    "xmlns": "http://www.w3.org/2000/svg",
    "viewBox": "0 0 16 16",
    "fill": "currentColor",
    "width": 16,
    "height": 16
  },
  "content": [{
    "elem": "path",
    "attrs": {
      "d": "M11 8L6 13 5.3 12.3 9.6 8 5.3 3.7 6 3z"
    }
  }],
  "name": "chevron--right",
  "size": 16
};




/***/ }),

/***/ "../../../node_modules/carbon-components-angular/node_modules/@carbon/icons/es/circle-dash/16.js":
/*!*******************************************************************************************************!*\
  !*** ../../../node_modules/carbon-components-angular/node_modules/@carbon/icons/es/circle-dash/16.js ***!
  \*******************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ _16)
/* harmony export */ });
/**
 * Copyright IBM Corp. 2016, 2020
 *
 * This source code is licensed under the Apache-2.0 license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * Code generated by @carbon/icon-build-helpers. DO NOT EDIT.
 */
var _16 = {
  "elem": "svg",
  "attrs": {
    "xmlns": "http://www.w3.org/2000/svg",
    "viewBox": "0 0 32 32",
    "fill": "currentColor",
    "width": 16,
    "height": 16
  },
  "content": [{
    "elem": "path",
    "attrs": {
      "d": "M7.7 4.7a14.7 14.7 0 00-3 3.1L6.3 9A13.26 13.26 0 018.9 6.3zM4.6 12.3l-1.9-.6A12.51 12.51 0 002 16H4A11.48 11.48 0 014.6 12.3zM2.7 20.4a14.4 14.4 0 002 3.9l1.6-1.2a12.89 12.89 0 01-1.7-3.3zM7.8 27.3a14.4 14.4 0 003.9 2l.6-1.9A12.89 12.89 0 019 25.7zM11.7 2.7l.6 1.9A11.48 11.48 0 0116 4V2A12.51 12.51 0 0011.7 2.7zM24.2 27.3a15.18 15.18 0 003.1-3.1L25.7 23A11.53 11.53 0 0123 25.7zM27.4 19.7l1.9.6A15.47 15.47 0 0030 16H28A11.48 11.48 0 0127.4 19.7zM29.2 11.6a14.4 14.4 0 00-2-3.9L25.6 8.9a12.89 12.89 0 011.7 3.3zM24.1 4.6a14.4 14.4 0 00-3.9-2l-.6 1.9a12.89 12.89 0 013.3 1.7zM20.3 29.3l-.6-1.9A11.48 11.48 0 0116 28v2A21.42 21.42 0 0020.3 29.3z"
    }
  }],
  "name": "circle-dash",
  "size": 16
};




/***/ }),

/***/ "../../../node_modules/carbon-components-angular/node_modules/@carbon/icons/es/close/16.js":
/*!*************************************************************************************************!*\
  !*** ../../../node_modules/carbon-components-angular/node_modules/@carbon/icons/es/close/16.js ***!
  \*************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ _16)
/* harmony export */ });
/**
 * Copyright IBM Corp. 2016, 2020
 *
 * This source code is licensed under the Apache-2.0 license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * Code generated by @carbon/icon-build-helpers. DO NOT EDIT.
 */
var _16 = {
  "elem": "svg",
  "attrs": {
    "xmlns": "http://www.w3.org/2000/svg",
    "viewBox": "0 0 32 32",
    "fill": "currentColor",
    "width": 16,
    "height": 16
  },
  "content": [{
    "elem": "path",
    "attrs": {
      "d": "M24 9.4L22.6 8 16 14.6 9.4 8 8 9.4 14.6 16 8 22.6 9.4 24 16 17.4 22.6 24 24 22.6 17.4 16 24 9.4z"
    }
  }],
  "name": "close",
  "size": 16
};




/***/ }),

/***/ "../../../node_modules/carbon-components-angular/node_modules/@carbon/icons/es/close/20.js":
/*!*************************************************************************************************!*\
  !*** ../../../node_modules/carbon-components-angular/node_modules/@carbon/icons/es/close/20.js ***!
  \*************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ _20)
/* harmony export */ });
/**
 * Copyright IBM Corp. 2016, 2020
 *
 * This source code is licensed under the Apache-2.0 license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * Code generated by @carbon/icon-build-helpers. DO NOT EDIT.
 */
var _20 = {
  "elem": "svg",
  "attrs": {
    "xmlns": "http://www.w3.org/2000/svg",
    "viewBox": "0 0 32 32",
    "fill": "currentColor",
    "width": 20,
    "height": 20
  },
  "content": [{
    "elem": "path",
    "attrs": {
      "d": "M24 9.4L22.6 8 16 14.6 9.4 8 8 9.4 14.6 16 8 22.6 9.4 24 16 17.4 22.6 24 24 22.6 17.4 16 24 9.4z"
    }
  }],
  "name": "close",
  "size": 20
};




/***/ }),

/***/ "../../../node_modules/carbon-components-angular/node_modules/@carbon/icons/es/copy/16.js":
/*!************************************************************************************************!*\
  !*** ../../../node_modules/carbon-components-angular/node_modules/@carbon/icons/es/copy/16.js ***!
  \************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ _16)
/* harmony export */ });
/**
 * Copyright IBM Corp. 2016, 2020
 *
 * This source code is licensed under the Apache-2.0 license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * Code generated by @carbon/icon-build-helpers. DO NOT EDIT.
 */
var _16 = {
  "elem": "svg",
  "attrs": {
    "xmlns": "http://www.w3.org/2000/svg",
    "viewBox": "0 0 32 32",
    "fill": "currentColor",
    "width": 16,
    "height": 16
  },
  "content": [{
    "elem": "path",
    "attrs": {
      "d": "M28,10V28H10V10H28m0-2H10a2,2,0,0,0-2,2V28a2,2,0,0,0,2,2H28a2,2,0,0,0,2-2V10a2,2,0,0,0-2-2Z"
    }
  }, {
    "elem": "path",
    "attrs": {
      "d": "M4,18H2V4A2,2,0,0,1,4,2H18V4H4Z"
    }
  }],
  "name": "copy",
  "size": 16
};




/***/ }),

/***/ "../../../node_modules/carbon-components-angular/node_modules/@carbon/icons/es/copy/20.js":
/*!************************************************************************************************!*\
  !*** ../../../node_modules/carbon-components-angular/node_modules/@carbon/icons/es/copy/20.js ***!
  \************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ _20)
/* harmony export */ });
/**
 * Copyright IBM Corp. 2016, 2020
 *
 * This source code is licensed under the Apache-2.0 license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * Code generated by @carbon/icon-build-helpers. DO NOT EDIT.
 */
var _20 = {
  "elem": "svg",
  "attrs": {
    "xmlns": "http://www.w3.org/2000/svg",
    "viewBox": "0 0 32 32",
    "fill": "currentColor",
    "width": 20,
    "height": 20
  },
  "content": [{
    "elem": "path",
    "attrs": {
      "d": "M28,10V28H10V10H28m0-2H10a2,2,0,0,0-2,2V28a2,2,0,0,0,2,2H28a2,2,0,0,0,2-2V10a2,2,0,0,0-2-2Z"
    }
  }, {
    "elem": "path",
    "attrs": {
      "d": "M4,18H2V4A2,2,0,0,1,4,2H18V4H4Z"
    }
  }],
  "name": "copy",
  "size": 20
};




/***/ }),

/***/ "../../../node_modules/carbon-components-angular/node_modules/@carbon/icons/es/data--2/16.js":
/*!***************************************************************************************************!*\
  !*** ../../../node_modules/carbon-components-angular/node_modules/@carbon/icons/es/data--2/16.js ***!
  \***************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ _16)
/* harmony export */ });
/**
 * Copyright IBM Corp. 2016, 2020
 *
 * This source code is licensed under the Apache-2.0 license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * Code generated by @carbon/icon-build-helpers. DO NOT EDIT.
 */
var _16 = {
  "elem": "svg",
  "attrs": {
    "xmlns": "http://www.w3.org/2000/svg",
    "viewBox": "0 0 32 32",
    "fill": "currentColor",
    "width": 16,
    "height": 16
  },
  "content": [{
    "elem": "path",
    "attrs": {
      "d": "M4 6H15V8H4zM18 6H28V8H18zM21 12H28V14H21zM11 12H18V14H11zM4 12H8V14H4zM4 18H28V20H4zM4 24H21V26H4zM24 24H28V26H24z"
    }
  }],
  "name": "data--2",
  "size": 16
};




/***/ }),

/***/ "../../../node_modules/carbon-components-angular/node_modules/@carbon/icons/es/data--2/20.js":
/*!***************************************************************************************************!*\
  !*** ../../../node_modules/carbon-components-angular/node_modules/@carbon/icons/es/data--2/20.js ***!
  \***************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ _20)
/* harmony export */ });
/**
 * Copyright IBM Corp. 2016, 2020
 *
 * This source code is licensed under the Apache-2.0 license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * Code generated by @carbon/icon-build-helpers. DO NOT EDIT.
 */
var _20 = {
  "elem": "svg",
  "attrs": {
    "xmlns": "http://www.w3.org/2000/svg",
    "viewBox": "0 0 32 32",
    "fill": "currentColor",
    "width": 20,
    "height": 20
  },
  "content": [{
    "elem": "path",
    "attrs": {
      "d": "M4 6H15V8H4zM18 6H28V8H18zM21 12H28V14H21zM11 12H18V14H11zM4 12H8V14H4zM4 18H28V20H4zM4 24H21V26H4zM24 24H28V26H24z"
    }
  }],
  "name": "data--2",
  "size": 20
};




/***/ }),

/***/ "../../../node_modules/carbon-components-angular/node_modules/@carbon/icons/es/document/16.js":
/*!****************************************************************************************************!*\
  !*** ../../../node_modules/carbon-components-angular/node_modules/@carbon/icons/es/document/16.js ***!
  \****************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ _16)
/* harmony export */ });
/**
 * Copyright IBM Corp. 2016, 2020
 *
 * This source code is licensed under the Apache-2.0 license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * Code generated by @carbon/icon-build-helpers. DO NOT EDIT.
 */
var _16 = {
  "elem": "svg",
  "attrs": {
    "xmlns": "http://www.w3.org/2000/svg",
    "viewBox": "0 0 32 32",
    "fill": "currentColor",
    "width": 16,
    "height": 16
  },
  "content": [{
    "elem": "path",
    "attrs": {
      "d": "M25.7,9.3l-7-7C18.5,2.1,18.3,2,18,2H8C6.9,2,6,2.9,6,4v24c0,1.1,0.9,2,2,2h16c1.1,0,2-0.9,2-2V10C26,9.7,25.9,9.5,25.7,9.3\tz M18,4.4l5.6,5.6H18V4.4z M24,28H8V4h8v6c0,1.1,0.9,2,2,2h6V28z"
    }
  }, {
    "elem": "path",
    "attrs": {
      "d": "M10 22H22V24H10zM10 16H22V18H10z"
    }
  }],
  "name": "document",
  "size": 16
};




/***/ }),

/***/ "../../../node_modules/carbon-components-angular/node_modules/@carbon/icons/es/document/20.js":
/*!****************************************************************************************************!*\
  !*** ../../../node_modules/carbon-components-angular/node_modules/@carbon/icons/es/document/20.js ***!
  \****************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ _20)
/* harmony export */ });
/**
 * Copyright IBM Corp. 2016, 2020
 *
 * This source code is licensed under the Apache-2.0 license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * Code generated by @carbon/icon-build-helpers. DO NOT EDIT.
 */
var _20 = {
  "elem": "svg",
  "attrs": {
    "xmlns": "http://www.w3.org/2000/svg",
    "viewBox": "0 0 32 32",
    "fill": "currentColor",
    "width": 20,
    "height": 20
  },
  "content": [{
    "elem": "path",
    "attrs": {
      "d": "M25.7,9.3l-7-7C18.5,2.1,18.3,2,18,2H8C6.9,2,6,2.9,6,4v24c0,1.1,0.9,2,2,2h16c1.1,0,2-0.9,2-2V10C26,9.7,25.9,9.5,25.7,9.3\tz M18,4.4l5.6,5.6H18V4.4z M24,28H8V4h8v6c0,1.1,0.9,2,2,2h6V28z"
    }
  }, {
    "elem": "path",
    "attrs": {
      "d": "M10 22H22V24H10zM10 16H22V18H10z"
    }
  }],
  "name": "document",
  "size": 20
};




/***/ }),

/***/ "../../../node_modules/carbon-components-angular/node_modules/@carbon/icons/es/download/16.js":
/*!****************************************************************************************************!*\
  !*** ../../../node_modules/carbon-components-angular/node_modules/@carbon/icons/es/download/16.js ***!
  \****************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ _16)
/* harmony export */ });
/**
 * Copyright IBM Corp. 2016, 2020
 *
 * This source code is licensed under the Apache-2.0 license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * Code generated by @carbon/icon-build-helpers. DO NOT EDIT.
 */
var _16 = {
  "elem": "svg",
  "attrs": {
    "xmlns": "http://www.w3.org/2000/svg",
    "viewBox": "0 0 16 16",
    "fill": "currentColor",
    "width": 16,
    "height": 16
  },
  "content": [{
    "elem": "path",
    "attrs": {
      "d": "M13 7L12.3 6.3 8.5 10.1 8.5 1 7.5 1 7.5 10.1 3.7 6.3 3 7 8 12zM13 12v2H3v-2H2v2l0 0c0 .6.4 1 1 1h10c.6 0 1-.4 1-1l0 0v-2H13z"
    }
  }],
  "name": "download",
  "size": 16
};




/***/ }),

/***/ "../../../node_modules/carbon-components-angular/node_modules/@carbon/icons/es/error--filled/16.js":
/*!*********************************************************************************************************!*\
  !*** ../../../node_modules/carbon-components-angular/node_modules/@carbon/icons/es/error--filled/16.js ***!
  \*********************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ _16)
/* harmony export */ });
/**
 * Copyright IBM Corp. 2016, 2020
 *
 * This source code is licensed under the Apache-2.0 license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * Code generated by @carbon/icon-build-helpers. DO NOT EDIT.
 */
var _16 = {
  "elem": "svg",
  "attrs": {
    "xmlns": "http://www.w3.org/2000/svg",
    "viewBox": "0 0 16 16",
    "fill": "currentColor",
    "width": 16,
    "height": 16
  },
  "content": [{
    "elem": "path",
    "attrs": {
      "d": "M8,1C4.1,1,1,4.1,1,8s3.1,7,7,7s7-3.1,7-7S11.9,1,8,1z M10.7,11.5L4.5,5.3l0.8-0.8l6.2,6.2L10.7,11.5z"
    }
  }, {
    "elem": "path",
    "attrs": {
      "fill": "none",
      "d": "M10.7,11.5L4.5,5.3l0.8-0.8l6.2,6.2L10.7,11.5z",
      "data-icon-path": "inner-path",
      "opacity": "0"
    }
  }],
  "name": "error--filled",
  "size": 16
};




/***/ }),

/***/ "../../../node_modules/carbon-components-angular/node_modules/@carbon/icons/es/error--filled/20.js":
/*!*********************************************************************************************************!*\
  !*** ../../../node_modules/carbon-components-angular/node_modules/@carbon/icons/es/error--filled/20.js ***!
  \*********************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ _20)
/* harmony export */ });
/**
 * Copyright IBM Corp. 2016, 2020
 *
 * This source code is licensed under the Apache-2.0 license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * Code generated by @carbon/icon-build-helpers. DO NOT EDIT.
 */
var _20 = {
  "elem": "svg",
  "attrs": {
    "xmlns": "http://www.w3.org/2000/svg",
    "viewBox": "0 0 20 20",
    "fill": "currentColor",
    "width": 20,
    "height": 20
  },
  "content": [{
    "elem": "path",
    "attrs": {
      "d": "M10,1c-5,0-9,4-9,9s4,9,9,9s9-4,9-9S15,1,10,1z M13.5,14.5l-8-8l1-1l8,8L13.5,14.5z"
    }
  }, {
    "elem": "path",
    "attrs": {
      "d": "M13.5,14.5l-8-8l1-1l8,8L13.5,14.5z",
      "data-icon-path": "inner-path",
      "opacity": "0"
    }
  }],
  "name": "error--filled",
  "size": 20
};




/***/ }),

/***/ "../../../node_modules/carbon-components-angular/node_modules/@carbon/icons/es/fade/16.js":
/*!************************************************************************************************!*\
  !*** ../../../node_modules/carbon-components-angular/node_modules/@carbon/icons/es/fade/16.js ***!
  \************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ _16)
/* harmony export */ });
/**
 * Copyright IBM Corp. 2016, 2020
 *
 * This source code is licensed under the Apache-2.0 license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * Code generated by @carbon/icon-build-helpers. DO NOT EDIT.
 */
var _16 = {
  "elem": "svg",
  "attrs": {
    "xmlns": "http://www.w3.org/2000/svg",
    "viewBox": "0 0 16 16",
    "fill": "currentColor",
    "width": 16,
    "height": 16
  },
  "content": [{
    "elem": "path",
    "attrs": {
      "d": "M4.1 12.6l-.6.8c.6.5 1.3.9 2.1 1.2l.3-.9C5.3 13.4 4.7 13 4.1 12.6zM2.1 9l-1 .2c.1.8.4 1.6.8 2.3L2.8 11C2.4 10.4 2.2 9.7 2.1 9zM5.9 2.4L5.6 1.4C4.8 1.7 4.1 2.1 3.5 2.7l.6.8C4.7 3 5.3 2.6 5.9 2.4zM2.8 5L1.9 4.5C1.5 5.2 1.3 6 1.1 6.8l1 .2C2.2 6.3 2.5 5.6 2.8 5zM8 1v1c3.3 0 6 2.7 6 6s-2.7 6-6 6v1c3.9 0 7-3.1 7-7S11.9 1 8 1z"
    }
  }],
  "name": "fade",
  "size": 16
};




/***/ }),

/***/ "../../../node_modules/carbon-components-angular/node_modules/@carbon/icons/es/fade/20.js":
/*!************************************************************************************************!*\
  !*** ../../../node_modules/carbon-components-angular/node_modules/@carbon/icons/es/fade/20.js ***!
  \************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ _20)
/* harmony export */ });
/**
 * Copyright IBM Corp. 2016, 2020
 *
 * This source code is licensed under the Apache-2.0 license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * Code generated by @carbon/icon-build-helpers. DO NOT EDIT.
 */
var _20 = {
  "elem": "svg",
  "attrs": {
    "xmlns": "http://www.w3.org/2000/svg",
    "viewBox": "0 0 32 32",
    "fill": "currentColor",
    "width": 20,
    "height": 20
  },
  "content": [{
    "elem": "path",
    "attrs": {
      "d": "M8.24 25.14L7 26.67a13.79 13.79 0 004.18 2.44l.69-1.87A12 12 0 018.24 25.14zM4.19 18l-2 .41A14.09 14.09 0 003.86 23L5.59 22A12.44 12.44 0 014.19 18zM11.82 4.76l-.69-1.87A13.79 13.79 0 007 5.33L8.24 6.86A12 12 0 0111.82 4.76zM5.59 10L3.86 9a14.37 14.37 0 00-1.64 4.59l2 .34A12.05 12.05 0 015.59 10zM16 2V4a12 12 0 010 24v2A14 14 0 0016 2z"
    }
  }],
  "name": "fade",
  "size": 20
};




/***/ }),

/***/ "../../../node_modules/carbon-components-angular/node_modules/@carbon/icons/es/folder/16.js":
/*!**************************************************************************************************!*\
  !*** ../../../node_modules/carbon-components-angular/node_modules/@carbon/icons/es/folder/16.js ***!
  \**************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ _16)
/* harmony export */ });
/**
 * Copyright IBM Corp. 2016, 2020
 *
 * This source code is licensed under the Apache-2.0 license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * Code generated by @carbon/icon-build-helpers. DO NOT EDIT.
 */
var _16 = {
  "elem": "svg",
  "attrs": {
    "xmlns": "http://www.w3.org/2000/svg",
    "viewBox": "0 0 32 32",
    "fill": "currentColor",
    "width": 16,
    "height": 16
  },
  "content": [{
    "elem": "path",
    "attrs": {
      "d": "M11.17,6l3.42,3.41.58.59H28V26H4V6h7.17m0-2H4A2,2,0,0,0,2,6V26a2,2,0,0,0,2,2H28a2,2,0,0,0,2-2V10a2,2,0,0,0-2-2H16L12.59,4.59A2,2,0,0,0,11.17,4Z"
    }
  }],
  "name": "folder",
  "size": 16
};




/***/ }),

/***/ "../../../node_modules/carbon-components-angular/node_modules/@carbon/icons/es/incomplete/16.js":
/*!******************************************************************************************************!*\
  !*** ../../../node_modules/carbon-components-angular/node_modules/@carbon/icons/es/incomplete/16.js ***!
  \******************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ _16)
/* harmony export */ });
/**
 * Copyright IBM Corp. 2016, 2020
 *
 * This source code is licensed under the Apache-2.0 license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * Code generated by @carbon/icon-build-helpers. DO NOT EDIT.
 */
var _16 = {
  "elem": "svg",
  "attrs": {
    "xmlns": "http://www.w3.org/2000/svg",
    "viewBox": "0 0 32 32",
    "fill": "currentColor",
    "width": 16,
    "height": 16
  },
  "content": [{
    "elem": "path",
    "attrs": {
      "d": "M23.7642 6.8593l1.2851-1.5315A13.976 13.976 0 0020.8672 2.887l-.6836 1.8776A11.9729 11.9729 0 0123.7642 6.8593zM27.81 14l1.9677-.4128A13.8888 13.8888 0 0028.14 9.0457L26.4087 10A12.52 12.52 0 0127.81 14zM20.1836 27.2354l.6836 1.8776a13.976 13.976 0 004.1821-2.4408l-1.2851-1.5315A11.9729 11.9729 0 0120.1836 27.2354zM26.4087 22L28.14 23a14.14 14.14 0 001.6382-4.5872L27.81 18.0659A12.1519 12.1519 0 0126.4087 22zM16 30V2a14 14 0 000 28z"
    }
  }],
  "name": "incomplete",
  "size": 16
};




/***/ }),

/***/ "../../../node_modules/carbon-components-angular/node_modules/@carbon/icons/es/information--filled/16.js":
/*!***************************************************************************************************************!*\
  !*** ../../../node_modules/carbon-components-angular/node_modules/@carbon/icons/es/information--filled/16.js ***!
  \***************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ _16)
/* harmony export */ });
/**
 * Copyright IBM Corp. 2016, 2020
 *
 * This source code is licensed under the Apache-2.0 license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * Code generated by @carbon/icon-build-helpers. DO NOT EDIT.
 */
var _16 = {
  "elem": "svg",
  "attrs": {
    "xmlns": "http://www.w3.org/2000/svg",
    "viewBox": "0 0 32 32",
    "fill": "currentColor",
    "width": 16,
    "height": 16
  },
  "content": [{
    "elem": "path",
    "attrs": {
      "fill": "none",
      "d": "M16,8a1.5,1.5,0,1,1-1.5,1.5A1.5,1.5,0,0,1,16,8Zm4,13.875H17.125v-8H13v2.25h1.875v5.75H12v2.25h8Z",
      "data-icon-path": "inner-path"
    }
  }, {
    "elem": "path",
    "attrs": {
      "d": "M16,2A14,14,0,1,0,30,16,14,14,0,0,0,16,2Zm0,6a1.5,1.5,0,1,1-1.5,1.5A1.5,1.5,0,0,1,16,8Zm4,16.125H12v-2.25h2.875v-5.75H13v-2.25h4.125v8H20Z"
    }
  }],
  "name": "information--filled",
  "size": 16
};




/***/ }),

/***/ "../../../node_modules/carbon-components-angular/node_modules/@carbon/icons/es/information--filled/20.js":
/*!***************************************************************************************************************!*\
  !*** ../../../node_modules/carbon-components-angular/node_modules/@carbon/icons/es/information--filled/20.js ***!
  \***************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ _20)
/* harmony export */ });
/**
 * Copyright IBM Corp. 2016, 2020
 *
 * This source code is licensed under the Apache-2.0 license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * Code generated by @carbon/icon-build-helpers. DO NOT EDIT.
 */
var _20 = {
  "elem": "svg",
  "attrs": {
    "xmlns": "http://www.w3.org/2000/svg",
    "viewBox": "0 0 32 32",
    "fill": "currentColor",
    "width": 20,
    "height": 20
  },
  "content": [{
    "elem": "path",
    "attrs": {
      "fill": "none",
      "d": "M16,8a1.5,1.5,0,1,1-1.5,1.5A1.5,1.5,0,0,1,16,8Zm4,13.875H17.125v-8H13v2.25h1.875v5.75H12v2.25h8Z",
      "data-icon-path": "inner-path"
    }
  }, {
    "elem": "path",
    "attrs": {
      "d": "M16,2A14,14,0,1,0,30,16,14,14,0,0,0,16,2Zm0,6a1.5,1.5,0,1,1-1.5,1.5A1.5,1.5,0,0,1,16,8Zm4,16.125H12v-2.25h2.875v-5.75H13v-2.25h4.125v8H20Z"
    }
  }],
  "name": "information--filled",
  "size": 20
};




/***/ }),

/***/ "../../../node_modules/carbon-components-angular/node_modules/@carbon/icons/es/information--square--filled/20.js":
/*!***********************************************************************************************************************!*\
  !*** ../../../node_modules/carbon-components-angular/node_modules/@carbon/icons/es/information--square--filled/20.js ***!
  \***********************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ _20)
/* harmony export */ });
/**
 * Copyright IBM Corp. 2016, 2020
 *
 * This source code is licensed under the Apache-2.0 license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * Code generated by @carbon/icon-build-helpers. DO NOT EDIT.
 */
var _20 = {
  "elem": "svg",
  "attrs": {
    "xmlns": "http://www.w3.org/2000/svg",
    "viewBox": "0 0 32 32",
    "fill": "currentColor",
    "width": 20,
    "height": 20
  },
  "content": [{
    "elem": "path",
    "attrs": {
      "fill": "none",
      "d": "M16,8a1.5,1.5,0,1,1-1.5,1.5A1.5,1.5,0,0,1,16,8Zm4,13.875H17.125v-8H13v2.25h1.875v5.75H12v2.25h8Z",
      "data-icon-path": "inner-path"
    }
  }, {
    "elem": "path",
    "attrs": {
      "d": "M26,4H6A2,2,0,0,0,4,6V26a2,2,0,0,0,2,2H26a2,2,0,0,0,2-2V6A2,2,0,0,0,26,4ZM16,8a1.5,1.5,0,1,1-1.5,1.5A1.5,1.5,0,0,1,16,8Zm4,16.125H12v-2.25h2.875v-5.75H13v-2.25h4.125v8H20Z"
    }
  }],
  "name": "information--square--filled",
  "size": 20
};




/***/ }),

/***/ "../../../node_modules/carbon-components-angular/node_modules/@carbon/icons/es/menu/16.js":
/*!************************************************************************************************!*\
  !*** ../../../node_modules/carbon-components-angular/node_modules/@carbon/icons/es/menu/16.js ***!
  \************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ _16)
/* harmony export */ });
/**
 * Copyright IBM Corp. 2016, 2020
 *
 * This source code is licensed under the Apache-2.0 license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * Code generated by @carbon/icon-build-helpers. DO NOT EDIT.
 */
var _16 = {
  "elem": "svg",
  "attrs": {
    "xmlns": "http://www.w3.org/2000/svg",
    "viewBox": "0 0 16 16",
    "fill": "currentColor",
    "width": 16,
    "height": 16
  },
  "content": [{
    "elem": "path",
    "attrs": {
      "d": "M2 12H14V13H2zM2 9H14V10H2zM2 6H14V7H2zM2 3H14V4H2z"
    }
  }],
  "name": "menu",
  "size": 16
};




/***/ }),

/***/ "../../../node_modules/carbon-components-angular/node_modules/@carbon/icons/es/menu/20.js":
/*!************************************************************************************************!*\
  !*** ../../../node_modules/carbon-components-angular/node_modules/@carbon/icons/es/menu/20.js ***!
  \************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ _20)
/* harmony export */ });
/**
 * Copyright IBM Corp. 2016, 2020
 *
 * This source code is licensed under the Apache-2.0 license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * Code generated by @carbon/icon-build-helpers. DO NOT EDIT.
 */
var _20 = {
  "elem": "svg",
  "attrs": {
    "xmlns": "http://www.w3.org/2000/svg",
    "viewBox": "0 0 20 20",
    "fill": "currentColor",
    "width": 20,
    "height": 20
  },
  "content": [{
    "elem": "path",
    "attrs": {
      "d": "M2 14.8H18V16H2zM2 11.2H18V12.399999999999999H2zM2 7.6H18V8.799999999999999H2zM2 4H18V5.2H2z"
    }
  }],
  "name": "menu",
  "size": 20
};




/***/ }),

/***/ "../../../node_modules/carbon-components-angular/node_modules/@carbon/icons/es/overflow-menu--horizontal/16.js":
/*!*********************************************************************************************************************!*\
  !*** ../../../node_modules/carbon-components-angular/node_modules/@carbon/icons/es/overflow-menu--horizontal/16.js ***!
  \*********************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ _16)
/* harmony export */ });
/**
 * Copyright IBM Corp. 2016, 2020
 *
 * This source code is licensed under the Apache-2.0 license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * Code generated by @carbon/icon-build-helpers. DO NOT EDIT.
 */
var _16 = {
  "elem": "svg",
  "attrs": {
    "xmlns": "http://www.w3.org/2000/svg",
    "viewBox": "0 0 32 32",
    "fill": "currentColor",
    "width": 16,
    "height": 16
  },
  "content": [{
    "elem": "circle",
    "attrs": {
      "cx": "8",
      "cy": "16",
      "r": "2"
    }
  }, {
    "elem": "circle",
    "attrs": {
      "cx": "16",
      "cy": "16",
      "r": "2"
    }
  }, {
    "elem": "circle",
    "attrs": {
      "cx": "24",
      "cy": "16",
      "r": "2"
    }
  }],
  "name": "overflow-menu--horizontal",
  "size": 16
};




/***/ }),

/***/ "../../../node_modules/carbon-components-angular/node_modules/@carbon/icons/es/overflow-menu--vertical/16.js":
/*!*******************************************************************************************************************!*\
  !*** ../../../node_modules/carbon-components-angular/node_modules/@carbon/icons/es/overflow-menu--vertical/16.js ***!
  \*******************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ _16)
/* harmony export */ });
/**
 * Copyright IBM Corp. 2016, 2020
 *
 * This source code is licensed under the Apache-2.0 license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * Code generated by @carbon/icon-build-helpers. DO NOT EDIT.
 */
var _16 = {
  "elem": "svg",
  "attrs": {
    "xmlns": "http://www.w3.org/2000/svg",
    "viewBox": "0 0 32 32",
    "fill": "currentColor",
    "width": 16,
    "height": 16
  },
  "content": [{
    "elem": "circle",
    "attrs": {
      "cx": "16",
      "cy": "8",
      "r": "2"
    }
  }, {
    "elem": "circle",
    "attrs": {
      "cx": "16",
      "cy": "16",
      "r": "2"
    }
  }, {
    "elem": "circle",
    "attrs": {
      "cx": "16",
      "cy": "24",
      "r": "2"
    }
  }],
  "name": "overflow-menu--vertical",
  "size": 16
};




/***/ }),

/***/ "../../../node_modules/carbon-components-angular/node_modules/@carbon/icons/es/save/16.js":
/*!************************************************************************************************!*\
  !*** ../../../node_modules/carbon-components-angular/node_modules/@carbon/icons/es/save/16.js ***!
  \************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ _16)
/* harmony export */ });
/**
 * Copyright IBM Corp. 2016, 2020
 *
 * This source code is licensed under the Apache-2.0 license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * Code generated by @carbon/icon-build-helpers. DO NOT EDIT.
 */
var _16 = {
  "elem": "svg",
  "attrs": {
    "xmlns": "http://www.w3.org/2000/svg",
    "viewBox": "0 0 16 16",
    "fill": "currentColor",
    "width": 16,
    "height": 16
  },
  "content": [{
    "elem": "path",
    "attrs": {
      "d": "M13.9,4.6l-2.5-2.5C11.3,2.1,11.1,2,11,2H3C2.4,2,2,2.4,2,3v10c0,0.6,0.4,1,1,1h10c0.6,0,1-0.4,1-1V5\tC14,4.9,13.9,4.7,13.9,4.6z M6,3h4v2H6V3z M10,13H6V9h4V13z M11,13V9c0-0.6-0.4-1-1-1H6C5.4,8,5,8.4,5,9v4H3V3h2v2c0,0.6,0.4,1,1,1\th4c0.6,0,1-0.4,1-1V3.2l2,2V13H11z"
    }
  }],
  "name": "save",
  "size": 16
};




/***/ }),

/***/ "../../../node_modules/carbon-components-angular/node_modules/@carbon/icons/es/search/16.js":
/*!**************************************************************************************************!*\
  !*** ../../../node_modules/carbon-components-angular/node_modules/@carbon/icons/es/search/16.js ***!
  \**************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ _16)
/* harmony export */ });
/**
 * Copyright IBM Corp. 2016, 2020
 *
 * This source code is licensed under the Apache-2.0 license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * Code generated by @carbon/icon-build-helpers. DO NOT EDIT.
 */
var _16 = {
  "elem": "svg",
  "attrs": {
    "xmlns": "http://www.w3.org/2000/svg",
    "viewBox": "0 0 16 16",
    "fill": "currentColor",
    "width": 16,
    "height": 16
  },
  "content": [{
    "elem": "path",
    "attrs": {
      "d": "M15,14.3L10.7,10c1.9-2.3,1.6-5.8-0.7-7.7S4.2,0.7,2.3,3S0.7,8.8,3,10.7c2,1.7,5,1.7,7,0l4.3,4.3L15,14.3z M2,6.5\tC2,4,4,2,6.5,2S11,4,11,6.5S9,11,6.5,11S2,9,2,6.5z"
    }
  }],
  "name": "search",
  "size": 16
};




/***/ }),

/***/ "../../../node_modules/carbon-components-angular/node_modules/@carbon/icons/es/settings--adjust/16.js":
/*!************************************************************************************************************!*\
  !*** ../../../node_modules/carbon-components-angular/node_modules/@carbon/icons/es/settings--adjust/16.js ***!
  \************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ _16)
/* harmony export */ });
/**
 * Copyright IBM Corp. 2016, 2020
 *
 * This source code is licensed under the Apache-2.0 license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * Code generated by @carbon/icon-build-helpers. DO NOT EDIT.
 */
var _16 = {
  "elem": "svg",
  "attrs": {
    "xmlns": "http://www.w3.org/2000/svg",
    "viewBox": "0 0 32 32",
    "fill": "currentColor",
    "width": 16,
    "height": 16
  },
  "content": [{
    "elem": "path",
    "attrs": {
      "d": "M30 8h-4.1c-.5-2.3-2.5-4-4.9-4s-4.4 1.7-4.9 4H2v2h14.1c.5 2.3 2.5 4 4.9 4s4.4-1.7 4.9-4H30V8zM21 12c-1.7 0-3-1.3-3-3s1.3-3 3-3 3 1.3 3 3S22.7 12 21 12zM2 24h4.1c.5 2.3 2.5 4 4.9 4s4.4-1.7 4.9-4H30v-2H15.9c-.5-2.3-2.5-4-4.9-4s-4.4 1.7-4.9 4H2V24zM11 20c1.7 0 3 1.3 3 3s-1.3 3-3 3-3-1.3-3-3S9.3 20 11 20z"
    }
  }],
  "name": "settings--adjust",
  "size": 16
};




/***/ }),

/***/ "../../../node_modules/carbon-components-angular/node_modules/@carbon/icons/es/settings/16.js":
/*!****************************************************************************************************!*\
  !*** ../../../node_modules/carbon-components-angular/node_modules/@carbon/icons/es/settings/16.js ***!
  \****************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ _16)
/* harmony export */ });
/**
 * Copyright IBM Corp. 2016, 2020
 *
 * This source code is licensed under the Apache-2.0 license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * Code generated by @carbon/icon-build-helpers. DO NOT EDIT.
 */
var _16 = {
  "elem": "svg",
  "attrs": {
    "xmlns": "http://www.w3.org/2000/svg",
    "viewBox": "0 0 16 16",
    "fill": "currentColor",
    "width": 16,
    "height": 16
  },
  "content": [{
    "elem": "path",
    "attrs": {
      "d": "M13.5,8.4c0-0.1,0-0.3,0-0.4c0-0.1,0-0.3,0-0.4l1-0.8c0.4-0.3,0.4-0.9,0.2-1.3l-1.2-2C13.3,3.2,13,3,12.6,3\tc-0.1,0-0.2,0-0.3,0.1l-1.2,0.4c-0.2-0.1-0.4-0.3-0.7-0.4l-0.3-1.3C10.1,1.3,9.7,1,9.2,1H6.8c-0.5,0-0.9,0.3-1,0.8L5.6,3.1\tC5.3,3.2,5.1,3.3,4.9,3.4L3.7,3C3.6,3,3.5,3,3.4,3C3,3,2.7,3.2,2.5,3.5l-1.2,2C1.1,5.9,1.2,6.4,1.6,6.8l0.9,0.9c0,0.1,0,0.3,0,0.4\tc0,0.1,0,0.3,0,0.4L1.6,9.2c-0.4,0.3-0.5,0.9-0.2,1.3l1.2,2C2.7,12.8,3,13,3.4,13c0.1,0,0.2,0,0.3-0.1l1.2-0.4\tc0.2,0.1,0.4,0.3,0.7,0.4l0.3,1.3c0.1,0.5,0.5,0.8,1,0.8h2.4c0.5,0,0.9-0.3,1-0.8l0.3-1.3c0.2-0.1,0.4-0.2,0.7-0.4l1.2,0.4\tc0.1,0,0.2,0.1,0.3,0.1c0.4,0,0.7-0.2,0.9-0.5l1.1-2c0.2-0.4,0.2-0.9-0.2-1.3L13.5,8.4z M12.6,12l-1.7-0.6c-0.4,0.3-0.9,0.6-1.4,0.8\tL9.2,14H6.8l-0.4-1.8c-0.5-0.2-0.9-0.5-1.4-0.8L3.4,12l-1.2-2l1.4-1.2c-0.1-0.5-0.1-1.1,0-1.6L2.2,6l1.2-2l1.7,0.6\tC5.5,4.2,6,4,6.5,3.8L6.8,2h2.4l0.4,1.8c0.5,0.2,0.9,0.5,1.4,0.8L12.6,4l1.2,2l-1.4,1.2c0.1,0.5,0.1,1.1,0,1.6l1.4,1.2L12.6,12z"
    }
  }, {
    "elem": "path",
    "attrs": {
      "d": "M8,11c-1.7,0-3-1.3-3-3s1.3-3,3-3s3,1.3,3,3C11,9.6,9.7,11,8,11C8,11,8,11,8,11z M8,6C6.9,6,6,6.8,6,7.9C6,7.9,6,8,6,8\tc0,1.1,0.8,2,1.9,2c0,0,0.1,0,0.1,0c1.1,0,2-0.8,2-1.9c0,0,0-0.1,0-0.1C10,6.9,9.2,6,8,6C8.1,6,8,6,8,6z"
    }
  }],
  "name": "settings",
  "size": 16
};




/***/ }),

/***/ "../../../node_modules/carbon-components-angular/node_modules/@carbon/icons/es/subtract/16.js":
/*!****************************************************************************************************!*\
  !*** ../../../node_modules/carbon-components-angular/node_modules/@carbon/icons/es/subtract/16.js ***!
  \****************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ _16)
/* harmony export */ });
/**
 * Copyright IBM Corp. 2016, 2020
 *
 * This source code is licensed under the Apache-2.0 license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * Code generated by @carbon/icon-build-helpers. DO NOT EDIT.
 */
var _16 = {
  "elem": "svg",
  "attrs": {
    "xmlns": "http://www.w3.org/2000/svg",
    "viewBox": "0 0 32 32",
    "fill": "currentColor",
    "width": 16,
    "height": 16
  },
  "content": [{
    "elem": "path",
    "attrs": {
      "d": "M8 15H24V17H8z"
    }
  }],
  "name": "subtract",
  "size": 16
};




/***/ }),

/***/ "../../../node_modules/carbon-components-angular/node_modules/@carbon/icons/es/trash-can/16.js":
/*!*****************************************************************************************************!*\
  !*** ../../../node_modules/carbon-components-angular/node_modules/@carbon/icons/es/trash-can/16.js ***!
  \*****************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ _16)
/* harmony export */ });
/**
 * Copyright IBM Corp. 2016, 2020
 *
 * This source code is licensed under the Apache-2.0 license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * Code generated by @carbon/icon-build-helpers. DO NOT EDIT.
 */
var _16 = {
  "elem": "svg",
  "attrs": {
    "xmlns": "http://www.w3.org/2000/svg",
    "viewBox": "0 0 32 32",
    "fill": "currentColor",
    "width": 16,
    "height": 16
  },
  "content": [{
    "elem": "path",
    "attrs": {
      "d": "M12 12H14V24H12zM18 12H20V24H18z"
    }
  }, {
    "elem": "path",
    "attrs": {
      "d": "M4 6V8H6V28a2 2 0 002 2H24a2 2 0 002-2V8h2V6zM8 28V8H24V28zM12 2H20V4H12z"
    }
  }],
  "name": "trash-can",
  "size": 16
};




/***/ }),

/***/ "../../../node_modules/carbon-components-angular/node_modules/@carbon/icons/es/view--off/16.js":
/*!*****************************************************************************************************!*\
  !*** ../../../node_modules/carbon-components-angular/node_modules/@carbon/icons/es/view--off/16.js ***!
  \*****************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ _16)
/* harmony export */ });
/**
 * Copyright IBM Corp. 2016, 2020
 *
 * This source code is licensed under the Apache-2.0 license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * Code generated by @carbon/icon-build-helpers. DO NOT EDIT.
 */
var _16 = {
  "elem": "svg",
  "attrs": {
    "xmlns": "http://www.w3.org/2000/svg",
    "viewBox": "0 0 16 16",
    "fill": "currentColor",
    "width": 16,
    "height": 16
  },
  "content": [{
    "elem": "path",
    "attrs": {
      "d": "M2.6,11.3l0.7-0.7C2.6,9.8,1.9,9,1.5,8c1-2.5,3.8-4.5,6.5-4.5c0.7,0,1.4,0.1,2,0.4l0.8-0.8C9.9,2.7,9,2.5,8,2.5\tC4.7,2.6,1.7,4.7,0.5,7.8c0,0.1,0,0.2,0,0.3C1,9.3,1.7,10.4,2.6,11.3z"
    }
  }, {
    "elem": "path",
    "attrs": {
      "d": "M6 7.9c.1-1 .9-1.8 1.8-1.8l.9-.9C7.2 4.7 5.5 5.6 5.1 7.2 5 7.7 5 8.3 5.1 8.8L6 7.9zM15.5 7.8c-.6-1.5-1.6-2.8-2.9-3.7L15 1.7 14.3 1 1 14.3 1.7 15l2.6-2.6c1.1.7 2.4 1 3.7 1.1 3.3-.1 6.3-2.2 7.5-5.3C15.5 8.1 15.5 7.9 15.5 7.8zM10 8c0 1.1-.9 2-2 2-.3 0-.7-.1-1-.3L9.7 7C9.9 7.3 10 7.6 10 8zM8 12.5c-1 0-2.1-.3-3-.8l1.3-1.3c1.4.9 3.2.6 4.2-.8.7-1 .7-2.4 0-3.4l1.4-1.4c1.1.8 2 1.9 2.6 3.2C13.4 10.5 10.6 12.5 8 12.5z"
    }
  }],
  "name": "view--off",
  "size": 16
};




/***/ }),

/***/ "../../../node_modules/carbon-components-angular/node_modules/@carbon/icons/es/view/16.js":
/*!************************************************************************************************!*\
  !*** ../../../node_modules/carbon-components-angular/node_modules/@carbon/icons/es/view/16.js ***!
  \************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ _16)
/* harmony export */ });
/**
 * Copyright IBM Corp. 2016, 2020
 *
 * This source code is licensed under the Apache-2.0 license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * Code generated by @carbon/icon-build-helpers. DO NOT EDIT.
 */
var _16 = {
  "elem": "svg",
  "attrs": {
    "xmlns": "http://www.w3.org/2000/svg",
    "viewBox": "0 0 16 16",
    "fill": "currentColor",
    "width": 16,
    "height": 16
  },
  "content": [{
    "elem": "path",
    "attrs": {
      "d": "M15.5,7.8C14.3,4.7,11.3,2.6,8,2.5C4.7,2.6,1.7,4.7,0.5,7.8c0,0.1,0,0.2,0,0.3c1.2,3.1,4.1,5.2,7.5,5.3\tc3.3-0.1,6.3-2.2,7.5-5.3C15.5,8.1,15.5,7.9,15.5,7.8z M8,12.5c-2.7,0-5.4-2-6.5-4.5c1-2.5,3.8-4.5,6.5-4.5s5.4,2,6.5,4.5\tC13.4,10.5,10.6,12.5,8,12.5z"
    }
  }, {
    "elem": "path",
    "attrs": {
      "d": "M8,5C6.3,5,5,6.3,5,8s1.3,3,3,3s3-1.3,3-3S9.7,5,8,5z M8,10c-1.1,0-2-0.9-2-2s0.9-2,2-2s2,0.9,2,2S9.1,10,8,10z"
    }
  }],
  "name": "view",
  "size": 16
};




/***/ }),

/***/ "../../../node_modules/carbon-components-angular/node_modules/@carbon/icons/es/warning--alt--filled/16.js":
/*!****************************************************************************************************************!*\
  !*** ../../../node_modules/carbon-components-angular/node_modules/@carbon/icons/es/warning--alt--filled/16.js ***!
  \****************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ _16)
/* harmony export */ });
/**
 * Copyright IBM Corp. 2016, 2020
 *
 * This source code is licensed under the Apache-2.0 license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * Code generated by @carbon/icon-build-helpers. DO NOT EDIT.
 */
var _16 = {
  "elem": "svg",
  "attrs": {
    "xmlns": "http://www.w3.org/2000/svg",
    "viewBox": "0 0 32 32",
    "fill": "currentColor",
    "width": 16,
    "height": 16
  },
  "content": [{
    "elem": "path",
    "attrs": {
      "fill": "none",
      "d": "M16,26a1.5,1.5,0,1,1,1.5-1.5A1.5,1.5,0,0,1,16,26Zm-1.125-5h2.25V12h-2.25Z",
      "data-icon-path": "inner-path"
    }
  }, {
    "elem": "path",
    "attrs": {
      "d": "M16.002,6.1714h-.004L4.6487,27.9966,4.6506,28H27.3494l.0019-.0034ZM14.875,12h2.25v9h-2.25ZM16,26a1.5,1.5,0,1,1,1.5-1.5A1.5,1.5,0,0,1,16,26Z"
    }
  }, {
    "elem": "path",
    "attrs": {
      "d": "M29,30H3a1,1,0,0,1-.8872-1.4614l13-25a1,1,0,0,1,1.7744,0l13,25A1,1,0,0,1,29,30ZM4.6507,28H27.3493l.002-.0033L16.002,6.1714h-.004L4.6487,27.9967Z"
    }
  }],
  "name": "warning--alt--filled",
  "size": 16
};




/***/ }),

/***/ "../../../node_modules/carbon-components-angular/node_modules/@carbon/icons/es/warning--alt--filled/20.js":
/*!****************************************************************************************************************!*\
  !*** ../../../node_modules/carbon-components-angular/node_modules/@carbon/icons/es/warning--alt--filled/20.js ***!
  \****************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ _20)
/* harmony export */ });
/**
 * Copyright IBM Corp. 2016, 2020
 *
 * This source code is licensed under the Apache-2.0 license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * Code generated by @carbon/icon-build-helpers. DO NOT EDIT.
 */
var _20 = {
  "elem": "svg",
  "attrs": {
    "xmlns": "http://www.w3.org/2000/svg",
    "viewBox": "0 0 32 32",
    "fill": "currentColor",
    "width": 20,
    "height": 20
  },
  "content": [{
    "elem": "path",
    "attrs": {
      "fill": "none",
      "d": "M16,26a1.5,1.5,0,1,1,1.5-1.5A1.5,1.5,0,0,1,16,26Zm-1.125-5h2.25V12h-2.25Z",
      "data-icon-path": "inner-path"
    }
  }, {
    "elem": "path",
    "attrs": {
      "d": "M16.002,6.1714h-.004L4.6487,27.9966,4.6506,28H27.3494l.0019-.0034ZM14.875,12h2.25v9h-2.25ZM16,26a1.5,1.5,0,1,1,1.5-1.5A1.5,1.5,0,0,1,16,26Z"
    }
  }, {
    "elem": "path",
    "attrs": {
      "d": "M29,30H3a1,1,0,0,1-.8872-1.4614l13-25a1,1,0,0,1,1.7744,0l13,25A1,1,0,0,1,29,30ZM4.6507,28H27.3493l.002-.0033L16.002,6.1714h-.004L4.6487,27.9967Z"
    }
  }],
  "name": "warning--alt--filled",
  "size": 20
};




/***/ }),

/***/ "../../../node_modules/carbon-components-angular/node_modules/@carbon/icons/es/warning--filled/16.js":
/*!***********************************************************************************************************!*\
  !*** ../../../node_modules/carbon-components-angular/node_modules/@carbon/icons/es/warning--filled/16.js ***!
  \***********************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ _16)
/* harmony export */ });
/**
 * Copyright IBM Corp. 2016, 2020
 *
 * This source code is licensed under the Apache-2.0 license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * Code generated by @carbon/icon-build-helpers. DO NOT EDIT.
 */
var _16 = {
  "elem": "svg",
  "attrs": {
    "xmlns": "http://www.w3.org/2000/svg",
    "viewBox": "0 0 16 16",
    "fill": "currentColor",
    "width": 16,
    "height": 16
  },
  "content": [{
    "elem": "path",
    "attrs": {
      "d": "M8,1C4.2,1,1,4.2,1,8s3.2,7,7,7s7-3.1,7-7S11.9,1,8,1z M7.5,4h1v5h-1C7.5,9,7.5,4,7.5,4z M8,12.2\tc-0.4,0-0.8-0.4-0.8-0.8s0.3-0.8,0.8-0.8c0.4,0,0.8,0.4,0.8,0.8S8.4,12.2,8,12.2z"
    }
  }, {
    "elem": "path",
    "attrs": {
      "d": "M7.5,4h1v5h-1C7.5,9,7.5,4,7.5,4z M8,12.2c-0.4,0-0.8-0.4-0.8-0.8s0.3-0.8,0.8-0.8\tc0.4,0,0.8,0.4,0.8,0.8S8.4,12.2,8,12.2z",
      "data-icon-path": "inner-path",
      "opacity": "0"
    }
  }],
  "name": "warning--filled",
  "size": 16
};




/***/ }),

/***/ "../../../node_modules/carbon-components-angular/node_modules/@carbon/icons/es/warning--filled/20.js":
/*!***********************************************************************************************************!*\
  !*** ../../../node_modules/carbon-components-angular/node_modules/@carbon/icons/es/warning--filled/20.js ***!
  \***********************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ _20)
/* harmony export */ });
/**
 * Copyright IBM Corp. 2016, 2020
 *
 * This source code is licensed under the Apache-2.0 license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * Code generated by @carbon/icon-build-helpers. DO NOT EDIT.
 */
var _20 = {
  "elem": "svg",
  "attrs": {
    "xmlns": "http://www.w3.org/2000/svg",
    "viewBox": "0 0 20 20",
    "fill": "currentColor",
    "width": 20,
    "height": 20
  },
  "content": [{
    "elem": "path",
    "attrs": {
      "d": "M10,1c-5,0-9,4-9,9s4,9,9,9s9-4,9-9S15,1,10,1z M9.2,5h1.5v7H9.2V5z M10,16c-0.6,0-1-0.4-1-1s0.4-1,1-1\ts1,0.4,1,1S10.6,16,10,16z"
    }
  }, {
    "elem": "path",
    "attrs": {
      "d": "M9.2,5h1.5v7H9.2V5z M10,16c-0.6,0-1-0.4-1-1s0.4-1,1-1s1,0.4,1,1S10.6,16,10,16z",
      "data-icon-path": "inner-path",
      "opacity": "0"
    }
  }],
  "name": "warning--filled",
  "size": 20
};




/***/ }),

/***/ "../../../node_modules/carbon-components-angular/node_modules/@carbon/icons/es/warning/16.js":
/*!***************************************************************************************************!*\
  !*** ../../../node_modules/carbon-components-angular/node_modules/@carbon/icons/es/warning/16.js ***!
  \***************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ _16)
/* harmony export */ });
/**
 * Copyright IBM Corp. 2016, 2020
 *
 * This source code is licensed under the Apache-2.0 license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * Code generated by @carbon/icon-build-helpers. DO NOT EDIT.
 */
var _16 = {
  "elem": "svg",
  "attrs": {
    "xmlns": "http://www.w3.org/2000/svg",
    "viewBox": "0 0 16 16",
    "fill": "currentColor",
    "width": 16,
    "height": 16
  },
  "content": [{
    "elem": "path",
    "attrs": {
      "d": "M8,1C4.1,1,1,4.1,1,8s3.1,7,7,7s7-3.1,7-7S11.9,1,8,1z M8,14c-3.3,0-6-2.7-6-6s2.7-6,6-6s6,2.7,6,6S11.3,14,8,14z"
    }
  }, {
    "elem": "path",
    "attrs": {
      "d": "M7.5 4H8.5V9H7.5zM8 10.2c-.4 0-.8.3-.8.8s.3.8.8.8c.4 0 .8-.3.8-.8S8.4 10.2 8 10.2z"
    }
  }],
  "name": "warning",
  "size": 16
};




/***/ }),

/***/ "../../../node_modules/carbon-components-angular/node_modules/@carbon/utils-position/index.js":
/*!****************************************************************************************************!*\
  !*** ../../../node_modules/carbon-components-angular/node_modules/@carbon/utils-position/index.js ***!
  \****************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   PLACEMENTS: () => (/* binding */ PLACEMENTS),
/* harmony export */   Position: () => (/* binding */ Position),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   defaultPositions: () => (/* binding */ defaultPositions),
/* harmony export */   position: () => (/* binding */ position)
/* harmony export */ });
/**
 * Utilites to manipulate the position of elements relative to other elements
 */
var _a;
var PLACEMENTS;
(function (PLACEMENTS) {
    PLACEMENTS["LEFT"] = "left";
    PLACEMENTS["RIGHT"] = "right";
    PLACEMENTS["TOP"] = "top";
    PLACEMENTS["BOTTOM"] = "bottom";
})(PLACEMENTS || (PLACEMENTS = {}));
var defaultPositions = (_a = {},
    _a[PLACEMENTS.LEFT] = function (referenceOffset, target, referenceRect) { return ({
        top: referenceOffset.top - Math.round(target.offsetHeight / 2) + Math.round(referenceRect.height / 2),
        left: Math.round(referenceOffset.left - target.offsetWidth)
    }); },
    _a[PLACEMENTS.RIGHT] = function (referenceOffset, target, referenceRect) { return ({
        top: referenceOffset.top - Math.round(target.offsetHeight / 2) + Math.round(referenceRect.height / 2),
        left: Math.round(referenceOffset.left + referenceRect.width)
    }); },
    _a[PLACEMENTS.TOP] = function (referenceOffset, target, referenceRect) { return ({
        top: Math.round(referenceOffset.top - target.offsetHeight),
        left: referenceOffset.left - Math.round(target.offsetWidth / 2) + Math.round(referenceRect.width / 2)
    }); },
    _a[PLACEMENTS.BOTTOM] = function (referenceOffset, target, referenceRect) { return ({
        top: Math.round(referenceOffset.top + referenceRect.height),
        left: referenceOffset.left - Math.round(target.offsetWidth / 2) + Math.round(referenceRect.width / 2)
    }); },
    _a);
var windowRef = typeof window !== "undefined" ? window : {
    innerHeight: 0,
    scrollY: 0,
    innerWidth: 0,
    scrollX: 0
};
var Position = /** @class */ (function () {
    function Position(positions) {
        if (positions === void 0) { positions = {}; }
        this.positions = defaultPositions;
        this.positions = Object.assign({}, defaultPositions, positions);
    }
    Position.prototype.getRelativeOffset = function (target) {
        // start with the initial element offsets
        var offsets = {
            left: target.offsetLeft,
            top: target.offsetTop
        };
        // get each static (i.e. not absolute or relative) offsetParent and sum the left/right offsets
        while (target.offsetParent && getComputedStyle(target.offsetParent).position === "static") {
            offsets.left += target.offsetLeft;
            offsets.top += target.offsetTop;
            target = target.offsetParent;
        }
        return offsets;
    };
    Position.prototype.getAbsoluteOffset = function (target) {
        var currentNode = target;
        var margins = {
            top: 0,
            left: 0
        };
        // searches for containing elements with additional margins
        while (currentNode.offsetParent) {
            var computed = getComputedStyle(currentNode.offsetParent);
            // find static elements with additional margins
            // since they tend to throw off our positioning
            // (usually this is just the body)
            if (computed.position === "static" &&
                computed.marginLeft &&
                computed.marginTop) {
                if (parseInt(computed.marginTop, 10)) {
                    margins.top += parseInt(computed.marginTop, 10);
                }
                if (parseInt(computed.marginLeft, 10)) {
                    margins.left += parseInt(computed.marginLeft, 10);
                }
            }
            currentNode = currentNode.offsetParent;
        }
        var targetRect = target.getBoundingClientRect();
        var relativeRect = document.body.getBoundingClientRect();
        return {
            top: targetRect.top - relativeRect.top + margins.top,
            left: targetRect.left - relativeRect.left + margins.left
        };
    };
    // finds the position relative to the `reference` element
    Position.prototype.findRelative = function (reference, target, placement) {
        var referenceOffset = this.getRelativeOffset(reference);
        var referenceRect = reference.getBoundingClientRect();
        return this.calculatePosition(referenceOffset, referenceRect, target, placement);
    };
    Position.prototype.findAbsolute = function (reference, target, placement) {
        var referenceOffset = this.getAbsoluteOffset(reference);
        var referenceRect = reference.getBoundingClientRect();
        return this.calculatePosition(referenceOffset, referenceRect, target, placement);
    };
    Position.prototype.findPosition = function (reference, target, placement, offsetFunction) {
        if (offsetFunction === void 0) { offsetFunction = this.getAbsoluteOffset.bind(this); }
        var referenceOffset = offsetFunction(reference);
        var referenceRect = reference.getBoundingClientRect();
        return this.calculatePosition(referenceOffset, referenceRect, target, placement);
    };
    Position.prototype.findPositionAt = function (offset, target, placement) {
        return this.calculatePosition(offset, { top: 0, left: 0, height: 0, width: 0 }, target, placement);
    };
    /**
     * Get the dimensions of an element from an AbsolutePosition and a reference element
     */
    Position.prototype.getPlacementBox = function (target, position) {
        var targetBottom = target.offsetHeight + position.top;
        var targetRight = target.offsetWidth + position.left;
        return {
            top: position.top,
            bottom: targetBottom,
            left: position.left,
            right: targetRight
        };
    };
    Position.prototype.addOffset = function (position, top, left) {
        if (top === void 0) { top = 0; }
        if (left === void 0) { left = 0; }
        return Object.assign({}, position, {
            top: position.top + top,
            left: position.left + left
        });
    };
    Position.prototype.setElement = function (element, position) {
        element.style.top = position.top + "px";
        element.style.left = position.left + "px";
    };
    Position.prototype.findBestPlacement = function (reference, target, placements, containerFunction, positionFunction) {
        var _this = this;
        if (containerFunction === void 0) { containerFunction = this.defaultContainerFunction.bind(this); }
        if (positionFunction === void 0) { positionFunction = this.findPosition.bind(this); }
        /**
         * map over the array of placements and weight them based on the percentage of visible area
         * where visible area is defined as the area not obscured by the window borders
         */
        var weightedPlacements = placements.map(function (placement) {
            var pos = positionFunction(reference, target, placement);
            var box = _this.getPlacementBox(target, pos);
            var hiddenHeight = 0;
            var hiddenWidth = 0;
            var container = containerFunction();
            // the element is exceeding from top or bottom of its container
            if (box.top < container.top) {
                hiddenHeight = container.top - box.top;
            }
            else if (box.bottom > container.height) {
                hiddenHeight = box.bottom - container.height;
            }
            // the element is exceeding from left or right of its container
            if (box.left < container.left) {
                hiddenWidth = container.left - box.left;
            }
            else if (box.right > container.width) {
                hiddenWidth = box.right - container.width;
            }
            // if one of the hidden dimensions is 0 but the other is > 0
            // we want to have a positive area, so setting the null one to 1
            if (hiddenHeight && !hiddenWidth) {
                hiddenWidth = 1;
            }
            else if (hiddenWidth && !hiddenHeight) {
                hiddenHeight = 1;
            }
            var area = target.offsetHeight * target.offsetWidth;
            var hiddenArea = hiddenHeight * hiddenWidth;
            // if visibleArea is 0 it means the element is fully outside container bounds
            // and visiblePercent will then be 0
            var visibleArea = area - hiddenArea;
            var visiblePercent = visibleArea / area;
            return {
                placement: placement,
                weight: visiblePercent
            };
        });
        // sort the placements from best to worst
        weightedPlacements.sort(function (a, b) { return b.weight - a.weight; });
        // pick the best!
        return weightedPlacements[0].placement;
    };
    Position.prototype.findBestPlacementAt = function (offset, target, placements, containerFunction) {
        var _this = this;
        if (containerFunction === void 0) { containerFunction = this.defaultContainerFunction.bind(this); }
        var positionAt = function (_, target, placement) {
            return _this.findPositionAt(offset, target, placement);
        };
        return this.findBestPlacement(null, target, placements, containerFunction, positionAt);
    };
    Position.prototype.defaultContainerFunction = function () {
        return {
            // we go with window here, because that's going to be the simple/common case
            top: 0,
            left: 0,
            height: windowRef.innerHeight,
            width: windowRef.innerWidth
        };
    };
    Position.prototype.calculatePosition = function (referenceOffset, referenceRect, target, placement) {
        if (this.positions[placement]) {
            return this.positions[placement](referenceOffset, target, referenceRect);
        }
        console.error("No function found for placement, defaulting to 0,0");
        return { left: 0, top: 0 };
    };
    return Position;
}());

var position = new Position();
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Position);
//# sourceMappingURL=../src/index.js.map

/***/ }),

/***/ "../../../node_modules/rxjs/dist/esm5/internal/NotificationFactories.js":
/*!******************************************************************************!*\
  !*** ../../../node_modules/rxjs/dist/esm5/internal/NotificationFactories.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   COMPLETE_NOTIFICATION: () => (/* binding */ COMPLETE_NOTIFICATION),
/* harmony export */   createNotification: () => (/* binding */ createNotification),
/* harmony export */   errorNotification: () => (/* binding */ errorNotification),
/* harmony export */   nextNotification: () => (/* binding */ nextNotification)
/* harmony export */ });
var COMPLETE_NOTIFICATION = (function () { return createNotification('C', undefined, undefined); })();
function errorNotification(error) {
    return createNotification('E', undefined, error);
}
function nextNotification(value) {
    return createNotification('N', value, undefined);
}
function createNotification(kind, value, error) {
    return {
        kind: kind,
        value: value,
        error: error,
    };
}
//# sourceMappingURL=NotificationFactories.js.map

/***/ }),

/***/ "../../../node_modules/rxjs/dist/esm5/internal/Observable.js":
/*!*******************************************************************!*\
  !*** ../../../node_modules/rxjs/dist/esm5/internal/Observable.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Observable: () => (/* binding */ Observable)
/* harmony export */ });
/* harmony import */ var _Subscriber__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Subscriber */ "../../../node_modules/rxjs/dist/esm5/internal/Subscriber.js");
/* harmony import */ var _Subscription__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./Subscription */ "../../../node_modules/rxjs/dist/esm5/internal/Subscription.js");
/* harmony import */ var _symbol_observable__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./symbol/observable */ "../../../node_modules/rxjs/dist/esm5/internal/symbol/observable.js");
/* harmony import */ var _util_pipe__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./util/pipe */ "../../../node_modules/rxjs/dist/esm5/internal/util/pipe.js");
/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./config */ "../../../node_modules/rxjs/dist/esm5/internal/config.js");
/* harmony import */ var _util_isFunction__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./util/isFunction */ "../../../node_modules/rxjs/dist/esm5/internal/util/isFunction.js");
/* harmony import */ var _util_errorContext__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./util/errorContext */ "../../../node_modules/rxjs/dist/esm5/internal/util/errorContext.js");







var Observable = (function () {
    function Observable(subscribe) {
        if (subscribe) {
            this._subscribe = subscribe;
        }
    }
    Observable.prototype.lift = function (operator) {
        var observable = new Observable();
        observable.source = this;
        observable.operator = operator;
        return observable;
    };
    Observable.prototype.subscribe = function (observerOrNext, error, complete) {
        var _this = this;
        var subscriber = isSubscriber(observerOrNext) ? observerOrNext : new _Subscriber__WEBPACK_IMPORTED_MODULE_0__.SafeSubscriber(observerOrNext, error, complete);
        (0,_util_errorContext__WEBPACK_IMPORTED_MODULE_1__.errorContext)(function () {
            var _a = _this, operator = _a.operator, source = _a.source;
            subscriber.add(operator
                ?
                    operator.call(subscriber, source)
                : source
                    ?
                        _this._subscribe(subscriber)
                    :
                        _this._trySubscribe(subscriber));
        });
        return subscriber;
    };
    Observable.prototype._trySubscribe = function (sink) {
        try {
            return this._subscribe(sink);
        }
        catch (err) {
            sink.error(err);
        }
    };
    Observable.prototype.forEach = function (next, promiseCtor) {
        var _this = this;
        promiseCtor = getPromiseCtor(promiseCtor);
        return new promiseCtor(function (resolve, reject) {
            var subscriber = new _Subscriber__WEBPACK_IMPORTED_MODULE_0__.SafeSubscriber({
                next: function (value) {
                    try {
                        next(value);
                    }
                    catch (err) {
                        reject(err);
                        subscriber.unsubscribe();
                    }
                },
                error: reject,
                complete: resolve,
            });
            _this.subscribe(subscriber);
        });
    };
    Observable.prototype._subscribe = function (subscriber) {
        var _a;
        return (_a = this.source) === null || _a === void 0 ? void 0 : _a.subscribe(subscriber);
    };
    Observable.prototype[_symbol_observable__WEBPACK_IMPORTED_MODULE_2__.observable] = function () {
        return this;
    };
    Observable.prototype.pipe = function () {
        var operations = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            operations[_i] = arguments[_i];
        }
        return (0,_util_pipe__WEBPACK_IMPORTED_MODULE_3__.pipeFromArray)(operations)(this);
    };
    Observable.prototype.toPromise = function (promiseCtor) {
        var _this = this;
        promiseCtor = getPromiseCtor(promiseCtor);
        return new promiseCtor(function (resolve, reject) {
            var value;
            _this.subscribe(function (x) { return (value = x); }, function (err) { return reject(err); }, function () { return resolve(value); });
        });
    };
    Observable.create = function (subscribe) {
        return new Observable(subscribe);
    };
    return Observable;
}());

function getPromiseCtor(promiseCtor) {
    var _a;
    return (_a = promiseCtor !== null && promiseCtor !== void 0 ? promiseCtor : _config__WEBPACK_IMPORTED_MODULE_4__.config.Promise) !== null && _a !== void 0 ? _a : Promise;
}
function isObserver(value) {
    return value && (0,_util_isFunction__WEBPACK_IMPORTED_MODULE_5__.isFunction)(value.next) && (0,_util_isFunction__WEBPACK_IMPORTED_MODULE_5__.isFunction)(value.error) && (0,_util_isFunction__WEBPACK_IMPORTED_MODULE_5__.isFunction)(value.complete);
}
function isSubscriber(value) {
    return (value && value instanceof _Subscriber__WEBPACK_IMPORTED_MODULE_0__.Subscriber) || (isObserver(value) && (0,_Subscription__WEBPACK_IMPORTED_MODULE_6__.isSubscription)(value));
}
//# sourceMappingURL=Observable.js.map

/***/ }),

/***/ "../../../node_modules/rxjs/dist/esm5/internal/Scheduler.js":
/*!******************************************************************!*\
  !*** ../../../node_modules/rxjs/dist/esm5/internal/Scheduler.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Scheduler: () => (/* binding */ Scheduler)
/* harmony export */ });
/* harmony import */ var _scheduler_dateTimestampProvider__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./scheduler/dateTimestampProvider */ "../../../node_modules/rxjs/dist/esm5/internal/scheduler/dateTimestampProvider.js");

var Scheduler = (function () {
    function Scheduler(schedulerActionCtor, now) {
        if (now === void 0) { now = Scheduler.now; }
        this.schedulerActionCtor = schedulerActionCtor;
        this.now = now;
    }
    Scheduler.prototype.schedule = function (work, delay, state) {
        if (delay === void 0) { delay = 0; }
        return new this.schedulerActionCtor(this, work).schedule(state, delay);
    };
    Scheduler.now = _scheduler_dateTimestampProvider__WEBPACK_IMPORTED_MODULE_0__.dateTimestampProvider.now;
    return Scheduler;
}());

//# sourceMappingURL=Scheduler.js.map

/***/ }),

/***/ "../../../node_modules/rxjs/dist/esm5/internal/Subscriber.js":
/*!*******************************************************************!*\
  !*** ../../../node_modules/rxjs/dist/esm5/internal/Subscriber.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   EMPTY_OBSERVER: () => (/* binding */ EMPTY_OBSERVER),
/* harmony export */   SafeSubscriber: () => (/* binding */ SafeSubscriber),
/* harmony export */   Subscriber: () => (/* binding */ Subscriber)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "tslib");
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(tslib__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _util_isFunction__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./util/isFunction */ "../../../node_modules/rxjs/dist/esm5/internal/util/isFunction.js");
/* harmony import */ var _Subscription__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Subscription */ "../../../node_modules/rxjs/dist/esm5/internal/Subscription.js");
/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./config */ "../../../node_modules/rxjs/dist/esm5/internal/config.js");
/* harmony import */ var _util_reportUnhandledError__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./util/reportUnhandledError */ "../../../node_modules/rxjs/dist/esm5/internal/util/reportUnhandledError.js");
/* harmony import */ var _util_noop__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./util/noop */ "../../../node_modules/rxjs/dist/esm5/internal/util/noop.js");
/* harmony import */ var _NotificationFactories__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./NotificationFactories */ "../../../node_modules/rxjs/dist/esm5/internal/NotificationFactories.js");
/* harmony import */ var _scheduler_timeoutProvider__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./scheduler/timeoutProvider */ "../../../node_modules/rxjs/dist/esm5/internal/scheduler/timeoutProvider.js");
/* harmony import */ var _util_errorContext__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./util/errorContext */ "../../../node_modules/rxjs/dist/esm5/internal/util/errorContext.js");









var Subscriber = (function (_super) {
    (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__extends)(Subscriber, _super);
    function Subscriber(destination) {
        var _this = _super.call(this) || this;
        _this.isStopped = false;
        if (destination) {
            _this.destination = destination;
            if ((0,_Subscription__WEBPACK_IMPORTED_MODULE_1__.isSubscription)(destination)) {
                destination.add(_this);
            }
        }
        else {
            _this.destination = EMPTY_OBSERVER;
        }
        return _this;
    }
    Subscriber.create = function (next, error, complete) {
        return new SafeSubscriber(next, error, complete);
    };
    Subscriber.prototype.next = function (value) {
        if (this.isStopped) {
            handleStoppedNotification((0,_NotificationFactories__WEBPACK_IMPORTED_MODULE_2__.nextNotification)(value), this);
        }
        else {
            this._next(value);
        }
    };
    Subscriber.prototype.error = function (err) {
        if (this.isStopped) {
            handleStoppedNotification((0,_NotificationFactories__WEBPACK_IMPORTED_MODULE_2__.errorNotification)(err), this);
        }
        else {
            this.isStopped = true;
            this._error(err);
        }
    };
    Subscriber.prototype.complete = function () {
        if (this.isStopped) {
            handleStoppedNotification(_NotificationFactories__WEBPACK_IMPORTED_MODULE_2__.COMPLETE_NOTIFICATION, this);
        }
        else {
            this.isStopped = true;
            this._complete();
        }
    };
    Subscriber.prototype.unsubscribe = function () {
        if (!this.closed) {
            this.isStopped = true;
            _super.prototype.unsubscribe.call(this);
            this.destination = null;
        }
    };
    Subscriber.prototype._next = function (value) {
        this.destination.next(value);
    };
    Subscriber.prototype._error = function (err) {
        try {
            this.destination.error(err);
        }
        finally {
            this.unsubscribe();
        }
    };
    Subscriber.prototype._complete = function () {
        try {
            this.destination.complete();
        }
        finally {
            this.unsubscribe();
        }
    };
    return Subscriber;
}(_Subscription__WEBPACK_IMPORTED_MODULE_1__.Subscription));

var _bind = Function.prototype.bind;
function bind(fn, thisArg) {
    return _bind.call(fn, thisArg);
}
var ConsumerObserver = (function () {
    function ConsumerObserver(partialObserver) {
        this.partialObserver = partialObserver;
    }
    ConsumerObserver.prototype.next = function (value) {
        var partialObserver = this.partialObserver;
        if (partialObserver.next) {
            try {
                partialObserver.next(value);
            }
            catch (error) {
                handleUnhandledError(error);
            }
        }
    };
    ConsumerObserver.prototype.error = function (err) {
        var partialObserver = this.partialObserver;
        if (partialObserver.error) {
            try {
                partialObserver.error(err);
            }
            catch (error) {
                handleUnhandledError(error);
            }
        }
        else {
            handleUnhandledError(err);
        }
    };
    ConsumerObserver.prototype.complete = function () {
        var partialObserver = this.partialObserver;
        if (partialObserver.complete) {
            try {
                partialObserver.complete();
            }
            catch (error) {
                handleUnhandledError(error);
            }
        }
    };
    return ConsumerObserver;
}());
var SafeSubscriber = (function (_super) {
    (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__extends)(SafeSubscriber, _super);
    function SafeSubscriber(observerOrNext, error, complete) {
        var _this = _super.call(this) || this;
        var partialObserver;
        if ((0,_util_isFunction__WEBPACK_IMPORTED_MODULE_3__.isFunction)(observerOrNext) || !observerOrNext) {
            partialObserver = {
                next: (observerOrNext !== null && observerOrNext !== void 0 ? observerOrNext : undefined),
                error: error !== null && error !== void 0 ? error : undefined,
                complete: complete !== null && complete !== void 0 ? complete : undefined,
            };
        }
        else {
            var context_1;
            if (_this && _config__WEBPACK_IMPORTED_MODULE_4__.config.useDeprecatedNextContext) {
                context_1 = Object.create(observerOrNext);
                context_1.unsubscribe = function () { return _this.unsubscribe(); };
                partialObserver = {
                    next: observerOrNext.next && bind(observerOrNext.next, context_1),
                    error: observerOrNext.error && bind(observerOrNext.error, context_1),
                    complete: observerOrNext.complete && bind(observerOrNext.complete, context_1),
                };
            }
            else {
                partialObserver = observerOrNext;
            }
        }
        _this.destination = new ConsumerObserver(partialObserver);
        return _this;
    }
    return SafeSubscriber;
}(Subscriber));

function handleUnhandledError(error) {
    if (_config__WEBPACK_IMPORTED_MODULE_4__.config.useDeprecatedSynchronousErrorHandling) {
        (0,_util_errorContext__WEBPACK_IMPORTED_MODULE_5__.captureError)(error);
    }
    else {
        (0,_util_reportUnhandledError__WEBPACK_IMPORTED_MODULE_6__.reportUnhandledError)(error);
    }
}
function defaultErrorHandler(err) {
    throw err;
}
function handleStoppedNotification(notification, subscriber) {
    var onStoppedNotification = _config__WEBPACK_IMPORTED_MODULE_4__.config.onStoppedNotification;
    onStoppedNotification && _scheduler_timeoutProvider__WEBPACK_IMPORTED_MODULE_7__.timeoutProvider.setTimeout(function () { return onStoppedNotification(notification, subscriber); });
}
var EMPTY_OBSERVER = {
    closed: true,
    next: _util_noop__WEBPACK_IMPORTED_MODULE_8__.noop,
    error: defaultErrorHandler,
    complete: _util_noop__WEBPACK_IMPORTED_MODULE_8__.noop,
};
//# sourceMappingURL=Subscriber.js.map

/***/ }),

/***/ "../../../node_modules/rxjs/dist/esm5/internal/Subscription.js":
/*!*********************************************************************!*\
  !*** ../../../node_modules/rxjs/dist/esm5/internal/Subscription.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   EMPTY_SUBSCRIPTION: () => (/* binding */ EMPTY_SUBSCRIPTION),
/* harmony export */   Subscription: () => (/* binding */ Subscription),
/* harmony export */   isSubscription: () => (/* binding */ isSubscription)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "tslib");
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(tslib__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _util_isFunction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./util/isFunction */ "../../../node_modules/rxjs/dist/esm5/internal/util/isFunction.js");
/* harmony import */ var _util_UnsubscriptionError__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./util/UnsubscriptionError */ "../../../node_modules/rxjs/dist/esm5/internal/util/UnsubscriptionError.js");
/* harmony import */ var _util_arrRemove__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./util/arrRemove */ "../../../node_modules/rxjs/dist/esm5/internal/util/arrRemove.js");




var Subscription = (function () {
    function Subscription(initialTeardown) {
        this.initialTeardown = initialTeardown;
        this.closed = false;
        this._parentage = null;
        this._finalizers = null;
    }
    Subscription.prototype.unsubscribe = function () {
        var e_1, _a, e_2, _b;
        var errors;
        if (!this.closed) {
            this.closed = true;
            var _parentage = this._parentage;
            if (_parentage) {
                this._parentage = null;
                if (Array.isArray(_parentage)) {
                    try {
                        for (var _parentage_1 = (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__values)(_parentage), _parentage_1_1 = _parentage_1.next(); !_parentage_1_1.done; _parentage_1_1 = _parentage_1.next()) {
                            var parent_1 = _parentage_1_1.value;
                            parent_1.remove(this);
                        }
                    }
                    catch (e_1_1) { e_1 = { error: e_1_1 }; }
                    finally {
                        try {
                            if (_parentage_1_1 && !_parentage_1_1.done && (_a = _parentage_1.return)) _a.call(_parentage_1);
                        }
                        finally { if (e_1) throw e_1.error; }
                    }
                }
                else {
                    _parentage.remove(this);
                }
            }
            var initialFinalizer = this.initialTeardown;
            if ((0,_util_isFunction__WEBPACK_IMPORTED_MODULE_1__.isFunction)(initialFinalizer)) {
                try {
                    initialFinalizer();
                }
                catch (e) {
                    errors = e instanceof _util_UnsubscriptionError__WEBPACK_IMPORTED_MODULE_2__.UnsubscriptionError ? e.errors : [e];
                }
            }
            var _finalizers = this._finalizers;
            if (_finalizers) {
                this._finalizers = null;
                try {
                    for (var _finalizers_1 = (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__values)(_finalizers), _finalizers_1_1 = _finalizers_1.next(); !_finalizers_1_1.done; _finalizers_1_1 = _finalizers_1.next()) {
                        var finalizer = _finalizers_1_1.value;
                        try {
                            execFinalizer(finalizer);
                        }
                        catch (err) {
                            errors = errors !== null && errors !== void 0 ? errors : [];
                            if (err instanceof _util_UnsubscriptionError__WEBPACK_IMPORTED_MODULE_2__.UnsubscriptionError) {
                                errors = (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__spreadArray)((0,tslib__WEBPACK_IMPORTED_MODULE_0__.__spreadArray)([], (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__read)(errors)), (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__read)(err.errors));
                            }
                            else {
                                errors.push(err);
                            }
                        }
                    }
                }
                catch (e_2_1) { e_2 = { error: e_2_1 }; }
                finally {
                    try {
                        if (_finalizers_1_1 && !_finalizers_1_1.done && (_b = _finalizers_1.return)) _b.call(_finalizers_1);
                    }
                    finally { if (e_2) throw e_2.error; }
                }
            }
            if (errors) {
                throw new _util_UnsubscriptionError__WEBPACK_IMPORTED_MODULE_2__.UnsubscriptionError(errors);
            }
        }
    };
    Subscription.prototype.add = function (teardown) {
        var _a;
        if (teardown && teardown !== this) {
            if (this.closed) {
                execFinalizer(teardown);
            }
            else {
                if (teardown instanceof Subscription) {
                    if (teardown.closed || teardown._hasParent(this)) {
                        return;
                    }
                    teardown._addParent(this);
                }
                (this._finalizers = (_a = this._finalizers) !== null && _a !== void 0 ? _a : []).push(teardown);
            }
        }
    };
    Subscription.prototype._hasParent = function (parent) {
        var _parentage = this._parentage;
        return _parentage === parent || (Array.isArray(_parentage) && _parentage.includes(parent));
    };
    Subscription.prototype._addParent = function (parent) {
        var _parentage = this._parentage;
        this._parentage = Array.isArray(_parentage) ? (_parentage.push(parent), _parentage) : _parentage ? [_parentage, parent] : parent;
    };
    Subscription.prototype._removeParent = function (parent) {
        var _parentage = this._parentage;
        if (_parentage === parent) {
            this._parentage = null;
        }
        else if (Array.isArray(_parentage)) {
            (0,_util_arrRemove__WEBPACK_IMPORTED_MODULE_3__.arrRemove)(_parentage, parent);
        }
    };
    Subscription.prototype.remove = function (teardown) {
        var _finalizers = this._finalizers;
        _finalizers && (0,_util_arrRemove__WEBPACK_IMPORTED_MODULE_3__.arrRemove)(_finalizers, teardown);
        if (teardown instanceof Subscription) {
            teardown._removeParent(this);
        }
    };
    Subscription.EMPTY = (function () {
        var empty = new Subscription();
        empty.closed = true;
        return empty;
    })();
    return Subscription;
}());

var EMPTY_SUBSCRIPTION = Subscription.EMPTY;
function isSubscription(value) {
    return (value instanceof Subscription ||
        (value && 'closed' in value && (0,_util_isFunction__WEBPACK_IMPORTED_MODULE_1__.isFunction)(value.remove) && (0,_util_isFunction__WEBPACK_IMPORTED_MODULE_1__.isFunction)(value.add) && (0,_util_isFunction__WEBPACK_IMPORTED_MODULE_1__.isFunction)(value.unsubscribe)));
}
function execFinalizer(finalizer) {
    if ((0,_util_isFunction__WEBPACK_IMPORTED_MODULE_1__.isFunction)(finalizer)) {
        finalizer();
    }
    else {
        finalizer.unsubscribe();
    }
}
//# sourceMappingURL=Subscription.js.map

/***/ }),

/***/ "../../../node_modules/rxjs/dist/esm5/internal/config.js":
/*!***************************************************************!*\
  !*** ../../../node_modules/rxjs/dist/esm5/internal/config.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   config: () => (/* binding */ config)
/* harmony export */ });
var config = {
    onUnhandledError: null,
    onStoppedNotification: null,
    Promise: undefined,
    useDeprecatedSynchronousErrorHandling: false,
    useDeprecatedNextContext: false,
};
//# sourceMappingURL=config.js.map

/***/ }),

/***/ "../../../node_modules/rxjs/dist/esm5/internal/observable/empty.js":
/*!*************************************************************************!*\
  !*** ../../../node_modules/rxjs/dist/esm5/internal/observable/empty.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   EMPTY: () => (/* binding */ EMPTY),
/* harmony export */   empty: () => (/* binding */ empty)
/* harmony export */ });
/* harmony import */ var _Observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Observable */ "../../../node_modules/rxjs/dist/esm5/internal/Observable.js");

var EMPTY = new _Observable__WEBPACK_IMPORTED_MODULE_0__.Observable(function (subscriber) { return subscriber.complete(); });
function empty(scheduler) {
    return scheduler ? emptyScheduled(scheduler) : EMPTY;
}
function emptyScheduled(scheduler) {
    return new _Observable__WEBPACK_IMPORTED_MODULE_0__.Observable(function (subscriber) { return scheduler.schedule(function () { return subscriber.complete(); }); });
}
//# sourceMappingURL=empty.js.map

/***/ }),

/***/ "../../../node_modules/rxjs/dist/esm5/internal/operators/OperatorSubscriber.js":
/*!*************************************************************************************!*\
  !*** ../../../node_modules/rxjs/dist/esm5/internal/operators/OperatorSubscriber.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   OperatorSubscriber: () => (/* binding */ OperatorSubscriber),
/* harmony export */   createOperatorSubscriber: () => (/* binding */ createOperatorSubscriber)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "tslib");
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(tslib__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _Subscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Subscriber */ "../../../node_modules/rxjs/dist/esm5/internal/Subscriber.js");


function createOperatorSubscriber(destination, onNext, onComplete, onError, onFinalize) {
    return new OperatorSubscriber(destination, onNext, onComplete, onError, onFinalize);
}
var OperatorSubscriber = (function (_super) {
    (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__extends)(OperatorSubscriber, _super);
    function OperatorSubscriber(destination, onNext, onComplete, onError, onFinalize, shouldUnsubscribe) {
        var _this = _super.call(this, destination) || this;
        _this.onFinalize = onFinalize;
        _this.shouldUnsubscribe = shouldUnsubscribe;
        _this._next = onNext
            ? function (value) {
                try {
                    onNext(value);
                }
                catch (err) {
                    destination.error(err);
                }
            }
            : _super.prototype._next;
        _this._error = onError
            ? function (err) {
                try {
                    onError(err);
                }
                catch (err) {
                    destination.error(err);
                }
                finally {
                    this.unsubscribe();
                }
            }
            : _super.prototype._error;
        _this._complete = onComplete
            ? function () {
                try {
                    onComplete();
                }
                catch (err) {
                    destination.error(err);
                }
                finally {
                    this.unsubscribe();
                }
            }
            : _super.prototype._complete;
        return _this;
    }
    OperatorSubscriber.prototype.unsubscribe = function () {
        var _a;
        if (!this.shouldUnsubscribe || this.shouldUnsubscribe()) {
            var closed_1 = this.closed;
            _super.prototype.unsubscribe.call(this);
            !closed_1 && ((_a = this.onFinalize) === null || _a === void 0 ? void 0 : _a.call(this));
        }
    };
    return OperatorSubscriber;
}(_Subscriber__WEBPACK_IMPORTED_MODULE_1__.Subscriber));

//# sourceMappingURL=OperatorSubscriber.js.map

/***/ }),

/***/ "../../../node_modules/rxjs/dist/esm5/internal/operators/debounceTime.js":
/*!*******************************************************************************!*\
  !*** ../../../node_modules/rxjs/dist/esm5/internal/operators/debounceTime.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   debounceTime: () => (/* binding */ debounceTime)
/* harmony export */ });
/* harmony import */ var _scheduler_async__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../scheduler/async */ "../../../node_modules/rxjs/dist/esm5/internal/scheduler/async.js");
/* harmony import */ var _util_lift__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/lift */ "../../../node_modules/rxjs/dist/esm5/internal/util/lift.js");
/* harmony import */ var _OperatorSubscriber__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./OperatorSubscriber */ "../../../node_modules/rxjs/dist/esm5/internal/operators/OperatorSubscriber.js");



function debounceTime(dueTime, scheduler) {
    if (scheduler === void 0) { scheduler = _scheduler_async__WEBPACK_IMPORTED_MODULE_0__.asyncScheduler; }
    return (0,_util_lift__WEBPACK_IMPORTED_MODULE_1__.operate)(function (source, subscriber) {
        var activeTask = null;
        var lastValue = null;
        var lastTime = null;
        var emit = function () {
            if (activeTask) {
                activeTask.unsubscribe();
                activeTask = null;
                var value = lastValue;
                lastValue = null;
                subscriber.next(value);
            }
        };
        function emitWhenIdle() {
            var targetTime = lastTime + dueTime;
            var now = scheduler.now();
            if (now < targetTime) {
                activeTask = this.schedule(undefined, targetTime - now);
                subscriber.add(activeTask);
                return;
            }
            emit();
        }
        source.subscribe((0,_OperatorSubscriber__WEBPACK_IMPORTED_MODULE_2__.createOperatorSubscriber)(subscriber, function (value) {
            lastValue = value;
            lastTime = scheduler.now();
            if (!activeTask) {
                activeTask = scheduler.schedule(emitWhenIdle, dueTime);
                subscriber.add(activeTask);
            }
        }, function () {
            emit();
            subscriber.complete();
        }, undefined, function () {
            lastValue = activeTask = null;
        }));
    });
}
//# sourceMappingURL=debounceTime.js.map

/***/ }),

/***/ "../../../node_modules/rxjs/dist/esm5/internal/operators/defaultIfEmpty.js":
/*!*********************************************************************************!*\
  !*** ../../../node_modules/rxjs/dist/esm5/internal/operators/defaultIfEmpty.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   defaultIfEmpty: () => (/* binding */ defaultIfEmpty)
/* harmony export */ });
/* harmony import */ var _util_lift__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/lift */ "../../../node_modules/rxjs/dist/esm5/internal/util/lift.js");
/* harmony import */ var _OperatorSubscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./OperatorSubscriber */ "../../../node_modules/rxjs/dist/esm5/internal/operators/OperatorSubscriber.js");


function defaultIfEmpty(defaultValue) {
    return (0,_util_lift__WEBPACK_IMPORTED_MODULE_0__.operate)(function (source, subscriber) {
        var hasValue = false;
        source.subscribe((0,_OperatorSubscriber__WEBPACK_IMPORTED_MODULE_1__.createOperatorSubscriber)(subscriber, function (value) {
            hasValue = true;
            subscriber.next(value);
        }, function () {
            if (!hasValue) {
                subscriber.next(defaultValue);
            }
            subscriber.complete();
        }));
    });
}
//# sourceMappingURL=defaultIfEmpty.js.map

/***/ }),

/***/ "../../../node_modules/rxjs/dist/esm5/internal/operators/filter.js":
/*!*************************************************************************!*\
  !*** ../../../node_modules/rxjs/dist/esm5/internal/operators/filter.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   filter: () => (/* binding */ filter)
/* harmony export */ });
/* harmony import */ var _util_lift__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/lift */ "../../../node_modules/rxjs/dist/esm5/internal/util/lift.js");
/* harmony import */ var _OperatorSubscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./OperatorSubscriber */ "../../../node_modules/rxjs/dist/esm5/internal/operators/OperatorSubscriber.js");


function filter(predicate, thisArg) {
    return (0,_util_lift__WEBPACK_IMPORTED_MODULE_0__.operate)(function (source, subscriber) {
        var index = 0;
        source.subscribe((0,_OperatorSubscriber__WEBPACK_IMPORTED_MODULE_1__.createOperatorSubscriber)(subscriber, function (value) { return predicate.call(thisArg, value, index++) && subscriber.next(value); }));
    });
}
//# sourceMappingURL=filter.js.map

/***/ }),

/***/ "../../../node_modules/rxjs/dist/esm5/internal/operators/first.js":
/*!************************************************************************!*\
  !*** ../../../node_modules/rxjs/dist/esm5/internal/operators/first.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   first: () => (/* binding */ first)
/* harmony export */ });
/* harmony import */ var _util_EmptyError__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../util/EmptyError */ "../../../node_modules/rxjs/dist/esm5/internal/util/EmptyError.js");
/* harmony import */ var _filter__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./filter */ "../../../node_modules/rxjs/dist/esm5/internal/operators/filter.js");
/* harmony import */ var _take__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./take */ "../../../node_modules/rxjs/dist/esm5/internal/operators/take.js");
/* harmony import */ var _defaultIfEmpty__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./defaultIfEmpty */ "../../../node_modules/rxjs/dist/esm5/internal/operators/defaultIfEmpty.js");
/* harmony import */ var _throwIfEmpty__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./throwIfEmpty */ "../../../node_modules/rxjs/dist/esm5/internal/operators/throwIfEmpty.js");
/* harmony import */ var _util_identity__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/identity */ "../../../node_modules/rxjs/dist/esm5/internal/util/identity.js");






function first(predicate, defaultValue) {
    var hasDefaultValue = arguments.length >= 2;
    return function (source) {
        return source.pipe(predicate ? (0,_filter__WEBPACK_IMPORTED_MODULE_0__.filter)(function (v, i) { return predicate(v, i, source); }) : _util_identity__WEBPACK_IMPORTED_MODULE_1__.identity, (0,_take__WEBPACK_IMPORTED_MODULE_2__.take)(1), hasDefaultValue ? (0,_defaultIfEmpty__WEBPACK_IMPORTED_MODULE_3__.defaultIfEmpty)(defaultValue) : (0,_throwIfEmpty__WEBPACK_IMPORTED_MODULE_4__.throwIfEmpty)(function () { return new _util_EmptyError__WEBPACK_IMPORTED_MODULE_5__.EmptyError(); }));
    };
}
//# sourceMappingURL=first.js.map

/***/ }),

/***/ "../../../node_modules/rxjs/dist/esm5/internal/operators/map.js":
/*!**********************************************************************!*\
  !*** ../../../node_modules/rxjs/dist/esm5/internal/operators/map.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   map: () => (/* binding */ map)
/* harmony export */ });
/* harmony import */ var _util_lift__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/lift */ "../../../node_modules/rxjs/dist/esm5/internal/util/lift.js");
/* harmony import */ var _OperatorSubscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./OperatorSubscriber */ "../../../node_modules/rxjs/dist/esm5/internal/operators/OperatorSubscriber.js");


function map(project, thisArg) {
    return (0,_util_lift__WEBPACK_IMPORTED_MODULE_0__.operate)(function (source, subscriber) {
        var index = 0;
        source.subscribe((0,_OperatorSubscriber__WEBPACK_IMPORTED_MODULE_1__.createOperatorSubscriber)(subscriber, function (value) {
            subscriber.next(project.call(thisArg, value, index++));
        }));
    });
}
//# sourceMappingURL=map.js.map

/***/ }),

/***/ "../../../node_modules/rxjs/dist/esm5/internal/operators/take.js":
/*!***********************************************************************!*\
  !*** ../../../node_modules/rxjs/dist/esm5/internal/operators/take.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   take: () => (/* binding */ take)
/* harmony export */ });
/* harmony import */ var _observable_empty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../observable/empty */ "../../../node_modules/rxjs/dist/esm5/internal/observable/empty.js");
/* harmony import */ var _util_lift__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/lift */ "../../../node_modules/rxjs/dist/esm5/internal/util/lift.js");
/* harmony import */ var _OperatorSubscriber__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./OperatorSubscriber */ "../../../node_modules/rxjs/dist/esm5/internal/operators/OperatorSubscriber.js");



function take(count) {
    return count <= 0
        ?
            function () { return _observable_empty__WEBPACK_IMPORTED_MODULE_0__.EMPTY; }
        : (0,_util_lift__WEBPACK_IMPORTED_MODULE_1__.operate)(function (source, subscriber) {
            var seen = 0;
            source.subscribe((0,_OperatorSubscriber__WEBPACK_IMPORTED_MODULE_2__.createOperatorSubscriber)(subscriber, function (value) {
                if (++seen <= count) {
                    subscriber.next(value);
                    if (count <= seen) {
                        subscriber.complete();
                    }
                }
            }));
        });
}
//# sourceMappingURL=take.js.map

/***/ }),

/***/ "../../../node_modules/rxjs/dist/esm5/internal/operators/throwIfEmpty.js":
/*!*******************************************************************************!*\
  !*** ../../../node_modules/rxjs/dist/esm5/internal/operators/throwIfEmpty.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   throwIfEmpty: () => (/* binding */ throwIfEmpty)
/* harmony export */ });
/* harmony import */ var _util_EmptyError__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../util/EmptyError */ "../../../node_modules/rxjs/dist/esm5/internal/util/EmptyError.js");
/* harmony import */ var _util_lift__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/lift */ "../../../node_modules/rxjs/dist/esm5/internal/util/lift.js");
/* harmony import */ var _OperatorSubscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./OperatorSubscriber */ "../../../node_modules/rxjs/dist/esm5/internal/operators/OperatorSubscriber.js");



function throwIfEmpty(errorFactory) {
    if (errorFactory === void 0) { errorFactory = defaultErrorFactory; }
    return (0,_util_lift__WEBPACK_IMPORTED_MODULE_0__.operate)(function (source, subscriber) {
        var hasValue = false;
        source.subscribe((0,_OperatorSubscriber__WEBPACK_IMPORTED_MODULE_1__.createOperatorSubscriber)(subscriber, function (value) {
            hasValue = true;
            subscriber.next(value);
        }, function () { return (hasValue ? subscriber.complete() : subscriber.error(errorFactory())); }));
    });
}
function defaultErrorFactory() {
    return new _util_EmptyError__WEBPACK_IMPORTED_MODULE_2__.EmptyError();
}
//# sourceMappingURL=throwIfEmpty.js.map

/***/ }),

/***/ "../../../node_modules/rxjs/dist/esm5/internal/scheduler/Action.js":
/*!*************************************************************************!*\
  !*** ../../../node_modules/rxjs/dist/esm5/internal/scheduler/Action.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Action: () => (/* binding */ Action)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "tslib");
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(tslib__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _Subscription__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Subscription */ "../../../node_modules/rxjs/dist/esm5/internal/Subscription.js");


var Action = (function (_super) {
    (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__extends)(Action, _super);
    function Action(scheduler, work) {
        return _super.call(this) || this;
    }
    Action.prototype.schedule = function (state, delay) {
        if (delay === void 0) { delay = 0; }
        return this;
    };
    return Action;
}(_Subscription__WEBPACK_IMPORTED_MODULE_1__.Subscription));

//# sourceMappingURL=Action.js.map

/***/ }),

/***/ "../../../node_modules/rxjs/dist/esm5/internal/scheduler/AsyncAction.js":
/*!******************************************************************************!*\
  !*** ../../../node_modules/rxjs/dist/esm5/internal/scheduler/AsyncAction.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AsyncAction: () => (/* binding */ AsyncAction)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "tslib");
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(tslib__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _Action__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Action */ "../../../node_modules/rxjs/dist/esm5/internal/scheduler/Action.js");
/* harmony import */ var _intervalProvider__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./intervalProvider */ "../../../node_modules/rxjs/dist/esm5/internal/scheduler/intervalProvider.js");
/* harmony import */ var _util_arrRemove__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../util/arrRemove */ "../../../node_modules/rxjs/dist/esm5/internal/util/arrRemove.js");




var AsyncAction = (function (_super) {
    (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__extends)(AsyncAction, _super);
    function AsyncAction(scheduler, work) {
        var _this = _super.call(this, scheduler, work) || this;
        _this.scheduler = scheduler;
        _this.work = work;
        _this.pending = false;
        return _this;
    }
    AsyncAction.prototype.schedule = function (state, delay) {
        var _a;
        if (delay === void 0) { delay = 0; }
        if (this.closed) {
            return this;
        }
        this.state = state;
        var id = this.id;
        var scheduler = this.scheduler;
        if (id != null) {
            this.id = this.recycleAsyncId(scheduler, id, delay);
        }
        this.pending = true;
        this.delay = delay;
        this.id = (_a = this.id) !== null && _a !== void 0 ? _a : this.requestAsyncId(scheduler, this.id, delay);
        return this;
    };
    AsyncAction.prototype.requestAsyncId = function (scheduler, _id, delay) {
        if (delay === void 0) { delay = 0; }
        return _intervalProvider__WEBPACK_IMPORTED_MODULE_1__.intervalProvider.setInterval(scheduler.flush.bind(scheduler, this), delay);
    };
    AsyncAction.prototype.recycleAsyncId = function (_scheduler, id, delay) {
        if (delay === void 0) { delay = 0; }
        if (delay != null && this.delay === delay && this.pending === false) {
            return id;
        }
        if (id != null) {
            _intervalProvider__WEBPACK_IMPORTED_MODULE_1__.intervalProvider.clearInterval(id);
        }
        return undefined;
    };
    AsyncAction.prototype.execute = function (state, delay) {
        if (this.closed) {
            return new Error('executing a cancelled action');
        }
        this.pending = false;
        var error = this._execute(state, delay);
        if (error) {
            return error;
        }
        else if (this.pending === false && this.id != null) {
            this.id = this.recycleAsyncId(this.scheduler, this.id, null);
        }
    };
    AsyncAction.prototype._execute = function (state, _delay) {
        var errored = false;
        var errorValue;
        try {
            this.work(state);
        }
        catch (e) {
            errored = true;
            errorValue = e ? e : new Error('Scheduled action threw falsy error');
        }
        if (errored) {
            this.unsubscribe();
            return errorValue;
        }
    };
    AsyncAction.prototype.unsubscribe = function () {
        if (!this.closed) {
            var _a = this, id = _a.id, scheduler = _a.scheduler;
            var actions = scheduler.actions;
            this.work = this.state = this.scheduler = null;
            this.pending = false;
            (0,_util_arrRemove__WEBPACK_IMPORTED_MODULE_2__.arrRemove)(actions, this);
            if (id != null) {
                this.id = this.recycleAsyncId(scheduler, id, null);
            }
            this.delay = null;
            _super.prototype.unsubscribe.call(this);
        }
    };
    return AsyncAction;
}(_Action__WEBPACK_IMPORTED_MODULE_3__.Action));

//# sourceMappingURL=AsyncAction.js.map

/***/ }),

/***/ "../../../node_modules/rxjs/dist/esm5/internal/scheduler/AsyncScheduler.js":
/*!*********************************************************************************!*\
  !*** ../../../node_modules/rxjs/dist/esm5/internal/scheduler/AsyncScheduler.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AsyncScheduler: () => (/* binding */ AsyncScheduler)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "tslib");
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(tslib__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _Scheduler__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Scheduler */ "../../../node_modules/rxjs/dist/esm5/internal/Scheduler.js");


var AsyncScheduler = (function (_super) {
    (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__extends)(AsyncScheduler, _super);
    function AsyncScheduler(SchedulerAction, now) {
        if (now === void 0) { now = _Scheduler__WEBPACK_IMPORTED_MODULE_1__.Scheduler.now; }
        var _this = _super.call(this, SchedulerAction, now) || this;
        _this.actions = [];
        _this._active = false;
        return _this;
    }
    AsyncScheduler.prototype.flush = function (action) {
        var actions = this.actions;
        if (this._active) {
            actions.push(action);
            return;
        }
        var error;
        this._active = true;
        do {
            if ((error = action.execute(action.state, action.delay))) {
                break;
            }
        } while ((action = actions.shift()));
        this._active = false;
        if (error) {
            while ((action = actions.shift())) {
                action.unsubscribe();
            }
            throw error;
        }
    };
    return AsyncScheduler;
}(_Scheduler__WEBPACK_IMPORTED_MODULE_1__.Scheduler));

//# sourceMappingURL=AsyncScheduler.js.map

/***/ }),

/***/ "../../../node_modules/rxjs/dist/esm5/internal/scheduler/async.js":
/*!************************************************************************!*\
  !*** ../../../node_modules/rxjs/dist/esm5/internal/scheduler/async.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   async: () => (/* binding */ async),
/* harmony export */   asyncScheduler: () => (/* binding */ asyncScheduler)
/* harmony export */ });
/* harmony import */ var _AsyncAction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./AsyncAction */ "../../../node_modules/rxjs/dist/esm5/internal/scheduler/AsyncAction.js");
/* harmony import */ var _AsyncScheduler__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./AsyncScheduler */ "../../../node_modules/rxjs/dist/esm5/internal/scheduler/AsyncScheduler.js");


var asyncScheduler = new _AsyncScheduler__WEBPACK_IMPORTED_MODULE_0__.AsyncScheduler(_AsyncAction__WEBPACK_IMPORTED_MODULE_1__.AsyncAction);
var async = asyncScheduler;
//# sourceMappingURL=async.js.map

/***/ }),

/***/ "../../../node_modules/rxjs/dist/esm5/internal/scheduler/dateTimestampProvider.js":
/*!****************************************************************************************!*\
  !*** ../../../node_modules/rxjs/dist/esm5/internal/scheduler/dateTimestampProvider.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   dateTimestampProvider: () => (/* binding */ dateTimestampProvider)
/* harmony export */ });
var dateTimestampProvider = {
    now: function () {
        return (dateTimestampProvider.delegate || Date).now();
    },
    delegate: undefined,
};
//# sourceMappingURL=dateTimestampProvider.js.map

/***/ }),

/***/ "../../../node_modules/rxjs/dist/esm5/internal/scheduler/intervalProvider.js":
/*!***********************************************************************************!*\
  !*** ../../../node_modules/rxjs/dist/esm5/internal/scheduler/intervalProvider.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   intervalProvider: () => (/* binding */ intervalProvider)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "tslib");
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(tslib__WEBPACK_IMPORTED_MODULE_0__);

var intervalProvider = {
    setInterval: function (handler, timeout) {
        var args = [];
        for (var _i = 2; _i < arguments.length; _i++) {
            args[_i - 2] = arguments[_i];
        }
        var delegate = intervalProvider.delegate;
        if (delegate === null || delegate === void 0 ? void 0 : delegate.setInterval) {
            return delegate.setInterval.apply(delegate, (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__spreadArray)([handler, timeout], (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__read)(args)));
        }
        return setInterval.apply(void 0, (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__spreadArray)([handler, timeout], (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__read)(args)));
    },
    clearInterval: function (handle) {
        var delegate = intervalProvider.delegate;
        return ((delegate === null || delegate === void 0 ? void 0 : delegate.clearInterval) || clearInterval)(handle);
    },
    delegate: undefined,
};
//# sourceMappingURL=intervalProvider.js.map

/***/ }),

/***/ "../../../node_modules/rxjs/dist/esm5/internal/scheduler/timeoutProvider.js":
/*!**********************************************************************************!*\
  !*** ../../../node_modules/rxjs/dist/esm5/internal/scheduler/timeoutProvider.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   timeoutProvider: () => (/* binding */ timeoutProvider)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "tslib");
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(tslib__WEBPACK_IMPORTED_MODULE_0__);

var timeoutProvider = {
    setTimeout: function (handler, timeout) {
        var args = [];
        for (var _i = 2; _i < arguments.length; _i++) {
            args[_i - 2] = arguments[_i];
        }
        var delegate = timeoutProvider.delegate;
        if (delegate === null || delegate === void 0 ? void 0 : delegate.setTimeout) {
            return delegate.setTimeout.apply(delegate, (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__spreadArray)([handler, timeout], (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__read)(args)));
        }
        return setTimeout.apply(void 0, (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__spreadArray)([handler, timeout], (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__read)(args)));
    },
    clearTimeout: function (handle) {
        var delegate = timeoutProvider.delegate;
        return ((delegate === null || delegate === void 0 ? void 0 : delegate.clearTimeout) || clearTimeout)(handle);
    },
    delegate: undefined,
};
//# sourceMappingURL=timeoutProvider.js.map

/***/ }),

/***/ "../../../node_modules/rxjs/dist/esm5/internal/symbol/observable.js":
/*!**************************************************************************!*\
  !*** ../../../node_modules/rxjs/dist/esm5/internal/symbol/observable.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   observable: () => (/* binding */ observable)
/* harmony export */ });
var observable = (function () { return (typeof Symbol === 'function' && Symbol.observable) || '@@observable'; })();
//# sourceMappingURL=observable.js.map

/***/ }),

/***/ "../../../node_modules/rxjs/dist/esm5/internal/util/EmptyError.js":
/*!************************************************************************!*\
  !*** ../../../node_modules/rxjs/dist/esm5/internal/util/EmptyError.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   EmptyError: () => (/* binding */ EmptyError)
/* harmony export */ });
/* harmony import */ var _createErrorClass__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./createErrorClass */ "../../../node_modules/rxjs/dist/esm5/internal/util/createErrorClass.js");

var EmptyError = (0,_createErrorClass__WEBPACK_IMPORTED_MODULE_0__.createErrorClass)(function (_super) { return function EmptyErrorImpl() {
    _super(this);
    this.name = 'EmptyError';
    this.message = 'no elements in sequence';
}; });
//# sourceMappingURL=EmptyError.js.map

/***/ }),

/***/ "../../../node_modules/rxjs/dist/esm5/internal/util/UnsubscriptionError.js":
/*!*********************************************************************************!*\
  !*** ../../../node_modules/rxjs/dist/esm5/internal/util/UnsubscriptionError.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   UnsubscriptionError: () => (/* binding */ UnsubscriptionError)
/* harmony export */ });
/* harmony import */ var _createErrorClass__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./createErrorClass */ "../../../node_modules/rxjs/dist/esm5/internal/util/createErrorClass.js");

var UnsubscriptionError = (0,_createErrorClass__WEBPACK_IMPORTED_MODULE_0__.createErrorClass)(function (_super) {
    return function UnsubscriptionErrorImpl(errors) {
        _super(this);
        this.message = errors
            ? errors.length + " errors occurred during unsubscription:\n" + errors.map(function (err, i) { return i + 1 + ") " + err.toString(); }).join('\n  ')
            : '';
        this.name = 'UnsubscriptionError';
        this.errors = errors;
    };
});
//# sourceMappingURL=UnsubscriptionError.js.map

/***/ }),

/***/ "../../../node_modules/rxjs/dist/esm5/internal/util/arrRemove.js":
/*!***********************************************************************!*\
  !*** ../../../node_modules/rxjs/dist/esm5/internal/util/arrRemove.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   arrRemove: () => (/* binding */ arrRemove)
/* harmony export */ });
function arrRemove(arr, item) {
    if (arr) {
        var index = arr.indexOf(item);
        0 <= index && arr.splice(index, 1);
    }
}
//# sourceMappingURL=arrRemove.js.map

/***/ }),

/***/ "../../../node_modules/rxjs/dist/esm5/internal/util/createErrorClass.js":
/*!******************************************************************************!*\
  !*** ../../../node_modules/rxjs/dist/esm5/internal/util/createErrorClass.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   createErrorClass: () => (/* binding */ createErrorClass)
/* harmony export */ });
function createErrorClass(createImpl) {
    var _super = function (instance) {
        Error.call(instance);
        instance.stack = new Error().stack;
    };
    var ctorFunc = createImpl(_super);
    ctorFunc.prototype = Object.create(Error.prototype);
    ctorFunc.prototype.constructor = ctorFunc;
    return ctorFunc;
}
//# sourceMappingURL=createErrorClass.js.map

/***/ }),

/***/ "../../../node_modules/rxjs/dist/esm5/internal/util/errorContext.js":
/*!**************************************************************************!*\
  !*** ../../../node_modules/rxjs/dist/esm5/internal/util/errorContext.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   captureError: () => (/* binding */ captureError),
/* harmony export */   errorContext: () => (/* binding */ errorContext)
/* harmony export */ });
/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../config */ "../../../node_modules/rxjs/dist/esm5/internal/config.js");

var context = null;
function errorContext(cb) {
    if (_config__WEBPACK_IMPORTED_MODULE_0__.config.useDeprecatedSynchronousErrorHandling) {
        var isRoot = !context;
        if (isRoot) {
            context = { errorThrown: false, error: null };
        }
        cb();
        if (isRoot) {
            var _a = context, errorThrown = _a.errorThrown, error = _a.error;
            context = null;
            if (errorThrown) {
                throw error;
            }
        }
    }
    else {
        cb();
    }
}
function captureError(err) {
    if (_config__WEBPACK_IMPORTED_MODULE_0__.config.useDeprecatedSynchronousErrorHandling && context) {
        context.errorThrown = true;
        context.error = err;
    }
}
//# sourceMappingURL=errorContext.js.map

/***/ }),

/***/ "../../../node_modules/rxjs/dist/esm5/internal/util/identity.js":
/*!**********************************************************************!*\
  !*** ../../../node_modules/rxjs/dist/esm5/internal/util/identity.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   identity: () => (/* binding */ identity)
/* harmony export */ });
function identity(x) {
    return x;
}
//# sourceMappingURL=identity.js.map

/***/ }),

/***/ "../../../node_modules/rxjs/dist/esm5/internal/util/isFunction.js":
/*!************************************************************************!*\
  !*** ../../../node_modules/rxjs/dist/esm5/internal/util/isFunction.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   isFunction: () => (/* binding */ isFunction)
/* harmony export */ });
function isFunction(value) {
    return typeof value === 'function';
}
//# sourceMappingURL=isFunction.js.map

/***/ }),

/***/ "../../../node_modules/rxjs/dist/esm5/internal/util/lift.js":
/*!******************************************************************!*\
  !*** ../../../node_modules/rxjs/dist/esm5/internal/util/lift.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   hasLift: () => (/* binding */ hasLift),
/* harmony export */   operate: () => (/* binding */ operate)
/* harmony export */ });
/* harmony import */ var _isFunction__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./isFunction */ "../../../node_modules/rxjs/dist/esm5/internal/util/isFunction.js");

function hasLift(source) {
    return (0,_isFunction__WEBPACK_IMPORTED_MODULE_0__.isFunction)(source === null || source === void 0 ? void 0 : source.lift);
}
function operate(init) {
    return function (source) {
        if (hasLift(source)) {
            return source.lift(function (liftedSource) {
                try {
                    return init(liftedSource, this);
                }
                catch (err) {
                    this.error(err);
                }
            });
        }
        throw new TypeError('Unable to lift unknown Observable type');
    };
}
//# sourceMappingURL=lift.js.map

/***/ }),

/***/ "../../../node_modules/rxjs/dist/esm5/internal/util/noop.js":
/*!******************************************************************!*\
  !*** ../../../node_modules/rxjs/dist/esm5/internal/util/noop.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   noop: () => (/* binding */ noop)
/* harmony export */ });
function noop() { }
//# sourceMappingURL=noop.js.map

/***/ }),

/***/ "../../../node_modules/rxjs/dist/esm5/internal/util/pipe.js":
/*!******************************************************************!*\
  !*** ../../../node_modules/rxjs/dist/esm5/internal/util/pipe.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   pipe: () => (/* binding */ pipe),
/* harmony export */   pipeFromArray: () => (/* binding */ pipeFromArray)
/* harmony export */ });
/* harmony import */ var _identity__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./identity */ "../../../node_modules/rxjs/dist/esm5/internal/util/identity.js");

function pipe() {
    var fns = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        fns[_i] = arguments[_i];
    }
    return pipeFromArray(fns);
}
function pipeFromArray(fns) {
    if (fns.length === 0) {
        return _identity__WEBPACK_IMPORTED_MODULE_0__.identity;
    }
    if (fns.length === 1) {
        return fns[0];
    }
    return function piped(input) {
        return fns.reduce(function (prev, fn) { return fn(prev); }, input);
    };
}
//# sourceMappingURL=pipe.js.map

/***/ }),

/***/ "../../../node_modules/rxjs/dist/esm5/internal/util/reportUnhandledError.js":
/*!**********************************************************************************!*\
  !*** ../../../node_modules/rxjs/dist/esm5/internal/util/reportUnhandledError.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   reportUnhandledError: () => (/* binding */ reportUnhandledError)
/* harmony export */ });
/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../config */ "../../../node_modules/rxjs/dist/esm5/internal/config.js");
/* harmony import */ var _scheduler_timeoutProvider__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../scheduler/timeoutProvider */ "../../../node_modules/rxjs/dist/esm5/internal/scheduler/timeoutProvider.js");


function reportUnhandledError(err) {
    _scheduler_timeoutProvider__WEBPACK_IMPORTED_MODULE_0__.timeoutProvider.setTimeout(function () {
        var onUnhandledError = _config__WEBPACK_IMPORTED_MODULE_1__.config.onUnhandledError;
        if (onUnhandledError) {
            onUnhandledError(err);
        }
        else {
            throw err;
        }
    });
}
//# sourceMappingURL=reportUnhandledError.js.map

/***/ }),

/***/ "./src/lib/assets/index.ts":
/*!*********************************!*\
  !*** ./src/lib/assets/index.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   SPOTLER_PLUGIN_LOGO_BASE64: () => (/* reexport safe */ _spotler_plugin_logo__WEBPACK_IMPORTED_MODULE_0__.SPOTLER_PLUGIN_LOGO_BASE64)
/* harmony export */ });
/* harmony import */ var _spotler_plugin_logo__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./spotler-plugin-logo */ "./src/lib/assets/spotler-plugin-logo.ts");
/*
 * Copyright 2015-2024. Ritense BV, the Netherlands.
 *
 * Licensed under EUPL, Version 1.2 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * https://joinup.ec.europa.eu/collection/eupl/eupl-text-eupl-12
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" basis,
 *
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */



/***/ }),

/***/ "./src/lib/assets/spotler-plugin-logo.ts":
/*!***********************************************!*\
  !*** ./src/lib/assets/spotler-plugin-logo.ts ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   SPOTLER_PLUGIN_LOGO_BASE64: () => (/* binding */ SPOTLER_PLUGIN_LOGO_BASE64)
/* harmony export */ });
/*
 * Copyright 2015-2024. Ritense BV, the Netherlands.
 *
 * Licensed under EUPL, Version 1.2 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * https://joinup.ec.europa.eu/collection/eupl/eupl-text-eupl-12
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" basis,
 *
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
const SPOTLER_PLUGIN_LOGO_BASE64 = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAm8AAAJvCAYAAAAtNjaIAAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAAABmJLR0QA/wD/AP+gvaeTAAAACXBIWXMAAA7DAAAOwwHHb6hkAAAAB3RJTUUH5AcJCzID9gWKhAAAgABJREFUeNrt3Xd8HNXZNuD7zMqSXGTcuwHb2OqmN5sUijElpBF6Td5AgBCSAOFNeFOAJKQAIQkEDMkXimmmpNFcgJAABmMM2OqSC7j3XlR25/n+mHNmzqxk1V1JI99XfsG2yu5snXufc85zlIiAiIiIiKLB6eoDICIiIqLWY3gjIiIiihCGNyIiIqIIYXgjIiIiihCGNyIiIqIIYXgjIiIiihCGNyIiIqIIYXgjIiIiihCGNyIiIqIIYXgjIiIiihCGNyIiIqIIYXgjIiIiihCGNyIiIqIIYXgjIiIiihCGNyIiIqIIYXgjIiIiihCGNyIiIqIIYXgjIiIiihCGNyIiIqIIYXgjIiIiihCGNyIiIqIIYXgjIiIiihCGNyIiIqIIYXgjIiIiihCGNyIiIqIIYXgjIiIiihCGNyIiIqIIYXgjIiIiihCGNyIiIqIIYXgjIiIiihCGNyIiIqIIYXgjIiIiihCGNyIiIqIIYXgjIiIiihCGNyIiIqIIYXgjIiIiihCGNyIiIqIIYXgjIiIiihCGNyIiIqIIYXgjIiIiihCGNyIiIqIIYXgjIiIiihCGNyIiIqIIYXgjIiIiihCGNyIiIqIIYXgjIiIiihCGNyIiIqIIYXgjIiIiihCGNyIiIqIIYXgjIiIiihCGNyIiIqIIYXgjIiIiihCGNyIiIqIIYXgjIiIiihCGNyIiIqIIYXgjIiIiihCGNyIiIqIIYXgjIiIiihCGNyIiIqIIYXgjIiIiihCGNyIiIqIIYXgjIiIiihCGNyIiIqIIYXgjIiIiihCGNyIiIqIIYXgjIiIiihCGNyIiIqIIYXgjIiIiihCGNyIiIqIIYXgjIiIiihCGNyIiIqIIYXgjIiIiihCGNyIiIqIIYXgjIiIiihCGNyIiIqIIYXgjIiIiihCGNyIiIqIIYXgjIiIiihCGNyIiIqIIYXgjIiIiihCGNyIiIqIIYXgjIiIiihCGNyIiIqIIYXgjIiIiihCGNyIiIqIIYXgjIiIiihCGNyIiIqIIYXgjIiIiihCGNyIiIqIIYXgjIiIiihCGNyIiIqIIYXgjIiIiihCGNyIiIqIIYXgjIiIiihCGNyIiIqIIYXgjIiIiihCGNyIiIqIIYXgjIiIiihCGNyIiIqIIYXgjIiIiihCGNyIiIqIIYXgjIiIiihCGNyIiIqIIYXgjIiIiihCGNyIiIqIIYXgjIiIiihCGNyIiIqIIYXgjIiIiihCGNyIiIqIIYXgjIiIiihCGNyIiIqIIYXgjIiIiihCGNyIiIqIIYXgjIiIiihCGNyIiIqIIYXgjIiIiihCGNyIiIqIIYXgjIiIiihCGNyIiIqIIYXgjIiIiihCGNyIiIqIIYXgjIiIiihCGNyIiIqIIYXgjIiIiihCGNyIiIqIIYXgjIiIiihCGNyIiIqIIYXgjIiIiihCGNyIiIqIIYXgjIiIiihCGNyIiIqIIYXgjIiIiihCGNyIiIqIIYXgjIiIiihCGNyIiIqIIYXgjIiIiihCGNyIiIqIIYXgjIiIiihCGNyIiIqIIYXgjIiIiihCGNyIiIqIIYXgjIiIiihCGNyIiIqIIYXgjIiIiihCGNyIiIqIIYXgjIiIiihCGNyIiIqIIYXgjIiIiihCGNyIiIqIIYXgjIiIiihCGNyIiIqIIYXgjIiIiihCGNyIiIqIIYXgjIiIiihCGNyIiIqIIYXgjIiIiihCGNyIiIqIIYXgjIiIiihCGNyIiIqIIYXgjIiIiihCGNyIiIqIIYXgjIiIiihCGNyIiIqIIYXgjIiIiihCGNyIiIqIIYXgjIiIiihCGNyIiIqIIYXgjIiIiihCGNyIiIqIIYXgjIiIiihCGNyIiIqIIYXgjIiIiihCGNyIiIqIIYXgjIiIiihCGNyIiIqIIYXgjIiIiihCGNyIiIqIIYXgjIiIiihCGNyIiIqIIYXgjIiIiihCGNyIiIqIIYXgjIiIiihCGNyIiIqIIYXgjIiIiihCGNyIiIqIIYXgjIiIiihCGNyIiIqIIYXgjIiIiihCGNyIiIqIIYXgjIiIiihCGNyIiIqIIYXgjIiIiihCGNyIiIqIIYXgjIiIiihCGNyIiIqIIYXgjIiIiihCGNyIiIqIIYXgjIiIiihCGNyIiIqIIYXgjIiIiihCGNyIiIqIIYXgjIiIiihCGNyIiIqIIYXgjIiIi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rw8ePwH33vV9buxORAxvRERNqSpdJlddcSv27N7q1ddErMqZbu7bREizw53A9GlrahjWnsuG4PLs92QFKCcTN/zft3Hs4ZOQVzyRwY2IGN6IiPanqmyF/Oau/4cl898LByulvKwFuzoWvJf6vdl0RU0l79pghkH9LrxICoKAk5GFs88/C+d+7TQUFbHaRkQBhjciomZUltTIQw8/j7fmvA4FrzmuEjOWai0qAGDCGuDtgCD2PDiIN2wKJ9g2wa/imb8D2TkDcdpZn8OF501HXjEXJBBRYwxvREQtqChdLrNfewtPPjBTf8VfcYAggCH0d4ELBcdb6mDvtuX/LILLcBwcWlSIa64+H6NHDUZ+EYdHiWj/GN6IiFqhsnSZrFu3Dj+86R4kand7X/SHS8NDpwrKHxU1e5J63/CCm6Mc9MoZgElF43DFpV/C8BFDGNiIqNUY3oiI2qBySY1AufhgcRWWVa9CWcVS7Ni1B0oU9mzdjto9e6DEGzAdeMgoOIhBKWD8YYdg2IAcnHfhmYDrooCLD4ionRjeiIiIiCKE22MRERERRQjDGxEREVGEMLwRERERRQjDGxEREVGEMLwRERERRQjDGxEREVGEMLwRERERRQjDGxEREVGEMLwRERERRQjDGxEREVGEMLwRERERRQjDGxEREVGEMLwRERERRQjDGxEREVGEMLwRERERRQjDGxEREVGEMLwRERERRQjDGxEREVGEMLwRERERRQjDGxEREVGEMLwRERERRQjDGxEREVGEMLwRERERRQjDGxEREVGEMLwRERERRQjDGxEREVGEMLwRERERRQjDGxEREVGEMLwRERERRQjDGxEREVGEMLwRERERRQjDGxEREVGEMLwRERERRQjDGxEREVGEMLwRERERRQjDGxEREVGEMLwRERERRQjDGxEREVGEMLwRERERRQjDGxEREVGEMLwRERERRQjDGxEREVGEMLwRERERRQjDGxEREVGEMLwRERERRQjDGxEREVGEMLwRERERRQjDGxEREVGEMLwRERERRQjDGxEREVGEMLwRERERRQjDGxEREVGEMLwRERERRQjDGxEREVGEMLwRERERRQjDGxEREVGEMLwRERERRQjDGxEREVGEMLwRERERRQjDGxEREVGEMLwRERERRQjDGxEREVGEMLwRERERRQjDGxEREVGEMLwRERERRQjDGxEREVGEMLwRERERRQjDGxEREVGEMLwRERERRQjDGxEREVGEMLwRERERRQjDGxEREVGEMLwRERERRQjDGxEREVGEMLwRERERRQjDGxEREVGEMLwRERERRQjDGxEREVGEMLwRERERRQjDGxEREVGEMLwRERERRQjDGxEREVGEMLwRERERRQjDGxEREVGEMLwRERERRQjDGxEREVGEMLwRERERRQjDGxEREVGEMLwRERERRQjDGxEREVGEMLwRERERRQjDGxEREVGEMLwRERERRQjDGxEREVGEMLwRERERRQjDGxEREVGEMLwRERERRQjDGxEREVGEMLwRERERRQjDGxEREVGEMLwRERERRQjDGxEREVGEMLwRERERRQjDGxEREVGEMLwRERERRQjDGxEREVGEMLwRERERRQjDGxEREVGEMLwRERERRQjDGxEREVGEMLwRERERRQjDGxEREVGEMLwRERERRQjDGxEREVGEMLwRERERRQjDGxEREVGEMLwRERERRQjDGxEREVGEMLwRERERRQjDGxEREVGEMLwRERERRQjDGxEREVGEMLwRERERRQjDGxEREVGEMLwRERERRQjDGxEREVGEMLwRERERRQjDGxEREVGEMLwRERERRQjDGxEREVGEMLwRERERRQjDGxEREVGEMLwRERERRQjDGxEREVGEMLwRERERRQjDGxEREVGEMLwRERERRQjDGxEREVGEMLwRERERRQjDGxEREVGEMLwRERERRQjDGxEREVGEMLwRERERRQjDGxEREVGEMLwRERERRQjDGxEREVGEMLwRERERRQjDGxEREVGEMLwRERERRQjDGxEREVGEMLwRERERRQjDGxEREVGEMLwRERERRQjDGxEREVGEMLwRERERRQjDGxEREVGEMLwRERERRQjDGxEREVGEMLwRERERRQjDGxEREVGEMLwRERERRQjDGxEREVGEMLwRERERRQjDGxEREVGEMLwRERERRQjDGxEREVGEMLwRERERRQjDGxEREVGEMLwRERERRQjDGxEREVGEMLwRERERRQjDGxEREVGEMLwRERERRQjDGxEREVGEMLwRERERRQjDGxEREVGEMLwRERERRQjDGxEREVGEMLwRERERRQjDGxEREVGEMLwRERERRQjDGxEREVGEMLwRERERRQjDGxEREVGEMLwRERERRQjDGxEREVGEMLwRERERRQjDGxEREVGEMLwRERERRQjDGxEREVGEMLwRERERRQjDGxEREVGEMLwRERERRQjDGxEREVGEMLwRERERRQjDGxEREVGEMLwRERERRQjDGxEREVGEMLwRERERRQjDGxEREVGEMLwRERERRQjDGxEREVGEMLwRERERRQjDGxEREVGEMLwRERERRQjDGxEREVGEMLwRERERRQjDGxEREVGEMLwRERERRQjDGxEREVGEMLwRERERRQjDGxEREVGEMLwRERERRQjDGxEREVGEMLwRERERRQjDGxEREVGEMLwRERERRcj/B/Tu3nR+WLLQAAAAJXRFWHRkYXRlOmNyZWF0ZQAyMDIwLTA3LTA5VDExOjQ5OjUyKzAwOjAwSPOckQAAACV0RVh0ZGF0ZTptb2RpZnkAMjAyMC0wNy0wOVQxMTo0OTo1MiswMDowMDmuJC0AAAAASUVORK5CYII=';



/***/ }),

/***/ "./src/lib/components/plugin-configuration/spotler-plugin-configuration.component.ts":
/*!*******************************************************************************************!*\
  !*** ./src/lib/components/plugin-configuration/spotler-plugin-configuration.component.ts ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   SpotlerPluginConfigurationComponent: () => (/* binding */ SpotlerPluginConfigurationComponent)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "tslib");
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(tslib__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @angular/core */ "@angular/core");
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_angular_core__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! rxjs */ "rxjs");
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(rxjs__WEBPACK_IMPORTED_MODULE_2__);
/*
 * Copyright 2015-2024. Ritense BV, the Netherlands.
 *
 * Licensed under EUPL, Version 1.2 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * https://joinup.ec.europa.eu/collection/eupl/eupl-text-eupl-12
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" basis,
 *
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */



let SpotlerPluginConfigurationComponent = class SpotlerPluginConfigurationComponent {
    constructor() {
        this.valid = new _angular_core__WEBPACK_IMPORTED_MODULE_1__.EventEmitter();
        this.configuration = new _angular_core__WEBPACK_IMPORTED_MODULE_1__.EventEmitter();
        this.formValue$ = new rxjs__WEBPACK_IMPORTED_MODULE_2__.BehaviorSubject(null);
        this.valid$ = new rxjs__WEBPACK_IMPORTED_MODULE_2__.BehaviorSubject(false);
    }
    ngOnInit() {
        this.openSaveSubscription();
    }
    ngOnDestroy() {
        this.saveSubscription?.unsubscribe();
    }
    formValueChange(formValue) {
        this.formValue$.next(formValue);
        this.handleValid(formValue);
    }
    handleValid(formValue) {
        const valid = !!(formValue.configurationTitle
            && formValue.clientId
            && formValue.clientSecret
            && formValue.accountId);
        this.valid$.next(valid);
        this.valid.emit(valid);
    }
    openSaveSubscription() {
        this.saveSubscription = this.save$?.subscribe(save => {
            (0,rxjs__WEBPACK_IMPORTED_MODULE_2__.combineLatest)([this.formValue$, this.valid$])
                .pipe((0,rxjs__WEBPACK_IMPORTED_MODULE_2__.take)(1))
                .subscribe(([formValue, valid]) => {
                if (valid) {
                    this.configuration.emit(formValue);
                }
            });
        });
    }
};
(0,tslib__WEBPACK_IMPORTED_MODULE_0__.__decorate)([
    (0,_angular_core__WEBPACK_IMPORTED_MODULE_1__.Input)()
], SpotlerPluginConfigurationComponent.prototype, "save$", void 0);
(0,tslib__WEBPACK_IMPORTED_MODULE_0__.__decorate)([
    (0,_angular_core__WEBPACK_IMPORTED_MODULE_1__.Input)()
], SpotlerPluginConfigurationComponent.prototype, "disabled$", void 0);
(0,tslib__WEBPACK_IMPORTED_MODULE_0__.__decorate)([
    (0,_angular_core__WEBPACK_IMPORTED_MODULE_1__.Input)()
], SpotlerPluginConfigurationComponent.prototype, "pluginId", void 0);
(0,tslib__WEBPACK_IMPORTED_MODULE_0__.__decorate)([
    (0,_angular_core__WEBPACK_IMPORTED_MODULE_1__.Input)()
], SpotlerPluginConfigurationComponent.prototype, "prefillConfiguration$", void 0);
(0,tslib__WEBPACK_IMPORTED_MODULE_0__.__decorate)([
    (0,_angular_core__WEBPACK_IMPORTED_MODULE_1__.Output)()
], SpotlerPluginConfigurationComponent.prototype, "valid", void 0);
(0,tslib__WEBPACK_IMPORTED_MODULE_0__.__decorate)([
    (0,_angular_core__WEBPACK_IMPORTED_MODULE_1__.Output)()
], SpotlerPluginConfigurationComponent.prototype, "configuration", void 0);
SpotlerPluginConfigurationComponent = (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__decorate)([
    (0,_angular_core__WEBPACK_IMPORTED_MODULE_1__.Component)({
        selector: 'spotler-plugin-configuration',
        template: __webpack_require__(/*! ./spotler-plugin-configuration.component.html */ "./src/lib/components/plugin-configuration/spotler-plugin-configuration.component.html"),
        styles: [__webpack_require__(/*! ./spotler-plugin-configuration.component.scss */ "./src/lib/components/plugin-configuration/spotler-plugin-configuration.component.scss")],
    })
], SpotlerPluginConfigurationComponent);



/***/ }),

/***/ "./src/lib/components/send-mail-configuration/send-mail-action-configuration.component.ts":
/*!************************************************************************************************!*\
  !*** ./src/lib/components/send-mail-configuration/send-mail-action-configuration.component.ts ***!
  \************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   SendMailActionConfigurationComponent: () => (/* binding */ SendMailActionConfigurationComponent)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "tslib");
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(tslib__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @angular/core */ "@angular/core");
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_angular_core__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! rxjs */ "rxjs");
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(rxjs__WEBPACK_IMPORTED_MODULE_2__);



let SendMailActionConfigurationComponent = class SendMailActionConfigurationComponent {
    constructor() {
        this.valid = new _angular_core__WEBPACK_IMPORTED_MODULE_1__.EventEmitter();
        this.configuration = new _angular_core__WEBPACK_IMPORTED_MODULE_1__.EventEmitter();
        this.formValue$ = new rxjs__WEBPACK_IMPORTED_MODULE_2__.BehaviorSubject(null);
        this.valid$ = new rxjs__WEBPACK_IMPORTED_MODULE_2__.BehaviorSubject(false);
        this.recipientTypes = [
            {
                id: "TO",
                text: "TO",
                translationKey: "to"
            },
            {
                id: "BCC",
                text: "BCC",
                translationKey: "bcc"
            },
            {
                id: "CC",
                text: "CC",
                translationKey: "cc"
            }
        ];
    }
    ngOnInit() {
        this.openSaveSubscription();
    }
    ngOnDestroy() {
        this.saveSubscription?.unsubscribe();
    }
    formValueChange(formValue) {
        this.formValue$.next(formValue);
        this.handleValid(formValue);
    }
    handleValid(formValue) {
        const valid = !!(formValue.subject
            && formValue.senderEmail
            && this.validateEmail(formValue.senderEmail)
            && formValue.senderName
            && formValue.recipients
            && formValue.recipients.every(recipient => !!(recipient.email
                && this.validateEmail(recipient.email)
                && recipient.name
                && recipient.type))
            && formValue.mailTemplateIdentifier);
        this.valid$.next(valid);
        this.valid.emit(valid);
    }
    openSaveSubscription() {
        this.saveSubscription = this.save$?.subscribe(save => {
            (0,rxjs__WEBPACK_IMPORTED_MODULE_2__.combineLatest)([this.formValue$, this.valid$])
                .pipe((0,rxjs__WEBPACK_IMPORTED_MODULE_2__.take)(1))
                .subscribe(([formValue, valid]) => {
                if (valid) {
                    this.configuration.emit(formValue);
                }
            });
        });
    }
    validateEmail(email) {
        const re = /\S+@\S+\.\S+/;
        return email.startsWith("pv:") || re.test(email);
    }
};
(0,tslib__WEBPACK_IMPORTED_MODULE_0__.__decorate)([
    (0,_angular_core__WEBPACK_IMPORTED_MODULE_1__.Input)()
], SendMailActionConfigurationComponent.prototype, "save$", void 0);
(0,tslib__WEBPACK_IMPORTED_MODULE_0__.__decorate)([
    (0,_angular_core__WEBPACK_IMPORTED_MODULE_1__.Input)()
], SendMailActionConfigurationComponent.prototype, "disabled$", void 0);
(0,tslib__WEBPACK_IMPORTED_MODULE_0__.__decorate)([
    (0,_angular_core__WEBPACK_IMPORTED_MODULE_1__.Input)()
], SendMailActionConfigurationComponent.prototype, "pluginId", void 0);
(0,tslib__WEBPACK_IMPORTED_MODULE_0__.__decorate)([
    (0,_angular_core__WEBPACK_IMPORTED_MODULE_1__.Input)()
], SendMailActionConfigurationComponent.prototype, "prefillConfiguration$", void 0);
(0,tslib__WEBPACK_IMPORTED_MODULE_0__.__decorate)([
    (0,_angular_core__WEBPACK_IMPORTED_MODULE_1__.Output)()
], SendMailActionConfigurationComponent.prototype, "valid", void 0);
(0,tslib__WEBPACK_IMPORTED_MODULE_0__.__decorate)([
    (0,_angular_core__WEBPACK_IMPORTED_MODULE_1__.Output)()
], SendMailActionConfigurationComponent.prototype, "configuration", void 0);
SendMailActionConfigurationComponent = (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__decorate)([
    (0,_angular_core__WEBPACK_IMPORTED_MODULE_1__.Component)({
        selector: 'spotler-send-mail-action-configuration',
        template: __webpack_require__(/*! ./send-mail-action-configuration.component.html */ "./src/lib/components/send-mail-configuration/send-mail-action-configuration.component.html"),
        styles: [__webpack_require__(/*! ./send-mail-action-configuration.component.scss */ "./src/lib/components/send-mail-configuration/send-mail-action-configuration.component.scss")],
    })
], SendMailActionConfigurationComponent);



/***/ }),

/***/ "./src/lib/models/config.ts":
/*!**********************************!*\
  !*** ./src/lib/models/config.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/*
 * Copyright 2015-2024. Ritense BV, the Netherlands.
 *
 * Licensed under EUPL, Version 1.2 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * https://joinup.ec.europa.eu/collection/eupl/eupl-text-eupl-12
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" basis,
 *
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
var RecipientType;
(function (RecipientType) {
    RecipientType[RecipientType["TO"] = 0] = "TO";
    RecipientType[RecipientType["CC"] = 1] = "CC";
    RecipientType[RecipientType["BCC"] = 2] = "BCC";
})(RecipientType || (RecipientType = {}));



/***/ }),

/***/ "./src/lib/models/index.ts":
/*!*********************************!*\
  !*** ./src/lib/models/index.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./config */ "./src/lib/models/config.ts");
/*
 * Copyright 2015-2024. Ritense BV, the Netherlands.
 *
 * Licensed under EUPL, Version 1.2 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * https://joinup.ec.europa.eu/collection/eupl/eupl-text-eupl-12
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" basis,
 *
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */



/***/ }),

/***/ "./src/lib/spotler-plugin-module.ts":
/*!******************************************!*\
  !*** ./src/lib/spotler-plugin-module.ts ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   SpotlerPluginModule: () => (/* binding */ SpotlerPluginModule)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "tslib");
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(tslib__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @angular/core */ "@angular/core");
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_angular_core__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _angular_common__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @angular/common */ "@angular/common");
/* harmony import */ var _angular_common__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_angular_common__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _valtimo_plugin__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @valtimo/plugin */ "@valtimo/plugin");
/* harmony import */ var _valtimo_plugin__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_valtimo_plugin__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _angular_forms__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @angular/forms */ "../../../node_modules/@angular/forms/fesm2022/forms.mjs");
/* harmony import */ var _valtimo_components__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @valtimo/components */ "@valtimo/components");
/* harmony import */ var _valtimo_components__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_valtimo_components__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _components_plugin_configuration_spotler_plugin_configuration_component__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./components/plugin-configuration/spotler-plugin-configuration.component */ "./src/lib/components/plugin-configuration/spotler-plugin-configuration.component.ts");
/* harmony import */ var _components_send_mail_configuration_send_mail_action_configuration_component__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./components/send-mail-configuration/send-mail-action-configuration.component */ "./src/lib/components/send-mail-configuration/send-mail-action-configuration.component.ts");
/* harmony import */ var carbon_components_angular__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! carbon-components-angular */ "../../../node_modules/carbon-components-angular/fesm2020/carbon-components-angular-dropdown.mjs");
/* harmony import */ var carbon_components_angular__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! carbon-components-angular */ "../../../node_modules/carbon-components-angular/fesm2020/carbon-components-angular-checkbox.mjs");
/* harmony import */ var _spotler_plugin_specification__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./spotler-plugin.specification */ "./src/lib/spotler-plugin.specification.ts");
/*
 * Copyright 2015-2024. Ritense BV, the Netherlands.
 *
 * Licensed under EUPL, Version 1.2 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * https://joinup.ec.europa.eu/collection/eupl/eupl-text-eupl-12
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" basis,
 *
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */










let SpotlerPluginModule = class SpotlerPluginModule {
};
SpotlerPluginModule = (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__decorate)([
    (0,_angular_core__WEBPACK_IMPORTED_MODULE_1__.NgModule)({
        declarations: [
            _components_plugin_configuration_spotler_plugin_configuration_component__WEBPACK_IMPORTED_MODULE_5__.SpotlerPluginConfigurationComponent,
            _components_send_mail_configuration_send_mail_action_configuration_component__WEBPACK_IMPORTED_MODULE_6__.SendMailActionConfigurationComponent
        ],
        imports: [_angular_common__WEBPACK_IMPORTED_MODULE_2__.CommonModule, _valtimo_plugin__WEBPACK_IMPORTED_MODULE_3__.PluginTranslatePipeModule, _valtimo_components__WEBPACK_IMPORTED_MODULE_4__.FormModule, _valtimo_components__WEBPACK_IMPORTED_MODULE_4__.InputModule, _angular_forms__WEBPACK_IMPORTED_MODULE_8__.FormsModule, _valtimo_plugin__WEBPACK_IMPORTED_MODULE_3__.PluginTranslatePipeModule, _valtimo_components__WEBPACK_IMPORTED_MODULE_4__.FormModule, _valtimo_components__WEBPACK_IMPORTED_MODULE_4__.FormModule, _valtimo_components__WEBPACK_IMPORTED_MODULE_4__.FormModule, _valtimo_components__WEBPACK_IMPORTED_MODULE_4__.FormModule, _valtimo_components__WEBPACK_IMPORTED_MODULE_4__.CarbonMultiInputModule, _valtimo_components__WEBPACK_IMPORTED_MODULE_4__.TableModule, _valtimo_components__WEBPACK_IMPORTED_MODULE_4__.CarbonListModule, _valtimo_components__WEBPACK_IMPORTED_MODULE_4__.MultiInputFormModule, carbon_components_angular__WEBPACK_IMPORTED_MODULE_9__.DropdownModule, _valtimo_components__WEBPACK_IMPORTED_MODULE_4__.SelectModule, carbon_components_angular__WEBPACK_IMPORTED_MODULE_10__.CheckboxModule],
        exports: [
            _components_plugin_configuration_spotler_plugin_configuration_component__WEBPACK_IMPORTED_MODULE_5__.SpotlerPluginConfigurationComponent,
            _components_send_mail_configuration_send_mail_action_configuration_component__WEBPACK_IMPORTED_MODULE_6__.SendMailActionConfigurationComponent
        ],
        providers: [
            {
                provide: _valtimo_plugin__WEBPACK_IMPORTED_MODULE_3__.PLUGINS_TOKEN,
                useValue: [
                    _spotler_plugin_specification__WEBPACK_IMPORTED_MODULE_7__.spotlerPluginSpecification,
                ]
            }
        ]
    })
], SpotlerPluginModule);



/***/ }),

/***/ "./src/lib/spotler-plugin.specification.ts":
/*!*************************************************!*\
  !*** ./src/lib/spotler-plugin.specification.ts ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   spotlerPluginSpecification: () => (/* binding */ spotlerPluginSpecification)
/* harmony export */ });
/* harmony import */ var _assets__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./assets */ "./src/lib/assets/index.ts");
/* harmony import */ var _components_plugin_configuration_spotler_plugin_configuration_component__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./components/plugin-configuration/spotler-plugin-configuration.component */ "./src/lib/components/plugin-configuration/spotler-plugin-configuration.component.ts");
/* harmony import */ var _components_send_mail_configuration_send_mail_action_configuration_component__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./components/send-mail-configuration/send-mail-action-configuration.component */ "./src/lib/components/send-mail-configuration/send-mail-action-configuration.component.ts");
/*
 * Copyright 2015-2024. Ritense BV, the Netherlands.
 *
 * Licensed under EUPL, Version 1.2 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * https://joinup.ec.europa.eu/collection/eupl/eupl-text-eupl-12
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" basis,
 *
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */



const spotlerPluginSpecification = {
    pluginId: 'spotler',
    pluginConfigurationComponent: _components_plugin_configuration_spotler_plugin_configuration_component__WEBPACK_IMPORTED_MODULE_1__.SpotlerPluginConfigurationComponent,
    pluginLogoBase64: _assets__WEBPACK_IMPORTED_MODULE_0__.SPOTLER_PLUGIN_LOGO_BASE64,
    functionConfigurationComponents: {
        sendMail: _components_send_mail_configuration_send_mail_action_configuration_component__WEBPACK_IMPORTED_MODULE_2__.SendMailActionConfigurationComponent
    },
    pluginTranslations: {
        nl: {
            title: 'Spotler',
            description: 'Met de Spotler plugin kun je in een process emails versturen',
            configurationTitle: 'Configuratienaam',
            configurationTitleTooltip: 'Onder deze naam zal de plugin te herkennen zijn in de rest van de applicatie',
            clientId: 'Client ID',
            clientIdTooltip: 'Vul hier het uw Spotler clientId in',
            accountId: 'Account ID',
            accountIdTooltip: 'Het ID van uw Spotler account',
            clientSecret: 'Secret',
            clientSecretTooltip: 'Vul de secret in die hoort bij de clientId hierboven',
            toAddress: "Email verzend adres",
            toName: "Naam van ontvanger",
            senderEmail: "Email van afzender",
            senderName: "Naam van afzender",
            emailSubject: "Onderwerp",
            mailTemplateIdentifier: "Spotler Email template ID",
            mailTemplateIdentifierTooltip: "Vul hier de template identifier van uw Spotler email template in",
            recipients: "Ontvangers",
            addRecipient: "Voeg nieuwe ontvanger toe",
            emailType: "Ontvanger type",
            sendMail: "Email verzenden",
            placeholders: "Placeholders",
            addPlaceholder: "Voeg een nieuwe variabele toe",
            placeholderKey: "Variabele",
            placeholderKeyTooltip: "Vul een variabele in die in de Spotler email template staat geconfigureerd.",
            placeholderValue: "Waarde",
            placeholderValueTooltip: "De waarde die in de email ingevuld word. Start met pv: om een process waarde te gebruiken"
        },
        en: {
            title: 'Spotler',
            description: 'Spotler allows you to send emails from within a process',
            configurationTitle: 'Configuration name',
            configurationTitleTooltip: 'Under this name, the plugin will be recognizable in the rest of the application',
            clientId: 'Client ID',
            clientIdTooltip: 'Enter your Spotler clientId here',
            accountId: 'Account ID',
            accountIdTooltip: 'Fill in the ID of your Spotler account',
            clientSecret: 'Secret',
            clientSecretTooltip: 'Enter the secret associated with the clientId above',
            toAddress: "Email To address",
            toName: "Name of recipient",
            senderEmail: "Sender's email address",
            senderName: "Sender's name",
            emailSubject: "Subject",
            mailTemplateIdentifier: "Spotler Email template ID",
            mailTemplateIdentifierTooltip: "Enter the template identifier of your Spotler email template",
            recipients: "Recipients",
            addRecipient: "Add new recipient",
            emailType: "Recipient type",
            sendMail: "Send an Email",
            placeholders: "Placeholders",
            addPlaceholder: "Add a new placeholder",
            placeholderKey: "Key",
            placeholderKeyTooltip: "Fill in a placeholder name that was referenced in the Spotler email template",
            placeholderValue: "Value",
            placeholderValueTooltip: "The value that will replace the placeholder. Start with pv: to retrieve a process variable"
        },
        de: {
            title: 'Spotler',
            description: 'Spotler ermglicht das versenden von E-Mails aus einem prozess heraus',
            configurationTitle: 'Konfigurationsname',
            configurationTitleTooltip: 'Unter diesem Namen wird das Plugin im Rest der Anwendung erkennbar sein',
            clientId: 'Client ID',
            clientIdTooltip: 'Geben Sie hier Ihre Spotler-Client-ID ein',
            accountId: 'Konto-ID',
            accountIdTooltip: 'Geben Sie die ID Ihres Spotler-Kontos ein',
            clientSecret: 'Secret',
            clientSecretTooltip: 'Geben Sie das mit der obigen clientId verknpfte Geheimnis ein',
            toAddress: "E-Mail-Adresse",
            toName: "Name des Empfngers",
            senderEmail: "E-Mail-Adresse des Absender",
            senderName: "Name des Absender",
            emailSubject: "E-Mail Betreff",
            mailTemplateIdentifier: "Spotler E-Mail-Vorlagen-ID",
            mailTemplateIdentifierTooltip: "Geben Sie die Vorlagenkennung Ihrer Spotler-E-Mail-Vorlage ein",
            recipients: "Empfnger",
            addRecipient: "Neuen Empfnger hinzufgen",
            emailType: "Empfngertyp",
            sendMail: "E-Mail senden",
            placeholders: "Platzhalter",
            addPlaceholder: "Fgen Sie einen neuen Platzhalter hinzu",
            placeholderKey: "Schlssel",
            placeholderKeyTooltip: "Geben Sie einen Platzhalternamen ein, auf den in der Spotler-E-Mail-Vorlage verwiesen wurde",
            placeholderValue: "Wert",
            placeholderValueTooltip: "Der Wert, der den Platzhalter ersetzt. Beginnen Sie mit pv:, um eine Prozessvariable abzurufen."
        },
    },
};



/***/ }),

/***/ "./src/lib/components/plugin-configuration/spotler-plugin-configuration.component.html":
/*!*********************************************************************************************!*\
  !*** ./src/lib/components/plugin-configuration/spotler-plugin-configuration.component.html ***!
  \*********************************************************************************************/
/***/ ((module) => {

module.exports = "<!--\n  ~ Copyright 2015-2024. Ritense BV, the Netherlands.\n  ~\n  ~ Licensed under EUPL, Version 1.2 (the \"License\");\n  ~ you may not use this file except in compliance with the License.\n  ~ You may obtain a copy of the License at\n  ~\n  ~ https://joinup.ec.europa.eu/collection/eupl/eupl-text-eupl-12\n  ~\n  ~ Unless required by applicable law or agreed to in writing, software\n  ~ distributed under the License is distributed on an \"AS IS\" basis,\n  ~\n  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n  ~ express or implied.\n  ~ See the License for the specific language governing permissions and\n  ~ limitations under the License.\n  ~\n  -->\n\n<v-form\n        (valueChange)=\"formValueChange($event)\"\n        *ngIf=\"{\n    disabled: disabled$ | async,\n    prefill: prefillConfiguration$ ? (prefillConfiguration$ | async) : null\n  } as obs\"\n>\n  <v-input\n          name=\"configurationTitle\"\n          [title]=\"'configurationTitle' | pluginTranslate: pluginId | async\"\n          [margin]=\"true\"\n          [disabled]=\"obs.disabled\"\n          [defaultValue]=\"obs.prefill?.configurationTitle\"\n          [required]=\"true\"\n          [tooltip]=\"'configurationTitleTooltip' | pluginTranslate: pluginId | async\"\n          placeholder=\"Spotler plugin\"\n  >\n  </v-input>\n  <v-input\n          name=\"clientId\"\n          [title]=\"'clientId' | pluginTranslate: pluginId | async\"\n          [margin]=\"true\"\n          [disabled]=\"obs.disabled\"\n          [defaultValue]=\"obs.prefill?.clientId\"\n          [required]=\"true\"\n          [tooltip]=\"'clientIdTooltip' | pluginTranslate: pluginId | async\"\n          placeholder=\"client-id\"\n  >\n  </v-input>\n  <v-input\n          name=\"accountId\"\n          [title]=\"'accountId' | pluginTranslate: pluginId | async\"\n          [margin]=\"true\"\n          [disabled]=\"obs.disabled\"\n          [defaultValue]=\"obs.prefill?.accountId\"\n          [required]=\"true\"\n          [tooltip]=\"'accountIdTooltip' | pluginTranslate: pluginId | async\"\n          placeholder=\"account-id\"\n  >\n  </v-input>\n  <v-input\n          name=\"clientSecret\"\n          type=\"password\"\n          [title]=\"'clientSecret' | pluginTranslate: pluginId | async\"\n          [margin]=\"true\"\n          [disabled]=\"obs.disabled\"\n          [defaultValue]=\"obs.prefill?.clientSecret\"\n          [required]=\"true\"\n          [fullWidth]=\"true\"\n          [tooltip]=\"'clientSecretTooltip' | pluginTranslate: pluginId | async\"\n  >\n  </v-input>\n</v-form>\n";

/***/ }),

/***/ "./src/lib/components/plugin-configuration/spotler-plugin-configuration.component.scss":
/*!*********************************************************************************************!*\
  !*** ./src/lib/components/plugin-configuration/spotler-plugin-configuration.component.scss ***!
  \*********************************************************************************************/
/***/ ((module) => {

module.exports = "/*!\n * Copyright 2015-2024. Ritense BV, the Netherlands.\n *\n * Licensed under EUPL, Version 1.2 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * https://joinup.ec.europa.eu/collection/eupl/eupl-text-eupl-12\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" basis,\n *\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n * express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n";

/***/ }),

/***/ "./src/lib/components/send-mail-configuration/send-mail-action-configuration.component.html":
/*!**************************************************************************************************!*\
  !*** ./src/lib/components/send-mail-configuration/send-mail-action-configuration.component.html ***!
  \**************************************************************************************************/
/***/ ((module) => {

module.exports = "<!--\n  ~ Copyright 2015-2024. Ritense BV, the Netherlands.\n  ~\n  ~ Licensed under EUPL, Version 1.2 (the \"License\");\n  ~ you may not use this file except in compliance with the License.\n  ~ You may obtain a copy of the License at\n  ~\n  ~ https://joinup.ec.europa.eu/collection/eupl/eupl-text-eupl-12\n  ~\n  ~ Unless required by applicable law or agreed to in writing, software\n  ~ distributed under the License is distributed on an \"AS IS\" basis,\n  ~\n  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n  ~ express or implied.\n  ~ See the License for the specific language governing permissions and\n  ~ limitations under the License.\n  ~\n  -->\n\n<v-form\n        (valueChange)=\"formValueChange($event)\"\n        *ngIf=\"{\n    disabled: disabled$ | async,\n    prefill: prefillConfiguration$ ? (prefillConfiguration$ | async) : null\n  } as obs\"\n>\n    <v-input\n            name=\"subject\"\n            [title]=\"'emailSubject' | pluginTranslate: pluginId | async\"\n            [margin]=\"true\"\n            [disabled]=\"obs.disabled\"\n            [defaultValue]=\"obs.prefill?.subject\"\n            [widthPx]=\"350\"\n            [required]=\"true\"\n            placeholder=\"Subject\"\n    >\n    </v-input>\n    <v-input\n            name=\"senderEmail\"\n            [title]=\"'senderEmail' | pluginTranslate: pluginId | async\"\n            [margin]=\"true\"\n            [disabled]=\"obs.disabled\"\n            [defaultValue]=\"obs.prefill?.senderEmail\"\n            [widthPx]=\"350\"\n            [required]=\"true\"\n            placeholder=\"Sender Email\"\n    >\n    </v-input>\n    <v-input\n            name=\"senderName\"\n            [title]=\"'senderName' | pluginTranslate: pluginId | async\"\n            [margin]=\"true\"\n            [disabled]=\"obs.disabled\"\n            [defaultValue]=\"obs.prefill?.senderName\"\n            [widthPx]=\"350\"\n            [required]=\"true\"\n            placeholder=\"Sender Name\"\n    >\n    </v-input>\n    <v-input\n            name=\"mailTemplateIdentifier\"\n            [title]=\"'mailTemplateIdentifier' | pluginTranslate: pluginId | async\"\n            [margin]=\"true\"\n            [disabled]=\"obs.disabled\"\n            [defaultValue]=\"obs.prefill?.mailTemplateIdentifier\"\n            [required]=\"true\"\n            [fullWidth]=\"true\"\n            [tooltip]=\"'mailTemplateIdentifier' | pluginTranslate: pluginId | async\"\n    >\n    </v-input>\n    <v-multi-input-form\n            name=\"recipients\"\n            [title]=\"'recipients' | pluginTranslate: pluginId | async\"\n            [formTemplate]=\"recipient\"\n            [addRowText]=\"'addRecipient' | pluginTranslate: pluginId | async\"\n            [required]=\"false\"\n            [initialAmountOfRows]=\"0\"\n            [minimumAmountOfRows]=\"0\"\n            [defaultValues]=\"obs.prefill?.recipients\"\n    >\n    </v-multi-input-form>\n    <v-multi-input-form\n            name=\"placeholders\"\n            [title]=\"'placeholders' | pluginTranslate: pluginId | async\"\n            [formTemplate]=\"placeholder\"\n            [addRowText]=\"'addPlaceholder' | pluginTranslate: pluginId | async\"\n            [required]=\"false\"\n            [initialAmountOfRows]=\"0\"\n            [minimumAmountOfRows]=\"0\"\n            [defaultValues]=\"obs.prefill?.placeholders\"\n    >\n    </v-multi-input-form>\n</v-form>\n\n<ng-template #recipient\n             let-uuid=\"uuid\"\n             let-changeFunction=\"changeFunction\"\n             let-prefill=\"prefill\">\n    <v-form (valueChange)=\"changeFunction($event, uuid);\" [className]=\"'recipient'\" class=\"recipient-form\">\n        <v-input\n                name=\"email\"\n                [title]=\"'toAddress' | pluginTranslate: pluginId | async\"\n                [margin]=\"true\"\n                [required]=\"true\"\n                [fullWidth]=\"true\"\n                [tooltip]=\"'toAddress' | pluginTranslate: pluginId | async\"\n                [defaultValue]=\"prefill?.email\"\n                [widthPx]=\"350\"\n                class=\"recipient-item\"\n        ></v-input>\n        <v-input\n                name=\"name\"\n                [title]=\"'toName' | pluginTranslate: pluginId | async\"\n                [margin]=\"true\"\n                [required]=\"true\"\n                [fullWidth]=\"true\"\n                [tooltip]=\"'toName' | pluginTranslate: pluginId | async\"\n                [defaultValue]=\"prefill?.name\"\n                class=\"recipient-item\"\n        ></v-input>\n        <v-select\n                name=\"type\"\n                [items] = recipientTypes\n                [title]=\"'emailType' | pluginTranslate: pluginId | async\"\n                [margin]=\"true\"\n                [required]=\"true\"\n                [defaultSelectionId]=\"prefill?.type ?? 'TO'\"\n                class=\"recipient-item\"\n        ></v-select>\n    </v-form>\n</ng-template>\n\n<ng-template #placeholder\n             let-uuid=\"uuid\"\n             let-changeFunction=\"changeFunction\"\n             let-prefill=\"prefill\">\n    <v-form (valueChange)=\"changeFunction($event, uuid);\" [className]=\"'recipient'\" class=\"recipient-form\">\n        <v-input\n                name=\"key\"\n                [title]=\"'placeholderKey' | pluginTranslate: pluginId | async\"\n                [margin]=\"true\"\n                [required]=\"true\"\n                [fullWidth]=\"true\"\n                [tooltip]=\"'placeholderKey' | pluginTranslate: pluginId | async\"\n                [defaultValue]=\"prefill?.key\"\n                [widthPx]=\"350\"\n                class=\"recipient-item\"\n        ></v-input>\n        <v-input\n                name=\"value\"\n                [title]=\"'placeholderValue' | pluginTranslate: pluginId | async\"\n                [margin]=\"true\"\n                [required]=\"true\"\n                [fullWidth]=\"true\"\n                [tooltip]=\"'placeholderValue' | pluginTranslate: pluginId | async\"\n                [defaultValue]=\"prefill?.value\"\n                [widthPx]=\"350\"\n                class=\"recipient-item\"\n        ></v-input>\n    </v-form>\n</ng-template>\n";

/***/ }),

/***/ "./src/lib/components/send-mail-configuration/send-mail-action-configuration.component.scss":
/*!**************************************************************************************************!*\
  !*** ./src/lib/components/send-mail-configuration/send-mail-action-configuration.component.scss ***!
  \**************************************************************************************************/
/***/ ((module) => {

module.exports = "/*!\n * Copyright 2015-2024. Ritense BV, the Netherlands.\n *\n * Licensed under EUPL, Version 1.2 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * https://joinup.ec.europa.eu/collection/eupl/eupl-text-eupl-12\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" basis,\n *\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n * express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n.recipient-form {\n  ::ng-deep {\n    .v-form {\n      flex-direction: row !important;\n    }\n  }\n}\n\n.recipient-item {\n  margin: 4px;\n}\n";

/***/ }),

/***/ "@angular/common":
/*!**********************************!*\
  !*** external "@angular/common" ***!
  \**********************************/
/***/ ((module) => {

module.exports = window["@angular/common"];

/***/ }),

/***/ "@angular/core":
/*!********************************!*\
  !*** external "@angular/core" ***!
  \********************************/
/***/ ((module) => {

module.exports = window["@angular/core"];

/***/ }),

/***/ "@valtimo/components":
/*!**************************************!*\
  !*** external "@valtimo/components" ***!
  \**************************************/
/***/ ((module) => {

module.exports = window["@valtimo/components"];

/***/ }),

/***/ "@valtimo/plugin":
/*!**********************************!*\
  !*** external "@valtimo/plugin" ***!
  \**********************************/
/***/ ((module) => {

module.exports = window["@valtimo/plugin"];

/***/ }),

/***/ "rxjs":
/*!***********************!*\
  !*** external "rxjs" ***!
  \***********************/
/***/ ((module) => {

module.exports = window["rxjs"];

/***/ }),

/***/ "tslib":
/*!************************!*\
  !*** external "tslib" ***!
  \************************/
/***/ ((module) => {

module.exports = window["tslib"];

/***/ }),

/***/ "../../../node_modules/@angular/forms/fesm2022/forms.mjs":
/*!***************************************************************!*\
  !*** ../../../node_modules/@angular/forms/fesm2022/forms.mjs ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

var _angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache;
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AbstractControl: () => (/* binding */ AbstractControl),
/* harmony export */   AbstractControlDirective: () => (/* binding */ AbstractControlDirective),
/* harmony export */   AbstractFormGroupDirective: () => (/* binding */ AbstractFormGroupDirective),
/* harmony export */   COMPOSITION_BUFFER_MODE: () => (/* binding */ COMPOSITION_BUFFER_MODE),
/* harmony export */   CheckboxControlValueAccessor: () => (/* binding */ CheckboxControlValueAccessor),
/* harmony export */   CheckboxRequiredValidator: () => (/* binding */ CheckboxRequiredValidator),
/* harmony export */   ControlContainer: () => (/* binding */ ControlContainer),
/* harmony export */   DefaultValueAccessor: () => (/* binding */ DefaultValueAccessor),
/* harmony export */   EmailValidator: () => (/* binding */ EmailValidator),
/* harmony export */   FormArray: () => (/* binding */ FormArray),
/* harmony export */   FormArrayName: () => (/* binding */ FormArrayName),
/* harmony export */   FormBuilder: () => (/* binding */ FormBuilder),
/* harmony export */   FormControl: () => (/* binding */ FormControl),
/* harmony export */   FormControlDirective: () => (/* binding */ FormControlDirective),
/* harmony export */   FormControlName: () => (/* binding */ FormControlName),
/* harmony export */   FormGroup: () => (/* binding */ FormGroup),
/* harmony export */   FormGroupDirective: () => (/* binding */ FormGroupDirective),
/* harmony export */   FormGroupName: () => (/* binding */ FormGroupName),
/* harmony export */   FormRecord: () => (/* binding */ FormRecord),
/* harmony export */   FormsModule: () => (/* binding */ FormsModule),
/* harmony export */   MaxLengthValidator: () => (/* binding */ MaxLengthValidator),
/* harmony export */   MaxValidator: () => (/* binding */ MaxValidator),
/* harmony export */   MinLengthValidator: () => (/* binding */ MinLengthValidator),
/* harmony export */   MinValidator: () => (/* binding */ MinValidator),
/* harmony export */   NG_ASYNC_VALIDATORS: () => (/* binding */ NG_ASYNC_VALIDATORS),
/* harmony export */   NG_VALIDATORS: () => (/* binding */ NG_VALIDATORS),
/* harmony export */   NG_VALUE_ACCESSOR: () => (/* binding */ NG_VALUE_ACCESSOR),
/* harmony export */   NgControl: () => (/* binding */ NgControl),
/* harmony export */   NgControlStatus: () => (/* binding */ NgControlStatus),
/* harmony export */   NgControlStatusGroup: () => (/* binding */ NgControlStatusGroup),
/* harmony export */   NgForm: () => (/* binding */ NgForm),
/* harmony export */   NgModel: () => (/* binding */ NgModel),
/* harmony export */   NgModelGroup: () => (/* binding */ NgModelGroup),
/* harmony export */   NgSelectOption: () => (/* binding */ NgSelectOption),
/* harmony export */   NonNullableFormBuilder: () => (/* binding */ NonNullableFormBuilder),
/* harmony export */   NumberValueAccessor: () => (/* binding */ NumberValueAccessor),
/* harmony export */   PatternValidator: () => (/* binding */ PatternValidator),
/* harmony export */   RadioControlValueAccessor: () => (/* binding */ RadioControlValueAccessor),
/* harmony export */   RangeValueAccessor: () => (/* binding */ RangeValueAccessor),
/* harmony export */   ReactiveFormsModule: () => (/* binding */ ReactiveFormsModule),
/* harmony export */   RequiredValidator: () => (/* binding */ RequiredValidator),
/* harmony export */   SelectControlValueAccessor: () => (/* binding */ SelectControlValueAccessor),
/* harmony export */   SelectMultipleControlValueAccessor: () => (/* binding */ SelectMultipleControlValueAccessor),
/* harmony export */   UntypedFormArray: () => (/* binding */ UntypedFormArray),
/* harmony export */   UntypedFormBuilder: () => (/* binding */ UntypedFormBuilder),
/* harmony export */   UntypedFormControl: () => (/* binding */ UntypedFormControl),
/* harmony export */   UntypedFormGroup: () => (/* binding */ UntypedFormGroup),
/* harmony export */   VERSION: () => (/* binding */ VERSION),
/* harmony export */   Validators: () => (/* binding */ Validators),
/* harmony export */   isFormArray: () => (/* binding */ isFormArray),
/* harmony export */   isFormControl: () => (/* binding */ isFormControl),
/* harmony export */   isFormGroup: () => (/* binding */ isFormGroup),
/* harmony export */   isFormRecord: () => (/* binding */ isFormRecord),
/* harmony export */   "InternalFormsSharedModule": () => (/* binding */ InternalFormsSharedModule),
/* harmony export */   "NgNoValidate": () => (/* binding */ NgNoValidate),
/* harmony export */   "NgSelectMultipleOption": () => (/* binding */ NgSelectMultipleOption)
/* harmony export */ });
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @angular/core */ "@angular/core");
/* harmony import */ var _angular_common__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @angular/common */ "@angular/common");
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! rxjs */ "rxjs");
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! rxjs/operators */ "../../../node_modules/rxjs/dist/esm5/internal/operators/map.js");
/**
 * @license Angular v17.3.12
 * (c) 2010-2024 Google LLC. https://angular.io/
 * License: MIT
 */







/**
 * Base class for all ControlValueAccessor classes defined in Forms package.
 * Contains common logic and utility functions.
 *
 * Note: this is an *internal-only* class and should not be extended or used directly in
 * applications code.
 */
class BaseControlValueAccessor {
    constructor(_renderer, _elementRef) {
        this._renderer = _renderer;
        this._elementRef = _elementRef;
        /**
         * The registered callback function called when a change or input event occurs on the input
         * element.
         * @nodoc
         */
        this.onChange = (_) => { };
        /**
         * The registered callback function called when a blur event occurs on the input element.
         * @nodoc
         */
        this.onTouched = () => { };
    }
    /**
     * Helper method that sets a property on a target element using the current Renderer
     * implementation.
     * @nodoc
     */
    setProperty(key, value) {
        this._renderer.setProperty(this._elementRef.nativeElement, key, value);
    }
    /**
     * Registers a function called when the control is touched.
     * @nodoc
     */
    registerOnTouched(fn) {
        this.onTouched = fn;
    }
    /**
     * Registers a function called when the control value changes.
     * @nodoc
     */
    registerOnChange(fn) {
        this.onChange = fn;
    }
    /**
     * Sets the "disabled" property on the range input element.
     * @nodoc
     */
    setDisabledState(isDisabled) {
        this.setProperty('disabled', isDisabled);
    }
    static { this.fac = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareFactory"]({ minVersion: "12.0.0", version: "17.3.12", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: BaseControlValueAccessor, deps: [{ token: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Renderer2 }, { token: _angular_core__WEBPACK_IMPORTED_MODULE_0__.ElementRef }], target: _angular_core__WEBPACK_IMPORTED_MODULE_0__["FactoryTarget"].Directive }); }
    static { this.dir = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareDirective"]({ minVersion: "14.0.0", version: "17.3.12", type: BaseControlValueAccessor, ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))) }); }
}
_angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareClassMetadata"]({ minVersion: "12.0.0", version: "17.3.12", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: BaseControlValueAccessor, decorators: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Directive
        }], ctorParameters: () => [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Renderer2 }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.ElementRef }] });
/**
 * Base class for all built-in ControlValueAccessor classes (except DefaultValueAccessor, which is
 * used in case no other CVAs can be found). We use this class to distinguish between default CVA,
 * built-in CVAs and custom CVAs, so that Forms logic can recognize built-in CVAs and treat custom
 * ones with higher priority (when both built-in and custom CVAs are present).
 *
 * Note: this is an *internal-only* class and should not be extended or used directly in
 * applications code.
 */
class BuiltInControlValueAccessor extends BaseControlValueAccessor {
    static { this.fac = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareFactory"]({ minVersion: "12.0.0", version: "17.3.12", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: BuiltInControlValueAccessor, deps: null, target: _angular_core__WEBPACK_IMPORTED_MODULE_0__["FactoryTarget"].Directive }); }
    static { this.dir = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareDirective"]({ minVersion: "14.0.0", version: "17.3.12", type: BuiltInControlValueAccessor, usesInheritance: true, ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))) }); }
}
_angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareClassMetadata"]({ minVersion: "12.0.0", version: "17.3.12", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: BuiltInControlValueAccessor, decorators: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Directive
        }] });
/**
 * Used to provide a `ControlValueAccessor` for form controls.
 *
 * See `DefaultValueAccessor` for how to implement one.
 *
 * @publicApi
 */
const NG_VALUE_ACCESSOR = new _angular_core__WEBPACK_IMPORTED_MODULE_0__.InjectionToken(ngDevMode ? 'NgValueAccessor' : '');

const CHECKBOX_VALUE_ACCESSOR = {
    provide: NG_VALUE_ACCESSOR,
    useExisting: (0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(() => CheckboxControlValueAccessor),
    multi: true,
};
/**
 * @description
 * A `ControlValueAccessor` for writing a value and listening to changes on a checkbox input
 * element.
 *
 * @usageNotes
 *
 * ### Using a checkbox with a reactive form.
 *
 * The following example shows how to use a checkbox with a reactive form.
 *
 * ```ts
 * const rememberLoginControl = new FormControl();
 * ```
 *
 * ```
 * <input type="checkbox" [formControl]="rememberLoginControl">
 * ```
 *
 * @ngModule ReactiveFormsModule
 * @ngModule FormsModule
 * @publicApi
 */
class CheckboxControlValueAccessor extends BuiltInControlValueAccessor {
    /**
     * Sets the "checked" property on the input element.
     * @nodoc
     */
    writeValue(value) {
        this.setProperty('checked', value);
    }
    static { this.fac = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareFactory"]({ minVersion: "12.0.0", version: "17.3.12", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: CheckboxControlValueAccessor, deps: null, target: _angular_core__WEBPACK_IMPORTED_MODULE_0__["FactoryTarget"].Directive }); }
    static { this.dir = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareDirective"]({ minVersion: "14.0.0", version: "17.3.12", type: CheckboxControlValueAccessor, selector: "input[type=checkbox][formControlName],input[type=checkbox][formControl],input[type=checkbox][ngModel]", host: { listeners: { "change": "onChange($event.target.checked)", "blur": "onTouched()" } }, providers: [CHECKBOX_VALUE_ACCESSOR], usesInheritance: true, ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))) }); }
}
_angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareClassMetadata"]({ minVersion: "12.0.0", version: "17.3.12", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: CheckboxControlValueAccessor, decorators: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Directive,
            args: [{
                    selector: 'input[type=checkbox][formControlName],input[type=checkbox][formControl],input[type=checkbox][ngModel]',
                    host: { '(change)': 'onChange($event.target.checked)', '(blur)': 'onTouched()' },
                    providers: [CHECKBOX_VALUE_ACCESSOR]
                }]
        }] });

const DEFAULT_VALUE_ACCESSOR = {
    provide: NG_VALUE_ACCESSOR,
    useExisting: (0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(() => DefaultValueAccessor),
    multi: true
};
/**
 * We must check whether the agent is Android because composition events
 * behave differently between iOS and Android.
 */
function _isAndroid() {
    const userAgent = (0,_angular_common__WEBPACK_IMPORTED_MODULE_1__["getDOM"])() ? (0,_angular_common__WEBPACK_IMPORTED_MODULE_1__["getDOM"])().getUserAgent() : '';
    return /android (\d+)/.test(userAgent.toLowerCase());
}
/**
 * @description
 * Provide this token to control if form directives buffer IME input until
 * the "compositionend" event occurs.
 * @publicApi
 */
const COMPOSITION_BUFFER_MODE = new _angular_core__WEBPACK_IMPORTED_MODULE_0__.InjectionToken(ngDevMode ? 'CompositionEventMode' : '');
/**
 * The default `ControlValueAccessor` for writing a value and listening to changes on input
 * elements. The accessor is used by the `FormControlDirective`, `FormControlName`, and
 * `NgModel` directives.
 *
 * {@searchKeywords ngDefaultControl}
 *
 * @usageNotes
 *
 * ### Using the default value accessor
 *
 * The following example shows how to use an input element that activates the default value accessor
 * (in this case, a text field).
 *
 * ```ts
 * const firstNameControl = new FormControl();
 * ```
 *
 * ```
 * <input type="text" [formControl]="firstNameControl">
 * ```
 *
 * This value accessor is used by default for `<input type="text">` and `<textarea>` elements, but
 * you could also use it for custom components that have similar behavior and do not require special
 * processing. In order to attach the default value accessor to a custom element, add the
 * `ngDefaultControl` attribute as shown below.
 *
 * ```
 * <custom-input-component ngDefaultControl [(ngModel)]="value"></custom-input-component>
 * ```
 *
 * @ngModule ReactiveFormsModule
 * @ngModule FormsModule
 * @publicApi
 */
class DefaultValueAccessor extends BaseControlValueAccessor {
    constructor(renderer, elementRef, _compositionMode) {
        super(renderer, elementRef);
        this._compositionMode = _compositionMode;
        /** Whether the user is creating a composition string (IME events). */
        this._composing = false;
        if (this._compositionMode == null) {
            this._compositionMode = !_isAndroid();
        }
    }
    /**
     * Sets the "value" property on the input element.
     * @nodoc
     */
    writeValue(value) {
        const normalizedValue = value == null ? '' : value;
        this.setProperty('value', normalizedValue);
    }
    /** @internal */
    _handleInput(value) {
        if (!this._compositionMode || (this._compositionMode && !this._composing)) {
            this.onChange(value);
        }
    }
    /** @internal */
    _compositionStart() {
        this._composing = true;
    }
    /** @internal */
    _compositionEnd(value) {
        this._composing = false;
        this._compositionMode && this.onChange(value);
    }
    static { this.fac = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareFactory"]({ minVersion: "12.0.0", version: "17.3.12", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: DefaultValueAccessor, deps: [{ token: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Renderer2 }, { token: _angular_core__WEBPACK_IMPORTED_MODULE_0__.ElementRef }, { token: COMPOSITION_BUFFER_MODE, optional: true }], target: _angular_core__WEBPACK_IMPORTED_MODULE_0__["FactoryTarget"].Directive }); }
    static { this.dir = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareDirective"]({ minVersion: "14.0.0", version: "17.3.12", type: DefaultValueAccessor, selector: "input:not([type=checkbox])[formControlName],textarea[formControlName],input:not([type=checkbox])[formControl],textarea[formControl],input:not([type=checkbox])[ngModel],textarea[ngModel],[ngDefaultControl]", host: { listeners: { "input": "$any(this)._handleInput($event.target.value)", "blur": "onTouched()", "compositionstart": "$any(this)._compositionStart()", "compositionend": "$any(this)._compositionEnd($event.target.value)" } }, providers: [DEFAULT_VALUE_ACCESSOR], usesInheritance: true, ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))) }); }
}
_angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareClassMetadata"]({ minVersion: "12.0.0", version: "17.3.12", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: DefaultValueAccessor, decorators: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Directive,
            args: [{
                    selector: 'input:not([type=checkbox])[formControlName],textarea[formControlName],input:not([type=checkbox])[formControl],textarea[formControl],input:not([type=checkbox])[ngModel],textarea[ngModel],[ngDefaultControl]',
                    // TODO: vsavkin replace the above selector with the one below it once
                    // https://github.com/angular/angular/issues/3011 is implemented
                    // selector: '[ngModel],[formControl],[formControlName]',
                    host: {
                        '(input)': '$any(this)._handleInput($event.target.value)',
                        '(blur)': 'onTouched()',
                        '(compositionstart)': '$any(this)._compositionStart()',
                        '(compositionend)': '$any(this)._compositionEnd($event.target.value)'
                    },
                    providers: [DEFAULT_VALUE_ACCESSOR]
                }]
        }], ctorParameters: () => [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Renderer2 }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.ElementRef }, { type: undefined, decorators: [{
                    type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Optional
                }, {
                    type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Inject,
                    args: [COMPOSITION_BUFFER_MODE]
                }] }] });

function isEmptyInputValue(value) {
    /**
     * Check if the object is a string or array before evaluating the length attribute.
     * This avoids falsely rejecting objects that contain a custom length attribute.
     * For example, the object {id: 1, length: 0, width: 0} should not be returned as empty.
     */
    return value == null ||
        ((typeof value === 'string' || Array.isArray(value)) && value.length === 0);
}
function hasValidLength(value) {
    // non-strict comparison is intentional, to check for both `null` and `undefined` values
    return value != null && typeof value.length === 'number';
}
/**
 * @description
 * An `InjectionToken` for registering additional synchronous validators used with
 * `AbstractControl`s.
 *
 * @see {@link NG_ASYNC_VALIDATORS}
 *
 * @usageNotes
 *
 * ### Providing a custom validator
 *
 * The following example registers a custom validator directive. Adding the validator to the
 * existing collection of validators requires the `multi: true` option.
 *
 * ```typescript
 * @Directive({
 *   selector: '[customValidator]',
 *   providers: [{provide: NG_VALIDATORS, useExisting: CustomValidatorDirective, multi: true}]
 * })
 * class CustomValidatorDirective implements Validator {
 *   validate(control: AbstractControl): ValidationErrors | null {
 *     return { 'custom': true };
 *   }
 * }
 * ```
 *
 * @publicApi
 */
const NG_VALIDATORS = new _angular_core__WEBPACK_IMPORTED_MODULE_0__.InjectionToken(ngDevMode ? 'NgValidators' : '');
/**
 * @description
 * An `InjectionToken` for registering additional asynchronous validators used with
 * `AbstractControl`s.
 *
 * @see {@link NG_VALIDATORS}
 *
 * @usageNotes
 *
 * ### Provide a custom async validator directive
 *
 * The following example implements the `AsyncValidator` interface to create an
 * async validator directive with a custom error key.
 *
 * ```typescript
 * @Directive({
 *   selector: '[customAsyncValidator]',
 *   providers: [{provide: NG_ASYNC_VALIDATORS, useExisting: CustomAsyncValidatorDirective, multi:
 * true}]
 * })
 * class CustomAsyncValidatorDirective implements AsyncValidator {
 *   validate(control: AbstractControl): Promise<ValidationErrors|null> {
 *     return Promise.resolve({'custom': true});
 *   }
 * }
 * ```
 *
 * @publicApi
 */
const NG_ASYNC_VALIDATORS = new _angular_core__WEBPACK_IMPORTED_MODULE_0__.InjectionToken(ngDevMode ? 'NgAsyncValidators' : '');
/**
 * A regular expression that matches valid e-mail addresses.
 *
 * At a high level, this regexp matches e-mail addresses of the format `local-part@tld`, where:
 * - `local-part` consists of one or more of the allowed characters (alphanumeric and some
 *   punctuation symbols).
 * - `local-part` cannot begin or end with a period (`.`).
 * - `local-part` cannot be longer than 64 characters.
 * - `tld` consists of one or more `labels` separated by periods (`.`). For example `localhost` or
 *   `foo.com`.
 * - A `label` consists of one or more of the allowed characters (alphanumeric, dashes (`-`) and
 *   periods (`.`)).
 * - A `label` cannot begin or end with a dash (`-`) or a period (`.`).
 * - A `label` cannot be longer than 63 characters.
 * - The whole address cannot be longer than 254 characters.
 *
 * ## Implementation background
 *
 * This regexp was ported over from AngularJS (see there for git history):
 * https://github.com/angular/angular.js/blob/c133ef836/src/ng/directive/input.js#L27
 * It is based on the
 * [WHATWG version](https://html.spec.whatwg.org/multipage/input.html#valid-e-mail-address) with
 * some enhancements to incorporate more RFC rules (such as rules related to domain names and the
 * lengths of different parts of the address). The main differences from the WHATWG version are:
 *   - Disallow `local-part` to begin or end with a period (`.`).
 *   - Disallow `local-part` length to exceed 64 characters.
 *   - Disallow total address length to exceed 254 characters.
 *
 * See [this commit](https://github.com/angular/angular.js/commit/f3f5cf72e) for more details.
 */
const EMAIL_REGEXP = /^(?=.{1,254}$)(?=.{1,64}@)[a-zA-Z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-zA-Z0-9!#$%&'*+/=?^_`{|}~-]+)*@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;
/**
 * @description
 * Provides a set of built-in validators that can be used by form controls.
 *
 * A validator is a function that processes a `FormControl` or collection of
 * controls and returns an error map or null. A null map means that validation has passed.
 *
 * @see [Form Validation](/guide/form-validation)
 *
 * @publicApi
 */
class Validators {
    /**
     * @description
     * Validator that requires the control's value to be greater than or equal to the provided number.
     *
     * @usageNotes
     *
     * ### Validate against a minimum of 3
     *
     * ```typescript
     * const control = new FormControl(2, Validators.min(3));
     *
     * console.log(control.errors); // {min: {min: 3, actual: 2}}
     * ```
     *
     * @returns A validator function that returns an error map with the
     * `min` property if the validation check fails, otherwise `null`.
     *
     * @see {@link updateValueAndValidity()}
     *
     */
    static min(min) {
        return minValidator(min);
    }
    /**
     * @description
     * Validator that requires the control's value to be less than or equal to the provided number.
     *
     * @usageNotes
     *
     * ### Validate against a maximum of 15
     *
     * ```typescript
     * const control = new FormControl(16, Validators.max(15));
     *
     * console.log(control.errors); // {max: {max: 15, actual: 16}}
     * ```
     *
     * @returns A validator function that returns an error map with the
     * `max` property if the validation check fails, otherwise `null`.
     *
     * @see {@link updateValueAndValidity()}
     *
     */
    static max(max) {
        return maxValidator(max);
    }
    /**
     * @description
     * Validator that requires the control have a non-empty value.
     *
     * @usageNotes
     *
     * ### Validate that the field is non-empty
     *
     * ```typescript
     * const control = new FormControl('', Validators.required);
     *
     * console.log(control.errors); // {required: true}
     * ```
     *
     * @returns An error map with the `required` property
     * if the validation check fails, otherwise `null`.
     *
     * @see {@link updateValueAndValidity()}
     *
     */
    static required(control) {
        return requiredValidator(control);
    }
    /**
     * @description
     * Validator that requires the control's value be true. This validator is commonly
     * used for required checkboxes.
     *
     * @usageNotes
     *
     * ### Validate that the field value is true
     *
     * ```typescript
     * const control = new FormControl('some value', Validators.requiredTrue);
     *
     * console.log(control.errors); // {required: true}
     * ```
     *
     * @returns An error map that contains the `required` property
     * set to `true` if the validation check fails, otherwise `null`.
     *
     * @see {@link updateValueAndValidity()}
     *
     */
    static requiredTrue(control) {
        return requiredTrueValidator(control);
    }
    /**
     * @description
     * Validator that requires the control's value pass an email validation test.
     *
     * Tests the value using a [regular
     * expression](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions)
     * pattern suitable for common use cases. The pattern is based on the definition of a valid email
     * address in the [WHATWG HTML
     * specification](https://html.spec.whatwg.org/multipage/input.html#valid-e-mail-address) with
     * some enhancements to incorporate more RFC rules (such as rules related to domain names and the
     * lengths of different parts of the address).
     *
     * The differences from the WHATWG version include:
     * - Disallow `local-part` (the part before the `@` symbol) to begin or end with a period (`.`).
     * - Disallow `local-part` to be longer than 64 characters.
     * - Disallow the whole address to be longer than 254 characters.
     *
     * If this pattern does not satisfy your business needs, you can use `Validators.pattern()` to
     * validate the value against a different pattern.
     *
     * @usageNotes
     *
     * ### Validate that the field matches a valid email pattern
     *
     * ```typescript
     * const control = new FormControl('bad@', Validators.email);
     *
     * console.log(control.errors); // {email: true}
     * ```
     *
     * @returns An error map with the `email` property
     * if the validation check fails, otherwise `null`.
     *
     * @see {@link updateValueAndValidity()}
     *
     */
    static email(control) {
        return emailValidator(control);
    }
    /**
     * @description
     * Validator that requires the length of the control's value to be greater than or equal
     * to the provided minimum length. This validator is also provided by default if you use the
     * the HTML5 `minlength` attribute. Note that the `minLength` validator is intended to be used
     * only for types that have a numeric `length` property, such as strings or arrays. The
     * `minLength` validator logic is also not invoked for values when their `length` property is 0
     * (for example in case of an empty string or an empty array), to support optional controls. You
     * can use the standard `required` validator if empty values should not be considered valid.
     *
     * @usageNotes
     *
     * ### Validate that the field has a minimum of 3 characters
     *
     * ```typescript
     * const control = new FormControl('ng', Validators.minLength(3));
     *
     * console.log(control.errors); // {minlength: {requiredLength: 3, actualLength: 2}}
     * ```
     *
     * ```html
     * <input minlength="5">
     * ```
     *
     * @returns A validator function that returns an error map with the
     * `minlength` property if the validation check fails, otherwise `null`.
     *
     * @see {@link updateValueAndValidity()}
     *
     */
    static minLength(minLength) {
        return minLengthValidator(minLength);
    }
    /**
     * @description
     * Validator that requires the length of the control's value to be less than or equal
     * to the provided maximum length. This validator is also provided by default if you use the
     * the HTML5 `maxlength` attribute. Note that the `maxLength` validator is intended to be used
     * only for types that have a numeric `length` property, such as strings or arrays.
     *
     * @usageNotes
     *
     * ### Validate that the field has maximum of 5 characters
     *
     * ```typescript
     * const control = new FormControl('Angular', Validators.maxLength(5));
     *
     * console.log(control.errors); // {maxlength: {requiredLength: 5, actualLength: 7}}
     * ```
     *
     * ```html
     * <input maxlength="5">
     * ```
     *
     * @returns A validator function that returns an error map with the
     * `maxlength` property if the validation check fails, otherwise `null`.
     *
     * @see {@link updateValueAndValidity()}
     *
     */
    static maxLength(maxLength) {
        return maxLengthValidator(maxLength);
    }
    /**
     * @description
     * Validator that requires the control's value to match a regex pattern. This validator is also
     * provided by default if you use the HTML5 `pattern` attribute.
     *
     * @usageNotes
     *
     * ### Validate that the field only contains letters or spaces
     *
     * ```typescript
     * const control = new FormControl('1', Validators.pattern('[a-zA-Z ]*'));
     *
     * console.log(control.errors); // {pattern: {requiredPattern: '^[a-zA-Z ]*$', actualValue: '1'}}
     * ```
     *
     * ```html
     * <input pattern="[a-zA-Z ]*">
     * ```
     *
     * ### Pattern matching with the global or sticky flag
     *
     * `RegExp` objects created with the `g` or `y` flags that are passed into `Validators.pattern`
     * can produce different results on the same input when validations are run consecutively. This is
     * due to how the behavior of `RegExp.prototype.test` is
     * specified in [ECMA-262](https://tc39.es/ecma262/#sec-regexpbuiltinexec)
     * (`RegExp` preserves the index of the last match when the global or sticky flag is used).
     * Due to this behavior, it is recommended that when using
     * `Validators.pattern` you **do not** pass in a `RegExp` object with either the global or sticky
     * flag enabled.
     *
     * ```typescript
     * // Not recommended (since the `g` flag is used)
     * const controlOne = new FormControl('1', Validators.pattern(/foo/g));
     *
     * // Good
     * const controlTwo = new FormControl('1', Validators.pattern(/foo/));
     * ```
     *
     * @param pattern A regular expression to be used as is to test the values, or a string.
     * If a string is passed, the `^` character is prepended and the `$` character is
     * appended to the provided string (if not already present), and the resulting regular
     * expression is used to test the values.
     *
     * @returns A validator function that returns an error map with the
     * `pattern` property if the validation check fails, otherwise `null`.
     *
     * @see {@link updateValueAndValidity()}
     *
     */
    static pattern(pattern) {
        return patternValidator(pattern);
    }
    /**
     * @description
     * Validator that performs no operation.
     *
     * @see {@link updateValueAndValidity()}
     *
     */
    static nullValidator(control) {
        return nullValidator(control);
    }
    static compose(validators) {
        return compose(validators);
    }
    /**
     * @description
     * Compose multiple async validators into a single function that returns the union
     * of the individual error objects for the provided control.
     *
     * @returns A validator function that returns an error map with the
     * merged error objects of the async validators if the validation check fails, otherwise `null`.
     *
     * @see {@link updateValueAndValidity()}
     *
     */
    static composeAsync(validators) {
        return composeAsync(validators);
    }
}
/**
 * Validator that requires the control's value to be greater than or equal to the provided number.
 * See `Validators.min` for additional information.
 */
function minValidator(min) {
    return (control) => {
        if (isEmptyInputValue(control.value) || isEmptyInputValue(min)) {
            return null; // don't validate empty values to allow optional controls
        }
        const value = parseFloat(control.value);
        // Controls with NaN values after parsing should be treated as not having a
        // minimum, per the HTML forms spec: https://www.w3.org/TR/html5/forms.html#attr-input-min
        return !isNaN(value) && value < min ? { 'min': { 'min': min, 'actual': control.value } } : null;
    };
}
/**
 * Validator that requires the control's value to be less than or equal to the provided number.
 * See `Validators.max` for additional information.
 */
function maxValidator(max) {
    return (control) => {
        if (isEmptyInputValue(control.value) || isEmptyInputValue(max)) {
            return null; // don't validate empty values to allow optional controls
        }
        const value = parseFloat(control.value);
        // Controls with NaN values after parsing should be treated as not having a
        // maximum, per the HTML forms spec: https://www.w3.org/TR/html5/forms.html#attr-input-max
        return !isNaN(value) && value > max ? { 'max': { 'max': max, 'actual': control.value } } : null;
    };
}
/**
 * Validator that requires the control have a non-empty value.
 * See `Validators.required` for additional information.
 */
function requiredValidator(control) {
    return isEmptyInputValue(control.value) ? { 'required': true } : null;
}
/**
 * Validator that requires the control's value be true. This validator is commonly
 * used for required checkboxes.
 * See `Validators.requiredTrue` for additional information.
 */
function requiredTrueValidator(control) {
    return control.value === true ? null : { 'required': true };
}
/**
 * Validator that requires the control's value pass an email validation test.
 * See `Validators.email` for additional information.
 */
function emailValidator(control) {
    if (isEmptyInputValue(control.value)) {
        return null; // don't validate empty values to allow optional controls
    }
    return EMAIL_REGEXP.test(control.value) ? null : { 'email': true };
}
/**
 * Validator that requires the length of the control's value to be greater than or equal
 * to the provided minimum length. See `Validators.minLength` for additional information.
 */
function minLengthValidator(minLength) {
    return (control) => {
        if (isEmptyInputValue(control.value) || !hasValidLength(control.value)) {
            // don't validate empty values to allow optional controls
            // don't validate values without `length` property
            return null;
        }
        return control.value.length < minLength ?
            { 'minlength': { 'requiredLength': minLength, 'actualLength': control.value.length } } :
            null;
    };
}
/**
 * Validator that requires the length of the control's value to be less than or equal
 * to the provided maximum length. See `Validators.maxLength` for additional information.
 */
function maxLengthValidator(maxLength) {
    return (control) => {
        return hasValidLength(control.value) && control.value.length > maxLength ?
            { 'maxlength': { 'requiredLength': maxLength, 'actualLength': control.value.length } } :
            null;
    };
}
/**
 * Validator that requires the control's value to match a regex pattern.
 * See `Validators.pattern` for additional information.
 */
function patternValidator(pattern) {
    if (!pattern)
        return nullValidator;
    let regex;
    let regexStr;
    if (typeof pattern === 'string') {
        regexStr = '';
        if (pattern.charAt(0) !== '^')
            regexStr += '^';
        regexStr += pattern;
        if (pattern.charAt(pattern.length - 1) !== '$')
            regexStr += '$';
        regex = new RegExp(regexStr);
    }
    else {
        regexStr = pattern.toString();
        regex = pattern;
    }
    return (control) => {
        if (isEmptyInputValue(control.value)) {
            return null; // don't validate empty values to allow optional controls
        }
        const value = control.value;
        return regex.test(value) ? null :
            { 'pattern': { 'requiredPattern': regexStr, 'actualValue': value } };
    };
}
/**
 * Function that has `ValidatorFn` shape, but performs no operation.
 */
function nullValidator(control) {
    return null;
}
function isPresent(o) {
    return o != null;
}
function toObservable(value) {
    const obs = (0,_angular_core__WEBPACK_IMPORTED_MODULE_0__["isPromise"])(value) ? (0,rxjs__WEBPACK_IMPORTED_MODULE_2__.from)(value) : value;
    if ((typeof ngDevMode === 'undefined' || ngDevMode) && !((0,_angular_core__WEBPACK_IMPORTED_MODULE_0__["isSubscribable"])(obs))) {
        let errorMessage = `Expected async validator to return Promise or Observable.`;
        // A synchronous validator will return object or null.
        if (typeof value === 'object') {
            errorMessage +=
                ' Are you using a synchronous validator where an async validator is expected?';
        }
        throw new _angular_core__WEBPACK_IMPORTED_MODULE_0__["RuntimeError"](-1101 /* RuntimeErrorCode.WRONG_VALIDATOR_RETURN_TYPE */, errorMessage);
    }
    return obs;
}
function mergeErrors(arrayOfErrors) {
    let res = {};
    arrayOfErrors.forEach((errors) => {
        res = errors != null ? { ...res, ...errors } : res;
    });
    return Object.keys(res).length === 0 ? null : res;
}
function executeValidators(control, validators) {
    return validators.map(validator => validator(control));
}
function isValidatorFn(validator) {
    return !validator.validate;
}
/**
 * Given the list of validators that may contain both functions as well as classes, return the list
 * of validator functions (convert validator classes into validator functions). This is needed to
 * have consistent structure in validators list before composing them.
 *
 * @param validators The set of validators that may contain validators both in plain function form
 *     as well as represented as a validator class.
 */
function normalizeValidators(validators) {
    return validators.map(validator => {
        return isValidatorFn(validator) ?
            validator :
            ((c) => validator.validate(c));
    });
}
/**
 * Merges synchronous validators into a single validator function.
 * See `Validators.compose` for additional information.
 */
function compose(validators) {
    if (!validators)
        return null;
    const presentValidators = validators.filter(isPresent);
    if (presentValidators.length == 0)
        return null;
    return function (control) {
        return mergeErrors(executeValidators(control, presentValidators));
    };
}
/**
 * Accepts a list of validators of different possible shapes (`Validator` and `ValidatorFn`),
 * normalizes the list (converts everything to `ValidatorFn`) and merges them into a single
 * validator function.
 */
function composeValidators(validators) {
    return validators != null ? compose(normalizeValidators(validators)) : null;
}
/**
 * Merges asynchronous validators into a single validator function.
 * See `Validators.composeAsync` for additional information.
 */
function composeAsync(validators) {
    if (!validators)
        return null;
    const presentValidators = validators.filter(isPresent);
    if (presentValidators.length == 0)
        return null;
    return function (control) {
        const observables = executeValidators(control, presentValidators).map(toObservable);
        return (0,rxjs__WEBPACK_IMPORTED_MODULE_2__.forkJoin)(observables).pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_3__.map)(mergeErrors));
    };
}
/**
 * Accepts a list of async validators of different possible shapes (`AsyncValidator` and
 * `AsyncValidatorFn`), normalizes the list (converts everything to `AsyncValidatorFn`) and merges
 * them into a single validator function.
 */
function composeAsyncValidators(validators) {
    return validators != null ? composeAsync(normalizeValidators(validators)) :
        null;
}
/**
 * Merges raw control validators with a given directive validator and returns the combined list of
 * validators as an array.
 */
function mergeValidators(controlValidators, dirValidator) {
    if (controlValidators === null)
        return [dirValidator];
    return Array.isArray(controlValidators) ? [...controlValidators, dirValidator] :
        [controlValidators, dirValidator];
}
/**
 * Retrieves the list of raw synchronous validators attached to a given control.
 */
function getControlValidators(control) {
    return control._rawValidators;
}
/**
 * Retrieves the list of raw asynchronous validators attached to a given control.
 */
function getControlAsyncValidators(control) {
    return control._rawAsyncValidators;
}
/**
 * Accepts a singleton validator, an array, or null, and returns an array type with the provided
 * validators.
 *
 * @param validators A validator, validators, or null.
 * @returns A validators array.
 */
function makeValidatorsArray(validators) {
    if (!validators)
        return [];
    return Array.isArray(validators) ? validators : [validators];
}
/**
 * Determines whether a validator or validators array has a given validator.
 *
 * @param validators The validator or validators to compare against.
 * @param validator The validator to check.
 * @returns Whether the validator is present.
 */
function hasValidator(validators, validator) {
    return Array.isArray(validators) ? validators.includes(validator) : validators === validator;
}
/**
 * Combines two arrays of validators into one. If duplicates are provided, only one will be added.
 *
 * @param validators The new validators.
 * @param currentValidators The base array of current validators.
 * @returns An array of validators.
 */
function addValidators(validators, currentValidators) {
    const current = makeValidatorsArray(currentValidators);
    const validatorsToAdd = makeValidatorsArray(validators);
    validatorsToAdd.forEach((v) => {
        // Note: if there are duplicate entries in the new validators array,
        // only the first one would be added to the current list of validators.
        // Duplicate ones would be ignored since `hasValidator` would detect
        // the presence of a validator function and we update the current list in place.
        if (!hasValidator(current, v)) {
            current.push(v);
        }
    });
    return current;
}
function removeValidators(validators, currentValidators) {
    return makeValidatorsArray(currentValidators).filter(v => !hasValidator(validators, v));
}

/**
 * @description
 * Base class for control directives.
 *
 * This class is only used internally in the `ReactiveFormsModule` and the `FormsModule`.
 *
 * @publicApi
 */
class AbstractControlDirective {
    constructor() {
        /**
         * Set of synchronous validators as they were provided while calling `setValidators` function.
         * @internal
         */
        this._rawValidators = [];
        /**
         * Set of asynchronous validators as they were provided while calling `setAsyncValidators`
         * function.
         * @internal
         */
        this._rawAsyncValidators = [];
        /*
         * The set of callbacks to be invoked when directive instance is being destroyed.
         */
        this._onDestroyCallbacks = [];
    }
    /**
     * @description
     * Reports the value of the control if it is present, otherwise null.
     */
    get value() {
        return this.control ? this.control.value : null;
    }
    /**
     * @description
     * Reports whether the control is valid. A control is considered valid if no
     * validation errors exist with the current value.
     * If the control is not present, null is returned.
     */
    get valid() {
        return this.control ? this.control.valid : null;
    }
    /**
     * @description
     * Reports whether the control is invalid, meaning that an error exists in the input value.
     * If the control is not present, null is returned.
     */
    get invalid() {
        return this.control ? this.control.invalid : null;
    }
    /**
     * @description
     * Reports whether a control is pending, meaning that async validation is occurring and
     * errors are not yet available for the input value. If the control is not present, null is
     * returned.
     */
    get pending() {
        return this.control ? this.control.pending : null;
    }
    /**
     * @description
     * Reports whether the control is disabled, meaning that the control is disabled
     * in the UI and is exempt from validation checks and excluded from aggregate
     * values of ancestor controls. If the control is not present, null is returned.
     */
    get disabled() {
        return this.control ? this.control.disabled : null;
    }
    /**
     * @description
     * Reports whether the control is enabled, meaning that the control is included in ancestor
     * calculations of validity or value. If the control is not present, null is returned.
     */
    get enabled() {
        return this.control ? this.control.enabled : null;
    }
    /**
     * @description
     * Reports the control's validation errors. If the control is not present, null is returned.
     */
    get errors() {
        return this.control ? this.control.errors : null;
    }
    /**
     * @description
     * Reports whether the control is pristine, meaning that the user has not yet changed
     * the value in the UI. If the control is not present, null is returned.
     */
    get pristine() {
        return this.control ? this.control.pristine : null;
    }
    /**
     * @description
     * Reports whether the control is dirty, meaning that the user has changed
     * the value in the UI. If the control is not present, null is returned.
     */
    get dirty() {
        return this.control ? this.control.dirty : null;
    }
    /**
     * @description
     * Reports whether the control is touched, meaning that the user has triggered
     * a `blur` event on it. If the control is not present, null is returned.
     */
    get touched() {
        return this.control ? this.control.touched : null;
    }
    /**
     * @description
     * Reports the validation status of the control. Possible values include:
     * 'VALID', 'INVALID', 'DISABLED', and 'PENDING'.
     * If the control is not present, null is returned.
     */
    get status() {
        return this.control ? this.control.status : null;
    }
    /**
     * @description
     * Reports whether the control is untouched, meaning that the user has not yet triggered
     * a `blur` event on it. If the control is not present, null is returned.
     */
    get untouched() {
        return this.control ? this.control.untouched : null;
    }
    /**
     * @description
     * Returns a multicasting observable that emits a validation status whenever it is
     * calculated for the control. If the control is not present, null is returned.
     */
    get statusChanges() {
        return this.control ? this.control.statusChanges : null;
    }
    /**
     * @description
     * Returns a multicasting observable of value changes for the control that emits every time the
     * value of the control changes in the UI or programmatically.
     * If the control is not present, null is returned.
     */
    get valueChanges() {
        return this.control ? this.control.valueChanges : null;
    }
    /**
     * @description
     * Returns an array that represents the path from the top-level form to this control.
     * Each index is the string name of the control on that level.
     */
    get path() {
        return null;
    }
    /**
     * Sets synchronous validators for this directive.
     * @internal
     */
    _setValidators(validators) {
        this._rawValidators = validators || [];
        this._composedValidatorFn = composeValidators(this._rawValidators);
    }
    /**
     * Sets asynchronous validators for this directive.
     * @internal
     */
    _setAsyncValidators(validators) {
        this._rawAsyncValidators = validators || [];
        this._composedAsyncValidatorFn = composeAsyncValidators(this._rawAsyncValidators);
    }
    /**
     * @description
     * Synchronous validator function composed of all the synchronous validators registered with this
     * directive.
     */
    get validator() {
        return this._composedValidatorFn || null;
    }
    /**
     * @description
     * Asynchronous validator function composed of all the asynchronous validators registered with
     * this directive.
     */
    get asyncValidator() {
        return this._composedAsyncValidatorFn || null;
    }
    /**
     * Internal function to register callbacks that should be invoked
     * when directive instance is being destroyed.
     * @internal
     */
    _registerOnDestroy(fn) {
        this._onDestroyCallbacks.push(fn);
    }
    /**
     * Internal function to invoke all registered "on destroy" callbacks.
     * Note: calling this function also clears the list of callbacks.
     * @internal
     */
    _invokeOnDestroyCallbacks() {
        this._onDestroyCallbacks.forEach(fn => fn());
        this._onDestroyCallbacks = [];
    }
    /**
     * @description
     * Resets the control with the provided value if the control is present.
     */
    reset(value = undefined) {
        if (this.control)
            this.control.reset(value);
    }
    /**
     * @description
     * Reports whether the control with the given path has the error specified.
     *
     * @param errorCode The code of the error to check
     * @param path A list of control names that designates how to move from the current control
     * to the control that should be queried for errors.
     *
     * @usageNotes
     * For example, for the following `FormGroup`:
     *
     * ```
     * form = new FormGroup({
     *   address: new FormGroup({ street: new FormControl() })
     * });
     * ```
     *
     * The path to the 'street' control from the root form would be 'address' -> 'street'.
     *
     * It can be provided to this method in one of two formats:
     *
     * 1. An array of string control names, e.g. `['address', 'street']`
     * 1. A period-delimited list of control names in one string, e.g. `'address.street'`
     *
     * If no path is given, this method checks for the error on the current control.
     *
     * @returns whether the given error is present in the control at the given path.
     *
     * If the control is not present, false is returned.
     */
    hasError(errorCode, path) {
        return this.control ? this.control.hasError(errorCode, path) : false;
    }
    /**
     * @description
     * Reports error data for the control with the given path.
     *
     * @param errorCode The code of the error to check
     * @param path A list of control names that designates how to move from the current control
     * to the control that should be queried for errors.
     *
     * @usageNotes
     * For example, for the following `FormGroup`:
     *
     * ```
     * form = new FormGroup({
     *   address: new FormGroup({ street: new FormControl() })
     * });
     * ```
     *
     * The path to the 'street' control from the root form would be 'address' -> 'street'.
     *
     * It can be provided to this method in one of two formats:
     *
     * 1. An array of string control names, e.g. `['address', 'street']`
     * 1. A period-delimited list of control names in one string, e.g. `'address.street'`
     *
     * @returns error data for that particular error. If the control or error is not present,
     * null is returned.
     */
    getError(errorCode, path) {
        return this.control ? this.control.getError(errorCode, path) : null;
    }
}

/**
 * @description
 * A base class for directives that contain multiple registered instances of `NgControl`.
 * Only used by the forms module.
 *
 * @publicApi
 */
class ControlContainer extends AbstractControlDirective {
    /**
     * @description
     * The top-level form directive for the control.
     */
    get formDirective() {
        return null;
    }
    /**
     * @description
     * The path to this group.
     */
    get path() {
        return null;
    }
}

/**
 * @description
 * A base class that all `FormControl`-based directives extend. It binds a `FormControl`
 * object to a DOM element.
 *
 * @publicApi
 */
class NgControl extends AbstractControlDirective {
    constructor() {
        super(...arguments);
        /**
         * @description
         * The parent form for the control.
         *
         * @internal
         */
        this._parent = null;
        /**
         * @description
         * The name for the control
         */
        this.name = null;
        /**
         * @description
         * The value accessor for the control
         */
        this.valueAccessor = null;
    }
}

// DO NOT REFACTOR!
// Each status is represented by a separate function to make sure that
// advanced Closure Compiler optimizations related to property renaming
// can work correctly.
class AbstractControlStatus {
    constructor(cd) {
        this._cd = cd;
    }
    get isTouched() {
        return !!this._cd?.control?.touched;
    }
    get isUntouched() {
        return !!this._cd?.control?.untouched;
    }
    get isPristine() {
        return !!this._cd?.control?.pristine;
    }
    get isDirty() {
        return !!this._cd?.control?.dirty;
    }
    get isValid() {
        return !!this._cd?.control?.valid;
    }
    get isInvalid() {
        return !!this._cd?.control?.invalid;
    }
    get isPending() {
        return !!this._cd?.control?.pending;
    }
    get isSubmitted() {
        // We check for the `submitted` field from `NgForm` and `FormGroupDirective` classes, but
        // we avoid instanceof checks to prevent non-tree-shakable references to those types.
        return !!this._cd?.submitted;
    }
}
const ngControlStatusHost = {
    '[class.ng-untouched]': 'isUntouched',
    '[class.ng-touched]': 'isTouched',
    '[class.ng-pristine]': 'isPristine',
    '[class.ng-dirty]': 'isDirty',
    '[class.ng-valid]': 'isValid',
    '[class.ng-invalid]': 'isInvalid',
    '[class.ng-pending]': 'isPending',
};
const ngGroupStatusHost = {
    ...ngControlStatusHost,
    '[class.ng-submitted]': 'isSubmitted',
};
/**
 * @description
 * Directive automatically applied to Angular form controls that sets CSS classes
 * based on control status.
 *
 * @usageNotes
 *
 * ### CSS classes applied
 *
 * The following classes are applied as the properties become true:
 *
 * * ng-valid
 * * ng-invalid
 * * ng-pending
 * * ng-pristine
 * * ng-dirty
 * * ng-untouched
 * * ng-touched
 *
 * @ngModule ReactiveFormsModule
 * @ngModule FormsModule
 * @publicApi
 */
class NgControlStatus extends AbstractControlStatus {
    constructor(cd) {
        super(cd);
    }
    static { this.fac = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareFactory"]({ minVersion: "12.0.0", version: "17.3.12", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: NgControlStatus, deps: [{ token: NgControl, self: true }], target: _angular_core__WEBPACK_IMPORTED_MODULE_0__["FactoryTarget"].Directive }); }
    static { this.dir = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareDirective"]({ minVersion: "14.0.0", version: "17.3.12", type: NgControlStatus, selector: "[formControlName],[ngModel],[formControl]", host: { properties: { "class.ng-untouched": "isUntouched", "class.ng-touched": "isTouched", "class.ng-pristine": "isPristine", "class.ng-dirty": "isDirty", "class.ng-valid": "isValid", "class.ng-invalid": "isInvalid", "class.ng-pending": "isPending" } }, usesInheritance: true, ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))) }); }
}
_angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareClassMetadata"]({ minVersion: "12.0.0", version: "17.3.12", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: NgControlStatus, decorators: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Directive,
            args: [{ selector: '[formControlName],[ngModel],[formControl]', host: ngControlStatusHost }]
        }], ctorParameters: () => [{ type: NgControl, decorators: [{
                    type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Self
                }] }] });
/**
 * @description
 * Directive automatically applied to Angular form groups that sets CSS classes
 * based on control status (valid/invalid/dirty/etc). On groups, this includes the additional
 * class ng-submitted.
 *
 * @see {@link NgControlStatus}
 *
 * @ngModule ReactiveFormsModule
 * @ngModule FormsModule
 * @publicApi
 */
class NgControlStatusGroup extends AbstractControlStatus {
    constructor(cd) {
        super(cd);
    }
    static { this.fac = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareFactory"]({ minVersion: "12.0.0", version: "17.3.12", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: NgControlStatusGroup, deps: [{ token: ControlContainer, optional: true, self: true }], target: _angular_core__WEBPACK_IMPORTED_MODULE_0__["FactoryTarget"].Directive }); }
    static { this.dir = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareDirective"]({ minVersion: "14.0.0", version: "17.3.12", type: NgControlStatusGroup, selector: "[formGroupName],[formArrayName],[ngModelGroup],[formGroup],form:not([ngNoForm]),[ngForm]", host: { properties: { "class.ng-untouched": "isUntouched", "class.ng-touched": "isTouched", "class.ng-pristine": "isPristine", "class.ng-dirty": "isDirty", "class.ng-valid": "isValid", "class.ng-invalid": "isInvalid", "class.ng-pending": "isPending", "class.ng-submitted": "isSubmitted" } }, usesInheritance: true, ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))) }); }
}
_angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareClassMetadata"]({ minVersion: "12.0.0", version: "17.3.12", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: NgControlStatusGroup, decorators: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Directive,
            args: [{
                    selector: '[formGroupName],[formArrayName],[ngModelGroup],[formGroup],form:not([ngNoForm]),[ngForm]',
                    host: ngGroupStatusHost
                }]
        }], ctorParameters: () => [{ type: ControlContainer, decorators: [{
                    type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Optional
                }, {
                    type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Self
                }] }] });

const formControlNameExample = `
  <div [formGroup]="myGroup">
    <input formControlName="firstName">
  </div>

  In your class:

  this.myGroup = new FormGroup({
      firstName: new FormControl()
  });`;
const formGroupNameExample = `
  <div [formGroup]="myGroup">
      <div formGroupName="person">
        <input formControlName="firstName">
      </div>
  </div>

  In your class:

  this.myGroup = new FormGroup({
      person: new FormGroup({ firstName: new FormControl() })
  });`;
const formArrayNameExample = `
  <div [formGroup]="myGroup">
    <div formArrayName="cities">
      <div *ngFor="let city of cityArray.controls; index as i">
        <input [formControlName]="i">
      </div>
    </div>
  </div>

  In your class:

  this.cityArray = new FormArray([new FormControl('SF')]);
  this.myGroup = new FormGroup({
    cities: this.cityArray
  });`;
const ngModelGroupExample = `
  <form>
      <div ngModelGroup="person">
        <input [(ngModel)]="person.name" name="firstName">
      </div>
  </form>`;
const ngModelWithFormGroupExample = `
  <div [formGroup]="myGroup">
      <input formControlName="firstName">
      <input [(ngModel)]="showMoreControls" [ngModelOptions]="{standalone: true}">
  </div>
`;

function controlParentException() {
    return new _angular_core__WEBPACK_IMPORTED_MODULE_0__["RuntimeError"](1050 /* RuntimeErrorCode.FORM_CONTROL_NAME_MISSING_PARENT */, `formControlName must be used with a parent formGroup directive.  You'll want to add a formGroup
      directive and pass it an existing FormGroup instance (you can create one in your class).

    Example:

    ${formControlNameExample}`);
}
function ngModelGroupException() {
    return new _angular_core__WEBPACK_IMPORTED_MODULE_0__["RuntimeError"](1051 /* RuntimeErrorCode.FORM_CONTROL_NAME_INSIDE_MODEL_GROUP */, `formControlName cannot be used with an ngModelGroup parent. It is only compatible with parents
      that also have a "form" prefix: formGroupName, formArrayName, or formGroup.

      Option 1:  Update the parent to be formGroupName (reactive form strategy)

      ${formGroupNameExample}

      Option 2: Use ngModel instead of formControlName (template-driven strategy)

      ${ngModelGroupExample}`);
}
function missingFormException() {
    return new _angular_core__WEBPACK_IMPORTED_MODULE_0__["RuntimeError"](1052 /* RuntimeErrorCode.FORM_GROUP_MISSING_INSTANCE */, `formGroup expects a FormGroup instance. Please pass one in.

      Example:

      ${formControlNameExample}`);
}
function groupParentException() {
    return new _angular_core__WEBPACK_IMPORTED_MODULE_0__["RuntimeError"](1053 /* RuntimeErrorCode.FORM_GROUP_NAME_MISSING_PARENT */, `formGroupName must be used with a parent formGroup directive.  You'll want to add a formGroup
    directive and pass it an existing FormGroup instance (you can create one in your class).

    Example:

    ${formGroupNameExample}`);
}
function arrayParentException() {
    return new _angular_core__WEBPACK_IMPORTED_MODULE_0__["RuntimeError"](1054 /* RuntimeErrorCode.FORM_ARRAY_NAME_MISSING_PARENT */, `formArrayName must be used with a parent formGroup directive.  You'll want to add a formGroup
      directive and pass it an existing FormGroup instance (you can create one in your class).

      Example:

      ${formArrayNameExample}`);
}
const disabledAttrWarning = `
  It looks like you're using the disabled attribute with a reactive form directive. If you set disabled to true
  when you set up this control in your component class, the disabled attribute will actually be set in the DOM for
  you. We recommend using this approach to avoid 'changed after checked' errors.

  Example:
  // Specify the \`disabled\` property at control creation time:
  form = new FormGroup({
    first: new FormControl({value: 'Nancy', disabled: true}, Validators.required),
    last: new FormControl('Drew', Validators.required)
  });

  // Controls can also be enabled/disabled after creation:
  form.get('first')?.enable();
  form.get('last')?.disable();
`;
const asyncValidatorsDroppedWithOptsWarning = `
  It looks like you're constructing using a FormControl with both an options argument and an
  async validators argument. Mixing these arguments will cause your async validators to be dropped.
  You should either put all your validators in the options object, or in separate validators
  arguments. For example:

  // Using validators arguments
  fc = new FormControl(42, Validators.required, myAsyncValidator);

  // Using AbstractControlOptions
  fc = new FormControl(42, {validators: Validators.required, asyncValidators: myAV});

  // Do NOT mix them: async validators will be dropped!
  fc = new FormControl(42, {validators: Validators.required}, /* Oops! */ myAsyncValidator);
`;
function ngModelWarning(directiveName) {
    return `
  It looks like you're using ngModel on the same form field as ${directiveName}.
  Support for using the ngModel input property and ngModelChange event with
  reactive form directives has been deprecated in Angular v6 and will be removed
  in a future version of Angular.

  For more information on this, see our API docs here:
  https://angular.io/api/forms/${directiveName === 'formControl' ? 'FormControlDirective' : 'FormControlName'}#use-with-ngmodel
  `;
}
function describeKey(isFormGroup, key) {
    return isFormGroup ? `with name: '${key}'` : `at index: ${key}`;
}
function noControlsError(isFormGroup) {
    return `
    There are no form controls registered with this ${isFormGroup ? 'group' : 'array'} yet. If you're using ngModel,
    you may want to check next tick (e.g. use setTimeout).
  `;
}
function missingControlError(isFormGroup, key) {
    return `Cannot find form control ${describeKey(isFormGroup, key)}`;
}
function missingControlValueError(isFormGroup, key) {
    return `Must supply a value for form control ${describeKey(isFormGroup, key)}`;
}

/**
 * Reports that a control is valid, meaning that no errors exist in the input value.
 *
 * @see {@link status}
 */
const VALID = 'VALID';
/**
 * Reports that a control is invalid, meaning that an error exists in the input value.
 *
 * @see {@link status}
 */
const INVALID = 'INVALID';
/**
 * Reports that a control is pending, meaning that async validation is occurring and
 * errors are not yet available for the input value.
 *
 * @see {@link markAsPending}
 * @see {@link status}
 */
const PENDING = 'PENDING';
/**
 * Reports that a control is disabled, meaning that the control is exempt from ancestor
 * calculations of validity or value.
 *
 * @see {@link markAsDisabled}
 * @see {@link status}
 */
const DISABLED = 'DISABLED';
/**
 * Gets validators from either an options object or given validators.
 */
function pickValidators(validatorOrOpts) {
    return (isOptionsObj(validatorOrOpts) ? validatorOrOpts.validators : validatorOrOpts) || null;
}
/**
 * Creates validator function by combining provided validators.
 */
function coerceToValidator(validator) {
    return Array.isArray(validator) ? composeValidators(validator) : validator || null;
}
/**
 * Gets async validators from either an options object or given validators.
 */
function pickAsyncValidators(asyncValidator, validatorOrOpts) {
    if (typeof ngDevMode === 'undefined' || ngDevMode) {
        if (isOptionsObj(validatorOrOpts) && asyncValidator) {
            console.warn(asyncValidatorsDroppedWithOptsWarning);
        }
    }
    return (isOptionsObj(validatorOrOpts) ? validatorOrOpts.asyncValidators : asyncValidator) || null;
}
/**
 * Creates async validator function by combining provided async validators.
 */
function coerceToAsyncValidator(asyncValidator) {
    return Array.isArray(asyncValidator) ? composeAsyncValidators(asyncValidator) :
        asyncValidator || null;
}
function isOptionsObj(validatorOrOpts) {
    return validatorOrOpts != null && !Array.isArray(validatorOrOpts) &&
        typeof validatorOrOpts === 'object';
}
function assertControlPresent(parent, isGroup, key) {
    const controls = parent.controls;
    const collection = isGroup ? Object.keys(controls) : controls;
    if (!collection.length) {
        throw new _angular_core__WEBPACK_IMPORTED_MODULE_0__["RuntimeError"](1000 /* RuntimeErrorCode.NO_CONTROLS */, (typeof ngDevMode === 'undefined' || ngDevMode) ? noControlsError(isGroup) : '');
    }
    if (!controls[key]) {
        throw new _angular_core__WEBPACK_IMPORTED_MODULE_0__["RuntimeError"](1001 /* RuntimeErrorCode.MISSING_CONTROL */, (typeof ngDevMode === 'undefined' || ngDevMode) ? missingControlError(isGroup, key) : '');
    }
}
function assertAllValuesPresent(control, isGroup, value) {
    control._forEachChild((_, key) => {
        if (value[key] === undefined) {
            throw new _angular_core__WEBPACK_IMPORTED_MODULE_0__["RuntimeError"](1002 /* RuntimeErrorCode.MISSING_CONTROL_VALUE */, (typeof ngDevMode === 'undefined' || ngDevMode) ? missingControlValueError(isGroup, key) :
                '');
        }
    });
}
// clang-format on
/**
 * This is the base class for `FormControl`, `FormGroup`, and `FormArray`.
 *
 * It provides some of the shared behavior that all controls and groups of controls have, like
 * running validators, calculating status, and resetting state. It also defines the properties
 * that are shared between all sub-classes, like `value`, `valid`, and `dirty`. It shouldn't be
 * instantiated directly.
 *
 * The first type parameter TValue represents the value type of the control (`control.value`).
 * The optional type parameter TRawValue  represents the raw value type (`control.getRawValue()`).
 *
 * @see [Forms Guide](/guide/forms)
 * @see [Reactive Forms Guide](/guide/reactive-forms)
 * @see [Dynamic Forms Guide](/guide/dynamic-form)
 *
 * @publicApi
 */
class AbstractControl {
    /**
     * Initialize the AbstractControl instance.
     *
     * @param validators The function or array of functions that is used to determine the validity of
     *     this control synchronously.
     * @param asyncValidators The function or array of functions that is used to determine validity of
     *     this control asynchronously.
     */
    constructor(validators, asyncValidators) {
        /** @internal */
        this._pendingDirty = false;
        /**
         * Indicates that a control has its own pending asynchronous validation in progress.
         *
         * @internal
         */
        this._hasOwnPendingAsyncValidator = false;
        /** @internal */
        this._pendingTouched = false;
        /** @internal */
        this._onCollectionChange = () => { };
        this._parent = null;
        /**
         * A control is `pristine` if the user has not yet changed
         * the value in the UI.
         *
         * @returns True if the user has not yet changed the value in the UI; compare `dirty`.
         * Programmatic changes to a control's value do not mark it dirty.
         */
        this.pristine = true;
        /**
         * True if the control is marked as `touched`.
         *
         * A control is marked `touched` once the user has triggered
         * a `blur` event on it.
         */
        this.touched = false;
        /** @internal */
        this._onDisabledChange = [];
        this._assignValidators(validators);
        this._assignAsyncValidators(asyncValidators);
    }
    /**
     * Returns the function that is used to determine the validity of this control synchronously.
     * If multiple validators have been added, this will be a single composed function.
     * See `Validators.compose()` for additional information.
     */
    get validator() {
        return this._composedValidatorFn;
    }
    set validator(validatorFn) {
        this._rawValidators = this._composedValidatorFn = validatorFn;
    }
    /**
     * Returns the function that is used to determine the validity of this control asynchronously.
     * If multiple validators have been added, this will be a single composed function.
     * See `Validators.compose()` for additional information.
     */
    get asyncValidator() {
        return this._composedAsyncValidatorFn;
    }
    set asyncValidator(asyncValidatorFn) {
        this._rawAsyncValidators = this._composedAsyncValidatorFn = asyncValidatorFn;
    }
    /**
     * The parent control.
     */
    get parent() {
        return this._parent;
    }
    /**
     * A control is `valid` when its `status` is `VALID`.
     *
     * @see {@link AbstractControl.status}
     *
     * @returns True if the control has passed all of its validation tests,
     * false otherwise.
     */
    get valid() {
        return this.status === VALID;
    }
    /**
     * A control is `invalid` when its `status` is `INVALID`.
     *
     * @see {@link AbstractControl.status}
     *
     * @returns True if this control has failed one or more of its validation checks,
     * false otherwise.
     */
    get invalid() {
        return this.status === INVALID;
    }
    /**
     * A control is `pending` when its `status` is `PENDING`.
     *
     * @see {@link AbstractControl.status}
     *
     * @returns True if this control is in the process of conducting a validation check,
     * false otherwise.
     */
    get pending() {
        return this.status == PENDING;
    }
    /**
     * A control is `disabled` when its `status` is `DISABLED`.
     *
     * Disabled controls are exempt from validation checks and
     * are not included in the aggregate value of their ancestor
     * controls.
     *
     * @see {@link AbstractControl.status}
     *
     * @returns True if the control is disabled, false otherwise.
     */
    get disabled() {
        return this.status === DISABLED;
    }
    /**
     * A control is `enabled` as long as its `status` is not `DISABLED`.
     *
     * @returns True if the control has any status other than 'DISABLED',
     * false if the status is 'DISABLED'.
     *
     * @see {@link AbstractControl.status}
     *
     */
    get enabled() {
        return this.status !== DISABLED;
    }
    /**
     * A control is `dirty` if the user has changed the value
     * in the UI.
     *
     * @returns True if the user has changed the value of this control in the UI; compare `pristine`.
     * Programmatic changes to a control's value do not mark it dirty.
     */
    get dirty() {
        return !this.pristine;
    }
    /**
     * True if the control has not been marked as touched
     *
     * A control is `untouched` if the user has not yet triggered
     * a `blur` event on it.
     */
    get untouched() {
        return !this.touched;
    }
    /**
     * Reports the update strategy of the `AbstractControl` (meaning
     * the event on which the control updates itself).
     * Possible values: `'change'` | `'blur'` | `'submit'`
     * Default value: `'change'`
     */
    get updateOn() {
        return this._updateOn ? this._updateOn : (this.parent ? this.parent.updateOn : 'change');
    }
    /**
     * Sets the synchronous validators that are active on this control.  Calling
     * this overwrites any existing synchronous validators.
     *
     * When you add or remove a validator at run time, you must call
     * `updateValueAndValidity()` for the new validation to take effect.
     *
     * If you want to add a new validator without affecting existing ones, consider
     * using `addValidators()` method instead.
     */
    setValidators(validators) {
        this._assignValidators(validators);
    }
    /**
     * Sets the asynchronous validators that are active on this control. Calling this
     * overwrites any existing asynchronous validators.
     *
     * When you add or remove a validator at run time, you must call
     * `updateValueAndValidity()` for the new validation to take effect.
     *
     * If you want to add a new validator without affecting existing ones, consider
     * using `addAsyncValidators()` method instead.
     */
    setAsyncValidators(validators) {
        this._assignAsyncValidators(validators);
    }
    /**
     * Add a synchronous validator or validators to this control, without affecting other validators.
     *
     * When you add or remove a validator at run time, you must call
     * `updateValueAndValidity()` for the new validation to take effect.
     *
     * Adding a validator that already exists will have no effect. If duplicate validator functions
     * are present in the `validators` array, only the first instance would be added to a form
     * control.
     *
     * @param validators The new validator function or functions to add to this control.
     */
    addValidators(validators) {
        this.setValidators(addValidators(validators, this._rawValidators));
    }
    /**
     * Add an asynchronous validator or validators to this control, without affecting other
     * validators.
     *
     * When you add or remove a validator at run time, you must call
     * `updateValueAndValidity()` for the new validation to take effect.
     *
     * Adding a validator that already exists will have no effect.
     *
     * @param validators The new asynchronous validator function or functions to add to this control.
     */
    addAsyncValidators(validators) {
        this.setAsyncValidators(addValidators(validators, this._rawAsyncValidators));
    }
    /**
     * Remove a synchronous validator from this control, without affecting other validators.
     * Validators are compared by function reference; you must pass a reference to the exact same
     * validator function as the one that was originally set. If a provided validator is not found,
     * it is ignored.
     *
     * @usageNotes
     *
     * ### Reference to a ValidatorFn
     *
     * ```
     * // Reference to the RequiredValidator
     * const ctrl = new FormControl<string | null>('', Validators.required);
     * ctrl.removeValidators(Validators.required);
     *
     * // Reference to anonymous function inside MinValidator
     * const minValidator = Validators.min(3);
     * const ctrl = new FormControl<string | null>('', minValidator);
     * expect(ctrl.hasValidator(minValidator)).toEqual(true)
     * expect(ctrl.hasValidator(Validators.min(3))).toEqual(false)
     *
     * ctrl.removeValidators(minValidator);
     * ```
     *
     * When you add or remove a validator at run time, you must call
     * `updateValueAndValidity()` for the new validation to take effect.
     *
     * @param validators The validator or validators to remove.
     */
    removeValidators(validators) {
        this.setValidators(removeValidators(validators, this._rawValidators));
    }
    /**
     * Remove an asynchronous validator from this control, without affecting other validators.
     * Validators are compared by function reference; you must pass a reference to the exact same
     * validator function as the one that was originally set. If a provided validator is not found, it
     * is ignored.
     *
     * When you add or remove a validator at run time, you must call
     * `updateValueAndValidity()` for the new validation to take effect.
     *
     * @param validators The asynchronous validator or validators to remove.
     */
    removeAsyncValidators(validators) {
        this.setAsyncValidators(removeValidators(validators, this._rawAsyncValidators));
    }
    /**
     * Check whether a synchronous validator function is present on this control. The provided
     * validator must be a reference to the exact same function that was provided.
     *
     * @usageNotes
     *
     * ### Reference to a ValidatorFn
     *
     * ```
     * // Reference to the RequiredValidator
     * const ctrl = new FormControl<number | null>(0, Validators.required);
     * expect(ctrl.hasValidator(Validators.required)).toEqual(true)
     *
     * // Reference to anonymous function inside MinValidator
     * const minValidator = Validators.min(3);
     * const ctrl = new FormControl<number | null>(0, minValidator);
     * expect(ctrl.hasValidator(minValidator)).toEqual(true)
     * expect(ctrl.hasValidator(Validators.min(3))).toEqual(false)
     * ```
     *
     * @param validator The validator to check for presence. Compared by function reference.
     * @returns Whether the provided validator was found on this control.
     */
    hasValidator(validator) {
        return hasValidator(this._rawValidators, validator);
    }
    /**
     * Check whether an asynchronous validator function is present on this control. The provided
     * validator must be a reference to the exact same function that was provided.
     *
     * @param validator The asynchronous validator to check for presence. Compared by function
     *     reference.
     * @returns Whether the provided asynchronous validator was found on this control.
     */
    hasAsyncValidator(validator) {
        return hasValidator(this._rawAsyncValidators, validator);
    }
    /**
     * Empties out the synchronous validator list.
     *
     * When you add or remove a validator at run time, you must call
     * `updateValueAndValidity()` for the new validation to take effect.
     *
     */
    clearValidators() {
        this.validator = null;
    }
    /**
     * Empties out the async validator list.
     *
     * When you add or remove a validator at run time, you must call
     * `updateValueAndValidity()` for the new validation to take effect.
     *
     */
    clearAsyncValidators() {
        this.asyncValidator = null;
    }
    /**
     * Marks the control as `touched`. A control is touched by focus and
     * blur events that do not change the value.
     *
     * @see {@link markAsUntouched()}
     * @see {@link markAsDirty()}
     * @see {@link markAsPristine()}
     *
     * @param opts Configuration options that determine how the control propagates changes
     * and emits events after marking is applied.
     * * `onlySelf`: When true, mark only this control. When false or not supplied,
     * marks all direct ancestors. Default is false.
     */
    markAsTouched(opts = {}) {
        this.touched = true;
        if (this._parent && !opts.onlySelf) {
            this._parent.markAsTouched(opts);
        }
    }
    /**
     * Marks the control and all its descendant controls as `touched`.
     * @see {@link markAsTouched()}
     */
    markAllAsTouched() {
        this.markAsTouched({ onlySelf: true });
        this._forEachChild((control) => control.markAllAsTouched());
    }
    /**
     * Marks the control as `untouched`.
     *
     * If the control has any children, also marks all children as `untouched`
     * and recalculates the `touched` status of all parent controls.
     *
     * @see {@link markAsTouched()}
     * @see {@link markAsDirty()}
     * @see {@link markAsPristine()}
     *
     * @param opts Configuration options that determine how the control propagates changes
     * and emits events after the marking is applied.
     * * `onlySelf`: When true, mark only this control. When false or not supplied,
     * marks all direct ancestors. Default is false.
     */
    markAsUntouched(opts = {}) {
        this.touched = false;
        this._pendingTouched = false;
        this._forEachChild((control) => {
            control.markAsUntouched({ onlySelf: true });
        });
        if (this._parent && !opts.onlySelf) {
            this._parent._updateTouched(opts);
        }
    }
    /**
     * Marks the control as `dirty`. A control becomes dirty when
     * the control's value is changed through the UI; compare `markAsTouched`.
     *
     * @see {@link markAsTouched()}
     * @see {@link markAsUntouched()}
     * @see {@link markAsPristine()}
     *
     * @param opts Configuration options that determine how the control propagates changes
     * and emits events after marking is applied.
     * * `onlySelf`: When true, mark only this control. When false or not supplied,
     * marks all direct ancestors. Default is false.
     */
    markAsDirty(opts = {}) {
        this.pristine = false;
        if (this._parent && !opts.onlySelf) {
            this._parent.markAsDirty(opts);
        }
    }
    /**
     * Marks the control as `pristine`.
     *
     * If the control has any children, marks all children as `pristine`,
     * and recalculates the `pristine` status of all parent
     * controls.
     *
     * @see {@link markAsTouched()}
     * @see {@link markAsUntouched()}
     * @see {@link markAsDirty()}
     *
     * @param opts Configuration options that determine how the control emits events after
     * marking is applied.
     * * `onlySelf`: When true, mark only this control. When false or not supplied,
     * marks all direct ancestors. Default is false.
     */
    markAsPristine(opts = {}) {
        this.pristine = true;
        this._pendingDirty = false;
        this._forEachChild((control) => {
            control.markAsPristine({ onlySelf: true });
        });
        if (this._parent && !opts.onlySelf) {
            this._parent._updatePristine(opts);
        }
    }
    /**
     * Marks the control as `pending`.
     *
     * A control is pending while the control performs async validation.
     *
     * @see {@link AbstractControl.status}
     *
     * @param opts Configuration options that determine how the control propagates changes and
     * emits events after marking is applied.
     * * `onlySelf`: When true, mark only this control. When false or not supplied,
     * marks all direct ancestors. Default is false.
     * * `emitEvent`: When true or not supplied (the default), the `statusChanges`
     * observable emits an event with the latest status the control is marked pending.
     * When false, no events are emitted.
     *
     */
    markAsPending(opts = {}) {
        this.status = PENDING;
        if (opts.emitEvent !== false) {
            this.statusChanges.emit(this.status);
        }
        if (this._parent && !opts.onlySelf) {
            this._parent.markAsPending(opts);
        }
    }
    /**
     * Disables the control. This means the control is exempt from validation checks and
     * excluded from the aggregate value of any parent. Its status is `DISABLED`.
     *
     * If the control has children, all children are also disabled.
     *
     * @see {@link AbstractControl.status}
     *
     * @param opts Configuration options that determine how the control propagates
     * changes and emits events after the control is disabled.
     * * `onlySelf`: When true, mark only this control. When false or not supplied,
     * marks all direct ancestors. Default is false.
     * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and
     * `valueChanges`
     * observables emit events with the latest status and value when the control is disabled.
     * When false, no events are emitted.
     */
    disable(opts = {}) {
        // If parent has been marked artificially dirty we don't want to re-calculate the
        // parent's dirtiness based on the children.
        const skipPristineCheck = this._parentMarkedDirty(opts.onlySelf);
        this.status = DISABLED;
        this.errors = null;
        this._forEachChild((control) => {
            control.disable({ ...opts, onlySelf: true });
        });
        this._updateValue();
        if (opts.emitEvent !== false) {
            this.valueChanges.emit(this.value);
            this.statusChanges.emit(this.status);
        }
        this._updateAncestors({ ...opts, skipPristineCheck });
        this._onDisabledChange.forEach((changeFn) => changeFn(true));
    }
    /**
     * Enables the control. This means the control is included in validation checks and
     * the aggregate value of its parent. Its status recalculates based on its value and
     * its validators.
     *
     * By default, if the control has children, all children are enabled.
     *
     * @see {@link AbstractControl.status}
     *
     * @param opts Configure options that control how the control propagates changes and
     * emits events when marked as untouched
     * * `onlySelf`: When true, mark only this control. When false or not supplied,
     * marks all direct ancestors. Default is false.
     * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and
     * `valueChanges`
     * observables emit events with the latest status and value when the control is enabled.
     * When false, no events are emitted.
     */
    enable(opts = {}) {
        // If parent has been marked artificially dirty we don't want to re-calculate the
        // parent's dirtiness based on the children.
        const skipPristineCheck = this._parentMarkedDirty(opts.onlySelf);
        this.status = VALID;
        this._forEachChild((control) => {
            control.enable({ ...opts, onlySelf: true });
        });
        this.updateValueAndValidity({ onlySelf: true, emitEvent: opts.emitEvent });
        this._updateAncestors({ ...opts, skipPristineCheck });
        this._onDisabledChange.forEach((changeFn) => changeFn(false));
    }
    _updateAncestors(opts) {
        if (this._parent && !opts.onlySelf) {
            this._parent.updateValueAndValidity(opts);
            if (!opts.skipPristineCheck) {
                this._parent._updatePristine();
            }
            this._parent._updateTouched();
        }
    }
    /**
     * Sets the parent of the control
     *
     * @param parent The new parent.
     */
    setParent(parent) {
        this._parent = parent;
    }
    /**
     * The raw value of this control. For most control implementations, the raw value will include
     * disabled children.
     */
    getRawValue() {
        return this.value;
    }
    /**
     * Recalculates the value and validation status of the control.
     *
     * By default, it also updates the value and validity of its ancestors.
     *
     * @param opts Configuration options determine how the control propagates changes and emits events
     * after updates and validity checks are applied.
     * * `onlySelf`: When true, only update this control. When false or not supplied,
     * update all direct ancestors. Default is false.
     * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and
     * `valueChanges`
     * observables emit events with the latest status and value when the control is updated.
     * When false, no events are emitted.
     */
    updateValueAndValidity(opts = {}) {
        this._setInitialStatus();
        this._updateValue();
        if (this.enabled) {
            this._cancelExistingSubscription();
            this.errors = this._runValidator();
            this.status = this._calculateStatus();
            if (this.status === VALID || this.status === PENDING) {
                this._runAsyncValidator(opts.emitEvent);
            }
        }
        if (opts.emitEvent !== false) {
            this.valueChanges.emit(this.value);
            this.statusChanges.emit(this.status);
        }
        if (this._parent && !opts.onlySelf) {
            this._parent.updateValueAndValidity(opts);
        }
    }
    /** @internal */
    _updateTreeValidity(opts = { emitEvent: true }) {
        this._forEachChild((ctrl) => ctrl._updateTreeValidity(opts));
        this.updateValueAndValidity({ onlySelf: true, emitEvent: opts.emitEvent });
    }
    _setInitialStatus() {
        this.status = this._allControlsDisabled() ? DISABLED : VALID;
    }
    _runValidator() {
        return this.validator ? this.validator(this) : null;
    }
    _runAsyncValidator(emitEvent) {
        if (this.asyncValidator) {
            this.status = PENDING;
            this._hasOwnPendingAsyncValidator = true;
            const obs = toObservable(this.asyncValidator(this));
            this._asyncValidationSubscription = obs.subscribe((errors) => {
                this._hasOwnPendingAsyncValidator = false;
                // This will trigger the recalculation of the validation status, which depends on
                // the state of the asynchronous validation (whether it is in progress or not). So, it is
                // necessary that we have updated the `_hasOwnPendingAsyncValidator` boolean flag first.
                this.setErrors(errors, { emitEvent });
            });
        }
    }
    _cancelExistingSubscription() {
        if (this._asyncValidationSubscription) {
            this._asyncValidationSubscription.unsubscribe();
            this._hasOwnPendingAsyncValidator = false;
        }
    }
    /**
     * Sets errors on a form control when running validations manually, rather than automatically.
     *
     * Calling `setErrors` also updates the validity of the parent control.
     *
     * @param opts Configuration options that determine how the control propagates
     * changes and emits events after the control errors are set.
     * * `emitEvent`: When true or not supplied (the default), the `statusChanges`
     * observable emits an event after the errors are set.
     *
     * @usageNotes
     *
     * ### Manually set the errors for a control
     *
     * ```
     * const login = new FormControl('someLogin');
     * login.setErrors({
     *   notUnique: true
     * });
     *
     * expect(login.valid).toEqual(false);
     * expect(login.errors).toEqual({ notUnique: true });
     *
     * login.setValue('someOtherLogin');
     *
     * expect(login.valid).toEqual(true);
     * ```
     */
    setErrors(errors, opts = {}) {
        this.errors = errors;
        this._updateControlsErrors(opts.emitEvent !== false);
    }
    /**
     * Retrieves a child control given the control's name or path.
     *
     * @param path A dot-delimited string or array of string/number values that define the path to the
     * control. If a string is provided, passing it as a string literal will result in improved type
     * information. Likewise, if an array is provided, passing it `as const` will cause improved type
     * information to be available.
     *
     * @usageNotes
     * ### Retrieve a nested control
     *
     * For example, to get a `name` control nested within a `person` sub-group:
     *
     * * `this.form.get('person.name');`
     *
     * -OR-
     *
     * * `this.form.get(['person', 'name'] as const);` // `as const` gives improved typings
     *
     * ### Retrieve a control in a FormArray
     *
     * When accessing an element inside a FormArray, you can use an element index.
     * For example, to get a `price` control from the first element in an `items` array you can use:
     *
     * * `this.form.get('items.0.price');`
     *
     * -OR-
     *
     * * `this.form.get(['items', 0, 'price']);`
     */
    get(path) {
        let currPath = path;
        if (currPath == null)
            return null;
        if (!Array.isArray(currPath))
            currPath = currPath.split('.');
        if (currPath.length === 0)
            return null;
        return currPath.reduce((control, name) => control && control._find(name), this);
    }
    /**
     * @description
     * Reports error data for the control with the given path.
     *
     * @param errorCode The code of the error to check
     * @param path A list of control names that designates how to move from the current control
     * to the control that should be queried for errors.
     *
     * @usageNotes
     * For example, for the following `FormGroup`:
     *
     * ```
     * form = new FormGroup({
     *   address: new FormGroup({ street: new FormControl() })
     * });
     * ```
     *
     * The path to the 'street' control from the root form would be 'address' -> 'street'.
     *
     * It can be provided to this method in one of two formats:
     *
     * 1. An array of string control names, e.g. `['address', 'street']`
     * 1. A period-delimited list of control names in one string, e.g. `'address.street'`
     *
     * @returns error data for that particular error. If the control or error is not present,
     * null is returned.
     */
    getError(errorCode, path) {
        const control = path ? this.get(path) : this;
        return control && control.errors ? control.errors[errorCode] : null;
    }
    /**
     * @description
     * Reports whether the control with the given path has the error specified.
     *
     * @param errorCode The code of the error to check
     * @param path A list of control names that designates how to move from the current control
     * to the control that should be queried for errors.
     *
     * @usageNotes
     * For example, for the following `FormGroup`:
     *
     * ```
     * form = new FormGroup({
     *   address: new FormGroup({ street: new FormControl() })
     * });
     * ```
     *
     * The path to the 'street' control from the root form would be 'address' -> 'street'.
     *
     * It can be provided to this method in one of two formats:
     *
     * 1. An array of string control names, e.g. `['address', 'street']`
     * 1. A period-delimited list of control names in one string, e.g. `'address.street'`
     *
     * If no path is given, this method checks for the error on the current control.
     *
     * @returns whether the given error is present in the control at the given path.
     *
     * If the control is not present, false is returned.
     */
    hasError(errorCode, path) {
        return !!this.getError(errorCode, path);
    }
    /**
     * Retrieves the top-level ancestor of this control.
     */
    get root() {
        let x = this;
        while (x._parent) {
            x = x._parent;
        }
        return x;
    }
    /** @internal */
    _updateControlsErrors(emitEvent) {
        this.status = this._calculateStatus();
        if (emitEvent) {
            this.statusChanges.emit(this.status);
        }
        if (this._parent) {
            this._parent._updateControlsErrors(emitEvent);
        }
    }
    /** @internal */
    _initObservables() {
        this.valueChanges = new _angular_core__WEBPACK_IMPORTED_MODULE_0__.EventEmitter();
        this.statusChanges = new _angular_core__WEBPACK_IMPORTED_MODULE_0__.EventEmitter();
    }
    _calculateStatus() {
        if (this._allControlsDisabled())
            return DISABLED;
        if (this.errors)
            return INVALID;
        if (this._hasOwnPendingAsyncValidator || this._anyControlsHaveStatus(PENDING))
            return PENDING;
        if (this._anyControlsHaveStatus(INVALID))
            return INVALID;
        return VALID;
    }
    /** @internal */
    _anyControlsHaveStatus(status) {
        return this._anyControls((control) => control.status === status);
    }
    /** @internal */
    _anyControlsDirty() {
        return this._anyControls((control) => control.dirty);
    }
    /** @internal */
    _anyControlsTouched() {
        return this._anyControls((control) => control.touched);
    }
    /** @internal */
    _updatePristine(opts = {}) {
        this.pristine = !this._anyControlsDirty();
        if (this._parent && !opts.onlySelf) {
            this._parent._updatePristine(opts);
        }
    }
    /** @internal */
    _updateTouched(opts = {}) {
        this.touched = this._anyControlsTouched();
        if (this._parent && !opts.onlySelf) {
            this._parent._updateTouched(opts);
        }
    }
    /** @internal */
    _registerOnCollectionChange(fn) {
        this._onCollectionChange = fn;
    }
    /** @internal */
    _setUpdateStrategy(opts) {
        if (isOptionsObj(opts) && opts.updateOn != null) {
            this._updateOn = opts.updateOn;
        }
    }
    /**
     * Check to see if parent has been marked artificially dirty.
     *
     * @internal
     */
    _parentMarkedDirty(onlySelf) {
        const parentDirty = this._parent && this._parent.dirty;
        return !onlySelf && !!parentDirty && !this._parent._anyControlsDirty();
    }
    /** @internal */
    _find(name) {
        return null;
    }
    /**
     * Internal implementation of the `setValidators` method. Needs to be separated out into a
     * different method, because it is called in the constructor and it can break cases where
     * a control is extended.
     */
    _assignValidators(validators) {
        this._rawValidators = Array.isArray(validators) ? validators.slice() : validators;
        this._composedValidatorFn = coerceToValidator(this._rawValidators);
    }
    /**
     * Internal implementation of the `setAsyncValidators` method. Needs to be separated out into a
     * different method, because it is called in the constructor and it can break cases where
     * a control is extended.
     */
    _assignAsyncValidators(validators) {
        this._rawAsyncValidators = Array.isArray(validators) ? validators.slice() : validators;
        this._composedAsyncValidatorFn = coerceToAsyncValidator(this._rawAsyncValidators);
    }
}

/**
 * Tracks the value and validity state of a group of `FormControl` instances.
 *
 * A `FormGroup` aggregates the values of each child `FormControl` into one object,
 * with each control name as the key.  It calculates its status by reducing the status values
 * of its children. For example, if one of the controls in a group is invalid, the entire
 * group becomes invalid.
 *
 * `FormGroup` is one of the four fundamental building blocks used to define forms in Angular,
 * along with `FormControl`, `FormArray`, and `FormRecord`.
 *
 * When instantiating a `FormGroup`, pass in a collection of child controls as the first
 * argument. The key for each child registers the name for the control.
 *
 * `FormGroup` is intended for use cases where the keys are known ahead of time.
 * If you need to dynamically add and remove controls, use {@link FormRecord} instead.
 *
 * `FormGroup` accepts an optional type parameter `TControl`, which is an object type with inner
 * control types as values.
 *
 * @usageNotes
 *
 * ### Create a form group with 2 controls
 *
 * ```
 * const form = new FormGroup({
 *   first: new FormControl('Nancy', Validators.minLength(2)),
 *   last: new FormControl('Drew'),
 * });
 *
 * console.log(form.value);   // {first: 'Nancy', last; 'Drew'}
 * console.log(form.status);  // 'VALID'
 * ```
 *
 * ### The type argument, and optional controls
 *
 * `FormGroup` accepts one generic argument, which is an object containing its inner controls.
 * This type will usually be inferred automatically, but you can always specify it explicitly if you
 * wish.
 *
 * If you have controls that are optional (i.e. they can be removed, you can use the `?` in the
 * type):
 *
 * ```
 * const form = new FormGroup<{
 *   first: FormControl<string|null>,
 *   middle?: FormControl<string|null>, // Middle name is optional.
 *   last: FormControl<string|null>,
 * }>({
 *   first: new FormControl('Nancy'),
 *   last: new FormControl('Drew'),
 * });
 * ```
 *
 * ### Create a form group with a group-level validator
 *
 * You include group-level validators as the second arg, or group-level async
 * validators as the third arg. These come in handy when you want to perform validation
 * that considers the value of more than one child control.
 *
 * ```
 * const form = new FormGroup({
 *   password: new FormControl('', Validators.minLength(2)),
 *   passwordConfirm: new FormControl('', Validators.minLength(2)),
 * }, passwordMatchValidator);
 *
 *
 * function passwordMatchValidator(g: FormGroup) {
 *    return g.get('password').value === g.get('passwordConfirm').value
 *       ? null : {'mismatch': true};
 * }
 * ```
 *
 * Like `FormControl` instances, you choose to pass in
 * validators and async validators as part of an options object.
 *
 * ```
 * const form = new FormGroup({
 *   password: new FormControl('')
 *   passwordConfirm: new FormControl('')
 * }, { validators: passwordMatchValidator, asyncValidators: otherValidator });
 * ```
 *
 * ### Set the updateOn property for all controls in a form group
 *
 * The options object is used to set a default value for each child
 * control's `updateOn` property. If you set `updateOn` to `'blur'` at the
 * group level, all child controls default to 'blur', unless the child
 * has explicitly specified a different `updateOn` value.
 *
 * ```ts
 * const c = new FormGroup({
 *   one: new FormControl()
 * }, { updateOn: 'blur' });
 * ```
 *
 * ### Using a FormGroup with optional controls
 *
 * It is possible to have optional controls in a FormGroup. An optional control can be removed later
 * using `removeControl`, and can be omitted when calling `reset`. Optional controls must be
 * declared optional in the group's type.
 *
 * ```ts
 * const c = new FormGroup<{one?: FormControl<string>}>({
 *   one: new FormControl('')
 * });
 * ```
 *
 * Notice that `c.value.one` has type `string|null|undefined`. This is because calling `c.reset({})`
 * without providing the optional key `one` will cause it to become `null`.
 *
 * @publicApi
 */
class FormGroup extends AbstractControl {
    /**
     * Creates a new `FormGroup` instance.
     *
     * @param controls A collection of child controls. The key for each child is the name
     * under which it is registered.
     *
     * @param validatorOrOpts A synchronous validator function, or an array of
     * such functions, or an `AbstractControlOptions` object that contains validation functions
     * and a validation trigger.
     *
     * @param asyncValidator A single async validator or array of async validator functions
     *
     */
    constructor(controls, validatorOrOpts, asyncValidator) {
        super(pickValidators(validatorOrOpts), pickAsyncValidators(asyncValidator, validatorOrOpts));
        (typeof ngDevMode === 'undefined' || ngDevMode) && validateFormGroupControls(controls);
        this.controls = controls;
        this._initObservables();
        this._setUpdateStrategy(validatorOrOpts);
        this._setUpControls();
        this.updateValueAndValidity({
            onlySelf: true,
            // If `asyncValidator` is present, it will trigger control status change from `PENDING` to
            // `VALID` or `INVALID`. The status should be broadcasted via the `statusChanges` observable,
            // so we set `emitEvent` to `true` to allow that during the control creation process.
            emitEvent: !!this.asyncValidator
        });
    }
    registerControl(name, control) {
        if (this.controls[name])
            return this.controls[name];
        this.controls[name] = control;
        control.setParent(this);
        control._registerOnCollectionChange(this._onCollectionChange);
        return control;
    }
    addControl(name, control, options = {}) {
        this.registerControl(name, control);
        this.updateValueAndValidity({ emitEvent: options.emitEvent });
        this._onCollectionChange();
    }
    /**
     * Remove a control from this group. In a strongly-typed group, required controls cannot be
     * removed.
     *
     * This method also updates the value and validity of the control.
     *
     * @param name The control name to remove from the collection
     * @param options Specifies whether this FormGroup instance should emit events after a
     *     control is removed.
     * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and
     * `valueChanges` observables emit events with the latest status and value when the control is
     * removed. When false, no events are emitted.
     */
    removeControl(name, options = {}) {
        if (this.controls[name])
            this.controls[name]._registerOnCollectionChange(() => { });
        delete (this.controls[name]);
        this.updateValueAndValidity({ emitEvent: options.emitEvent });
        this._onCollectionChange();
    }
    setControl(name, control, options = {}) {
        if (this.controls[name])
            this.controls[name]._registerOnCollectionChange(() => { });
        delete (this.controls[name]);
        if (control)
            this.registerControl(name, control);
        this.updateValueAndValidity({ emitEvent: options.emitEvent });
        this._onCollectionChange();
    }
    contains(controlName) {
        return this.controls.hasOwnProperty(controlName) && this.controls[controlName].enabled;
    }
    /**
     * Sets the value of the `FormGroup`. It accepts an object that matches
     * the structure of the group, with control names as keys.
     *
     * @usageNotes
     * ### Set the complete value for the form group
     *
     * ```
     * const form = new FormGroup({
     *   first: new FormControl(),
     *   last: new FormControl()
     * });
     *
     * console.log(form.value);   // {first: null, last: null}
     *
     * form.setValue({first: 'Nancy', last: 'Drew'});
     * console.log(form.value);   // {first: 'Nancy', last: 'Drew'}
     * ```
     *
     * @throws When strict checks fail, such as setting the value of a control
     * that doesn't exist or if you exclude a value of a control that does exist.
     *
     * @param value The new value for the control that matches the structure of the group.
     * @param options Configuration options that determine how the control propagates changes
     * and emits events after the value changes.
     * The configuration options are passed to the {@link AbstractControl#updateValueAndValidity
     * updateValueAndValidity} method.
     *
     * * `onlySelf`: When true, each change only affects this control, and not its parent. Default is
     * false.
     * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and
     * `valueChanges`
     * observables emit events with the latest status and value when the control value is updated.
     * When false, no events are emitted.
     */
    setValue(value, options = {}) {
        assertAllValuesPresent(this, true, value);
        Object.keys(value).forEach(name => {
            assertControlPresent(this, true, name);
            this.controls[name].setValue(value[name], { onlySelf: true, emitEvent: options.emitEvent });
        });
        this.updateValueAndValidity(options);
    }
    /**
     * Patches the value of the `FormGroup`. It accepts an object with control
     * names as keys, and does its best to match the values to the correct controls
     * in the group.
     *
     * It accepts both super-sets and sub-sets of the group without throwing an error.
     *
     * @usageNotes
     * ### Patch the value for a form group
     *
     * ```
     * const form = new FormGroup({
     *    first: new FormControl(),
     *    last: new FormControl()
     * });
     * console.log(form.value);   // {first: null, last: null}
     *
     * form.patchValue({first: 'Nancy'});
     * console.log(form.value);   // {first: 'Nancy', last: null}
     * ```
     *
     * @param value The object that matches the structure of the group.
     * @param options Configuration options that determine how the control propagates changes and
     * emits events after the value is patched.
     * * `onlySelf`: When true, each change only affects this control and not its parent. Default is
     * true.
     * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and
     * `valueChanges` observables emit events with the latest status and value when the control value
     * is updated. When false, no events are emitted. The configuration options are passed to
     * the {@link AbstractControl#updateValueAndValidity updateValueAndValidity} method.
     */
    patchValue(value, options = {}) {
        // Even though the `value` argument type doesn't allow `null` and `undefined` values, the
        // `patchValue` can be called recursively and inner data structures might have these values, so
        // we just ignore such cases when a field containing FormGroup instance receives `null` or
        // `undefined` as a value.
        if (value == null /* both `null` and `undefined` */)
            return;
        Object.keys(value).forEach(name => {
            // The compiler cannot see through the uninstantiated conditional type of `this.controls`, so
            // `as any` is required.
            const control = this.controls[name];
            if (control) {
                control.patchValue(
                /* Guaranteed to be present, due to the outer forEach. */ value[name], { onlySelf: true, emitEvent: options.emitEvent });
            }
        });
        this.updateValueAndValidity(options);
    }
    /**
     * Resets the `FormGroup`, marks all descendants `pristine` and `untouched` and sets
     * the value of all descendants to their default values, or null if no defaults were provided.
     *
     * You reset to a specific form state by passing in a map of states
     * that matches the structure of your form, with control names as keys. The state
     * is a standalone value or a form state object with both a value and a disabled
     * status.
     *
     * @param value Resets the control with an initial value,
     * or an object that defines the initial value and disabled state.
     *
     * @param options Configuration options that determine how the control propagates changes
     * and emits events when the group is reset.
     * * `onlySelf`: When true, each change only affects this control, and not its parent. Default is
     * false.
     * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and
     * `valueChanges`
     * observables emit events with the latest status and value when the control is reset.
     * When false, no events are emitted.
     * The configuration options are passed to the {@link AbstractControl#updateValueAndValidity
     * updateValueAndValidity} method.
     *
     * @usageNotes
     *
     * ### Reset the form group values
     *
     * ```ts
     * const form = new FormGroup({
     *   first: new FormControl('first name'),
     *   last: new FormControl('last name')
     * });
     *
     * console.log(form.value);  // {first: 'first name', last: 'last name'}
     *
     * form.reset({ first: 'name', last: 'last name' });
     *
     * console.log(form.value);  // {first: 'name', last: 'last name'}
     * ```
     *
     * ### Reset the form group values and disabled status
     *
     * ```
     * const form = new FormGroup({
     *   first: new FormControl('first name'),
     *   last: new FormControl('last name')
     * });
     *
     * form.reset({
     *   first: {value: 'name', disabled: true},
     *   last: 'last'
     * });
     *
     * console.log(form.value);  // {last: 'last'}
     * console.log(form.get('first').status);  // 'DISABLED'
     * ```
     */
    reset(value = {}, options = {}) {
        this._forEachChild((control, name) => {
            control.reset(value ? value[name] : null, { onlySelf: true, emitEvent: options.emitEvent });
        });
        this._updatePristine(options);
        this._updateTouched(options);
        this.updateValueAndValidity(options);
    }
    /**
     * The aggregate value of the `FormGroup`, including any disabled controls.
     *
     * Retrieves all values regardless of disabled status.
     */
    getRawValue() {
        return this._reduceChildren({}, (acc, control, name) => {
            acc[name] = control.getRawValue();
            return acc;
        });
    }
    /** @internal */
    _syncPendingControls() {
        let subtreeUpdated = this._reduceChildren(false, (updated, child) => {
            return child._syncPendingControls() ? true : updated;
        });
        if (subtreeUpdated)
            this.updateValueAndValidity({ onlySelf: true });
        return subtreeUpdated;
    }
    /** @internal */
    _forEachChild(cb) {
        Object.keys(this.controls).forEach(key => {
            // The list of controls can change (for ex. controls might be removed) while the loop
            // is running (as a result of invoking Forms API in `valueChanges` subscription), so we
            // have to null check before invoking the callback.
            const control = this.controls[key];
            control && cb(control, key);
        });
    }
    /** @internal */
    _setUpControls() {
        this._forEachChild((control) => {
            control.setParent(this);
            control._registerOnCollectionChange(this._onCollectionChange);
        });
    }
    /** @internal */
    _updateValue() {
        this.value = this._reduceValue();
    }
    /** @internal */
    _anyControls(condition) {
        for (const [controlName, control] of Object.entries(this.controls)) {
            if (this.contains(controlName) && condition(control)) {
                return true;
            }
        }
        return false;
    }
    /** @internal */
    _reduceValue() {
        let acc = {};
        return this._reduceChildren(acc, (acc, control, name) => {
            if (control.enabled || this.disabled) {
                acc[name] = control.value;
            }
            return acc;
        });
    }
    /** @internal */
    _reduceChildren(initValue, fn) {
        let res = initValue;
        this._forEachChild((control, name) => {
            res = fn(res, control, name);
        });
        return res;
    }
    /** @internal */
    _allControlsDisabled() {
        for (const controlName of Object.keys(this.controls)) {
            if (this.controls[controlName].enabled) {
                return false;
            }
        }
        return Object.keys(this.controls).length > 0 || this.disabled;
    }
    /** @internal */
    _find(name) {
        return this.controls.hasOwnProperty(name) ?
            this.controls[name] :
            null;
    }
}
/**
 * Will validate that none of the controls has a key with a dot
 * Throws other wise
 */
function validateFormGroupControls(controls) {
    const invalidKeys = Object.keys(controls).filter(key => key.includes('.'));
    if (invalidKeys.length > 0) {
        // TODO: make this an error once there are no more uses in G3
        console.warn(`FormGroup keys cannot include \`.\`, please replace the keys for: ${invalidKeys.join(',')}.`);
    }
}
const UntypedFormGroup = FormGroup;
/**
 * @description
 * Asserts that the given control is an instance of `FormGroup`
 *
 * @publicApi
 */
const isFormGroup = (control) => control instanceof FormGroup;
/**
 * Tracks the value and validity state of a collection of `FormControl` instances, each of which has
 * the same value type.
 *
 * `FormRecord` is very similar to {@link FormGroup}, except it can be used with a dynamic keys,
 * with controls added and removed as needed.
 *
 * `FormRecord` accepts one generic argument, which describes the type of the controls it contains.
 *
 * @usageNotes
 *
 * ```
 * let numbers = new FormRecord({bill: new FormControl('415-123-456')});
 * numbers.addControl('bob', new FormControl('415-234-567'));
 * numbers.removeControl('bill');
 * ```
 *
 * @publicApi
 */
class FormRecord extends FormGroup {
}
/**
 * @description
 * Asserts that the given control is an instance of `FormRecord`
 *
 * @publicApi
 */
const isFormRecord = (control) => control instanceof FormRecord;

/**
 * Token to provide to allow SetDisabledState to always be called when a CVA is added, regardless of
 * whether the control is disabled or enabled.
 *
 * @see {@link FormsModule#withconfig}
 */
const CALL_SET_DISABLED_STATE = new _angular_core__WEBPACK_IMPORTED_MODULE_0__.InjectionToken('CallSetDisabledState', { providedIn: 'root', factory: () => setDisabledStateDefault });
/**
 * Whether to use the fixed setDisabledState behavior by default.
 */
const setDisabledStateDefault = 'always';
function controlPath(name, parent) {
    return [...parent.path, name];
}
/**
 * Links a Form control and a Form directive by setting up callbacks (such as `onChange`) on both
 * instances. This function is typically invoked when form directive is being initialized.
 *
 * @param control Form control instance that should be linked.
 * @param dir Directive that should be linked with a given control.
 */
function setUpControl(control, dir, callSetDisabledState = setDisabledStateDefault) {
    if (typeof ngDevMode === 'undefined' || ngDevMode) {
        if (!control)
            _throwError(dir, 'Cannot find control with');
        if (!dir.valueAccessor)
            _throwMissingValueAccessorError(dir);
    }
    setUpValidators(control, dir);
    dir.valueAccessor.writeValue(control.value);
    // The legacy behavior only calls the CVA's `setDisabledState` if the control is disabled.
    // If the `callSetDisabledState` option is set to `always`, then this bug is fixed and
    // the method is always called.
    if (control.disabled || callSetDisabledState === 'always') {
        dir.valueAccessor.setDisabledState?.(control.disabled);
    }
    setUpViewChangePipeline(control, dir);
    setUpModelChangePipeline(control, dir);
    setUpBlurPipeline(control, dir);
    setUpDisabledChangeHandler(control, dir);
}
/**
 * Reverts configuration performed by the `setUpControl` control function.
 * Effectively disconnects form control with a given form directive.
 * This function is typically invoked when corresponding form directive is being destroyed.
 *
 * @param control Form control which should be cleaned up.
 * @param dir Directive that should be disconnected from a given control.
 * @param validateControlPresenceOnChange Flag that indicates whether onChange handler should
 *     contain asserts to verify that it's not called once directive is destroyed. We need this flag
 *     to avoid potentially breaking changes caused by better control cleanup introduced in #39235.
 */
function cleanUpControl(control, dir, validateControlPresenceOnChange = true) {
    const noop = () => {
        if (validateControlPresenceOnChange && (typeof ngDevMode === 'undefined' || ngDevMode)) {
            _noControlError(dir);
        }
    };
    // The `valueAccessor` field is typically defined on FromControl and FormControlName directive
    // instances and there is a logic in `selectValueAccessor` function that throws if it's not the
    // case. We still check the presence of `valueAccessor` before invoking its methods to make sure
    // that cleanup works correctly if app code or tests are setup to ignore the error thrown from
    // `selectValueAccessor`. See https://github.com/angular/angular/issues/40521.
    if (dir.valueAccessor) {
        dir.valueAccessor.registerOnChange(noop);
        dir.valueAccessor.registerOnTouched(noop);
    }
    cleanUpValidators(control, dir);
    if (control) {
        dir._invokeOnDestroyCallbacks();
        control._registerOnCollectionChange(() => { });
    }
}
function registerOnValidatorChange(validators, onChange) {
    validators.forEach((validator) => {
        if (validator.registerOnValidatorChange)
            validator.registerOnValidatorChange(onChange);
    });
}
/**
 * Sets up disabled change handler function on a given form control if ControlValueAccessor
 * associated with a given directive instance supports the `setDisabledState` call.
 *
 * @param control Form control where disabled change handler should be setup.
 * @param dir Corresponding directive instance associated with this control.
 */
function setUpDisabledChangeHandler(control, dir) {
    if (dir.valueAccessor.setDisabledState) {
        const onDisabledChange = (isDisabled) => {
            dir.valueAccessor.setDisabledState(isDisabled);
        };
        control.registerOnDisabledChange(onDisabledChange);
        // Register a callback function to cleanup disabled change handler
        // from a control instance when a directive is destroyed.
        dir._registerOnDestroy(() => {
            control._unregisterOnDisabledChange(onDisabledChange);
        });
    }
}
/**
 * Sets up sync and async directive validators on provided form control.
 * This function merges validators from the directive into the validators of the control.
 *
 * @param control Form control where directive validators should be setup.
 * @param dir Directive instance that contains validators to be setup.
 */
function setUpValidators(control, dir) {
    const validators = getControlValidators(control);
    if (dir.validator !== null) {
        control.setValidators(mergeValidators(validators, dir.validator));
    }
    else if (typeof validators === 'function') {
        // If sync validators are represented by a single validator function, we force the
        // `Validators.compose` call to happen by executing the `setValidators` function with
        // an array that contains that function. We need this to avoid possible discrepancies in
        // validators behavior, so sync validators are always processed by the `Validators.compose`.
        // Note: we should consider moving this logic inside the `setValidators` function itself, so we
        // have consistent behavior on AbstractControl API level. The same applies to the async
        // validators logic below.
        control.setValidators([validators]);
    }
    const asyncValidators = getControlAsyncValidators(control);
    if (dir.asyncValidator !== null) {
        control.setAsyncValidators(mergeValidators(asyncValidators, dir.asyncValidator));
    }
    else if (typeof asyncValidators === 'function') {
        control.setAsyncValidators([asyncValidators]);
    }
    // Re-run validation when validator binding changes, e.g. minlength=3 -> minlength=4
    const onValidatorChange = () => control.updateValueAndValidity();
    registerOnValidatorChange(dir._rawValidators, onValidatorChange);
    registerOnValidatorChange(dir._rawAsyncValidators, onValidatorChange);
}
/**
 * Cleans up sync and async directive validators on provided form control.
 * This function reverts the setup performed by the `setUpValidators` function, i.e.
 * removes directive-specific validators from a given control instance.
 *
 * @param control Form control from where directive validators should be removed.
 * @param dir Directive instance that contains validators to be removed.
 * @returns true if a control was updated as a result of this action.
 */
function cleanUpValidators(control, dir) {
    let isControlUpdated = false;
    if (control !== null) {
        if (dir.validator !== null) {
            const validators = getControlValidators(control);
            if (Array.isArray(validators) && validators.length > 0) {
                // Filter out directive validator function.
                const updatedValidators = validators.filter((validator) => validator !== dir.validator);
                if (updatedValidators.length !== validators.length) {
                    isControlUpdated = true;
                    control.setValidators(updatedValidators);
                }
            }
        }
        if (dir.asyncValidator !== null) {
            const asyncValidators = getControlAsyncValidators(control);
            if (Array.isArray(asyncValidators) && asyncValidators.length > 0) {
                // Filter out directive async validator function.
                const updatedAsyncValidators = asyncValidators.filter((asyncValidator) => asyncValidator !== dir.asyncValidator);
                if (updatedAsyncValidators.length !== asyncValidators.length) {
                    isControlUpdated = true;
                    control.setAsyncValidators(updatedAsyncValidators);
                }
            }
        }
    }
    // Clear onValidatorChange callbacks by providing a noop function.
    const noop = () => { };
    registerOnValidatorChange(dir._rawValidators, noop);
    registerOnValidatorChange(dir._rawAsyncValidators, noop);
    return isControlUpdated;
}
function setUpViewChangePipeline(control, dir) {
    dir.valueAccessor.registerOnChange((newValue) => {
        control._pendingValue = newValue;
        control._pendingChange = true;
        control._pendingDirty = true;
        if (control.updateOn === 'change')
            updateControl(control, dir);
    });
}
function setUpBlurPipeline(control, dir) {
    dir.valueAccessor.registerOnTouched(() => {
        control._pendingTouched = true;
        if (control.updateOn === 'blur' && control._pendingChange)
            updateControl(control, dir);
        if (control.updateOn !== 'submit')
            control.markAsTouched();
    });
}
function updateControl(control, dir) {
    if (control._pendingDirty)
        control.markAsDirty();
    control.setValue(control._pendingValue, { emitModelToViewChange: false });
    dir.viewToModelUpdate(control._pendingValue);
    control._pendingChange = false;
}
function setUpModelChangePipeline(control, dir) {
    const onChange = (newValue, emitModelEvent) => {
        // control -> view
        dir.valueAccessor.writeValue(newValue);
        // control -> ngModel
        if (emitModelEvent)
            dir.viewToModelUpdate(newValue);
    };
    control.registerOnChange(onChange);
    // Register a callback function to cleanup onChange handler
    // from a control instance when a directive is destroyed.
    dir._registerOnDestroy(() => {
        control._unregisterOnChange(onChange);
    });
}
/**
 * Links a FormGroup or FormArray instance and corresponding Form directive by setting up validators
 * present in the view.
 *
 * @param control FormGroup or FormArray instance that should be linked.
 * @param dir Directive that provides view validators.
 */
function setUpFormContainer(control, dir) {
    if (control == null && (typeof ngDevMode === 'undefined' || ngDevMode))
        _throwError(dir, 'Cannot find control with');
    setUpValidators(control, dir);
}
/**
 * Reverts the setup performed by the `setUpFormContainer` function.
 *
 * @param control FormGroup or FormArray instance that should be cleaned up.
 * @param dir Directive that provided view validators.
 * @returns true if a control was updated as a result of this action.
 */
function cleanUpFormContainer(control, dir) {
    return cleanUpValidators(control, dir);
}
function _noControlError(dir) {
    return _throwError(dir, 'There is no FormControl instance attached to form control element with');
}
function _throwError(dir, message) {
    const messageEnd = _describeControlLocation(dir);
    throw new Error(`${message} ${messageEnd}`);
}
function _describeControlLocation(dir) {
    const path = dir.path;
    if (path && path.length > 1)
        return `path: '${path.join(' -> ')}'`;
    if (path?.[0])
        return `name: '${path}'`;
    return 'unspecified name attribute';
}
function _throwMissingValueAccessorError(dir) {
    const loc = _describeControlLocation(dir);
    throw new _angular_core__WEBPACK_IMPORTED_MODULE_0__["RuntimeError"](-1203 /* RuntimeErrorCode.NG_MISSING_VALUE_ACCESSOR */, `No value accessor for form control ${loc}.`);
}
function _throwInvalidValueAccessorError(dir) {
    const loc = _describeControlLocation(dir);
    throw new _angular_core__WEBPACK_IMPORTED_MODULE_0__["RuntimeError"](1200 /* RuntimeErrorCode.NG_VALUE_ACCESSOR_NOT_PROVIDED */, `Value accessor was not provided as an array for form control with ${loc}. ` +
        `Check that the \`NG_VALUE_ACCESSOR\` token is configured as a \`multi: true\` provider.`);
}
function isPropertyUpdated(changes, viewModel) {
    if (!changes.hasOwnProperty('model'))
        return false;
    const change = changes['model'];
    if (change.isFirstChange())
        return true;
    return !Object.is(viewModel, change.currentValue);
}
function isBuiltInAccessor(valueAccessor) {
    // Check if a given value accessor is an instance of a class that directly extends
    // `BuiltInControlValueAccessor` one.
    return Object.getPrototypeOf(valueAccessor.constructor) === BuiltInControlValueAccessor;
}
function syncPendingControls(form, directives) {
    form._syncPendingControls();
    directives.forEach((dir) => {
        const control = dir.control;
        if (control.updateOn === 'submit' && control._pendingChange) {
            dir.viewToModelUpdate(control._pendingValue);
            control._pendingChange = false;
        }
    });
}
// TODO: vsavkin remove it once https://github.com/angular/angular/issues/3011 is implemented
function selectValueAccessor(dir, valueAccessors) {
    if (!valueAccessors)
        return null;
    if (!Array.isArray(valueAccessors) && (typeof ngDevMode === 'undefined' || ngDevMode))
        _throwInvalidValueAccessorError(dir);
    let defaultAccessor = undefined;
    let builtinAccessor = undefined;
    let customAccessor = undefined;
    valueAccessors.forEach((v) => {
        if (v.constructor === DefaultValueAccessor) {
            defaultAccessor = v;
        }
        else if (isBuiltInAccessor(v)) {
            if (builtinAccessor && (typeof ngDevMode === 'undefined' || ngDevMode))
                _throwError(dir, 'More than one built-in value accessor matches form control with');
            builtinAccessor = v;
        }
        else {
            if (customAccessor && (typeof ngDevMode === 'undefined' || ngDevMode))
                _throwError(dir, 'More than one custom value accessor matches form control with');
            customAccessor = v;
        }
    });
    if (customAccessor)
        return customAccessor;
    if (builtinAccessor)
        return builtinAccessor;
    if (defaultAccessor)
        return defaultAccessor;
    if (typeof ngDevMode === 'undefined' || ngDevMode) {
        _throwError(dir, 'No valid value accessor for form control with');
    }
    return null;
}
function removeListItem$1(list, el) {
    const index = list.indexOf(el);
    if (index > -1)
        list.splice(index, 1);
}
// TODO(kara): remove after deprecation period
function _ngModelWarning(name, type, instance, warningConfig) {
    if (warningConfig === 'never')
        return;
    if (((warningConfig === null || warningConfig === 'once') && !type._ngModelWarningSentOnce) ||
        (warningConfig === 'always' && !instance._ngModelWarningSent)) {
        console.warn(ngModelWarning(name));
        type._ngModelWarningSentOnce = true;
        instance._ngModelWarningSent = true;
    }
}

const formDirectiveProvider$1 = {
    provide: ControlContainer,
    useExisting: (0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(() => NgForm)
};
const resolvedPromise$1 = (() => Promise.resolve())();
/**
 * @description
 * Creates a top-level `FormGroup` instance and binds it to a form
 * to track aggregate form value and validation status.
 *
 * As soon as you import the `FormsModule`, this directive becomes active by default on
 * all `<form>` tags.  You don't need to add a special selector.
 *
 * You optionally export the directive into a local template variable using `ngForm` as the key
 * (ex: `#myForm="ngForm"`). This is optional, but useful.  Many properties from the underlying
 * `FormGroup` instance are duplicated on the directive itself, so a reference to it
 * gives you access to the aggregate value and validity status of the form, as well as
 * user interaction properties like `dirty` and `touched`.
 *
 * To register child controls with the form, use `NgModel` with a `name`
 * attribute. You may use `NgModelGroup` to create sub-groups within the form.
 *
 * If necessary, listen to the directive's `ngSubmit` event to be notified when the user has
 * triggered a form submission. The `ngSubmit` event emits the original form
 * submission event.
 *
 * In template driven forms, all `<form>` tags are automatically tagged as `NgForm`.
 * To import the `FormsModule` but skip its usage in some forms,
 * for example, to use native HTML5 validation, add the `ngNoForm` and the `<form>`
 * tags won't create an `NgForm` directive. In reactive forms, using `ngNoForm` is
 * unnecessary because the `<form>` tags are inert. In that case, you would
 * refrain from using the `formGroup` directive.
 *
 * @usageNotes
 *
 * ### Listening for form submission
 *
 * The following example shows how to capture the form values from the "ngSubmit" event.
 *
 * {@example forms/ts/simpleForm/simple_form_example.ts region='Component'}
 *
 * ### Setting the update options
 *
 * The following example shows you how to change the "updateOn" option from its default using
 * ngFormOptions.
 *
 * ```html
 * <form [ngFormOptions]="{updateOn: 'blur'}">
 *    <input name="one" ngModel>  <!-- this ngModel will update on blur -->
 * </form>
 * ```
 *
 * ### Native DOM validation UI
 *
 * In order to prevent the native DOM form validation UI from interfering with Angular's form
 * validation, Angular automatically adds the `novalidate` attribute on any `<form>` whenever
 * `FormModule` or `ReactiveFormModule` are imported into the application.
 * If you want to explicitly enable native DOM validation UI with Angular forms, you can add the
 * `ngNativeValidate` attribute to the `<form>` element:
 *
 * ```html
 * <form ngNativeValidate>
 *   ...
 * </form>
 * ```
 *
 * @ngModule FormsModule
 * @publicApi
 */
class NgForm extends ControlContainer {
    constructor(validators, asyncValidators, callSetDisabledState) {
        super();
        this.callSetDisabledState = callSetDisabledState;
        /**
         * @description
         * Returns whether the form submission has been triggered.
         */
        this.submitted = false;
        this._directives = new Set();
        /**
         * @description
         * Event emitter for the "ngSubmit" event
         */
        this.ngSubmit = new _angular_core__WEBPACK_IMPORTED_MODULE_0__.EventEmitter();
        this.form =
            new FormGroup({}, composeValidators(validators), composeAsyncValidators(asyncValidators));
    }
    /** @nodoc */
    ngAfterViewInit() {
        this._setUpdateStrategy();
    }
    /**
     * @description
     * The directive instance.
     */
    get formDirective() {
        return this;
    }
    /**
     * @description
     * The internal `FormGroup` instance.
     */
    get control() {
        return this.form;
    }
    /**
     * @description
     * Returns an array representing the path to this group. Because this directive
     * always lives at the top level of a form, it is always an empty array.
     */
    get path() {
        return [];
    }
    /**
     * @description
     * Returns a map of the controls in this group.
     */
    get controls() {
        return this.form.controls;
    }
    /**
     * @description
     * Method that sets up the control directive in this group, re-calculates its value
     * and validity, and adds the instance to the internal list of directives.
     *
     * @param dir The `NgModel` directive instance.
     */
    addControl(dir) {
        resolvedPromise$1.then(() => {
            const container = this._findContainer(dir.path);
            dir.control =
                container.registerControl(dir.name, dir.control);
            setUpControl(dir.control, dir, this.callSetDisabledState);
            dir.control.updateValueAndValidity({ emitEvent: false });
            this._directives.add(dir);
        });
    }
    /**
     * @description
     * Retrieves the `FormControl` instance from the provided `NgModel` directive.
     *
     * @param dir The `NgModel` directive instance.
     */
    getControl(dir) {
        return this.form.get(dir.path);
    }
    /**
     * @description
     * Removes the `NgModel` instance from the internal list of directives
     *
     * @param dir The `NgModel` directive instance.
     */
    removeControl(dir) {
        resolvedPromise$1.then(() => {
            const container = this._findContainer(dir.path);
            if (container) {
                container.removeControl(dir.name);
            }
            this._directives.delete(dir);
        });
    }
    /**
     * @description
     * Adds a new `NgModelGroup` directive instance to the form.
     *
     * @param dir The `NgModelGroup` directive instance.
     */
    addFormGroup(dir) {
        resolvedPromise$1.then(() => {
            const container = this._findContainer(dir.path);
            const group = new FormGroup({});
            setUpFormContainer(group, dir);
            container.registerControl(dir.name, group);
            group.updateValueAndValidity({ emitEvent: false });
        });
    }
    /**
     * @description
     * Removes the `NgModelGroup` directive instance from the form.
     *
     * @param dir The `NgModelGroup` directive instance.
     */
    removeFormGroup(dir) {
        resolvedPromise$1.then(() => {
            const container = this._findContainer(dir.path);
            if (container) {
                container.removeControl(dir.name);
            }
        });
    }
    /**
     * @description
     * Retrieves the `FormGroup` for a provided `NgModelGroup` directive instance
     *
     * @param dir The `NgModelGroup` directive instance.
     */
    getFormGroup(dir) {
        return this.form.get(dir.path);
    }
    /**
     * Sets the new value for the provided `NgControl` directive.
     *
     * @param dir The `NgControl` directive instance.
     * @param value The new value for the directive's control.
     */
    updateModel(dir, value) {
        resolvedPromise$1.then(() => {
            const ctrl = this.form.get(dir.path);
            ctrl.setValue(value);
        });
    }
    /**
     * @description
     * Sets the value for this `FormGroup`.
     *
     * @param value The new value
     */
    setValue(value) {
        this.control.setValue(value);
    }
    /**
     * @description
     * Method called when the "submit" event is triggered on the form.
     * Triggers the `ngSubmit` emitter to emit the "submit" event as its payload.
     *
     * @param $event The "submit" event object
     */
    onSubmit($event) {
        this.submitted = true;
        syncPendingControls(this.form, this._directives);
        this.ngSubmit.emit($event);
        // Forms with `method="dialog"` have some special behavior
        // that won't reload the page and that shouldn't be prevented.
        return $event?.target?.method === 'dialog';
    }
    /**
     * @description
     * Method called when the "reset" event is triggered on the form.
     */
    onReset() {
        this.resetForm();
    }
    /**
     * @description
     * Resets the form to an initial value and resets its submitted status.
     *
     * @param value The new value for the form.
     */
    resetForm(value = undefined) {
        this.form.reset(value);
        this.submitted = false;
    }
    _setUpdateStrategy() {
        if (this.options && this.options.updateOn != null) {
            this.form._updateOn = this.options.updateOn;
        }
    }
    _findContainer(path) {
        path.pop();
        return path.length ? this.form.get(path) : this.form;
    }
    static { this.fac = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareFactory"]({ minVersion: "12.0.0", version: "17.3.12", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: NgForm, deps: [{ token: NG_VALIDATORS, optional: true, self: true }, { token: NG_ASYNC_VALIDATORS, optional: true, self: true }, { token: CALL_SET_DISABLED_STATE, optional: true }], target: _angular_core__WEBPACK_IMPORTED_MODULE_0__["FactoryTarget"].Directive }); }
    static { this.dir = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareDirective"]({ minVersion: "14.0.0", version: "17.3.12", type: NgForm, selector: "form:not([ngNoForm]):not([formGroup]),ng-form,[ngForm]", inputs: { options: ["ngFormOptions", "options"] }, outputs: { ngSubmit: "ngSubmit" }, host: { listeners: { "submit": "onSubmit($event)", "reset": "onReset()" } }, providers: [formDirectiveProvider$1], exportAs: ["ngForm"], usesInheritance: true, ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))) }); }
}
_angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareClassMetadata"]({ minVersion: "12.0.0", version: "17.3.12", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: NgForm, decorators: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Directive,
            args: [{
                    selector: 'form:not([ngNoForm]):not([formGroup]),ng-form,[ngForm]',
                    providers: [formDirectiveProvider$1],
                    host: { '(submit)': 'onSubmit($event)', '(reset)': 'onReset()' },
                    outputs: ['ngSubmit'],
                    exportAs: 'ngForm'
                }]
        }], ctorParameters: () => [{ type: undefined, decorators: [{
                    type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Optional
                }, {
                    type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Self
                }, {
                    type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Inject,
                    args: [NG_VALIDATORS]
                }] }, { type: undefined, decorators: [{
                    type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Optional
                }, {
                    type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Self
                }, {
                    type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Inject,
                    args: [NG_ASYNC_VALIDATORS]
                }] }, { type: undefined, decorators: [{
                    type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Optional
                }, {
                    type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Inject,
                    args: [CALL_SET_DISABLED_STATE]
                }] }], propDecorators: { options: [{
                type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input,
                args: ['ngFormOptions']
            }] } });

function removeListItem(list, el) {
    const index = list.indexOf(el);
    if (index > -1)
        list.splice(index, 1);
}

function isFormControlState(formState) {
    return typeof formState === 'object' && formState !== null &&
        Object.keys(formState).length === 2 && 'value' in formState && 'disabled' in formState;
}
const FormControl = (class FormControl extends AbstractControl {
    constructor(
    // formState and defaultValue will only be null if T is nullable
    formState = null, validatorOrOpts, asyncValidator) {
        super(pickValidators(validatorOrOpts), pickAsyncValidators(asyncValidator, validatorOrOpts));
        /** @publicApi */
        this.defaultValue = null;
        /** @internal */
        this._onChange = [];
        /** @internal */
        this._pendingChange = false;
        this._applyFormState(formState);
        this._setUpdateStrategy(validatorOrOpts);
        this._initObservables();
        this.updateValueAndValidity({
            onlySelf: true,
            // If `asyncValidator` is present, it will trigger control status change from `PENDING` to
            // `VALID` or `INVALID`.
            // The status should be broadcasted via the `statusChanges` observable, so we set
            // `emitEvent` to `true` to allow that during the control creation process.
            emitEvent: !!this.asyncValidator
        });
        if (isOptionsObj(validatorOrOpts) &&
            (validatorOrOpts.nonNullable || validatorOrOpts.initialValueIsDefault)) {
            if (isFormControlState(formState)) {
                this.defaultValue = formState.value;
            }
            else {
                this.defaultValue = formState;
            }
        }
    }
    setValue(value, options = {}) {
        this.value = this._pendingValue = value;
        if (this._onChange.length && options.emitModelToViewChange !== false) {
            this._onChange.forEach((changeFn) => changeFn(this.value, options.emitViewToModelChange !== false));
        }
        this.updateValueAndValidity(options);
    }
    patchValue(value, options = {}) {
        this.setValue(value, options);
    }
    reset(formState = this.defaultValue, options = {}) {
        this._applyFormState(formState);
        this.markAsPristine(options);
        this.markAsUntouched(options);
        this.setValue(this.value, options);
        this._pendingChange = false;
    }
    /**  @internal */
    _updateValue() { }
    /**  @internal */
    _anyControls(condition) {
        return false;
    }
    /**  @internal */
    _allControlsDisabled() {
        return this.disabled;
    }
    registerOnChange(fn) {
        this._onChange.push(fn);
    }
    /** @internal */
    _unregisterOnChange(fn) {
        removeListItem(this._onChange, fn);
    }
    registerOnDisabledChange(fn) {
        this._onDisabledChange.push(fn);
    }
    /** @internal */
    _unregisterOnDisabledChange(fn) {
        removeListItem(this._onDisabledChange, fn);
    }
    /** @internal */
    _forEachChild(cb) { }
    /** @internal */
    _syncPendingControls() {
        if (this.updateOn === 'submit') {
            if (this._pendingDirty)
                this.markAsDirty();
            if (this._pendingTouched)
                this.markAsTouched();
            if (this._pendingChange) {
                this.setValue(this._pendingValue, { onlySelf: true, emitModelToViewChange: false });
                return true;
            }
        }
        return false;
    }
    _applyFormState(formState) {
        if (isFormControlState(formState)) {
            this.value = this._pendingValue = formState.value;
            formState.disabled ? this.disable({ onlySelf: true, emitEvent: false }) :
                this.enable({ onlySelf: true, emitEvent: false });
        }
        else {
            this.value = this._pendingValue = formState;
        }
    }
});
const UntypedFormControl = FormControl;
/**
 * @description
 * Asserts that the given control is an instance of `FormControl`
 *
 * @publicApi
 */
const isFormControl = (control) => control instanceof FormControl;

/**
 * @description
 * A base class for code shared between the `NgModelGroup` and `FormGroupName` directives.
 *
 * @publicApi
 */
class AbstractFormGroupDirective extends ControlContainer {
    /** @nodoc */
    ngOnInit() {
        this._checkParentType();
        // Register the group with its parent group.
        this.formDirective.addFormGroup(this);
    }
    /** @nodoc */
    ngOnDestroy() {
        if (this.formDirective) {
            // Remove the group from its parent group.
            this.formDirective.removeFormGroup(this);
        }
    }
    /**
     * @description
     * The `FormGroup` bound to this directive.
     */
    get control() {
        return this.formDirective.getFormGroup(this);
    }
    /**
     * @description
     * The path to this group from the top-level directive.
     */
    get path() {
        return controlPath(this.name == null ? this.name : this.name.toString(), this._parent);
    }
    /**
     * @description
     * The top-level directive for this group if present, otherwise null.
     */
    get formDirective() {
        return this._parent ? this._parent.formDirective : null;
    }
    /** @internal */
    _checkParentType() { }
    static { this.fac = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareFactory"]({ minVersion: "12.0.0", version: "17.3.12", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: AbstractFormGroupDirective, deps: null, target: _angular_core__WEBPACK_IMPORTED_MODULE_0__["FactoryTarget"].Directive }); }
    static { this.dir = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareDirective"]({ minVersion: "14.0.0", version: "17.3.12", type: AbstractFormGroupDirective, usesInheritance: true, ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))) }); }
}
_angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareClassMetadata"]({ minVersion: "12.0.0", version: "17.3.12", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: AbstractFormGroupDirective, decorators: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Directive
        }] });

function modelParentException() {
    return new _angular_core__WEBPACK_IMPORTED_MODULE_0__["RuntimeError"](1350 /* RuntimeErrorCode.NGMODEL_IN_FORM_GROUP */, `
    ngModel cannot be used to register form controls with a parent formGroup directive.  Try using
    formGroup's partner directive "formControlName" instead.  Example:

    ${formControlNameExample}

    Or, if you'd like to avoid registering this form control, indicate that it's standalone in ngModelOptions:

    Example:

    ${ngModelWithFormGroupExample}`);
}
function formGroupNameException() {
    return new _angular_core__WEBPACK_IMPORTED_MODULE_0__["RuntimeError"](1351 /* RuntimeErrorCode.NGMODEL_IN_FORM_GROUP_NAME */, `
    ngModel cannot be used to register form controls with a parent formGroupName or formArrayName directive.

    Option 1: Use formControlName instead of ngModel (reactive strategy):

    ${formGroupNameExample}

    Option 2:  Update ngModel's parent be ngModelGroup (template-driven strategy):

    ${ngModelGroupExample}`);
}
function missingNameException() {
    return new _angular_core__WEBPACK_IMPORTED_MODULE_0__["RuntimeError"](1352 /* RuntimeErrorCode.NGMODEL_WITHOUT_NAME */, `If ngModel is used within a form tag, either the name attribute must be set or the form
    control must be defined as 'standalone' in ngModelOptions.

    Example 1: <input [(ngModel)]="person.firstName" name="first">
    Example 2: <input [(ngModel)]="person.firstName" [ngModelOptions]="{standalone: true}">`);
}
function modelGroupParentException() {
    return new _angular_core__WEBPACK_IMPORTED_MODULE_0__["RuntimeError"](1353 /* RuntimeErrorCode.NGMODELGROUP_IN_FORM_GROUP */, `
    ngModelGroup cannot be used with a parent formGroup directive.

    Option 1: Use formGroupName instead of ngModelGroup (reactive strategy):

    ${formGroupNameExample}

    Option 2:  Use a regular form tag instead of the formGroup directive (template-driven strategy):

    ${ngModelGroupExample}`);
}

const modelGroupProvider = {
    provide: ControlContainer,
    useExisting: (0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(() => NgModelGroup)
};
/**
 * @description
 * Creates and binds a `FormGroup` instance to a DOM element.
 *
 * This directive can only be used as a child of `NgForm` (within `<form>` tags).
 *
 * Use this directive to validate a sub-group of your form separately from the
 * rest of your form, or if some values in your domain model make more sense
 * to consume together in a nested object.
 *
 * Provide a name for the sub-group and it will become the key
 * for the sub-group in the form's full value. If you need direct access, export the directive into
 * a local template variable using `ngModelGroup` (ex: `#myGroup="ngModelGroup"`).
 *
 * @usageNotes
 *
 * ### Consuming controls in a grouping
 *
 * The following example shows you how to combine controls together in a sub-group
 * of the form.
 *
 * {@example forms/ts/ngModelGroup/ng_model_group_example.ts region='Component'}
 *
 * @ngModule FormsModule
 * @publicApi
 */
class NgModelGroup extends AbstractFormGroupDirective {
    constructor(parent, validators, asyncValidators) {
        super();
        /**
         * @description
         * Tracks the name of the `NgModelGroup` bound to the directive. The name corresponds
         * to a key in the parent `NgForm`.
         */
        this.name = '';
        this._parent = parent;
        this._setValidators(validators);
        this._setAsyncValidators(asyncValidators);
    }
    /** @internal */
    _checkParentType() {
        if (!(this._parent instanceof NgModelGroup) && !(this._parent instanceof NgForm) &&
            (typeof ngDevMode === 'undefined' || ngDevMode)) {
            throw modelGroupParentException();
        }
    }
    static { this.fac = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareFactory"]({ minVersion: "12.0.0", version: "17.3.12", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: NgModelGroup, deps: [{ token: ControlContainer, host: true, skipSelf: true }, { token: NG_VALIDATORS, optional: true, self: true }, { token: NG_ASYNC_VALIDATORS, optional: true, self: true }], target: _angular_core__WEBPACK_IMPORTED_MODULE_0__["FactoryTarget"].Directive }); }
    static { this.dir = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareDirective"]({ minVersion: "14.0.0", version: "17.3.12", type: NgModelGroup, selector: "[ngModelGroup]", inputs: { name: ["ngModelGroup", "name"] }, providers: [modelGroupProvider], exportAs: ["ngModelGroup"], usesInheritance: true, ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))) }); }
}
_angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareClassMetadata"]({ minVersion: "12.0.0", version: "17.3.12", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: NgModelGroup, decorators: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Directive,
            args: [{ selector: '[ngModelGroup]', providers: [modelGroupProvider], exportAs: 'ngModelGroup' }]
        }], ctorParameters: () => [{ type: ControlContainer, decorators: [{
                    type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Host
                }, {
                    type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.SkipSelf
                }] }, { type: undefined, decorators: [{
                    type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Optional
                }, {
                    type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Self
                }, {
                    type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Inject,
                    args: [NG_VALIDATORS]
                }] }, { type: undefined, decorators: [{
                    type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Optional
                }, {
                    type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Self
                }, {
                    type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Inject,
                    args: [NG_ASYNC_VALIDATORS]
                }] }], propDecorators: { name: [{
                type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input,
                args: ['ngModelGroup']
            }] } });

const formControlBinding$1 = {
    provide: NgControl,
    useExisting: (0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(() => NgModel)
};
/**
 * `ngModel` forces an additional change detection run when its inputs change:
 * E.g.:
 * ```
 * <div>{{myModel.valid}}</div>
 * <input [(ngModel)]="myValue" #myModel="ngModel">
 * ```
 * I.e. `ngModel` can export itself on the element and then be used in the template.
 * Normally, this would result in expressions before the `input` that use the exported directive
 * to have an old value as they have been
 * dirty checked before. As this is a very common case for `ngModel`, we added this second change
 * detection run.
 *
 * Notes:
 * - this is just one extra run no matter how many `ngModel`s have been changed.
 * - this is a general problem when using `exportAs` for directives!
 */
const resolvedPromise = (() => Promise.resolve())();
/**
 * @description
 * Creates a `FormControl` instance from a [domain
 * model](https://en.wikipedia.org/wiki/Domain_model) and binds it to a form control element.
 *
 * The `FormControl` instance tracks the value, user interaction, and
 * validation status of the control and keeps the view synced with the model. If used
 * within a parent form, the directive also registers itself with the form as a child
 * control.
 *
 * This directive is used by itself or as part of a larger form. Use the
 * `ngModel` selector to activate it.
 *
 * It accepts a domain model as an optional `Input`. If you have a one-way binding
 * to `ngModel` with `[]` syntax, changing the domain model's value in the component
 * class sets the value in the view. If you have a two-way binding with `[()]` syntax
 * (also known as 'banana-in-a-box syntax'), the value in the UI always syncs back to
 * the domain model in your class.
 *
 * To inspect the properties of the associated `FormControl` (like the validity state),
 * export the directive into a local template variable using `ngModel` as the key (ex:
 * `#myVar="ngModel"`). You can then access the control using the directive's `control` property.
 * However, the most commonly used properties (like `valid` and `dirty`) also exist on the control
 * for direct access. See a full list of properties directly available in
 * `AbstractControlDirective`.
 *
 * @see {@link RadioControlValueAccessor}
 * @see {@link SelectControlValueAccessor}
 *
 * @usageNotes
 *
 * ### Using ngModel on a standalone control
 *
 * The following examples show a simple standalone control using `ngModel`:
 *
 * {@example forms/ts/simpleNgModel/simple_ng_model_example.ts region='Component'}
 *
 * When using the `ngModel` within `<form>` tags, you'll also need to supply a `name` attribute
 * so that the control can be registered with the parent form under that name.
 *
 * In the context of a parent form, it's often unnecessary to include one-way or two-way binding,
 * as the parent form syncs the value for you. You access its properties by exporting it into a
 * local template variable using `ngForm` such as (`#f="ngForm"`). Use the variable where
 * needed on form submission.
 *
 * If you do need to populate initial values into your form, using a one-way binding for
 * `ngModel` tends to be sufficient as long as you use the exported form's value rather
 * than the domain model's value on submit.
 *
 * ### Using ngModel within a form
 *
 * The following example shows controls using `ngModel` within a form:
 *
 * {@example forms/ts/simpleForm/simple_form_example.ts region='Component'}
 *
 * ### Using a standalone ngModel within a group
 *
 * The following example shows you how to use a standalone ngModel control
 * within a form. This controls the display of the form, but doesn't contain form data.
 *
 * ```html
 * <form>
 *   <input name="login" ngModel placeholder="Login">
 *   <input type="checkbox" ngModel [ngModelOptions]="{standalone: true}"> Show more options?
 * </form>
 * <!-- form value: {login: ''} -->
 * ```
 *
 * ### Setting the ngModel `name` attribute through options
 *
 * The following example shows you an alternate way to set the name attribute. Here,
 * an attribute identified as name is used within a custom form control component. To still be able
 * to specify the NgModel's name, you must specify it using the `ngModelOptions` input instead.
 *
 * ```html
 * <form>
 *   <my-custom-form-control name="Nancy" ngModel [ngModelOptions]="{name: 'user'}">
 *   </my-custom-form-control>
 * </form>
 * <!-- form value: {user: ''} -->
 * ```
 *
 * @ngModule FormsModule
 * @publicApi
 */
class NgModel extends NgControl {
    constructor(parent, validators, asyncValidators, valueAccessors, _changeDetectorRef, callSetDisabledState) {
        super();
        this._changeDetectorRef = _changeDetectorRef;
        this.callSetDisabledState = callSetDisabledState;
        this.control = new FormControl();
        /** @internal */
        this._registered = false;
        /**
         * @description
         * Tracks the name bound to the directive. If a parent form exists, it
         * uses this name as a key to retrieve this control's value.
         */
        this.name = '';
        /**
         * @description
         * Event emitter for producing the `ngModelChange` event after
         * the view model updates.
         */
        this.update = new _angular_core__WEBPACK_IMPORTED_MODULE_0__.EventEmitter();
        this._parent = parent;
        this._setValidators(validators);
        this._setAsyncValidators(asyncValidators);
        this.valueAccessor = selectValueAccessor(this, valueAccessors);
    }
    /** @nodoc */
    ngOnChanges(changes) {
        this._checkForErrors();
        if (!this._registered || 'name' in changes) {
            if (this._registered) {
                this._checkName();
                if (this.formDirective) {
                    // We can't call `formDirective.removeControl(this)`, because the `name` has already been
                    // changed. We also can't reset the name temporarily since the logic in `removeControl`
                    // is inside a promise and it won't run immediately. We work around it by giving it an
                    // object with the same shape instead.
                    const oldName = changes['name'].previousValue;
                    this.formDirective.removeControl({ name: oldName, path: this._getPath(oldName) });
                }
            }
            this._setUpControl();
        }
        if ('isDisabled' in changes) {
            this._updateDisabled(changes);
        }
        if (isPropertyUpdated(changes, this.viewModel)) {
            this._updateValue(this.model);
            this.viewModel = this.model;
        }
    }
    /** @nodoc */
    ngOnDestroy() {
        this.formDirective && this.formDirective.removeControl(this);
    }
    /**
     * @description
     * Returns an array that represents the path from the top-level form to this control.
     * Each index is the string name of the control on that level.
     */
    get path() {
        return this._getPath(this.name);
    }
    /**
     * @description
     * The top-level directive for this control if present, otherwise null.
     */
    get formDirective() {
        return this._parent ? this._parent.formDirective : null;
    }
    /**
     * @description
     * Sets the new value for the view model and emits an `ngModelChange` event.
     *
     * @param newValue The new value emitted by `ngModelChange`.
     */
    viewToModelUpdate(newValue) {
        this.viewModel = newValue;
        this.update.emit(newValue);
    }
    _setUpControl() {
        this._setUpdateStrategy();
        this._isStandalone() ? this._setUpStandalone() : this.formDirective.addControl(this);
        this._registered = true;
    }
    _setUpdateStrategy() {
        if (this.options && this.options.updateOn != null) {
            this.control._updateOn = this.options.updateOn;
        }
    }
    _isStandalone() {
        return !this._parent || !!(this.options && this.options.standalone);
    }
    _setUpStandalone() {
        setUpControl(this.control, this, this.callSetDisabledState);
        this.control.updateValueAndValidity({ emitEvent: false });
    }
    _checkForErrors() {
        if (!this._isStandalone()) {
            this._checkParentType();
        }
        this._checkName();
    }
    _checkParentType() {
        if (typeof ngDevMode === 'undefined' || ngDevMode) {
            if (!(this._parent instanceof NgModelGroup) &&
                this._parent instanceof AbstractFormGroupDirective) {
                throw formGroupNameException();
            }
            else if (!(this._parent instanceof NgModelGroup) && !(this._parent instanceof NgForm)) {
                throw modelParentException();
            }
        }
    }
    _checkName() {
        if (this.options && this.options.name)
            this.name = this.options.name;
        if (!this._isStandalone() && !this.name && (typeof ngDevMode === 'undefined' || ngDevMode)) {
            throw missingNameException();
        }
    }
    _updateValue(value) {
        resolvedPromise.then(() => {
            this.control.setValue(value, { emitViewToModelChange: false });
            this._changeDetectorRef?.markForCheck();
        });
    }
    _updateDisabled(changes) {
        const disabledValue = changes['isDisabled'].currentValue;
        // checking for 0 to avoid breaking change
        const isDisabled = disabledValue !== 0 && (0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.booleanAttribute)(disabledValue);
        resolvedPromise.then(() => {
            if (isDisabled && !this.control.disabled) {
                this.control.disable();
            }
            else if (!isDisabled && this.control.disabled) {
                this.control.enable();
            }
            this._changeDetectorRef?.markForCheck();
        });
    }
    _getPath(controlName) {
        return this._parent ? controlPath(controlName, this._parent) : [controlName];
    }
    static { this.fac = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareFactory"]({ minVersion: "12.0.0", version: "17.3.12", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: NgModel, deps: [{ token: ControlContainer, host: true, optional: true }, { token: NG_VALIDATORS, optional: true, self: true }, { token: NG_ASYNC_VALIDATORS, optional: true, self: true }, { token: NG_VALUE_ACCESSOR, optional: true, self: true }, { token: _angular_core__WEBPACK_IMPORTED_MODULE_0__.ChangeDetectorRef, optional: true }, { token: CALL_SET_DISABLED_STATE, optional: true }], target: _angular_core__WEBPACK_IMPORTED_MODULE_0__["FactoryTarget"].Directive }); }
    static { this.dir = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareDirective"]({ minVersion: "14.0.0", version: "17.3.12", type: NgModel, selector: "[ngModel]:not([formControlName]):not([formControl])", inputs: { name: "name", isDisabled: ["disabled", "isDisabled"], model: ["ngModel", "model"], options: ["ngModelOptions", "options"] }, outputs: { update: "ngModelChange" }, providers: [formControlBinding$1], exportAs: ["ngModel"], usesInheritance: true, usesOnChanges: true, ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))) }); }
}
_angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareClassMetadata"]({ minVersion: "12.0.0", version: "17.3.12", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: NgModel, decorators: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Directive,
            args: [{
                    selector: '[ngModel]:not([formControlName]):not([formControl])',
                    providers: [formControlBinding$1],
                    exportAs: 'ngModel'
                }]
        }], ctorParameters: () => [{ type: ControlContainer, decorators: [{
                    type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Optional
                }, {
                    type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Host
                }] }, { type: undefined, decorators: [{
                    type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Optional
                }, {
                    type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Self
                }, {
                    type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Inject,
                    args: [NG_VALIDATORS]
                }] }, { type: undefined, decorators: [{
                    type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Optional
                }, {
                    type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Self
                }, {
                    type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Inject,
                    args: [NG_ASYNC_VALIDATORS]
                }] }, { type: undefined, decorators: [{
                    type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Optional
                }, {
                    type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Self
                }, {
                    type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Inject,
                    args: [NG_VALUE_ACCESSOR]
                }] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.ChangeDetectorRef, decorators: [{
                    type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Optional
                }, {
                    type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Inject,
                    args: [_angular_core__WEBPACK_IMPORTED_MODULE_0__.ChangeDetectorRef]
                }] }, { type: undefined, decorators: [{
                    type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Optional
                }, {
                    type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Inject,
                    args: [CALL_SET_DISABLED_STATE]
                }] }], propDecorators: { name: [{
                type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input
            }], isDisabled: [{
                type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input,
                args: ['disabled']
            }], model: [{
                type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input,
                args: ['ngModel']
            }], options: [{
                type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input,
                args: ['ngModelOptions']
            }], update: [{
                type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Output,
                args: ['ngModelChange']
            }] } });

/**
 * @description
 *
 * Adds `novalidate` attribute to all forms by default.
 *
 * `novalidate` is used to disable browser's native form validation.
 *
 * If you want to use native validation with Angular forms, just add `ngNativeValidate` attribute:
 *
 * ```
 * <form ngNativeValidate></form>
 * ```
 *
 * @publicApi
 * @ngModule ReactiveFormsModule
 * @ngModule FormsModule
 */
class NgNoValidate {
    static { this.fac = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareFactory"]({ minVersion: "12.0.0", version: "17.3.12", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: NgNoValidate, deps: [], target: _angular_core__WEBPACK_IMPORTED_MODULE_0__["FactoryTarget"].Directive }); }
    static { this.dir = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareDirective"]({ minVersion: "14.0.0", version: "17.3.12", type: NgNoValidate, selector: "form:not([ngNoForm]):not([ngNativeValidate])", host: { attributes: { "novalidate": "" } }, ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))) }); }
}
_angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareClassMetadata"]({ minVersion: "12.0.0", version: "17.3.12", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: NgNoValidate, decorators: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Directive,
            args: [{
                    selector: 'form:not([ngNoForm]):not([ngNativeValidate])',
                    host: { 'novalidate': '' },
                }]
        }] });

const NUMBER_VALUE_ACCESSOR = {
    provide: NG_VALUE_ACCESSOR,
    useExisting: (0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(() => NumberValueAccessor),
    multi: true
};
/**
 * @description
 * The `ControlValueAccessor` for writing a number value and listening to number input changes.
 * The value accessor is used by the `FormControlDirective`, `FormControlName`, and `NgModel`
 * directives.
 *
 * @usageNotes
 *
 * ### Using a number input with a reactive form.
 *
 * The following example shows how to use a number input with a reactive form.
 *
 * ```ts
 * const totalCountControl = new FormControl();
 * ```
 *
 * ```
 * <input type="number" [formControl]="totalCountControl">
 * ```
 *
 * @ngModule ReactiveFormsModule
 * @ngModule FormsModule
 * @publicApi
 */
class NumberValueAccessor extends BuiltInControlValueAccessor {
    /**
     * Sets the "value" property on the input element.
     * @nodoc
     */
    writeValue(value) {
        // The value needs to be normalized for IE9, otherwise it is set to 'null' when null
        const normalizedValue = value == null ? '' : value;
        this.setProperty('value', normalizedValue);
    }
    /**
     * Registers a function called when the control value changes.
     * @nodoc
     */
    registerOnChange(fn) {
        this.onChange = (value) => {
            fn(value == '' ? null : parseFloat(value));
        };
    }
    static { this.fac = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareFactory"]({ minVersion: "12.0.0", version: "17.3.12", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: NumberValueAccessor, deps: null, target: _angular_core__WEBPACK_IMPORTED_MODULE_0__["FactoryTarget"].Directive }); }
    static { this.dir = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareDirective"]({ minVersion: "14.0.0", version: "17.3.12", type: NumberValueAccessor, selector: "input[type=number][formControlName],input[type=number][formControl],input[type=number][ngModel]", host: { listeners: { "input": "onChange($event.target.value)", "blur": "onTouched()" } }, providers: [NUMBER_VALUE_ACCESSOR], usesInheritance: true, ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))) }); }
}
_angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareClassMetadata"]({ minVersion: "12.0.0", version: "17.3.12", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: NumberValueAccessor, decorators: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Directive,
            args: [{
                    selector: 'input[type=number][formControlName],input[type=number][formControl],input[type=number][ngModel]',
                    host: { '(input)': 'onChange($event.target.value)', '(blur)': 'onTouched()' },
                    providers: [NUMBER_VALUE_ACCESSOR]
                }]
        }] });

const RADIO_VALUE_ACCESSOR = {
    provide: NG_VALUE_ACCESSOR,
    useExisting: (0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(() => RadioControlValueAccessor),
    multi: true
};
function throwNameError() {
    throw new _angular_core__WEBPACK_IMPORTED_MODULE_0__["RuntimeError"](1202 /* RuntimeErrorCode.NAME_AND_FORM_CONTROL_NAME_MUST_MATCH */, `
      If you define both a name and a formControlName attribute on your radio button, their values
      must match. Ex: <input type="radio" formControlName="food" name="food">
    `);
}
/**
 * @description
 * Class used by Angular to track radio buttons. For internal use only.
 */
class RadioControlRegistry {
    constructor() {
        this._accessors = [];
    }
    /**
     * @description
     * Adds a control to the internal registry. For internal use only.
     */
    add(control, accessor) {
        this._accessors.push([control, accessor]);
    }
    /**
     * @description
     * Removes a control from the internal registry. For internal use only.
     */
    remove(accessor) {
        for (let i = this._accessors.length - 1; i >= 0; --i) {
            if (this._accessors[i][1] === accessor) {
                this._accessors.splice(i, 1);
                return;
            }
        }
    }
    /**
     * @description
     * Selects a radio button. For internal use only.
     */
    select(accessor) {
        this._accessors.forEach((c) => {
            if (this._isSameGroup(c, accessor) && c[1] !== accessor) {
                c[1].fireUncheck(accessor.value);
            }
        });
    }
    _isSameGroup(controlPair, accessor) {
        if (!controlPair[0].control)
            return false;
        return controlPair[0]._parent === accessor._control._parent &&
            controlPair[1].name === accessor.name;
    }
    static { this.fac = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareFactory"]({ minVersion: "12.0.0", version: "17.3.12", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: RadioControlRegistry, deps: [], target: _angular_core__WEBPACK_IMPORTED_MODULE_0__["FactoryTarget"].Injectable }); }
    static { this.prov = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareInjectable"]({ minVersion: "12.0.0", version: "17.3.12", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: RadioControlRegistry, providedIn: 'root' }); }
}
_angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareClassMetadata"]({ minVersion: "12.0.0", version: "17.3.12", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: RadioControlRegistry, decorators: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Injectable,
            args: [{ providedIn: 'root' }]
        }] });
/**
 * @description
 * The `ControlValueAccessor` for writing radio control values and listening to radio control
 * changes. The value accessor is used by the `FormControlDirective`, `FormControlName`, and
 * `NgModel` directives.
 *
 * @usageNotes
 *
 * ### Using radio buttons with reactive form directives
 *
 * The follow example shows how to use radio buttons in a reactive form. When using radio buttons in
 * a reactive form, radio buttons in the same group should have the same `formControlName`.
 * Providing a `name` attribute is optional.
 *
 * {@example forms/ts/reactiveRadioButtons/reactive_radio_button_example.ts region='Reactive'}
 *
 * @ngModule ReactiveFormsModule
 * @ngModule FormsModule
 * @publicApi
 */
class RadioControlValueAccessor extends BuiltInControlValueAccessor {
    constructor(renderer, elementRef, _registry, _injector) {
        super(renderer, elementRef);
        this._registry = _registry;
        this._injector = _injector;
        this.setDisabledStateFired = false;
        /**
         * The registered callback function called when a change event occurs on the input element.
         * Note: we declare `onChange` here (also used as host listener) as a function with no arguments
         * to override the `onChange` function (which expects 1 argument) in the parent
         * `BaseControlValueAccessor` class.
         * @nodoc
         */
        this.onChange = () => { };
        this.callSetDisabledState = (0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.inject)(CALL_SET_DISABLED_STATE, { optional: true }) ?? setDisabledStateDefault;
    }
    /** @nodoc */
    ngOnInit() {
        this._control = this._injector.get(NgControl);
        this._checkName();
        this._registry.add(this._control, this);
    }
    /** @nodoc */
    ngOnDestroy() {
        this._registry.remove(this);
    }
    /**
     * Sets the "checked" property value on the radio input element.
     * @nodoc
     */
    writeValue(value) {
        this._state = value === this.value;
        this.setProperty('checked', this._state);
    }
    /**
     * Registers a function called when the control value changes.
     * @nodoc
     */
    registerOnChange(fn) {
        this._fn = fn;
        this.onChange = () => {
            fn(this.value);
            this._registry.select(this);
        };
    }
    /** @nodoc */
    setDisabledState(isDisabled) {
        /**
         * `setDisabledState` is supposed to be called whenever the disabled state of a control changes,
         * including upon control creation. However, a longstanding bug caused the method to not fire
         * when an *enabled* control was attached. This bug was fixed in v15 in #47576.
         *
         * This had a side effect: previously, it was possible to instantiate a reactive form control
         * with `[attr.disabled]=true`, even though the corresponding control was enabled in the
         * model. This resulted in a mismatch between the model and the DOM. Now, because
         * `setDisabledState` is always called, the value in the DOM will be immediately overwritten
         * with the "correct" enabled value.
         *
         * However, the fix also created an exceptional case: radio buttons. Because Reactive Forms
         * models the entire group of radio buttons as a single `FormControl`, there is no way to
         * control the disabled state for individual radios, so they can no longer be configured as
         * disabled. Thus, we keep the old behavior for radio buttons, so that `[attr.disabled]`
         * continues to work. Specifically, we drop the first call to `setDisabledState` if `disabled`
         * is `false`, and we are not in legacy mode.
         */
        if (this.setDisabledStateFired || isDisabled ||
            this.callSetDisabledState === 'whenDisabledForLegacyCode') {
            this.setProperty('disabled', isDisabled);
        }
        this.setDisabledStateFired = true;
    }
    /**
     * Sets the "value" on the radio input element and unchecks it.
     *
     * @param value
     */
    fireUncheck(value) {
        this.writeValue(value);
    }
    _checkName() {
        if (this.name && this.formControlName && this.name !== this.formControlName &&
            (typeof ngDevMode === 'undefined' || ngDevMode)) {
            throwNameError();
        }
        if (!this.name && this.formControlName)
            this.name = this.formControlName;
    }
    static { this.fac = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareFactory"]({ minVersion: "12.0.0", version: "17.3.12", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: RadioControlValueAccessor, deps: [{ token: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Renderer2 }, { token: _angular_core__WEBPACK_IMPORTED_MODULE_0__.ElementRef }, { token: RadioControlRegistry }, { token: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Injector }], target: _angular_core__WEBPACK_IMPORTED_MODULE_0__["FactoryTarget"].Directive }); }
    static { this.dir = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareDirective"]({ minVersion: "14.0.0", version: "17.3.12", type: RadioControlValueAccessor, selector: "input[type=radio][formControlName],input[type=radio][formControl],input[type=radio][ngModel]", inputs: { name: "name", formControlName: "formControlName", value: "value" }, host: { listeners: { "change": "onChange()", "blur": "onTouched()" } }, providers: [RADIO_VALUE_ACCESSOR], usesInheritance: true, ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))) }); }
}
_angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareClassMetadata"]({ minVersion: "12.0.0", version: "17.3.12", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: RadioControlValueAccessor, decorators: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Directive,
            args: [{
                    selector: 'input[type=radio][formControlName],input[type=radio][formControl],input[type=radio][ngModel]',
                    host: { '(change)': 'onChange()', '(blur)': 'onTouched()' },
                    providers: [RADIO_VALUE_ACCESSOR]
                }]
        }], ctorParameters: () => [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Renderer2 }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.ElementRef }, { type: RadioControlRegistry }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Injector }], propDecorators: { name: [{
                type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input
            }], formControlName: [{
                type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input
            }], value: [{
                type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input
            }] } });

const RANGE_VALUE_ACCESSOR = {
    provide: NG_VALUE_ACCESSOR,
    useExisting: (0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(() => RangeValueAccessor),
    multi: true
};
/**
 * @description
 * The `ControlValueAccessor` for writing a range value and listening to range input changes.
 * The value accessor is used by the `FormControlDirective`, `FormControlName`, and  `NgModel`
 * directives.
 *
 * @usageNotes
 *
 * ### Using a range input with a reactive form
 *
 * The following example shows how to use a range input with a reactive form.
 *
 * ```ts
 * const ageControl = new FormControl();
 * ```
 *
 * ```
 * <input type="range" [formControl]="ageControl">
 * ```
 *
 * @ngModule ReactiveFormsModule
 * @ngModule FormsModule
 * @publicApi
 */
class RangeValueAccessor extends BuiltInControlValueAccessor {
    /**
     * Sets the "value" property on the input element.
     * @nodoc
     */
    writeValue(value) {
        this.setProperty('value', parseFloat(value));
    }
    /**
     * Registers a function called when the control value changes.
     * @nodoc
     */
    registerOnChange(fn) {
        this.onChange = (value) => {
            fn(value == '' ? null : parseFloat(value));
        };
    }
    static { this.fac = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareFactory"]({ minVersion: "12.0.0", version: "17.3.12", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: RangeValueAccessor, deps: null, target: _angular_core__WEBPACK_IMPORTED_MODULE_0__["FactoryTarget"].Directive }); }
    static { this.dir = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareDirective"]({ minVersion: "14.0.0", version: "17.3.12", type: RangeValueAccessor, selector: "input[type=range][formControlName],input[type=range][formControl],input[type=range][ngModel]", host: { listeners: { "change": "onChange($event.target.value)", "input": "onChange($event.target.value)", "blur": "onTouched()" } }, providers: [RANGE_VALUE_ACCESSOR], usesInheritance: true, ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))) }); }
}
_angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareClassMetadata"]({ minVersion: "12.0.0", version: "17.3.12", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: RangeValueAccessor, decorators: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Directive,
            args: [{
                    selector: 'input[type=range][formControlName],input[type=range][formControl],input[type=range][ngModel]',
                    host: {
                        '(change)': 'onChange($event.target.value)',
                        '(input)': 'onChange($event.target.value)',
                        '(blur)': 'onTouched()'
                    },
                    providers: [RANGE_VALUE_ACCESSOR]
                }]
        }] });

/**
 * Token to provide to turn off the ngModel warning on formControl and formControlName.
 */
const NG_MODEL_WITH_FORM_CONTROL_WARNING = new _angular_core__WEBPACK_IMPORTED_MODULE_0__.InjectionToken(ngDevMode ? 'NgModelWithFormControlWarning' : '');
const formControlBinding = {
    provide: NgControl,
    useExisting: (0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(() => FormControlDirective)
};
/**
 * @description
 * Synchronizes a standalone `FormControl` instance to a form control element.
 *
 * Note that support for using the `ngModel` input property and `ngModelChange` event with reactive
 * form directives was deprecated in Angular v6 and is scheduled for removal in
 * a future version of Angular.
 * For details, see [Deprecated features](guide/deprecations#ngmodel-with-reactive-forms).
 *
 * @see [Reactive Forms Guide](guide/reactive-forms)
 * @see {@link FormControl}
 * @see {@link AbstractControl}
 *
 * @usageNotes
 *
 * The following example shows how to register a standalone control and set its value.
 *
 * {@example forms/ts/simpleFormControl/simple_form_control_example.ts region='Component'}
 *
 * @ngModule ReactiveFormsModule
 * @publicApi
 */
class FormControlDirective extends NgControl {
    /**
     * @description
     * Triggers a warning in dev mode that this input should not be used with reactive forms.
     */
    set isDisabled(isDisabled) {
        if (typeof ngDevMode === 'undefined' || ngDevMode) {
            console.warn(disabledAttrWarning);
        }
    }
    /**
     * @description
     * Static property used to track whether any ngModel warnings have been sent across
     * all instances of FormControlDirective. Used to support warning config of "once".
     *
     * @internal
     */
    static { this._ngModelWarningSentOnce = false; }
    constructor(validators, asyncValidators, valueAccessors, _ngModelWarningConfig, callSetDisabledState) {
        super();
        this._ngModelWarningConfig = _ngModelWarningConfig;
        this.callSetDisabledState = callSetDisabledState;
        /** @deprecated as of v6 */
        this.update = new _angular_core__WEBPACK_IMPORTED_MODULE_0__.EventEmitter();
        /**
         * @description
         * Instance property used to track whether an ngModel warning has been sent out for this
         * particular `FormControlDirective` instance. Used to support warning config of "always".
         *
         * @internal
         */
        this._ngModelWarningSent = false;
        this._setValidators(validators);
        this._setAsyncValidators(asyncValidators);
        this.valueAccessor = selectValueAccessor(this, valueAccessors);
    }
    /** @nodoc */
    ngOnChanges(changes) {
        if (this._isControlChanged(changes)) {
            const previousForm = changes['form'].previousValue;
            if (previousForm) {
                cleanUpControl(previousForm, this, /* validateControlPresenceOnChange */ false);
            }
            setUpControl(this.form, this, this.callSetDisabledState);
            this.form.updateValueAndValidity({ emitEvent: false });
        }
        if (isPropertyUpdated(changes, this.viewModel)) {
            if (typeof ngDevMode === 'undefined' || ngDevMode) {
                _ngModelWarning('formControl', FormControlDirective, this, this._ngModelWarningConfig);
            }
            this.form.setValue(this.model);
            this.viewModel = this.model;
        }
    }
    /** @nodoc */
    ngOnDestroy() {
        if (this.form) {
            cleanUpControl(this.form, this, /* validateControlPresenceOnChange */ false);
        }
    }
    /**
     * @description
     * Returns an array that represents the path from the top-level form to this control.
     * Each index is the string name of the control on that level.
     */
    get path() {
        return [];
    }
    /**
     * @description
     * The `FormControl` bound to this directive.
     */
    get control() {
        return this.form;
    }
    /**
     * @description
     * Sets the new value for the view model and emits an `ngModelChange` event.
     *
     * @param newValue The new value for the view model.
     */
    viewToModelUpdate(newValue) {
        this.viewModel = newValue;
        this.update.emit(newValue);
    }
    _isControlChanged(changes) {
        return changes.hasOwnProperty('form');
    }
    static { this.fac = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareFactory"]({ minVersion: "12.0.0", version: "17.3.12", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: FormControlDirective, deps: [{ token: NG_VALIDATORS, optional: true, self: true }, { token: NG_ASYNC_VALIDATORS, optional: true, self: true }, { token: NG_VALUE_ACCESSOR, optional: true, self: true }, { token: NG_MODEL_WITH_FORM_CONTROL_WARNING, optional: true }, { token: CALL_SET_DISABLED_STATE, optional: true }], target: _angular_core__WEBPACK_IMPORTED_MODULE_0__["FactoryTarget"].Directive }); }
    static { this.dir = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareDirective"]({ minVersion: "14.0.0", version: "17.3.12", type: FormControlDirective, selector: "[formControl]", inputs: { form: ["formControl", "form"], isDisabled: ["disabled", "isDisabled"], model: ["ngModel", "model"] }, outputs: { update: "ngModelChange" }, providers: [formControlBinding], exportAs: ["ngForm"], usesInheritance: true, usesOnChanges: true, ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))) }); }
}
_angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareClassMetadata"]({ minVersion: "12.0.0", version: "17.3.12", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: FormControlDirective, decorators: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Directive,
            args: [{ selector: '[formControl]', providers: [formControlBinding], exportAs: 'ngForm' }]
        }], ctorParameters: () => [{ type: undefined, decorators: [{
                    type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Optional
                }, {
                    type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Self
                }, {
                    type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Inject,
                    args: [NG_VALIDATORS]
                }] }, { type: undefined, decorators: [{
                    type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Optional
                }, {
                    type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Self
                }, {
                    type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Inject,
                    args: [NG_ASYNC_VALIDATORS]
                }] }, { type: undefined, decorators: [{
                    type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Optional
                }, {
                    type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Self
                }, {
                    type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Inject,
                    args: [NG_VALUE_ACCESSOR]
                }] }, { type: undefined, decorators: [{
                    type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Optional
                }, {
                    type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Inject,
                    args: [NG_MODEL_WITH_FORM_CONTROL_WARNING]
                }] }, { type: undefined, decorators: [{
                    type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Optional
                }, {
                    type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Inject,
                    args: [CALL_SET_DISABLED_STATE]
                }] }], propDecorators: { form: [{
                type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input,
                args: ['formControl']
            }], isDisabled: [{
                type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input,
                args: ['disabled']
            }], model: [{
                type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input,
                args: ['ngModel']
            }], update: [{
                type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Output,
                args: ['ngModelChange']
            }] } });

const formDirectiveProvider = {
    provide: ControlContainer,
    useExisting: (0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(() => FormGroupDirective)
};
/**
 * @description
 *
 * Binds an existing `FormGroup` or `FormRecord` to a DOM element.
 *
 * This directive accepts an existing `FormGroup` instance. It will then use this
 * `FormGroup` instance to match any child `FormControl`, `FormGroup`/`FormRecord`,
 * and `FormArray` instances to child `FormControlName`, `FormGroupName`,
 * and `FormArrayName` directives.
 *
 * @see [Reactive Forms Guide](guide/reactive-forms)
 * @see {@link AbstractControl}
 *
 * @usageNotes
 * ### Register Form Group
 *
 * The following example registers a `FormGroup` with first name and last name controls,
 * and listens for the *ngSubmit* event when the button is clicked.
 *
 * {@example forms/ts/simpleFormGroup/simple_form_group_example.ts region='Component'}
 *
 * @ngModule ReactiveFormsModule
 * @publicApi
 */
class FormGroupDirective extends ControlContainer {
    constructor(validators, asyncValidators, callSetDisabledState) {
        super();
        this.callSetDisabledState = callSetDisabledState;
        /**
         * @description
         * Reports whether the form submission has been triggered.
         */
        this.submitted = false;
        /**
         * Callback that should be invoked when controls in FormGroup or FormArray collection change
         * (added or removed). This callback triggers corresponding DOM updates.
         */
        this._onCollectionChange = () => this._updateDomValue();
        /**
         * @description
         * Tracks the list of added `FormControlName` instances
         */
        this.directives = [];
        /**
         * @description
         * Tracks the `FormGroup` bound to this directive.
         */
        this.form = null;
        /**
         * @description
         * Emits an event when the form submission has been triggered.
         */
        this.ngSubmit = new _angular_core__WEBPACK_IMPORTED_MODULE_0__.EventEmitter();
        this._setValidators(validators);
        this._setAsyncValidators(asyncValidators);
    }
    /** @nodoc */
    ngOnChanges(changes) {
        this._checkFormPresent();
        if (changes.hasOwnProperty('form')) {
            this._updateValidators();
            this._updateDomValue();
            this._updateRegistrations();
            this._oldForm = this.form;
        }
    }
    /** @nodoc */
    ngOnDestroy() {
        if (this.form) {
            cleanUpValidators(this.form, this);
            // Currently the `onCollectionChange` callback is rewritten each time the
            // `_registerOnCollectionChange` function is invoked. The implication is that cleanup should
            // happen *only* when the `onCollectionChange` callback was set by this directive instance.
            // Otherwise it might cause overriding a callback of some other directive instances. We should
            // consider updating this logic later to make it similar to how `onChange` callbacks are
            // handled, see https://github.com/angular/angular/issues/39732 for additional info.
            if (this.form._onCollectionChange === this._onCollectionChange) {
                this.form._registerOnCollectionChange(() => { });
            }
        }
    }
    /**
     * @description
     * Returns this directive's instance.
     */
    get formDirective() {
        return this;
    }
    /**
     * @description
     * Returns the `FormGroup` bound to this directive.
     */
    get control() {
        return this.form;
    }
    /**
     * @description
     * Returns an array representing the path to this group. Because this directive
     * always lives at the top level of a form, it always an empty array.
     */
    get path() {
        return [];
    }
    /**
     * @description
     * Method that sets up the control directive in this group, re-calculates its value
     * and validity, and adds the instance to the internal list of directives.
     *
     * @param dir The `FormControlName` directive instance.
     */
    addControl(dir) {
        const ctrl = this.form.get(dir.path);
        setUpControl(ctrl, dir, this.callSetDisabledState);
        ctrl.updateValueAndValidity({ emitEvent: false });
        this.directives.push(dir);
        return ctrl;
    }
    /**
     * @description
     * Retrieves the `FormControl` instance from the provided `FormControlName` directive
     *
     * @param dir The `FormControlName` directive instance.
     */
    getControl(dir) {
        return this.form.get(dir.path);
    }
    /**
     * @description
     * Removes the `FormControlName` instance from the internal list of directives
     *
     * @param dir The `FormControlName` directive instance.
     */
    removeControl(dir) {
        cleanUpControl(dir.control || null, dir, /* validateControlPresenceOnChange */ false);
        removeListItem$1(this.directives, dir);
    }
    /**
     * Adds a new `FormGroupName` directive instance to the form.
     *
     * @param dir The `FormGroupName` directive instance.
     */
    addFormGroup(dir) {
        this._setUpFormContainer(dir);
    }
    /**
     * Performs the necessary cleanup when a `FormGroupName` directive instance is removed from the
     * view.
     *
     * @param dir The `FormGroupName` directive instance.
     */
    removeFormGroup(dir) {
        this._cleanUpFormContainer(dir);
    }
    /**
     * @description
     * Retrieves the `FormGroup` for a provided `FormGroupName` directive instance
     *
     * @param dir The `FormGroupName` directive instance.
     */
    getFormGroup(dir) {
        return this.form.get(dir.path);
    }
    /**
     * Performs the necessary setup when a `FormArrayName` directive instance is added to the view.
     *
     * @param dir The `FormArrayName` directive instance.
     */
    addFormArray(dir) {
        this._setUpFormContainer(dir);
    }
    /**
     * Performs the necessary cleanup when a `FormArrayName` directive instance is removed from the
     * view.
     *
     * @param dir The `FormArrayName` directive instance.
     */
    removeFormArray(dir) {
        this._cleanUpFormContainer(dir);
    }
    /**
     * @description
     * Retrieves the `FormArray` for a provided `FormArrayName` directive instance.
     *
     * @param dir The `FormArrayName` directive instance.
     */
    getFormArray(dir) {
        return this.form.get(dir.path);
    }
    /**
     * Sets the new value for the provided `FormControlName` directive.
     *
     * @param dir The `FormControlName` directive instance.
     * @param value The new value for the directive's control.
     */
    updateModel(dir, value) {
        const ctrl = this.form.get(dir.path);
        ctrl.setValue(value);
    }
    /**
     * @description
     * Method called with the "submit" event is triggered on the form.
     * Triggers the `ngSubmit` emitter to emit the "submit" event as its payload.
     *
     * @param $event The "submit" event object
     */
    onSubmit($event) {
        this.submitted = true;
        syncPendingControls(this.form, this.directives);
        this.ngSubmit.emit($event);
        // Forms with `method="dialog"` have some special behavior that won't reload the page and that
        // shouldn't be prevented. Note that we need to null check the `event` and the `target`, because
        // some internal apps call this method directly with the wrong arguments.
        return $event?.target?.method === 'dialog';
    }
    /**
     * @description
     * Method called when the "reset" event is triggered on the form.
     */
    onReset() {
        this.resetForm();
    }
    /**
     * @description
     * Resets the form to an initial value and resets its submitted status.
     *
     * @param value The new value for the form.
     */
    resetForm(value = undefined) {
        this.form.reset(value);
        this.submitted = false;
    }
    /** @internal */
    _updateDomValue() {
        this.directives.forEach(dir => {
            const oldCtrl = dir.control;
            const newCtrl = this.form.get(dir.path);
            if (oldCtrl !== newCtrl) {
                // Note: the value of the `dir.control` may not be defined, for example when it's a first
                // `FormControl` that is added to a `FormGroup` instance (via `addControl` call).
                cleanUpControl(oldCtrl || null, dir);
                // Check whether new control at the same location inside the corresponding `FormGroup` is an
                // instance of `FormControl` and perform control setup only if that's the case.
                // Note: we don't need to clear the list of directives (`this.directives`) here, it would be
                // taken care of in the `removeControl` method invoked when corresponding `formControlName`
                // directive instance is being removed (invoked from `FormControlName.ngOnDestroy`).
                if (isFormControl(newCtrl)) {
                    setUpControl(newCtrl, dir, this.callSetDisabledState);
                    dir.control = newCtrl;
                }
            }
        });
        this.form._updateTreeValidity({ emitEvent: false });
    }
    _setUpFormContainer(dir) {
        const ctrl = this.form.get(dir.path);
        setUpFormContainer(ctrl, dir);
        // NOTE: this operation looks unnecessary in case no new validators were added in
        // `setUpFormContainer` call. Consider updating this code to match the logic in
        // `_cleanUpFormContainer` function.
        ctrl.updateValueAndValidity({ emitEvent: false });
    }
    _cleanUpFormContainer(dir) {
        if (this.form) {
            const ctrl = this.form.get(dir.path);
            if (ctrl) {
                const isControlUpdated = cleanUpFormContainer(ctrl, dir);
                if (isControlUpdated) {
                    // Run validity check only in case a control was updated (i.e. view validators were
                    // removed) as removing view validators might cause validity to change.
                    ctrl.updateValueAndValidity({ emitEvent: false });
                }
            }
        }
    }
    _updateRegistrations() {
        this.form._registerOnCollectionChange(this._onCollectionChange);
        if (this._oldForm) {
            this._oldForm._registerOnCollectionChange(() => { });
        }
    }
    _updateValidators() {
        setUpValidators(this.form, this);
        if (this._oldForm) {
            cleanUpValidators(this._oldForm, this);
        }
    }
    _checkFormPresent() {
        if (!this.form && (typeof ngDevMode === 'undefined' || ngDevMode)) {
            throw missingFormException();
        }
    }
    static { this.fac = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareFactory"]({ minVersion: "12.0.0", version: "17.3.12", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: FormGroupDirective, deps: [{ token: NG_VALIDATORS, optional: true, self: true }, { token: NG_ASYNC_VALIDATORS, optional: true, self: true }, { token: CALL_SET_DISABLED_STATE, optional: true }], target: _angular_core__WEBPACK_IMPORTED_MODULE_0__["FactoryTarget"].Directive }); }
    static { this.dir = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareDirective"]({ minVersion: "14.0.0", version: "17.3.12", type: FormGroupDirective, selector: "[formGroup]", inputs: { form: ["formGroup", "form"] }, outputs: { ngSubmit: "ngSubmit" }, host: { listeners: { "submit": "onSubmit($event)", "reset": "onReset()" } }, providers: [formDirectiveProvider], exportAs: ["ngForm"], usesInheritance: true, usesOnChanges: true, ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))) }); }
}
_angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareClassMetadata"]({ minVersion: "12.0.0", version: "17.3.12", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: FormGroupDirective, decorators: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Directive,
            args: [{
                    selector: '[formGroup]',
                    providers: [formDirectiveProvider],
                    host: { '(submit)': 'onSubmit($event)', '(reset)': 'onReset()' },
                    exportAs: 'ngForm'
                }]
        }], ctorParameters: () => [{ type: undefined, decorators: [{
                    type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Optional
                }, {
                    type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Self
                }, {
                    type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Inject,
                    args: [NG_VALIDATORS]
                }] }, { type: undefined, decorators: [{
                    type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Optional
                }, {
                    type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Self
                }, {
                    type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Inject,
                    args: [NG_ASYNC_VALIDATORS]
                }] }, { type: undefined, decorators: [{
                    type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Optional
                }, {
                    type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Inject,
                    args: [CALL_SET_DISABLED_STATE]
                }] }], propDecorators: { form: [{
                type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input,
                args: ['formGroup']
            }], ngSubmit: [{
                type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Output
            }] } });

const formGroupNameProvider = {
    provide: ControlContainer,
    useExisting: (0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(() => FormGroupName)
};
/**
 * @description
 *
 * Syncs a nested `FormGroup` or `FormRecord` to a DOM element.
 *
 * This directive can only be used with a parent `FormGroupDirective`.
 *
 * It accepts the string name of the nested `FormGroup` or `FormRecord` to link, and
 * looks for a `FormGroup` or `FormRecord` registered with that name in the parent
 * `FormGroup` instance you passed into `FormGroupDirective`.
 *
 * Use nested form groups to validate a sub-group of a
 * form separately from the rest or to group the values of certain
 * controls into their own nested object.
 *
 * @see [Reactive Forms Guide](guide/reactive-forms)
 *
 * @usageNotes
 *
 * ### Access the group by name
 *
 * The following example uses the `AbstractControl.get` method to access the
 * associated `FormGroup`
 *
 * ```ts
 *   this.form.get('name');
 * ```
 *
 * ### Access individual controls in the group
 *
 * The following example uses the `AbstractControl.get` method to access
 * individual controls within the group using dot syntax.
 *
 * ```ts
 *   this.form.get('name.first');
 * ```
 *
 * ### Register a nested `FormGroup`.
 *
 * The following example registers a nested *name* `FormGroup` within an existing `FormGroup`,
 * and provides methods to retrieve the nested `FormGroup` and individual controls.
 *
 * {@example forms/ts/nestedFormGroup/nested_form_group_example.ts region='Component'}
 *
 * @ngModule ReactiveFormsModule
 * @publicApi
 */
class FormGroupName extends AbstractFormGroupDirective {
    constructor(parent, validators, asyncValidators) {
        super();
        /**
         * @description
         * Tracks the name of the `FormGroup` bound to the directive. The name corresponds
         * to a key in the parent `FormGroup` or `FormArray`.
         * Accepts a name as a string or a number.
         * The name in the form of a string is useful for individual forms,
         * while the numerical form allows for form groups to be bound
         * to indices when iterating over groups in a `FormArray`.
         */
        this.name = null;
        this._parent = parent;
        this._setValidators(validators);
        this._setAsyncValidators(asyncValidators);
    }
    /** @internal */
    _checkParentType() {
        if (_hasInvalidParent(this._parent) && (typeof ngDevMode === 'undefined' || ngDevMode)) {
            throw groupParentException();
        }
    }
    static { this.fac = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareFactory"]({ minVersion: "12.0.0", version: "17.3.12", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: FormGroupName, deps: [{ token: ControlContainer, host: true, optional: true, skipSelf: true }, { token: NG_VALIDATORS, optional: true, self: true }, { token: NG_ASYNC_VALIDATORS, optional: true, self: true }], target: _angular_core__WEBPACK_IMPORTED_MODULE_0__["FactoryTarget"].Directive }); }
    static { this.dir = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareDirective"]({ minVersion: "14.0.0", version: "17.3.12", type: FormGroupName, selector: "[formGroupName]", inputs: { name: ["formGroupName", "name"] }, providers: [formGroupNameProvider], usesInheritance: true, ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))) }); }
}
_angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareClassMetadata"]({ minVersion: "12.0.0", version: "17.3.12", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: FormGroupName, decorators: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Directive,
            args: [{ selector: '[formGroupName]', providers: [formGroupNameProvider] }]
        }], ctorParameters: () => [{ type: ControlContainer, decorators: [{
                    type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Optional
                }, {
                    type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Host
                }, {
                    type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.SkipSelf
                }] }, { type: undefined, decorators: [{
                    type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Optional
                }, {
                    type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Self
                }, {
                    type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Inject,
                    args: [NG_VALIDATORS]
                }] }, { type: undefined, decorators: [{
                    type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Optional
                }, {
                    type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Self
                }, {
                    type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Inject,
                    args: [NG_ASYNC_VALIDATORS]
                }] }], propDecorators: { name: [{
                type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input,
                args: ['formGroupName']
            }] } });
const formArrayNameProvider = {
    provide: ControlContainer,
    useExisting: (0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(() => FormArrayName)
};
/**
 * @description
 *
 * Syncs a nested `FormArray` to a DOM element.
 *
 * This directive is designed to be used with a parent `FormGroupDirective` (selector:
 * `[formGroup]`).
 *
 * It accepts the string name of the nested `FormArray` you want to link, and
 * will look for a `FormArray` registered with that name in the parent
 * `FormGroup` instance you passed into `FormGroupDirective`.
 *
 * @see [Reactive Forms Guide](guide/reactive-forms)
 * @see {@link AbstractControl}
 *
 * @usageNotes
 *
 * ### Example
 *
 * {@example forms/ts/nestedFormArray/nested_form_array_example.ts region='Component'}
 *
 * @ngModule ReactiveFormsModule
 * @publicApi
 */
class FormArrayName extends ControlContainer {
    constructor(parent, validators, asyncValidators) {
        super();
        /**
         * @description
         * Tracks the name of the `FormArray` bound to the directive. The name corresponds
         * to a key in the parent `FormGroup` or `FormArray`.
         * Accepts a name as a string or a number.
         * The name in the form of a string is useful for individual forms,
         * while the numerical form allows for form arrays to be bound
         * to indices when iterating over arrays in a `FormArray`.
         */
        this.name = null;
        this._parent = parent;
        this._setValidators(validators);
        this._setAsyncValidators(asyncValidators);
    }
    /**
     * A lifecycle method called when the directive's inputs are initialized. For internal use only.
     * @throws If the directive does not have a valid parent.
     * @nodoc
     */
    ngOnInit() {
        this._checkParentType();
        this.formDirective.addFormArray(this);
    }
    /**
     * A lifecycle method called before the directive's instance is destroyed. For internal use only.
     * @nodoc
     */
    ngOnDestroy() {
        if (this.formDirective) {
            this.formDirective.removeFormArray(this);
        }
    }
    /**
     * @description
     * The `FormArray` bound to this directive.
     */
    get control() {
        return this.formDirective.getFormArray(this);
    }
    /**
     * @description
     * The top-level directive for this group if present, otherwise null.
     */
    get formDirective() {
        return this._parent ? this._parent.formDirective : null;
    }
    /**
     * @description
     * Returns an array that represents the path from the top-level form to this control.
     * Each index is the string name of the control on that level.
     */
    get path() {
        return controlPath(this.name == null ? this.name : this.name.toString(), this._parent);
    }
    _checkParentType() {
        if (_hasInvalidParent(this._parent) && (typeof ngDevMode === 'undefined' || ngDevMode)) {
            throw arrayParentException();
        }
    }
    static { this.fac = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareFactory"]({ minVersion: "12.0.0", version: "17.3.12", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: FormArrayName, deps: [{ token: ControlContainer, host: true, optional: true, skipSelf: true }, { token: NG_VALIDATORS, optional: true, self: true }, { token: NG_ASYNC_VALIDATORS, optional: true, self: true }], target: _angular_core__WEBPACK_IMPORTED_MODULE_0__["FactoryTarget"].Directive }); }
    static { this.dir = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareDirective"]({ minVersion: "14.0.0", version: "17.3.12", type: FormArrayName, selector: "[formArrayName]", inputs: { name: ["formArrayName", "name"] }, providers: [formArrayNameProvider], usesInheritance: true, ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))) }); }
}
_angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareClassMetadata"]({ minVersion: "12.0.0", version: "17.3.12", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: FormArrayName, decorators: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Directive,
            args: [{ selector: '[formArrayName]', providers: [formArrayNameProvider] }]
        }], ctorParameters: () => [{ type: ControlContainer, decorators: [{
                    type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Optional
                }, {
                    type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Host
                }, {
                    type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.SkipSelf
                }] }, { type: undefined, decorators: [{
                    type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Optional
                }, {
                    type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Self
                }, {
                    type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Inject,
                    args: [NG_VALIDATORS]
                }] }, { type: undefined, decorators: [{
                    type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Optional
                }, {
                    type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Self
                }, {
                    type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Inject,
                    args: [NG_ASYNC_VALIDATORS]
                }] }], propDecorators: { name: [{
                type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input,
                args: ['formArrayName']
            }] } });
function _hasInvalidParent(parent) {
    return !(parent instanceof FormGroupName) && !(parent instanceof FormGroupDirective) &&
        !(parent instanceof FormArrayName);
}

const controlNameBinding = {
    provide: NgControl,
    useExisting: (0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(() => FormControlName)
};
/**
 * @description
 * Syncs a `FormControl` in an existing `FormGroup` to a form control
 * element by name.
 *
 * @see [Reactive Forms Guide](guide/reactive-forms)
 * @see {@link FormControl}
 * @see {@link AbstractControl}
 *
 * @usageNotes
 *
 * ### Register `FormControl` within a group
 *
 * The following example shows how to register multiple form controls within a form group
 * and set their value.
 *
 * {@example forms/ts/simpleFormGroup/simple_form_group_example.ts region='Component'}
 *
 * To see `formControlName` examples with different form control types, see:
 *
 * * Radio buttons: `RadioControlValueAccessor`
 * * Selects: `SelectControlValueAccessor`
 *
 * ### Use with ngModel is deprecated
 *
 * Support for using the `ngModel` input property and `ngModelChange` event with reactive
 * form directives has been deprecated in Angular v6 and is scheduled for removal in
 * a future version of Angular.
 *
 * For details, see [Deprecated features](guide/deprecations#ngmodel-with-reactive-forms).
 *
 * @ngModule ReactiveFormsModule
 * @publicApi
 */
class FormControlName extends NgControl {
    /**
     * @description
     * Triggers a warning in dev mode that this input should not be used with reactive forms.
     */
    set isDisabled(isDisabled) {
        if (typeof ngDevMode === 'undefined' || ngDevMode) {
            console.warn(disabledAttrWarning);
        }
    }
    /**
     * @description
     * Static property used to track whether any ngModel warnings have been sent across
     * all instances of FormControlName. Used to support warning config of "once".
     *
     * @internal
     */
    static { this._ngModelWarningSentOnce = false; }
    constructor(parent, validators, asyncValidators, valueAccessors, _ngModelWarningConfig) {
        super();
        this._ngModelWarningConfig = _ngModelWarningConfig;
        this._added = false;
        /**
         * @description
         * Tracks the name of the `FormControl` bound to the directive. The name corresponds
         * to a key in the parent `FormGroup` or `FormArray`.
         * Accepts a name as a string or a number.
         * The name in the form of a string is useful for individual forms,
         * while the numerical form allows for form controls to be bound
         * to indices when iterating over controls in a `FormArray`.
         */
        this.name = null;
        /** @deprecated as of v6 */
        this.update = new _angular_core__WEBPACK_IMPORTED_MODULE_0__.EventEmitter();
        /**
         * @description
         * Instance property used to track whether an ngModel warning has been sent out for this
         * particular FormControlName instance. Used to support warning config of "always".
         *
         * @internal
         */
        this._ngModelWarningSent = false;
        this._parent = parent;
        this._setValidators(validators);
        this._setAsyncValidators(asyncValidators);
        this.valueAccessor = selectValueAccessor(this, valueAccessors);
    }
    /** @nodoc */
    ngOnChanges(changes) {
        if (!this._added)
            this._setUpControl();
        if (isPropertyUpdated(changes, this.viewModel)) {
            if (typeof ngDevMode === 'undefined' || ngDevMode) {
                _ngModelWarning('formControlName', FormControlName, this, this._ngModelWarningConfig);
            }
            this.viewModel = this.model;
            this.formDirective.updateModel(this, this.model);
        }
    }
    /** @nodoc */
    ngOnDestroy() {
        if (this.formDirective) {
            this.formDirective.removeControl(this);
        }
    }
    /**
     * @description
     * Sets the new value for the view model and emits an `ngModelChange` event.
     *
     * @param newValue The new value for the view model.
     */
    viewToModelUpdate(newValue) {
        this.viewModel = newValue;
        this.update.emit(newValue);
    }
    /**
     * @description
     * Returns an array that represents the path from the top-level form to this control.
     * Each index is the string name of the control on that level.
     */
    get path() {
        return controlPath(this.name == null ? this.name : this.name.toString(), this._parent);
    }
    /**
     * @description
     * The top-level directive for this group if present, otherwise null.
     */
    get formDirective() {
        return this._parent ? this._parent.formDirective : null;
    }
    _checkParentType() {
        if (typeof ngDevMode === 'undefined' || ngDevMode) {
            if (!(this._parent instanceof FormGroupName) &&
                this._parent instanceof AbstractFormGroupDirective) {
                throw ngModelGroupException();
            }
            else if (!(this._parent instanceof FormGroupName) &&
                !(this._parent instanceof FormGroupDirective) &&
                !(this._parent instanceof FormArrayName)) {
                throw controlParentException();
            }
        }
    }
    _setUpControl() {
        this._checkParentType();
        this.control = this.formDirective.addControl(this);
        this._added = true;
    }
    static { this.fac = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareFactory"]({ minVersion: "12.0.0", version: "17.3.12", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: FormControlName, deps: [{ token: ControlContainer, host: true, optional: true, skipSelf: true }, { token: NG_VALIDATORS, optional: true, self: true }, { token: NG_ASYNC_VALIDATORS, optional: true, self: true }, { token: NG_VALUE_ACCESSOR, optional: true, self: true }, { token: NG_MODEL_WITH_FORM_CONTROL_WARNING, optional: true }], target: _angular_core__WEBPACK_IMPORTED_MODULE_0__["FactoryTarget"].Directive }); }
    static { this.dir = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareDirective"]({ minVersion: "14.0.0", version: "17.3.12", type: FormControlName, selector: "[formControlName]", inputs: { name: ["formControlName", "name"], isDisabled: ["disabled", "isDisabled"], model: ["ngModel", "model"] }, outputs: { update: "ngModelChange" }, providers: [controlNameBinding], usesInheritance: true, usesOnChanges: true, ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))) }); }
}
_angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareClassMetadata"]({ minVersion: "12.0.0", version: "17.3.12", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: FormControlName, decorators: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Directive,
            args: [{ selector: '[formControlName]', providers: [controlNameBinding] }]
        }], ctorParameters: () => [{ type: ControlContainer, decorators: [{
                    type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Optional
                }, {
                    type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Host
                }, {
                    type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.SkipSelf
                }] }, { type: undefined, decorators: [{
                    type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Optional
                }, {
                    type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Self
                }, {
                    type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Inject,
                    args: [NG_VALIDATORS]
                }] }, { type: undefined, decorators: [{
                    type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Optional
                }, {
                    type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Self
                }, {
                    type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Inject,
                    args: [NG_ASYNC_VALIDATORS]
                }] }, { type: undefined, decorators: [{
                    type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Optional
                }, {
                    type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Self
                }, {
                    type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Inject,
                    args: [NG_VALUE_ACCESSOR]
                }] }, { type: undefined, decorators: [{
                    type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Optional
                }, {
                    type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Inject,
                    args: [NG_MODEL_WITH_FORM_CONTROL_WARNING]
                }] }], propDecorators: { name: [{
                type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input,
                args: ['formControlName']
            }], isDisabled: [{
                type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input,
                args: ['disabled']
            }], model: [{
                type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input,
                args: ['ngModel']
            }], update: [{
                type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Output,
                args: ['ngModelChange']
            }] } });

const SELECT_VALUE_ACCESSOR = {
    provide: NG_VALUE_ACCESSOR,
    useExisting: (0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(() => SelectControlValueAccessor),
    multi: true
};
function _buildValueString$1(id, value) {
    if (id == null)
        return `${value}`;
    if (value && typeof value === 'object')
        value = 'Object';
    return `${id}: ${value}`.slice(0, 50);
}
function _extractId$1(valueString) {
    return valueString.split(':')[0];
}
/**
 * @description
 * The `ControlValueAccessor` for writing select control values and listening to select control
 * changes. The value accessor is used by the `FormControlDirective`, `FormControlName`, and
 * `NgModel` directives.
 *
 * @usageNotes
 *
 * ### Using select controls in a reactive form
 *
 * The following examples show how to use a select control in a reactive form.
 *
 * {@example forms/ts/reactiveSelectControl/reactive_select_control_example.ts region='Component'}
 *
 * ### Using select controls in a template-driven form
 *
 * To use a select in a template-driven form, simply add an `ngModel` and a `name`
 * attribute to the main `<select>` tag.
 *
 * {@example forms/ts/selectControl/select_control_example.ts region='Component'}
 *
 * ### Customizing option selection
 *
 * Angular uses object identity to select option. It's possible for the identities of items
 * to change while the data does not. This can happen, for example, if the items are produced
 * from an RPC to the server, and that RPC is re-run. Even if the data hasn't changed, the
 * second response will produce objects with different identities.
 *
 * To customize the default option comparison algorithm, `<select>` supports `compareWith` input.
 * `compareWith` takes a **function** which has two arguments: `option1` and `option2`.
 * If `compareWith` is given, Angular selects option by the return value of the function.
 *
 * ```ts
 * const selectedCountriesControl = new FormControl();
 * ```
 *
 * ```
 * <select [compareWith]="compareFn"  [formControl]="selectedCountriesControl">
 *     <option *ngFor="let country of countries" [ngValue]="country">
 *         {{country.name}}
 *     </option>
 * </select>
 *
 * compareFn(c1: Country, c2: Country): boolean {
 *     return c1 && c2 ? c1.id === c2.id : c1 === c2;
 * }
 * ```
 *
 * **Note:** We listen to the 'change' event because 'input' events aren't fired
 * for selects in IE, see:
 * https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/input_event#browser_compatibility
 *
 * @ngModule ReactiveFormsModule
 * @ngModule FormsModule
 * @publicApi
 */
class SelectControlValueAccessor extends BuiltInControlValueAccessor {
    constructor() {
        super(...arguments);
        /** @internal */
        this._optionMap = new Map();
        /** @internal */
        this._idCounter = 0;
        this._compareWith = Object.is;
    }
    /**
     * @description
     * Tracks the option comparison algorithm for tracking identities when
     * checking for changes.
     */
    set compareWith(fn) {
        if (typeof fn !== 'function' && (typeof ngDevMode === 'undefined' || ngDevMode)) {
            throw new _angular_core__WEBPACK_IMPORTED_MODULE_0__["RuntimeError"](1201 /* RuntimeErrorCode.COMPAREWITH_NOT_A_FN */, `compareWith must be a function, but received ${JSON.stringify(fn)}`);
        }
        this._compareWith = fn;
    }
    /**
     * Sets the "value" property on the select element.
     * @nodoc
     */
    writeValue(value) {
        this.value = value;
        const id = this._getOptionId(value);
        const valueString = _buildValueString$1(id, value);
        this.setProperty('value', valueString);
    }
    /**
     * Registers a function called when the control value changes.
     * @nodoc
     */
    registerOnChange(fn) {
        this.onChange = (valueString) => {
            this.value = this._getOptionValue(valueString);
            fn(this.value);
        };
    }
    /** @internal */
    _registerOption() {
        return (this._idCounter++).toString();
    }
    /** @internal */
    _getOptionId(value) {
        for (const id of this._optionMap.keys()) {
            if (this._compareWith(this._optionMap.get(id), value))
                return id;
        }
        return null;
    }
    /** @internal */
    _getOptionValue(valueString) {
        const id = _extractId$1(valueString);
        return this._optionMap.has(id) ? this._optionMap.get(id) : valueString;
    }
    static { this.fac = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareFactory"]({ minVersion: "12.0.0", version: "17.3.12", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: SelectControlValueAccessor, deps: null, target: _angular_core__WEBPACK_IMPORTED_MODULE_0__["FactoryTarget"].Directive }); }
    static { this.dir = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareDirective"]({ minVersion: "14.0.0", version: "17.3.12", type: SelectControlValueAccessor, selector: "select:not([multiple])[formControlName],select:not([multiple])[formControl],select:not([multiple])[ngModel]", inputs: { compareWith: "compareWith" }, host: { listeners: { "change": "onChange($event.target.value)", "blur": "onTouched()" } }, providers: [SELECT_VALUE_ACCESSOR], usesInheritance: true, ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))) }); }
}
_angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareClassMetadata"]({ minVersion: "12.0.0", version: "17.3.12", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: SelectControlValueAccessor, decorators: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Directive,
            args: [{
                    selector: 'select:not([multiple])[formControlName],select:not([multiple])[formControl],select:not([multiple])[ngModel]',
                    host: { '(change)': 'onChange($event.target.value)', '(blur)': 'onTouched()' },
                    providers: [SELECT_VALUE_ACCESSOR]
                }]
        }], propDecorators: { compareWith: [{
                type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input
            }] } });
/**
 * @description
 * Marks `<option>` as dynamic, so Angular can be notified when options change.
 *
 * @see {@link SelectControlValueAccessor}
 *
 * @ngModule ReactiveFormsModule
 * @ngModule FormsModule
 * @publicApi
 */
class NgSelectOption {
    constructor(_element, _renderer, _select) {
        this._element = _element;
        this._renderer = _renderer;
        this._select = _select;
        if (this._select)
            this.id = this._select._registerOption();
    }
    /**
     * @description
     * Tracks the value bound to the option element. Unlike the value binding,
     * ngValue supports binding to objects.
     */
    set ngValue(value) {
        if (this._select == null)
            return;
        this._select._optionMap.set(this.id, value);
        this._setElementValue(_buildValueString$1(this.id, value));
        this._select.writeValue(this._select.value);
    }
    /**
     * @description
     * Tracks simple string values bound to the option element.
     * For objects, use the `ngValue` input binding.
     */
    set value(value) {
        this._setElementValue(value);
        if (this._select)
            this._select.writeValue(this._select.value);
    }
    /** @internal */
    _setElementValue(value) {
        this._renderer.setProperty(this._element.nativeElement, 'value', value);
    }
    /** @nodoc */
    ngOnDestroy() {
        if (this._select) {
            this._select._optionMap.delete(this.id);
            this._select.writeValue(this._select.value);
        }
    }
    static { this.fac = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareFactory"]({ minVersion: "12.0.0", version: "17.3.12", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: NgSelectOption, deps: [{ token: _angular_core__WEBPACK_IMPORTED_MODULE_0__.ElementRef }, { token: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Renderer2 }, { token: SelectControlValueAccessor, host: true, optional: true }], target: _angular_core__WEBPACK_IMPORTED_MODULE_0__["FactoryTarget"].Directive }); }
    static { this.dir = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareDirective"]({ minVersion: "14.0.0", version: "17.3.12", type: NgSelectOption, selector: "option", inputs: { ngValue: "ngValue", value: "value" }, ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))) }); }
}
_angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareClassMetadata"]({ minVersion: "12.0.0", version: "17.3.12", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: NgSelectOption, decorators: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Directive,
            args: [{ selector: 'option' }]
        }], ctorParameters: () => [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.ElementRef }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Renderer2 }, { type: SelectControlValueAccessor, decorators: [{
                    type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Optional
                }, {
                    type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Host
                }] }], propDecorators: { ngValue: [{
                type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input,
                args: ['ngValue']
            }], value: [{
                type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input,
                args: ['value']
            }] } });

const SELECT_MULTIPLE_VALUE_ACCESSOR = {
    provide: NG_VALUE_ACCESSOR,
    useExisting: (0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(() => SelectMultipleControlValueAccessor),
    multi: true
};
function _buildValueString(id, value) {
    if (id == null)
        return `${value}`;
    if (typeof value === 'string')
        value = `'${value}'`;
    if (value && typeof value === 'object')
        value = 'Object';
    return `${id}: ${value}`.slice(0, 50);
}
function _extractId(valueString) {
    return valueString.split(':')[0];
}
/** Mock interface for HTMLCollection */
class HTMLCollection {
}
/**
 * @description
 * The `ControlValueAccessor` for writing multi-select control values and listening to multi-select
 * control changes. The value accessor is used by the `FormControlDirective`, `FormControlName`, and
 * `NgModel` directives.
 *
 * @see {@link SelectControlValueAccessor}
 *
 * @usageNotes
 *
 * ### Using a multi-select control
 *
 * The follow example shows you how to use a multi-select control with a reactive form.
 *
 * ```ts
 * const countryControl = new FormControl();
 * ```
 *
 * ```
 * <select multiple name="countries" [formControl]="countryControl">
 *   <option *ngFor="let country of countries" [ngValue]="country">
 *     {{ country.name }}
 *   </option>
 * </select>
 * ```
 *
 * ### Customizing option selection
 *
 * To customize the default option comparison algorithm, `<select>` supports `compareWith` input.
 * See the `SelectControlValueAccessor` for usage.
 *
 * @ngModule ReactiveFormsModule
 * @ngModule FormsModule
 * @publicApi
 */
class SelectMultipleControlValueAccessor extends BuiltInControlValueAccessor {
    constructor() {
        super(...arguments);
        /** @internal */
        this._optionMap = new Map();
        /** @internal */
        this._idCounter = 0;
        this._compareWith = Object.is;
    }
    /**
     * @description
     * Tracks the option comparison algorithm for tracking identities when
     * checking for changes.
     */
    set compareWith(fn) {
        if (typeof fn !== 'function' && (typeof ngDevMode === 'undefined' || ngDevMode)) {
            throw new _angular_core__WEBPACK_IMPORTED_MODULE_0__["RuntimeError"](1201 /* RuntimeErrorCode.COMPAREWITH_NOT_A_FN */, `compareWith must be a function, but received ${JSON.stringify(fn)}`);
        }
        this._compareWith = fn;
    }
    /**
     * Sets the "value" property on one or of more of the select's options.
     * @nodoc
     */
    writeValue(value) {
        this.value = value;
        let optionSelectedStateSetter;
        if (Array.isArray(value)) {
            // convert values to ids
            const ids = value.map((v) => this._getOptionId(v));
            optionSelectedStateSetter = (opt, o) => {
                opt._setSelected(ids.indexOf(o.toString()) > -1);
            };
        }
        else {
            optionSelectedStateSetter = (opt, o) => {
                opt._setSelected(false);
            };
        }
        this._optionMap.forEach(optionSelectedStateSetter);
    }
    /**
     * Registers a function called when the control value changes
     * and writes an array of the selected options.
     * @nodoc
     */
    registerOnChange(fn) {
        this.onChange = (element) => {
            const selected = [];
            const selectedOptions = element.selectedOptions;
            if (selectedOptions !== undefined) {
                const options = selectedOptions;
                for (let i = 0; i < options.length; i++) {
                    const opt = options[i];
                    const val = this._getOptionValue(opt.value);
                    selected.push(val);
                }
            }
            // Degrade to use `options` when `selectedOptions` property is not available.
            // Note: the `selectedOptions` is available in all supported browsers, but the Domino lib
            // doesn't have it currently, see https://github.com/fgnass/domino/issues/177.
            else {
                const options = element.options;
                for (let i = 0; i < options.length; i++) {
                    const opt = options[i];
                    if (opt.selected) {
                        const val = this._getOptionValue(opt.value);
                        selected.push(val);
                    }
                }
            }
            this.value = selected;
            fn(selected);
        };
    }
    /** @internal */
    _registerOption(value) {
        const id = (this._idCounter++).toString();
        this._optionMap.set(id, value);
        return id;
    }
    /** @internal */
    _getOptionId(value) {
        for (const id of this._optionMap.keys()) {
            if (this._compareWith(this._optionMap.get(id)._value, value))
                return id;
        }
        return null;
    }
    /** @internal */
    _getOptionValue(valueString) {
        const id = _extractId(valueString);
        return this._optionMap.has(id) ? this._optionMap.get(id)._value : valueString;
    }
    static { this.fac = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareFactory"]({ minVersion: "12.0.0", version: "17.3.12", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: SelectMultipleControlValueAccessor, deps: null, target: _angular_core__WEBPACK_IMPORTED_MODULE_0__["FactoryTarget"].Directive }); }
    static { this.dir = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareDirective"]({ minVersion: "14.0.0", version: "17.3.12", type: SelectMultipleControlValueAccessor, selector: "select[multiple][formControlName],select[multiple][formControl],select[multiple][ngModel]", inputs: { compareWith: "compareWith" }, host: { listeners: { "change": "onChange($event.target)", "blur": "onTouched()" } }, providers: [SELECT_MULTIPLE_VALUE_ACCESSOR], usesInheritance: true, ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))) }); }
}
_angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareClassMetadata"]({ minVersion: "12.0.0", version: "17.3.12", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: SelectMultipleControlValueAccessor, decorators: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Directive,
            args: [{
                    selector: 'select[multiple][formControlName],select[multiple][formControl],select[multiple][ngModel]',
                    host: { '(change)': 'onChange($event.target)', '(blur)': 'onTouched()' },
                    providers: [SELECT_MULTIPLE_VALUE_ACCESSOR]
                }]
        }], propDecorators: { compareWith: [{
                type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input
            }] } });
/**
 * @description
 * Marks `<option>` as dynamic, so Angular can be notified when options change.
 *
 * @see {@link SelectMultipleControlValueAccessor}
 *
 * @ngModule ReactiveFormsModule
 * @ngModule FormsModule
 * @publicApi
 */
class NgSelectMultipleOption {
    constructor(_element, _renderer, _select) {
        this._element = _element;
        this._renderer = _renderer;
        this._select = _select;
        if (this._select) {
            this.id = this._select._registerOption(this);
        }
    }
    /**
     * @description
     * Tracks the value bound to the option element. Unlike the value binding,
     * ngValue supports binding to objects.
     */
    set ngValue(value) {
        if (this._select == null)
            return;
        this._value = value;
        this._setElementValue(_buildValueString(this.id, value));
        this._select.writeValue(this._select.value);
    }
    /**
     * @description
     * Tracks simple string values bound to the option element.
     * For objects, use the `ngValue` input binding.
     */
    set value(value) {
        if (this._select) {
            this._value = value;
            this._setElementValue(_buildValueString(this.id, value));
            this._select.writeValue(this._select.value);
        }
        else {
            this._setElementValue(value);
        }
    }
    /** @internal */
    _setElementValue(value) {
        this._renderer.setProperty(this._element.nativeElement, 'value', value);
    }
    /** @internal */
    _setSelected(selected) {
        this._renderer.setProperty(this._element.nativeElement, 'selected', selected);
    }
    /** @nodoc */
    ngOnDestroy() {
        if (this._select) {
            this._select._optionMap.delete(this.id);
            this._select.writeValue(this._select.value);
        }
    }
    static { this.fac = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareFactory"]({ minVersion: "12.0.0", version: "17.3.12", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: NgSelectMultipleOption, deps: [{ token: _angular_core__WEBPACK_IMPORTED_MODULE_0__.ElementRef }, { token: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Renderer2 }, { token: SelectMultipleControlValueAccessor, host: true, optional: true }], target: _angular_core__WEBPACK_IMPORTED_MODULE_0__["FactoryTarget"].Directive }); }
    static { this.dir = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareDirective"]({ minVersion: "14.0.0", version: "17.3.12", type: NgSelectMultipleOption, selector: "option", inputs: { ngValue: "ngValue", value: "value" }, ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))) }); }
}
_angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareClassMetadata"]({ minVersion: "12.0.0", version: "17.3.12", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: NgSelectMultipleOption, decorators: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Directive,
            args: [{ selector: 'option' }]
        }], ctorParameters: () => [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.ElementRef }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Renderer2 }, { type: SelectMultipleControlValueAccessor, decorators: [{
                    type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Optional
                }, {
                    type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Host
                }] }], propDecorators: { ngValue: [{
                type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input,
                args: ['ngValue']
            }], value: [{
                type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input,
                args: ['value']
            }] } });

/**
 * Method that updates string to integer if not already a number
 *
 * @param value The value to convert to integer.
 * @returns value of parameter converted to number or integer.
 */
function toInteger(value) {
    return typeof value === 'number' ? value : parseInt(value, 10);
}
/**
 * Method that ensures that provided value is a float (and converts it to float if needed).
 *
 * @param value The value to convert to float.
 * @returns value of parameter converted to number or float.
 */
function toFloat(value) {
    return typeof value === 'number' ? value : parseFloat(value);
}
/**
 * A base class for Validator-based Directives. The class contains common logic shared across such
 * Directives.
 *
 * For internal use only, this class is not intended for use outside of the Forms package.
 */
class AbstractValidatorDirective {
    constructor() {
        this._validator = nullValidator;
    }
    /** @nodoc */
    ngOnChanges(changes) {
        if (this.inputName in changes) {
            const input = this.normalizeInput(changes[this.inputName].currentValue);
            this._enabled = this.enabled(input);
            this._validator = this._enabled ? this.createValidator(input) : nullValidator;
            if (this._onChange) {
                this._onChange();
            }
        }
    }
    /** @nodoc */
    validate(control) {
        return this._validator(control);
    }
    /** @nodoc */
    registerOnValidatorChange(fn) {
        this._onChange = fn;
    }
    /**
     * @description
     * Determines whether this validator should be active or not based on an input.
     * Base class implementation checks whether an input is defined (if the value is different from
     * `null` and `undefined`). Validator classes that extend this base class can override this
     * function with the logic specific to a particular validator directive.
     */
    enabled(input) {
        return input != null /* both `null` and `undefined` */;
    }
    static { this.fac = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareFactory"]({ minVersion: "12.0.0", version: "17.3.12", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: AbstractValidatorDirective, deps: [], target: _angular_core__WEBPACK_IMPORTED_MODULE_0__["FactoryTarget"].Directive }); }
    static { this.dir = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareDirective"]({ minVersion: "14.0.0", version: "17.3.12", type: AbstractValidatorDirective, usesOnChanges: true, ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))) }); }
}
_angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareClassMetadata"]({ minVersion: "12.0.0", version: "17.3.12", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: AbstractValidatorDirective, decorators: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Directive
        }] });
/**
 * @description
 * Provider which adds `MaxValidator` to the `NG_VALIDATORS` multi-provider list.
 */
const MAX_VALIDATOR = {
    provide: NG_VALIDATORS,
    useExisting: (0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(() => MaxValidator),
    multi: true
};
/**
 * A directive which installs the {@link MaxValidator} for any `formControlName`,
 * `formControl`, or control with `ngModel` that also has a `max` attribute.
 *
 * @see [Form Validation](guide/form-validation)
 *
 * @usageNotes
 *
 * ### Adding a max validator
 *
 * The following example shows how to add a max validator to an input attached to an
 * ngModel binding.
 *
 * ```html
 * <input type="number" ngModel max="4">
 * ```
 *
 * @ngModule ReactiveFormsModule
 * @ngModule FormsModule
 * @publicApi
 */
class MaxValidator extends AbstractValidatorDirective {
    constructor() {
        super(...arguments);
        /** @internal */
        this.inputName = 'max';
        /** @internal */
        this.normalizeInput = (input) => toFloat(input);
        /** @internal */
        this.createValidator = (max) => maxValidator(max);
    }
    static { this.fac = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareFactory"]({ minVersion: "12.0.0", version: "17.3.12", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: MaxValidator, deps: null, target: _angular_core__WEBPACK_IMPORTED_MODULE_0__["FactoryTarget"].Directive }); }
    static { this.dir = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareDirective"]({ minVersion: "14.0.0", version: "17.3.12", type: MaxValidator, selector: "input[type=number][max][formControlName],input[type=number][max][formControl],input[type=number][max][ngModel]", inputs: { max: "max" }, host: { properties: { "attr.max": "_enabled ? max : null" } }, providers: [MAX_VALIDATOR], usesInheritance: true, ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))) }); }
}
_angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareClassMetadata"]({ minVersion: "12.0.0", version: "17.3.12", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: MaxValidator, decorators: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Directive,
            args: [{
                    selector: 'input[type=number][max][formControlName],input[type=number][max][formControl],input[type=number][max][ngModel]',
                    providers: [MAX_VALIDATOR],
                    host: { '[attr.max]': '_enabled ? max : null' }
                }]
        }], propDecorators: { max: [{
                type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input
            }] } });
/**
 * @description
 * Provider which adds `MinValidator` to the `NG_VALIDATORS` multi-provider list.
 */
const MIN_VALIDATOR = {
    provide: NG_VALIDATORS,
    useExisting: (0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(() => MinValidator),
    multi: true
};
/**
 * A directive which installs the {@link MinValidator} for any `formControlName`,
 * `formControl`, or control with `ngModel` that also has a `min` attribute.
 *
 * @see [Form Validation](guide/form-validation)
 *
 * @usageNotes
 *
 * ### Adding a min validator
 *
 * The following example shows how to add a min validator to an input attached to an
 * ngModel binding.
 *
 * ```html
 * <input type="number" ngModel min="4">
 * ```
 *
 * @ngModule ReactiveFormsModule
 * @ngModule FormsModule
 * @publicApi
 */
class MinValidator extends AbstractValidatorDirective {
    constructor() {
        super(...arguments);
        /** @internal */
        this.inputName = 'min';
        /** @internal */
        this.normalizeInput = (input) => toFloat(input);
        /** @internal */
        this.createValidator = (min) => minValidator(min);
    }
    static { this.fac = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareFactory"]({ minVersion: "12.0.0", version: "17.3.12", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: MinValidator, deps: null, target: _angular_core__WEBPACK_IMPORTED_MODULE_0__["FactoryTarget"].Directive }); }
    static { this.dir = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareDirective"]({ minVersion: "14.0.0", version: "17.3.12", type: MinValidator, selector: "input[type=number][min][formControlName],input[type=number][min][formControl],input[type=number][min][ngModel]", inputs: { min: "min" }, host: { properties: { "attr.min": "_enabled ? min : null" } }, providers: [MIN_VALIDATOR], usesInheritance: true, ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))) }); }
}
_angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareClassMetadata"]({ minVersion: "12.0.0", version: "17.3.12", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: MinValidator, decorators: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Directive,
            args: [{
                    selector: 'input[type=number][min][formControlName],input[type=number][min][formControl],input[type=number][min][ngModel]',
                    providers: [MIN_VALIDATOR],
                    host: { '[attr.min]': '_enabled ? min : null' }
                }]
        }], propDecorators: { min: [{
                type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input
            }] } });
/**
 * @description
 * Provider which adds `RequiredValidator` to the `NG_VALIDATORS` multi-provider list.
 */
const REQUIRED_VALIDATOR = {
    provide: NG_VALIDATORS,
    useExisting: (0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(() => RequiredValidator),
    multi: true
};
/**
 * @description
 * Provider which adds `CheckboxRequiredValidator` to the `NG_VALIDATORS` multi-provider list.
 */
const CHECKBOX_REQUIRED_VALIDATOR = {
    provide: NG_VALIDATORS,
    useExisting: (0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(() => CheckboxRequiredValidator),
    multi: true
};
/**
 * @description
 * A directive that adds the `required` validator to any controls marked with the
 * `required` attribute. The directive is provided with the `NG_VALIDATORS` multi-provider list.
 *
 * @see [Form Validation](guide/form-validation)
 *
 * @usageNotes
 *
 * ### Adding a required validator using template-driven forms
 *
 * ```
 * <input name="fullName" ngModel required>
 * ```
 *
 * @ngModule FormsModule
 * @ngModule ReactiveFormsModule
 * @publicApi
 */
class RequiredValidator extends AbstractValidatorDirective {
    constructor() {
        super(...arguments);
        /** @internal */
        this.inputName = 'required';
        /** @internal */
        this.normalizeInput = _angular_core__WEBPACK_IMPORTED_MODULE_0__.booleanAttribute;
        /** @internal */
        this.createValidator = (input) => requiredValidator;
    }
    /** @nodoc */
    enabled(input) {
        return input;
    }
    static { this.fac = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareFactory"]({ minVersion: "12.0.0", version: "17.3.12", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: RequiredValidator, deps: null, target: _angular_core__WEBPACK_IMPORTED_MODULE_0__["FactoryTarget"].Directive }); }
    static { this.dir = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareDirective"]({ minVersion: "14.0.0", version: "17.3.12", type: RequiredValidator, selector: ":not([type=checkbox])[required][formControlName],:not([type=checkbox])[required][formControl],:not([type=checkbox])[required][ngModel]", inputs: { required: "required" }, host: { properties: { "attr.required": "_enabled ? \"\" : null" } }, providers: [REQUIRED_VALIDATOR], usesInheritance: true, ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))) }); }
}
_angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareClassMetadata"]({ minVersion: "12.0.0", version: "17.3.12", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: RequiredValidator, decorators: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Directive,
            args: [{
                    selector: ':not([type=checkbox])[required][formControlName],:not([type=checkbox])[required][formControl],:not([type=checkbox])[required][ngModel]',
                    providers: [REQUIRED_VALIDATOR],
                    host: { '[attr.required]': '_enabled ? "" : null' }
                }]
        }], propDecorators: { required: [{
                type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input
            }] } });
/**
 * A Directive that adds the `required` validator to checkbox controls marked with the
 * `required` attribute. The directive is provided with the `NG_VALIDATORS` multi-provider list.
 *
 * @see [Form Validation](guide/form-validation)
 *
 * @usageNotes
 *
 * ### Adding a required checkbox validator using template-driven forms
 *
 * The following example shows how to add a checkbox required validator to an input attached to an
 * ngModel binding.
 *
 * ```
 * <input type="checkbox" name="active" ngModel required>
 * ```
 *
 * @publicApi
 * @ngModule FormsModule
 * @ngModule ReactiveFormsModule
 */
class CheckboxRequiredValidator extends RequiredValidator {
    constructor() {
        super(...arguments);
        /** @internal */
        this.createValidator = (input) => requiredTrueValidator;
    }
    static { this.fac = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareFactory"]({ minVersion: "12.0.0", version: "17.3.12", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: CheckboxRequiredValidator, deps: null, target: _angular_core__WEBPACK_IMPORTED_MODULE_0__["FactoryTarget"].Directive }); }
    static { this.dir = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareDirective"]({ minVersion: "14.0.0", version: "17.3.12", type: CheckboxRequiredValidator, selector: "input[type=checkbox][required][formControlName],input[type=checkbox][required][formControl],input[type=checkbox][required][ngModel]", host: { properties: { "attr.required": "_enabled ? \"\" : null" } }, providers: [CHECKBOX_REQUIRED_VALIDATOR], usesInheritance: true, ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))) }); }
}
_angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareClassMetadata"]({ minVersion: "12.0.0", version: "17.3.12", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: CheckboxRequiredValidator, decorators: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Directive,
            args: [{
                    selector: 'input[type=checkbox][required][formControlName],input[type=checkbox][required][formControl],input[type=checkbox][required][ngModel]',
                    providers: [CHECKBOX_REQUIRED_VALIDATOR],
                    host: { '[attr.required]': '_enabled ? "" : null' }
                }]
        }] });
/**
 * @description
 * Provider which adds `EmailValidator` to the `NG_VALIDATORS` multi-provider list.
 */
const EMAIL_VALIDATOR = {
    provide: NG_VALIDATORS,
    useExisting: (0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(() => EmailValidator),
    multi: true
};
/**
 * A directive that adds the `email` validator to controls marked with the
 * `email` attribute. The directive is provided with the `NG_VALIDATORS` multi-provider list.
 *
 * The email validation is based on the WHATWG HTML specification with some enhancements to
 * incorporate more RFC rules. More information can be found on the [Validators.email
 * page](api/forms/Validators#email).
 *
 * @see [Form Validation](guide/form-validation)
 *
 * @usageNotes
 *
 * ### Adding an email validator
 *
 * The following example shows how to add an email validator to an input attached to an ngModel
 * binding.
 *
 * ```
 * <input type="email" name="email" ngModel email>
 * <input type="email" name="email" ngModel email="true">
 * <input type="email" name="email" ngModel [email]="true">
 * ```
 *
 * @publicApi
 * @ngModule FormsModule
 * @ngModule ReactiveFormsModule
 */
class EmailValidator extends AbstractValidatorDirective {
    constructor() {
        super(...arguments);
        /** @internal */
        this.inputName = 'email';
        /** @internal */
        this.normalizeInput = _angular_core__WEBPACK_IMPORTED_MODULE_0__.booleanAttribute;
        /** @internal */
        this.createValidator = (input) => emailValidator;
    }
    /** @nodoc */
    enabled(input) {
        return input;
    }
    static { this.fac = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareFactory"]({ minVersion: "12.0.0", version: "17.3.12", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: EmailValidator, deps: null, target: _angular_core__WEBPACK_IMPORTED_MODULE_0__["FactoryTarget"].Directive }); }
    static { this.dir = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareDirective"]({ minVersion: "14.0.0", version: "17.3.12", type: EmailValidator, selector: "[email][formControlName],[email][formControl],[email][ngModel]", inputs: { email: "email" }, providers: [EMAIL_VALIDATOR], usesInheritance: true, ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))) }); }
}
_angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareClassMetadata"]({ minVersion: "12.0.0", version: "17.3.12", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: EmailValidator, decorators: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Directive,
            args: [{
                    selector: '[email][formControlName],[email][formControl],[email][ngModel]',
                    providers: [EMAIL_VALIDATOR]
                }]
        }], propDecorators: { email: [{
                type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input
            }] } });
/**
 * @description
 * Provider which adds `MinLengthValidator` to the `NG_VALIDATORS` multi-provider list.
 */
const MIN_LENGTH_VALIDATOR = {
    provide: NG_VALIDATORS,
    useExisting: (0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(() => MinLengthValidator),
    multi: true
};
/**
 * A directive that adds minimum length validation to controls marked with the
 * `minlength` attribute. The directive is provided with the `NG_VALIDATORS` multi-provider list.
 *
 * @see [Form Validation](guide/form-validation)
 *
 * @usageNotes
 *
 * ### Adding a minimum length validator
 *
 * The following example shows how to add a minimum length validator to an input attached to an
 * ngModel binding.
 *
 * ```html
 * <input name="firstName" ngModel minlength="4">
 * ```
 *
 * @ngModule ReactiveFormsModule
 * @ngModule FormsModule
 * @publicApi
 */
class MinLengthValidator extends AbstractValidatorDirective {
    constructor() {
        super(...arguments);
        /** @internal */
        this.inputName = 'minlength';
        /** @internal */
        this.normalizeInput = (input) => toInteger(input);
        /** @internal */
        this.createValidator = (minlength) => minLengthValidator(minlength);
    }
    static { this.fac = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareFactory"]({ minVersion: "12.0.0", version: "17.3.12", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: MinLengthValidator, deps: null, target: _angular_core__WEBPACK_IMPORTED_MODULE_0__["FactoryTarget"].Directive }); }
    static { this.dir = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareDirective"]({ minVersion: "14.0.0", version: "17.3.12", type: MinLengthValidator, selector: "[minlength][formControlName],[minlength][formControl],[minlength][ngModel]", inputs: { minlength: "minlength" }, host: { properties: { "attr.minlength": "_enabled ? minlength : null" } }, providers: [MIN_LENGTH_VALIDATOR], usesInheritance: true, ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))) }); }
}
_angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareClassMetadata"]({ minVersion: "12.0.0", version: "17.3.12", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: MinLengthValidator, decorators: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Directive,
            args: [{
                    selector: '[minlength][formControlName],[minlength][formControl],[minlength][ngModel]',
                    providers: [MIN_LENGTH_VALIDATOR],
                    host: { '[attr.minlength]': '_enabled ? minlength : null' }
                }]
        }], propDecorators: { minlength: [{
                type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input
            }] } });
/**
 * @description
 * Provider which adds `MaxLengthValidator` to the `NG_VALIDATORS` multi-provider list.
 */
const MAX_LENGTH_VALIDATOR = {
    provide: NG_VALIDATORS,
    useExisting: (0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(() => MaxLengthValidator),
    multi: true
};
/**
 * A directive that adds maximum length validation to controls marked with the
 * `maxlength` attribute. The directive is provided with the `NG_VALIDATORS` multi-provider list.
 *
 * @see [Form Validation](guide/form-validation)
 *
 * @usageNotes
 *
 * ### Adding a maximum length validator
 *
 * The following example shows how to add a maximum length validator to an input attached to an
 * ngModel binding.
 *
 * ```html
 * <input name="firstName" ngModel maxlength="25">
 * ```
 *
 * @ngModule ReactiveFormsModule
 * @ngModule FormsModule
 * @publicApi
 */
class MaxLengthValidator extends AbstractValidatorDirective {
    constructor() {
        super(...arguments);
        /** @internal */
        this.inputName = 'maxlength';
        /** @internal */
        this.normalizeInput = (input) => toInteger(input);
        /** @internal */
        this.createValidator = (maxlength) => maxLengthValidator(maxlength);
    }
    static { this.fac = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareFactory"]({ minVersion: "12.0.0", version: "17.3.12", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: MaxLengthValidator, deps: null, target: _angular_core__WEBPACK_IMPORTED_MODULE_0__["FactoryTarget"].Directive }); }
    static { this.dir = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareDirective"]({ minVersion: "14.0.0", version: "17.3.12", type: MaxLengthValidator, selector: "[maxlength][formControlName],[maxlength][formControl],[maxlength][ngModel]", inputs: { maxlength: "maxlength" }, host: { properties: { "attr.maxlength": "_enabled ? maxlength : null" } }, providers: [MAX_LENGTH_VALIDATOR], usesInheritance: true, ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))) }); }
}
_angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareClassMetadata"]({ minVersion: "12.0.0", version: "17.3.12", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: MaxLengthValidator, decorators: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Directive,
            args: [{
                    selector: '[maxlength][formControlName],[maxlength][formControl],[maxlength][ngModel]',
                    providers: [MAX_LENGTH_VALIDATOR],
                    host: { '[attr.maxlength]': '_enabled ? maxlength : null' }
                }]
        }], propDecorators: { maxlength: [{
                type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input
            }] } });
/**
 * @description
 * Provider which adds `PatternValidator` to the `NG_VALIDATORS` multi-provider list.
 */
const PATTERN_VALIDATOR = {
    provide: NG_VALIDATORS,
    useExisting: (0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(() => PatternValidator),
    multi: true
};
/**
 * @description
 * A directive that adds regex pattern validation to controls marked with the
 * `pattern` attribute. The regex must match the entire control value.
 * The directive is provided with the `NG_VALIDATORS` multi-provider list.
 *
 * @see [Form Validation](guide/form-validation)
 *
 * @usageNotes
 *
 * ### Adding a pattern validator
 *
 * The following example shows how to add a pattern validator to an input attached to an
 * ngModel binding.
 *
 * ```html
 * <input name="firstName" ngModel pattern="[a-zA-Z ]*">
 * ```
 *
 * @ngModule ReactiveFormsModule
 * @ngModule FormsModule
 * @publicApi
 */
class PatternValidator extends AbstractValidatorDirective {
    constructor() {
        super(...arguments);
        /** @internal */
        this.inputName = 'pattern';
        /** @internal */
        this.normalizeInput = (input) => input;
        /** @internal */
        this.createValidator = (input) => patternValidator(input);
    }
    static { this.fac = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareFactory"]({ minVersion: "12.0.0", version: "17.3.12", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: PatternValidator, deps: null, target: _angular_core__WEBPACK_IMPORTED_MODULE_0__["FactoryTarget"].Directive }); }
    static { this.dir = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareDirective"]({ minVersion: "14.0.0", version: "17.3.12", type: PatternValidator, selector: "[pattern][formControlName],[pattern][formControl],[pattern][ngModel]", inputs: { pattern: "pattern" }, host: { properties: { "attr.pattern": "_enabled ? pattern : null" } }, providers: [PATTERN_VALIDATOR], usesInheritance: true, ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))) }); }
}
_angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareClassMetadata"]({ minVersion: "12.0.0", version: "17.3.12", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: PatternValidator, decorators: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Directive,
            args: [{
                    selector: '[pattern][formControlName],[pattern][formControl],[pattern][ngModel]',
                    providers: [PATTERN_VALIDATOR],
                    host: { '[attr.pattern]': '_enabled ? pattern : null' }
                }]
        }], propDecorators: { pattern: [{
                type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input
            }] } });

const SHARED_FORM_DIRECTIVES = [
    NgNoValidate,
    NgSelectOption,
    NgSelectMultipleOption,
    DefaultValueAccessor,
    NumberValueAccessor,
    RangeValueAccessor,
    CheckboxControlValueAccessor,
    SelectControlValueAccessor,
    SelectMultipleControlValueAccessor,
    RadioControlValueAccessor,
    NgControlStatus,
    NgControlStatusGroup,
    RequiredValidator,
    MinLengthValidator,
    MaxLengthValidator,
    PatternValidator,
    CheckboxRequiredValidator,
    EmailValidator,
    MinValidator,
    MaxValidator,
];
const TEMPLATE_DRIVEN_DIRECTIVES = [NgModel, NgModelGroup, NgForm];
const REACTIVE_DRIVEN_DIRECTIVES = [FormControlDirective, FormGroupDirective, FormControlName, FormGroupName, FormArrayName];
/**
 * Internal module used for sharing directives between FormsModule and ReactiveFormsModule
 */
class InternalFormsSharedModule {
    static { this.fac = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareFactory"]({ minVersion: "12.0.0", version: "17.3.12", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: InternalFormsSharedModule, deps: [], target: _angular_core__WEBPACK_IMPORTED_MODULE_0__["FactoryTarget"].NgModule }); }
    static { this.mod = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareNgModule"]({ minVersion: "14.0.0", version: "17.3.12", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: InternalFormsSharedModule, declarations: [NgNoValidate,
            NgSelectOption,
            NgSelectMultipleOption,
            DefaultValueAccessor,
            NumberValueAccessor,
            RangeValueAccessor,
            CheckboxControlValueAccessor,
            SelectControlValueAccessor,
            SelectMultipleControlValueAccessor,
            RadioControlValueAccessor,
            NgControlStatus,
            NgControlStatusGroup,
            RequiredValidator,
            MinLengthValidator,
            MaxLengthValidator,
            PatternValidator,
            CheckboxRequiredValidator,
            EmailValidator,
            MinValidator,
            MaxValidator], exports: [NgNoValidate,
            NgSelectOption,
            NgSelectMultipleOption,
            DefaultValueAccessor,
            NumberValueAccessor,
            RangeValueAccessor,
            CheckboxControlValueAccessor,
            SelectControlValueAccessor,
            SelectMultipleControlValueAccessor,
            RadioControlValueAccessor,
            NgControlStatus,
            NgControlStatusGroup,
            RequiredValidator,
            MinLengthValidator,
            MaxLengthValidator,
            PatternValidator,
            CheckboxRequiredValidator,
            EmailValidator,
            MinValidator,
            MaxValidator] }); }
    static { this.inj = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareInjector"]({ minVersion: "12.0.0", version: "17.3.12", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: InternalFormsSharedModule }); }
}
_angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareClassMetadata"]({ minVersion: "12.0.0", version: "17.3.12", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: InternalFormsSharedModule, decorators: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.NgModule,
            args: [{
                    declarations: SHARED_FORM_DIRECTIVES,
                    exports: SHARED_FORM_DIRECTIVES,
                }]
        }] });

/**
 * Tracks the value and validity state of an array of `FormControl`,
 * `FormGroup` or `FormArray` instances.
 *
 * A `FormArray` aggregates the values of each child `FormControl` into an array.
 * It calculates its status by reducing the status values of its children. For example, if one of
 * the controls in a `FormArray` is invalid, the entire array becomes invalid.
 *
 * `FormArray` accepts one generic argument, which is the type of the controls inside.
 * If you need a heterogenous array, use {@link UntypedFormArray}.
 *
 * `FormArray` is one of the four fundamental building blocks used to define forms in Angular,
 * along with `FormControl`, `FormGroup`, and `FormRecord`.
 *
 * @usageNotes
 *
 * ### Create an array of form controls
 *
 * ```
 * const arr = new FormArray([
 *   new FormControl('Nancy', Validators.minLength(2)),
 *   new FormControl('Drew'),
 * ]);
 *
 * console.log(arr.value);   // ['Nancy', 'Drew']
 * console.log(arr.status);  // 'VALID'
 * ```
 *
 * ### Create a form array with array-level validators
 *
 * You include array-level validators and async validators. These come in handy
 * when you want to perform validation that considers the value of more than one child
 * control.
 *
 * The two types of validators are passed in separately as the second and third arg
 * respectively, or together as part of an options object.
 *
 * ```
 * const arr = new FormArray([
 *   new FormControl('Nancy'),
 *   new FormControl('Drew')
 * ], {validators: myValidator, asyncValidators: myAsyncValidator});
 * ```
 *
 * ### Set the updateOn property for all controls in a form array
 *
 * The options object is used to set a default value for each child
 * control's `updateOn` property. If you set `updateOn` to `'blur'` at the
 * array level, all child controls default to 'blur', unless the child
 * has explicitly specified a different `updateOn` value.
 *
 * ```ts
 * const arr = new FormArray([
 *    new FormControl()
 * ], {updateOn: 'blur'});
 * ```
 *
 * ### Adding or removing controls from a form array
 *
 * To change the controls in the array, use the `push`, `insert`, `removeAt` or `clear` methods
 * in `FormArray` itself. These methods ensure the controls are properly tracked in the
 * form's hierarchy. Do not modify the array of `AbstractControl`s used to instantiate
 * the `FormArray` directly, as that result in strange and unexpected behavior such
 * as broken change detection.
 *
 * @publicApi
 */
class FormArray extends AbstractControl {
    /**
     * Creates a new `FormArray` instance.
     *
     * @param controls An array of child controls. Each child control is given an index
     * where it is registered.
     *
     * @param validatorOrOpts A synchronous validator function, or an array of
     * such functions, or an `AbstractControlOptions` object that contains validation functions
     * and a validation trigger.
     *
     * @param asyncValidator A single async validator or array of async validator functions
     *
     */
    constructor(controls, validatorOrOpts, asyncValidator) {
        super(pickValidators(validatorOrOpts), pickAsyncValidators(asyncValidator, validatorOrOpts));
        this.controls = controls;
        this._initObservables();
        this._setUpdateStrategy(validatorOrOpts);
        this._setUpControls();
        this.updateValueAndValidity({
            onlySelf: true,
            // If `asyncValidator` is present, it will trigger control status change from `PENDING` to
            // `VALID` or `INVALID`.
            // The status should be broadcasted via the `statusChanges` observable, so we set `emitEvent`
            // to `true` to allow that during the control creation process.
            emitEvent: !!this.asyncValidator
        });
    }
    /**
     * Get the `AbstractControl` at the given `index` in the array.
     *
     * @param index Index in the array to retrieve the control. If `index` is negative, it will wrap
     *     around from the back, and if index is greatly negative (less than `-length`), the result is
     * undefined. This behavior is the same as `Array.at(index)`.
     */
    at(index) {
        return this.controls[this._adjustIndex(index)];
    }
    /**
     * Insert a new `AbstractControl` at the end of the array.
     *
     * @param control Form control to be inserted
     * @param options Specifies whether this FormArray instance should emit events after a new
     *     control is added.
     * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and
     * `valueChanges` observables emit events with the latest status and value when the control is
     * inserted. When false, no events are emitted.
     */
    push(control, options = {}) {
        this.controls.push(control);
        this._registerControl(control);
        this.updateValueAndValidity({ emitEvent: options.emitEvent });
        this._onCollectionChange();
    }
    /**
     * Insert a new `AbstractControl` at the given `index` in the array.
     *
     * @param index Index in the array to insert the control. If `index` is negative, wraps around
     *     from the back. If `index` is greatly negative (less than `-length`), prepends to the array.
     * This behavior is the same as `Array.splice(index, 0, control)`.
     * @param control Form control to be inserted
     * @param options Specifies whether this FormArray instance should emit events after a new
     *     control is inserted.
     * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and
     * `valueChanges` observables emit events with the latest status and value when the control is
     * inserted. When false, no events are emitted.
     */
    insert(index, control, options = {}) {
        this.controls.splice(index, 0, control);
        this._registerControl(control);
        this.updateValueAndValidity({ emitEvent: options.emitEvent });
    }
    /**
     * Remove the control at the given `index` in the array.
     *
     * @param index Index in the array to remove the control.  If `index` is negative, wraps around
     *     from the back. If `index` is greatly negative (less than `-length`), removes the first
     *     element. This behavior is the same as `Array.splice(index, 1)`.
     * @param options Specifies whether this FormArray instance should emit events after a
     *     control is removed.
     * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and
     * `valueChanges` observables emit events with the latest status and value when the control is
     * removed. When false, no events are emitted.
     */
    removeAt(index, options = {}) {
        // Adjust the index, then clamp it at no less than 0 to prevent undesired underflows.
        let adjustedIndex = this._adjustIndex(index);
        if (adjustedIndex < 0)
            adjustedIndex = 0;
        if (this.controls[adjustedIndex])
            this.controls[adjustedIndex]._registerOnCollectionChange(() => { });
        this.controls.splice(adjustedIndex, 1);
        this.updateValueAndValidity({ emitEvent: options.emitEvent });
    }
    /**
     * Replace an existing control.
     *
     * @param index Index in the array to replace the control. If `index` is negative, wraps around
     *     from the back. If `index` is greatly negative (less than `-length`), replaces the first
     *     element. This behavior is the same as `Array.splice(index, 1, control)`.
     * @param control The `AbstractControl` control to replace the existing control
     * @param options Specifies whether this FormArray instance should emit events after an
     *     existing control is replaced with a new one.
     * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and
     * `valueChanges` observables emit events with the latest status and value when the control is
     * replaced with a new one. When false, no events are emitted.
     */
    setControl(index, control, options = {}) {
        // Adjust the index, then clamp it at no less than 0 to prevent undesired underflows.
        let adjustedIndex = this._adjustIndex(index);
        if (adjustedIndex < 0)
            adjustedIndex = 0;
        if (this.controls[adjustedIndex])
            this.controls[adjustedIndex]._registerOnCollectionChange(() => { });
        this.controls.splice(adjustedIndex, 1);
        if (control) {
            this.controls.splice(adjustedIndex, 0, control);
            this._registerControl(control);
        }
        this.updateValueAndValidity({ emitEvent: options.emitEvent });
        this._onCollectionChange();
    }
    /**
     * Length of the control array.
     */
    get length() {
        return this.controls.length;
    }
    /**
     * Sets the value of the `FormArray`. It accepts an array that matches
     * the structure of the control.
     *
     * This method performs strict checks, and throws an error if you try
     * to set the value of a control that doesn't exist or if you exclude the
     * value of a control.
     *
     * @usageNotes
     * ### Set the values for the controls in the form array
     *
     * ```
     * const arr = new FormArray([
     *   new FormControl(),
     *   new FormControl()
     * ]);
     * console.log(arr.value);   // [null, null]
     *
     * arr.setValue(['Nancy', 'Drew']);
     * console.log(arr.value);   // ['Nancy', 'Drew']
     * ```
     *
     * @param value Array of values for the controls
     * @param options Configure options that determine how the control propagates changes and
     * emits events after the value changes
     *
     * * `onlySelf`: When true, each change only affects this control, and not its parent. Default
     * is false.
     * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and
     * `valueChanges`
     * observables emit events with the latest status and value when the control value is updated.
     * When false, no events are emitted.
     * The configuration options are passed to the {@link AbstractControl#updateValueAndValidity
     * updateValueAndValidity} method.
     */
    setValue(value, options = {}) {
        assertAllValuesPresent(this, false, value);
        value.forEach((newValue, index) => {
            assertControlPresent(this, false, index);
            this.at(index).setValue(newValue, { onlySelf: true, emitEvent: options.emitEvent });
        });
        this.updateValueAndValidity(options);
    }
    /**
     * Patches the value of the `FormArray`. It accepts an array that matches the
     * structure of the control, and does its best to match the values to the correct
     * controls in the group.
     *
     * It accepts both super-sets and sub-sets of the array without throwing an error.
     *
     * @usageNotes
     * ### Patch the values for controls in a form array
     *
     * ```
     * const arr = new FormArray([
     *    new FormControl(),
     *    new FormControl()
     * ]);
     * console.log(arr.value);   // [null, null]
     *
     * arr.patchValue(['Nancy']);
     * console.log(arr.value);   // ['Nancy', null]
     * ```
     *
     * @param value Array of latest values for the controls
     * @param options Configure options that determine how the control propagates changes and
     * emits events after the value changes
     *
     * * `onlySelf`: When true, each change only affects this control, and not its parent. Default
     * is false.
     * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and
     * `valueChanges` observables emit events with the latest status and value when the control
     * value is updated. When false, no events are emitted. The configuration options are passed to
     * the {@link AbstractControl#updateValueAndValidity updateValueAndValidity} method.
     */
    patchValue(value, options = {}) {
        // Even though the `value` argument type doesn't allow `null` and `undefined` values, the
        // `patchValue` can be called recursively and inner data structures might have these values,
        // so we just ignore such cases when a field containing FormArray instance receives `null` or
        // `undefined` as a value.
        if (value == null /* both `null` and `undefined` */)
            return;
        value.forEach((newValue, index) => {
            if (this.at(index)) {
                this.at(index).patchValue(newValue, { onlySelf: true, emitEvent: options.emitEvent });
            }
        });
        this.updateValueAndValidity(options);
    }
    /**
     * Resets the `FormArray` and all descendants are marked `pristine` and `untouched`, and the
     * value of all descendants to null or null maps.
     *
     * You reset to a specific form state by passing in an array of states
     * that matches the structure of the control. The state is a standalone value
     * or a form state object with both a value and a disabled status.
     *
     * @usageNotes
     * ### Reset the values in a form array
     *
     * ```ts
     * const arr = new FormArray([
     *    new FormControl(),
     *    new FormControl()
     * ]);
     * arr.reset(['name', 'last name']);
     *
     * console.log(arr.value);  // ['name', 'last name']
     * ```
     *
     * ### Reset the values in a form array and the disabled status for the first control
     *
     * ```
     * arr.reset([
     *   {value: 'name', disabled: true},
     *   'last'
     * ]);
     *
     * console.log(arr.value);  // ['last']
     * console.log(arr.at(0).status);  // 'DISABLED'
     * ```
     *
     * @param value Array of values for the controls
     * @param options Configure options that determine how the control propagates changes and
     * emits events after the value changes
     *
     * * `onlySelf`: When true, each change only affects this control, and not its parent. Default
     * is false.
     * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and
     * `valueChanges`
     * observables emit events with the latest status and value when the control is reset.
     * When false, no events are emitted.
     * The configuration options are passed to the {@link AbstractControl#updateValueAndValidity
     * updateValueAndValidity} method.
     */
    reset(value = [], options = {}) {
        this._forEachChild((control, index) => {
            control.reset(value[index], { onlySelf: true, emitEvent: options.emitEvent });
        });
        this._updatePristine(options);
        this._updateTouched(options);
        this.updateValueAndValidity(options);
    }
    /**
     * The aggregate value of the array, including any disabled controls.
     *
     * Reports all values regardless of disabled status.
     */
    getRawValue() {
        return this.controls.map((control) => control.getRawValue());
    }
    /**
     * Remove all controls in the `FormArray`.
     *
     * @param options Specifies whether this FormArray instance should emit events after all
     *     controls are removed.
     * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and
     * `valueChanges` observables emit events with the latest status and value when all controls
     * in this FormArray instance are removed. When false, no events are emitted.
     *
     * @usageNotes
     * ### Remove all elements from a FormArray
     *
     * ```ts
     * const arr = new FormArray([
     *    new FormControl(),
     *    new FormControl()
     * ]);
     * console.log(arr.length);  // 2
     *
     * arr.clear();
     * console.log(arr.length);  // 0
     * ```
     *
     * It's a simpler and more efficient alternative to removing all elements one by one:
     *
     * ```ts
     * const arr = new FormArray([
     *    new FormControl(),
     *    new FormControl()
     * ]);
     *
     * while (arr.length) {
     *    arr.removeAt(0);
     * }
     * ```
     */
    clear(options = {}) {
        if (this.controls.length < 1)
            return;
        this._forEachChild((control) => control._registerOnCollectionChange(() => { }));
        this.controls.splice(0);
        this.updateValueAndValidity({ emitEvent: options.emitEvent });
    }
    /**
     * Adjusts a negative index by summing it with the length of the array. For very negative
     * indices, the result may remain negative.
     * @internal
     */
    _adjustIndex(index) {
        return index < 0 ? index + this.length : index;
    }
    /** @internal */
    _syncPendingControls() {
        let subtreeUpdated = this.controls.reduce((updated, child) => {
            return child._syncPendingControls() ? true : updated;
        }, false);
        if (subtreeUpdated)
            this.updateValueAndValidity({ onlySelf: true });
        return subtreeUpdated;
    }
    /** @internal */
    _forEachChild(cb) {
        this.controls.forEach((control, index) => {
            cb(control, index);
        });
    }
    /** @internal */
    _updateValue() {
        this.value =
            this.controls.filter((control) => control.enabled || this.disabled)
                .map((control) => control.value);
    }
    /** @internal */
    _anyControls(condition) {
        return this.controls.some((control) => control.enabled && condition(control));
    }
    /** @internal */
    _setUpControls() {
        this._forEachChild((control) => this._registerControl(control));
    }
    /** @internal */
    _allControlsDisabled() {
        for (const control of this.controls) {
            if (control.enabled)
                return false;
        }
        return this.controls.length > 0 || this.disabled;
    }
    _registerControl(control) {
        control.setParent(this);
        control._registerOnCollectionChange(this._onCollectionChange);
    }
    /** @internal */
    _find(name) {
        return this.at(name) ?? null;
    }
}
const UntypedFormArray = FormArray;
/**
 * @description
 * Asserts that the given control is an instance of `FormArray`
 *
 * @publicApi
 */
const isFormArray = (control) => control instanceof FormArray;

function isAbstractControlOptions(options) {
    return !!options &&
        (options.asyncValidators !== undefined ||
            options.validators !== undefined ||
            options.updateOn !== undefined);
}
// clang-format on
/**
 * @description
 * Creates an `AbstractControl` from a user-specified configuration.
 *
 * The `FormBuilder` provides syntactic sugar that shortens creating instances of a
 * `FormControl`, `FormGroup`, or `FormArray`. It reduces the amount of boilerplate needed to
 * build complex forms.
 *
 * @see [Reactive Forms Guide](guide/reactive-forms)
 *
 * @publicApi
 */
class FormBuilder {
    constructor() {
        this.useNonNullable = false;
    }
    /**
     * @description
     * Returns a FormBuilder in which automatically constructed `FormControl` elements
     * have `{nonNullable: true}` and are non-nullable.
     *
     * **Constructing non-nullable controls**
     *
     * When constructing a control, it will be non-nullable, and will reset to its initial value.
     *
     * ```ts
     * let nnfb = new FormBuilder().nonNullable;
     * let name = nnfb.control('Alex'); // FormControl<string>
     * name.reset();
     * console.log(name); // 'Alex'
     * ```
     *
     * **Constructing non-nullable groups or arrays**
     *
     * When constructing a group or array, all automatically created inner controls will be
     * non-nullable, and will reset to their initial values.
     *
     * ```ts
     * let nnfb = new FormBuilder().nonNullable;
     * let name = nnfb.group({who: 'Alex'}); // FormGroup<{who: FormControl<string>}>
     * name.reset();
     * console.log(name); // {who: 'Alex'}
     * ```
     * **Constructing *nullable* fields on groups or arrays**
     *
     * It is still possible to have a nullable field. In particular, any `FormControl` which is
     * *already* constructed will not be altered. For example:
     *
     * ```ts
     * let nnfb = new FormBuilder().nonNullable;
     * // FormGroup<{who: FormControl<string|null>}>
     * let name = nnfb.group({who: new FormControl('Alex')});
     * name.reset(); console.log(name); // {who: null}
     * ```
     *
     * Because the inner control is constructed explicitly by the caller, the builder has
     * no control over how it is created, and cannot exclude the `null`.
     */
    get nonNullable() {
        const nnfb = new FormBuilder();
        nnfb.useNonNullable = true;
        return nnfb;
    }
    group(controls, options = null) {
        const reducedControls = this._reduceControls(controls);
        let newOptions = {};
        if (isAbstractControlOptions(options)) {
            // `options` are `AbstractControlOptions`
            newOptions = options;
        }
        else if (options !== null) {
            // `options` are legacy form group options
            newOptions.validators = options.validator;
            newOptions.asyncValidators = options.asyncValidator;
        }
        return new FormGroup(reducedControls, newOptions);
    }
    /**
     * @description
     * Constructs a new `FormRecord` instance. Accepts a single generic argument, which is an object
     * containing all the keys and corresponding inner control types.
     *
     * @param controls A collection of child controls. The key for each child is the name
     * under which it is registered.
     *
     * @param options Configuration options object for the `FormRecord`. The object should have the
     * `AbstractControlOptions` type and might contain the following fields:
     * * `validators`: A synchronous validator function, or an array of validator functions.
     * * `asyncValidators`: A single async validator or array of async validator functions.
     * * `updateOn`: The event upon which the control should be updated (options: 'change' | 'blur'
     * | submit').
     */
    record(controls, options = null) {
        const reducedControls = this._reduceControls(controls);
        // Cast to `any` because the inferred types are not as specific as Element.
        return new FormRecord(reducedControls, options);
    }
    /**
     * @description
     * Constructs a new `FormControl` with the given state, validators and options. Sets
     * `{nonNullable: true}` in the options to get a non-nullable control. Otherwise, the
     * control will be nullable. Accepts a single generic argument, which is the type  of the
     * control's value.
     *
     * @param formState Initializes the control with an initial state value, or
     * with an object that contains both a value and a disabled status.
     *
     * @param validatorOrOpts A synchronous validator function, or an array of
     * such functions, or a `FormControlOptions` object that contains
     * validation functions and a validation trigger.
     *
     * @param asyncValidator A single async validator or array of async validator
     * functions.
     *
     * @usageNotes
     *
     * ### Initialize a control as disabled
     *
     * The following example returns a control with an initial value in a disabled state.
     *
     * <code-example path="forms/ts/formBuilder/form_builder_example.ts" region="disabled-control">
     * </code-example>
     */
    control(formState, validatorOrOpts, asyncValidator) {
        let newOptions = {};
        if (!this.useNonNullable) {
            return new FormControl(formState, validatorOrOpts, asyncValidator);
        }
        if (isAbstractControlOptions(validatorOrOpts)) {
            // If the second argument is options, then they are copied.
            newOptions = validatorOrOpts;
        }
        else {
            // If the other arguments are validators, they are copied into an options object.
            newOptions.validators = validatorOrOpts;
            newOptions.asyncValidators = asyncValidator;
        }
        return new FormControl(formState, { ...newOptions, nonNullable: true });
    }
    /**
     * Constructs a new `FormArray` from the given array of configurations,
     * validators and options. Accepts a single generic argument, which is the type of each control
     * inside the array.
     *
     * @param controls An array of child controls or control configs. Each child control is given an
     *     index when it is registered.
     *
     * @param validatorOrOpts A synchronous validator function, or an array of such functions, or an
     *     `AbstractControlOptions` object that contains
     * validation functions and a validation trigger.
     *
     * @param asyncValidator A single async validator or array of async validator functions.
     */
    array(controls, validatorOrOpts, asyncValidator) {
        const createdControls = controls.map(c => this._createControl(c));
        // Cast to `any` because the inferred types are not as specific as Element.
        return new FormArray(createdControls, validatorOrOpts, asyncValidator);
    }
    /** @internal */
    _reduceControls(controls) {
        const createdControls = {};
        Object.keys(controls).forEach(controlName => {
            createdControls[controlName] = this._createControl(controls[controlName]);
        });
        return createdControls;
    }
    /** @internal */
    _createControl(controls) {
        if (controls instanceof FormControl) {
            return controls;
        }
        else if (controls instanceof AbstractControl) { // A control; just return it
            return controls;
        }
        else if (Array.isArray(controls)) { // ControlConfig Tuple
            const value = controls[0];
            const validator = controls.length > 1 ? controls[1] : null;
            const asyncValidator = controls.length > 2 ? controls[2] : null;
            return this.control(value, validator, asyncValidator);
        }
        else { // T or FormControlState<T>
            return this.control(controls);
        }
    }
    static { this.fac = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareFactory"]({ minVersion: "12.0.0", version: "17.3.12", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: FormBuilder, deps: [], target: _angular_core__WEBPACK_IMPORTED_MODULE_0__["FactoryTarget"].Injectable }); }
    static { this.prov = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareInjectable"]({ minVersion: "12.0.0", version: "17.3.12", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: FormBuilder, providedIn: 'root' }); }
}
_angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareClassMetadata"]({ minVersion: "12.0.0", version: "17.3.12", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: FormBuilder, decorators: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Injectable,
            args: [{ providedIn: 'root' }]
        }] });
/**
 * @description
 * `NonNullableFormBuilder` is similar to {@link FormBuilder}, but automatically constructed
 * {@link FormControl} elements have `{nonNullable: true}` and are non-nullable.
 *
 * @publicApi
 */
class NonNullableFormBuilder {
    static { this.fac = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareFactory"]({ minVersion: "12.0.0", version: "17.3.12", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: NonNullableFormBuilder, deps: [], target: _angular_core__WEBPACK_IMPORTED_MODULE_0__["FactoryTarget"].Injectable }); }
    static { this.prov = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareInjectable"]({ minVersion: "12.0.0", version: "17.3.12", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: NonNullableFormBuilder, providedIn: 'root', useFactory: () => (0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.inject)(FormBuilder).nonNullable }); }
}
_angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareClassMetadata"]({ minVersion: "12.0.0", version: "17.3.12", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: NonNullableFormBuilder, decorators: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Injectable,
            args: [{
                    providedIn: 'root',
                    useFactory: () => (0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.inject)(FormBuilder).nonNullable,
                }]
        }] });
/**
 * UntypedFormBuilder is the same as `FormBuilder`, but it provides untyped controls.
 */
class UntypedFormBuilder extends FormBuilder {
    group(controlsConfig, options = null) {
        return super.group(controlsConfig, options);
    }
    /**
     * Like `FormBuilder#control`, except the resulting control is untyped.
     */
    control(formState, validatorOrOpts, asyncValidator) {
        return super.control(formState, validatorOrOpts, asyncValidator);
    }
    /**
     * Like `FormBuilder#array`, except the resulting array is untyped.
     */
    array(controlsConfig, validatorOrOpts, asyncValidator) {
        return super.array(controlsConfig, validatorOrOpts, asyncValidator);
    }
    static { this.fac = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareFactory"]({ minVersion: "12.0.0", version: "17.3.12", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: UntypedFormBuilder, deps: null, target: _angular_core__WEBPACK_IMPORTED_MODULE_0__["FactoryTarget"].Injectable }); }
    static { this.prov = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareInjectable"]({ minVersion: "12.0.0", version: "17.3.12", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: UntypedFormBuilder, providedIn: 'root' }); }
}
_angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareClassMetadata"]({ minVersion: "12.0.0", version: "17.3.12", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: UntypedFormBuilder, decorators: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Injectable,
            args: [{ providedIn: 'root' }]
        }] });

/**
 * @module
 * @description
 * Entry point for all public APIs of the forms package.
 */
/**
 * @publicApi
 */
const VERSION = new _angular_core__WEBPACK_IMPORTED_MODULE_0__.Version('17.3.12');

/**
 * Exports the required providers and directives for template-driven forms,
 * making them available for import by NgModules that import this module.
 *
 * @see [Forms Overview](/guide/forms-overview)
 * @see [Template-driven Forms Guide](/guide/forms)
 *
 * @publicApi
 */
class FormsModule {
    /**
     * @description
     * Provides options for configuring the forms module.
     *
     * @param opts An object of configuration options
     * * `callSetDisabledState` Configures whether to `always` call `setDisabledState`, which is more
     * correct, or to only call it `whenDisabled`, which is the legacy behavior.
     */
    static withConfig(opts) {
        return {
            ngModule: FormsModule,
            providers: [{
                    provide: CALL_SET_DISABLED_STATE,
                    useValue: opts.callSetDisabledState ?? setDisabledStateDefault
                }]
        };
    }
    static { this.fac = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareFactory"]({ minVersion: "12.0.0", version: "17.3.12", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: FormsModule, deps: [], target: _angular_core__WEBPACK_IMPORTED_MODULE_0__["FactoryTarget"].NgModule }); }
    static { this.mod = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareNgModule"]({ minVersion: "14.0.0", version: "17.3.12", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: FormsModule, declarations: [NgModel, NgModelGroup, NgForm], exports: [InternalFormsSharedModule, NgModel, NgModelGroup, NgForm] }); }
    static { this.inj = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareInjector"]({ minVersion: "12.0.0", version: "17.3.12", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: FormsModule, imports: [InternalFormsSharedModule] }); }
}
_angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareClassMetadata"]({ minVersion: "12.0.0", version: "17.3.12", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: FormsModule, decorators: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.NgModule,
            args: [{
                    declarations: TEMPLATE_DRIVEN_DIRECTIVES,
                    exports: [InternalFormsSharedModule, TEMPLATE_DRIVEN_DIRECTIVES]
                }]
        }] });
/**
 * Exports the required infrastructure and directives for reactive forms,
 * making them available for import by NgModules that import this module.
 *
 * @see [Forms Overview](guide/forms-overview)
 * @see [Reactive Forms Guide](guide/reactive-forms)
 *
 * @publicApi
 */
class ReactiveFormsModule {
    /**
     * @description
     * Provides options for configuring the reactive forms module.
     *
     * @param opts An object of configuration options
     * * `warnOnNgModelWithFormControl` Configures when to emit a warning when an `ngModel`
     * binding is used with reactive form directives.
     * * `callSetDisabledState` Configures whether to `always` call `setDisabledState`, which is more
     * correct, or to only call it `whenDisabled`, which is the legacy behavior.
     */
    static withConfig(opts) {
        return {
            ngModule: ReactiveFormsModule,
            providers: [
                {
                    provide: NG_MODEL_WITH_FORM_CONTROL_WARNING,
                    useValue: opts.warnOnNgModelWithFormControl ?? 'always'
                },
                {
                    provide: CALL_SET_DISABLED_STATE,
                    useValue: opts.callSetDisabledState ?? setDisabledStateDefault
                }
            ]
        };
    }
    static { this.fac = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareFactory"]({ minVersion: "12.0.0", version: "17.3.12", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: ReactiveFormsModule, deps: [], target: _angular_core__WEBPACK_IMPORTED_MODULE_0__["FactoryTarget"].NgModule }); }
    static { this.mod = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareNgModule"]({ minVersion: "14.0.0", version: "17.3.12", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: ReactiveFormsModule, declarations: [FormControlDirective, FormGroupDirective, FormControlName, FormGroupName, FormArrayName], exports: [InternalFormsSharedModule, FormControlDirective, FormGroupDirective, FormControlName, FormGroupName, FormArrayName] }); }
    static { this.inj = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareInjector"]({ minVersion: "12.0.0", version: "17.3.12", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: ReactiveFormsModule, imports: [InternalFormsSharedModule] }); }
}
_angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareClassMetadata"]({ minVersion: "12.0.0", version: "17.3.12", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: ReactiveFormsModule, decorators: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.NgModule,
            args: [{
                    declarations: [REACTIVE_DRIVEN_DIRECTIVES],
                    exports: [InternalFormsSharedModule, REACTIVE_DRIVEN_DIRECTIVES]
                }]
        }] });

/**
 * @module
 * @description
 * This module is used for handling user input, by defining and building a `FormGroup` that
 * consists of `FormControl` objects, and mapping them onto the DOM. `FormControl`
 * objects can then be used to read information from the form DOM elements.
 *
 * Forms providers are not included in default providers; you must import these providers
 * explicitly.
 */

/**
 * @module
 * @description
 * Entry point for all public APIs of this package.
 */
// This file only reexports content of the `src` folder. Keep it that way.

// This file is not used to build this module. It is only used during editing

/**
 * Generated bundle index. Do not edit.
 */


//# sourceMappingURL=forms.mjs.map


/***/ }),

/***/ "../../../node_modules/carbon-components-angular/fesm2020/carbon-components-angular-checkbox.mjs":
/*!*******************************************************************************************************!*\
  !*** ../../../node_modules/carbon-components-angular/fesm2020/carbon-components-angular-checkbox.mjs ***!
  \*******************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

var _angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache;
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Checkbox: () => (/* binding */ Checkbox),
/* harmony export */   CheckboxModule: () => (/* binding */ CheckboxModule),
/* harmony export */   CheckboxState: () => (/* binding */ CheckboxState)
/* harmony export */ });
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @angular/core */ "@angular/core");
/* harmony import */ var _angular_forms__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @angular/forms */ "../../../node_modules/@angular/forms/fesm2022/forms.mjs");
/* harmony import */ var _angular_common__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @angular/common */ "@angular/common");






/**
 * Defines the set of states for a checkbox component.
 */
var CheckboxState;
(function (CheckboxState) {
    CheckboxState[CheckboxState["Init"] = 0] = "Init";
    CheckboxState[CheckboxState["Indeterminate"] = 1] = "Indeterminate";
    CheckboxState[CheckboxState["Checked"] = 2] = "Checked";
    CheckboxState[CheckboxState["Unchecked"] = 3] = "Unchecked";
})(CheckboxState || (CheckboxState = {}));
/**
 * Get started with importing the module:
 *
 * ```typescript
 * import { CheckboxModule } from 'carbon-components-angular';
 * ```
 *
 * [See demo](../../?path=/story/components-checkbox--basic)
 */
class Checkbox {
    /**
     * Creates an instance of `Checkbox`.
     */
    constructor(changeDetectorRef) {
        this.changeDetectorRef = changeDetectorRef;
        /**
         * Set to `true` for a disabled checkbox.
         */
        this.disabled = false;
        /**
         * Set to `true` for a loading checkbox.
         */
        this.skeleton = false;
        /**
         * Set to `true` to hide the checkbox labels.
         */
        this.hideLabel = false;
        /**
         * The unique id for the checkbox component.
         */
        this.id = `checkbox-${Checkbox.checkboxCount}`;
        /**
         * Emits click event.
         */
        this.click = new _angular_core__WEBPACK_IMPORTED_MODULE_0__.EventEmitter();
        /**
         * Emits an event when the value of the checkbox changes.
         *
         * Allows double biding with the `checked` Input.
         */
        this.checkedChange = new _angular_core__WEBPACK_IMPORTED_MODULE_0__.EventEmitter();
        /**
         * Emits event notifying other classes when a change in state occurs specifically
         * on an indeterminate checkbox.
         */
        this.indeterminateChange = new _angular_core__WEBPACK_IMPORTED_MODULE_0__.EventEmitter();
        /**
         * Set to `true` if the input checkbox is selected (or checked).
         */
        this._checked = false;
        /**
         * Set to `true` if the input checkbox is in state indeterminate.
         */
        this._indeterminate = false;
        /**
         * Keeps a reference to the checkboxes current state, as defined in `CheckboxState`.
         */
        this.currentCheckboxState = CheckboxState.Init;
        /**
         * Called when checkbox is blurred. Needed to properly implement `ControlValueAccessor`.
         */
        this.onTouched = () => { };
        /**
         * Method set in `registerOnChange` to propagate changes back to the form.
         */
        this.propagateChange = (_) => { };
        Checkbox.checkboxCount++;
    }
    /**
     * Set the checkbox's indeterminate state to match the parameter and transition the view to reflect the change.
     *
     * Allows double binding with the `indeterminateChange` Output.
     */
    set indeterminate(indeterminate) {
        if (indeterminate === this._indeterminate) {
            return;
        }
        this._indeterminate = indeterminate;
        if (this._indeterminate) {
            this.transitionCheckboxState(CheckboxState.Indeterminate);
        }
        else {
            this.transitionCheckboxState(this.checked ? CheckboxState.Checked : CheckboxState.Unchecked);
        }
        if (this.inputCheckbox && this.inputCheckbox.nativeElement) {
            this.inputCheckbox.nativeElement.indeterminate = indeterminate;
        }
        this.changeDetectorRef.markForCheck();
        this.indeterminateChange.emit(this._indeterminate);
    }
    /**
     * Reflects whether the checkbox state is indeterminate.
     */
    get indeterminate() {
        return this._indeterminate;
    }
    /**
     * Sets the `checked` state. `true` for checked, `false` for unchecked
     *
     * Allows double binding with the `checkedChange` Output.
     */
    set checked(checked) {
        this.setChecked(checked, false);
    }
    /**
     * Returns value `true` if state is selected for the checkbox.
     */
    get checked() {
        return this._checked;
    }
    /**
     * Toggle the selected state of the checkbox.
     */
    toggle() {
        // Flip checked and reset indeterminate
        this.setChecked(!this.checked, true);
    }
    /**
     * Writes a value from `ngModel` to the component.
     *
     * In this case the value is the `checked` property.
     *
     * @param value boolean, corresponds to the `checked` property.
     */
    writeValue(value) {
        // Set checked and reset indeterminate
        this.setChecked(!!value, true);
    }
    /**
     * Sets a method in order to propagate changes back to the form.
     */
    registerOnChange(fn) {
        this.propagateChange = fn;
    }
    /**
     * Registers a callback to be triggered when the control has been touched.
     * @param fn Callback to be triggered when the checkbox is touched.
     */
    registerOnTouched(fn) {
        this.onTouched = fn;
    }
    /**
     * `ControlValueAccessor` method to programmatically disable the checkbox.
     *
     * ex: `this.formGroup.get("myCheckbox").disable();`
     *
     * @param isDisabled `true` to disable the checkbox
     */
    setDisabledState(isDisabled) {
        this.disabled = isDisabled;
        this.changeDetectorRef.markForCheck();
    }
    focusOut() {
        this.onTouched();
    }
    /**
     * Executes on the event of a change within `Checkbox` to block propagation.
     */
    onChange(event) {
        event.stopPropagation();
    }
    /**
     * Handles click events on the `Checkbox` and emits changes to other classes.
     */
    onClick(event) {
        if (this.click.observers.length) {
            // Disable default checkbox activation behavior which flips checked and resets indeterminate.
            // This allows the parent component to control the checked/indeterminate properties.
            event.preventDefault();
            this.click.emit();
            return;
        }
        if (!this.disabled) {
            this.toggle();
            this.transitionCheckboxState(this._checked ? CheckboxState.Checked : CheckboxState.Unchecked);
            this.emitChangeEvent();
        }
    }
    /**
     * Handles changes between checkbox states.
     */
    transitionCheckboxState(newState) {
        this.currentCheckboxState = newState;
    }
    /**
     * Creates instance of `CheckboxChange` used to propagate the change event.
     */
    emitChangeEvent() {
        this.checkedChange.emit(this.checked);
        this.propagateChange(this.checked);
    }
    /**
     * Updates the checkbox if it is in the indeterminate state.
     */
    ngAfterViewInit() {
        if (this.indeterminate && this.inputCheckbox && this.inputCheckbox.nativeElement) {
            this.inputCheckbox.nativeElement.indeterminate = true;
        }
    }
    /**
     * Sets checked state and optionally resets indeterminate state.
     */
    setChecked(checked, resetIndeterminate) {
        if (checked === this._checked) {
            return;
        }
        this._checked = checked;
        // Reset indeterminate if requested
        if (resetIndeterminate && this._indeterminate) {
            this._indeterminate = false;
            Promise.resolve().then(() => {
                this.indeterminateChange.emit(this._indeterminate);
            });
        }
        this.changeDetectorRef.markForCheck();
    }
}
/**
 * Variable used for creating unique ids for checkbox components.
 */
Checkbox.checkboxCount = 0;
Checkbox.fac = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareFactory"]({ minVersion: "12.0.0", version: "14.3.0", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: Checkbox, deps: [{ token: _angular_core__WEBPACK_IMPORTED_MODULE_0__.ChangeDetectorRef }], target: _angular_core__WEBPACK_IMPORTED_MODULE_0__["FactoryTarget"].Component });
Checkbox.cmp = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareComponent"]({ minVersion: "14.0.0", version: "14.3.0", type: Checkbox, selector: "cds-checkbox, ibm-checkbox", inputs: { disabled: "disabled", skeleton: "skeleton", hideLabel: "hideLabel", name: "name", id: "id", required: "required", value: "value", ariaLabel: "ariaLabel", ariaLabelledby: "ariaLabelledby", indeterminate: "indeterminate", checked: "checked" }, outputs: { click: "click", checkedChange: "checkedChange", indeterminateChange: "indeterminateChange" }, host: { listeners: { "focusout": "focusOut()" } }, providers: [
        {
            provide: _angular_forms__WEBPACK_IMPORTED_MODULE_2__.NG_VALUE_ACCESSOR,
            useExisting: Checkbox,
            multi: true
        }
    ], viewQueries: [{ propertyName: "inputCheckbox", first: true, predicate: ["inputCheckbox"], descendants: true }], ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), template: `
		<div class="cds--form-item cds--checkbox-wrapper">
			<input
				#inputCheckbox
				class="cds--checkbox"
				type="checkbox"
				[id]="id + '_input'"
				[value]="value"
				[name]="name"
				[required]="required"
				[checked]="checked"
				[disabled]="disabled"
				[attr.aria-labelledby]="ariaLabelledby"
				(change)="onChange($event)"
				(click)="onClick($event)">
			<label
				[for]="id + '_input'"
				[attr.aria-label]="ariaLabel"
				class="cds--checkbox-label"
				[ngClass]="{
					'cds--skeleton' : skeleton
				}">
				<span [ngClass]="{'cds--visually-hidden' : hideLabel}" class="cds--checkbox-label-text">
					<ng-content></ng-content>
				</span>
			</label>
		</div>
	`, isInline: true, dependencies: [{ kind: "directive", type: _angular_common__WEBPACK_IMPORTED_MODULE_1__.NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }], changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_0__.ChangeDetectionStrategy.OnPush });
_angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareClassMetadata"]({ minVersion: "12.0.0", version: "14.3.0", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: Checkbox, decorators: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Component,
            args: [{
                    selector: "cds-checkbox, ibm-checkbox",
                    template: `
		<div class="cds--form-item cds--checkbox-wrapper">
			<input
				#inputCheckbox
				class="cds--checkbox"
				type="checkbox"
				[id]="id + '_input'"
				[value]="value"
				[name]="name"
				[required]="required"
				[checked]="checked"
				[disabled]="disabled"
				[attr.aria-labelledby]="ariaLabelledby"
				(change)="onChange($event)"
				(click)="onClick($event)">
			<label
				[for]="id + '_input'"
				[attr.aria-label]="ariaLabel"
				class="cds--checkbox-label"
				[ngClass]="{
					'cds--skeleton' : skeleton
				}">
				<span [ngClass]="{'cds--visually-hidden' : hideLabel}" class="cds--checkbox-label-text">
					<ng-content></ng-content>
				</span>
			</label>
		</div>
	`,
                    providers: [
                        {
                            provide: _angular_forms__WEBPACK_IMPORTED_MODULE_2__.NG_VALUE_ACCESSOR,
                            useExisting: Checkbox,
                            multi: true
                        }
                    ],
                    changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_0__.ChangeDetectionStrategy.OnPush
                }]
        }], ctorParameters: function () { return [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.ChangeDetectorRef }]; }, propDecorators: { disabled: [{
                type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input
            }], skeleton: [{
                type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input
            }], hideLabel: [{
                type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input
            }], name: [{
                type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input
            }], id: [{
                type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input
            }], required: [{
                type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input
            }], value: [{
                type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input
            }], ariaLabel: [{
                type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input
            }], ariaLabelledby: [{
                type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input
            }], indeterminate: [{
                type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input
            }], checked: [{
                type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input
            }], click: [{
                type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Output
            }], checkedChange: [{
                type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Output
            }], indeterminateChange: [{
                type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Output
            }], inputCheckbox: [{
                type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.ViewChild,
                args: ["inputCheckbox"]
            }], focusOut: [{
                type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.HostListener,
                args: ["focusout"]
            }] } });

// modules
class CheckboxModule {
}
CheckboxModule.fac = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareFactory"]({ minVersion: "12.0.0", version: "14.3.0", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: CheckboxModule, deps: [], target: _angular_core__WEBPACK_IMPORTED_MODULE_0__["FactoryTarget"].NgModule });
CheckboxModule.mod = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareNgModule"]({ minVersion: "14.0.0", version: "14.3.0", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: CheckboxModule, declarations: [Checkbox], imports: [_angular_common__WEBPACK_IMPORTED_MODULE_1__.CommonModule,
        _angular_forms__WEBPACK_IMPORTED_MODULE_2__.FormsModule], exports: [Checkbox] });
CheckboxModule.inj = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareInjector"]({ minVersion: "12.0.0", version: "14.3.0", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: CheckboxModule, imports: [_angular_common__WEBPACK_IMPORTED_MODULE_1__.CommonModule,
        _angular_forms__WEBPACK_IMPORTED_MODULE_2__.FormsModule] });
_angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareClassMetadata"]({ minVersion: "12.0.0", version: "14.3.0", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: CheckboxModule, decorators: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.NgModule,
            args: [{
                    declarations: [
                        Checkbox
                    ],
                    exports: [
                        Checkbox
                    ],
                    imports: [
                        _angular_common__WEBPACK_IMPORTED_MODULE_1__.CommonModule,
                        _angular_forms__WEBPACK_IMPORTED_MODULE_2__.FormsModule
                    ]
                }]
        }] });

/**
 * Generated bundle index. Do not edit.
 */


//# sourceMappingURL=carbon-components-angular-checkbox.mjs.map


/***/ }),

/***/ "../../../node_modules/carbon-components-angular/fesm2020/carbon-components-angular-dropdown.mjs":
/*!*******************************************************************************************************!*\
  !*** ../../../node_modules/carbon-components-angular/fesm2020/carbon-components-angular-dropdown.mjs ***!
  \*******************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

var _angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache;
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AbstractDropdownView: () => (/* binding */ AbstractDropdownView),
/* harmony export */   Dropdown: () => (/* binding */ Dropdown),
/* harmony export */   DropdownList: () => (/* binding */ DropdownList),
/* harmony export */   DropdownModule: () => (/* binding */ DropdownModule),
/* harmony export */   DropdownService: () => (/* binding */ DropdownService),
/* harmony export */   ScrollableList: () => (/* binding */ ScrollableList)
/* harmony export */ });
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @angular/core */ "@angular/core");
/* harmony import */ var _angular_forms__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @angular/forms */ "../../../node_modules/@angular/forms/fesm2022/forms.mjs");
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! rxjs */ "rxjs");
/* harmony import */ var carbon_components_angular_utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! carbon-components-angular/utils */ "../../../node_modules/carbon-components-angular/fesm2020/carbon-components-angular-utils.mjs");
/* harmony import */ var carbon_components_angular_i18n__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! carbon-components-angular/i18n */ "../../../node_modules/carbon-components-angular/fesm2020/carbon-components-angular-i18n.mjs");
/* harmony import */ var _carbon_utils_position__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @carbon/utils-position */ "../../../node_modules/carbon-components-angular/node_modules/@carbon/utils-position/index.js");
/* harmony import */ var carbon_components_angular_placeholder__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! carbon-components-angular/placeholder */ "../../../node_modules/carbon-components-angular/fesm2020/carbon-components-angular-placeholder.mjs");
/* harmony import */ var _angular_common__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @angular/common */ "@angular/common");
/* harmony import */ var carbon_components_angular_icon__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! carbon-components-angular/icon */ "../../../node_modules/carbon-components-angular/fesm2020/carbon-components-angular-icon.mjs");
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! rxjs/operators */ "../../../node_modules/rxjs/dist/esm5/internal/operators/debounceTime.js");
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! rxjs/operators */ "../../../node_modules/rxjs/dist/esm5/internal/operators/map.js");
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! rxjs/operators */ "../../../node_modules/rxjs/dist/esm5/internal/operators/filter.js");
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! rxjs/operators */ "../../../node_modules/rxjs/dist/esm5/internal/operators/first.js");

















/**
 * A component that intends to be used within `Dropdown` must provide an implementation that extends this base class.
 * It also must provide the base class in the `@Component` meta-data.
 * ex: `providers: [{provide: AbstractDropdownView, useExisting: forwardRef(() => MyDropdownView)}]`
 */
class AbstractDropdownView {
    constructor() {
        /**
         * Specifies whether or not the `DropdownList` supports selecting multiple items as opposed to single
         * item selection.
         */
        this.type = "single";
        /**
         * Specifies the render size of the items within the `AbstractDropdownView`.
         */
        this.size = "md";
    }
    /**
     * The items to be displayed in the list within the `AbstractDropDownView`.
     */
    set items(value) { }
    get items() { return; }
    /**
     * Returns the `ListItem` that is subsequent to the selected item in the `DropdownList`.
     */
    getNextItem() { return; }
    /**
     * Returns a boolean if the currently selected item is preceded by another
     */
    hasNextElement() { return; }
    /**
     * Returns the `HTMLElement` for the item that is subsequent to the selected item.
     */
    getNextElement() { return; }
    /**
     * Returns the `ListItem` that precedes the selected item within `DropdownList`.
     */
    getPrevItem() { return; }
    /**
     * Returns a boolean if the currently selected item is followed by another
     */
    hasPrevElement() { return; }
    /**
     * Returns the `HTMLElement` for the item that precedes the selected item.
     */
    getPrevElement() { return; }
    /**
     * Returns the selected leaf level item(s) within the `DropdownList`.
     */
    getSelected() { return; }
    /**
     * Returns the `ListItem` that is selected within `DropdownList`.
     */
    getCurrentItem() { return; }
    /**
     * Returns the `HTMLElement` for the item that is selected within the `DropdownList`.
     */
    getCurrentElement() { return; }
    /**
     * Guaranteed to return the current items as an Array.
     */
    getListItems() { return; }
    /**
     * Transforms array input list of items to the correct state by updating the selected item(s).
     */
    propagateSelected(value) { }
    /**
     *
     * @param value value to filter the list by
     */
    filterBy(value) { }
    /**
     * Initializes focus in the list
     * In most cases this just calls `getCurrentElement().focus()`
     */
    initFocus() { }
    /**
     * Subscribe the function passed to an internal observable that will resolve once the items are ready
     */
    onItemsReady(subcription) { }
    /**
     * Reorder selected items bringing them to the top of the list
     */
    reorderSelected(moveFocus) { }
}
AbstractDropdownView.fac = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareFactory"]({ minVersion: "12.0.0", version: "14.3.0", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: AbstractDropdownView, deps: [], target: _angular_core__WEBPACK_IMPORTED_MODULE_0__["FactoryTarget"].Directive });
AbstractDropdownView.dir = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareDirective"]({ minVersion: "14.0.0", version: "14.3.0", type: AbstractDropdownView, selector: "[cdsAbstractDropdownView], [ibmAbstractDropdownView]", inputs: { items: "items" }, outputs: { select: "select", blurIntent: "blurIntent" }, ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))) });
_angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareClassMetadata"]({ minVersion: "12.0.0", version: "14.3.0", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: AbstractDropdownView, decorators: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Directive,
            args: [{
                    selector: "[cdsAbstractDropdownView], [ibmAbstractDropdownView]"
                }]
        }], propDecorators: { items: [{
                type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input
            }], select: [{
                type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Output
            }], blurIntent: [{
                type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Output
            }] } });

const defaultOffset = { top: 0, left: 0 };
class DropdownService {
    constructor(placeholderService, animationFrameService) {
        this.placeholderService = placeholderService;
        this.animationFrameService = animationFrameService;
        /**
         * Maintains an Event Observable Subscription for the global requestAnimationFrame.
         * requestAnimationFrame is tracked only if the `Dropdown` is appended to the body otherwise we don't need it
         */
        this.animationFrameSubscription = new rxjs__WEBPACK_IMPORTED_MODULE_1__.Subscription();
        this._offset = defaultOffset;
    }
    set offset(value) {
        this._offset = Object.assign({}, defaultOffset, value);
    }
    get offset() {
        return this._offset;
    }
    /**
     * Appends the menu to the body, or a `cds-placeholder` (if defined)
     *
     * @param parentRef container to position relative to
     * @param menuRef menu to be appended to body
     * @param classList any extra classes we should wrap the container with
     */
    appendToBody(parentRef, menuRef, classList) {
        // build the dropdown list container
        menuRef.style.display = "block";
        const dropdownWrapper = document.createElement("div");
        dropdownWrapper.className = `dropdown ${classList}`;
        dropdownWrapper.style.width = parentRef.offsetWidth + "px";
        dropdownWrapper.style.position = "absolute";
        dropdownWrapper.appendChild(menuRef);
        // append it to the placeholder
        if (this.placeholderService.hasPlaceholderRef()) {
            this.placeholderService.appendElement(dropdownWrapper);
            // or append it directly to the body
        }
        else {
            document.body.appendChild(dropdownWrapper);
        }
        this.menuInstance = dropdownWrapper;
        this.animationFrameSubscription = this.animationFrameService.tick.subscribe(() => {
            this.positionDropdown(parentRef, dropdownWrapper);
        });
        // run one position in sync, so we're less likely to have the view "jump" as we focus
        this.positionDropdown(parentRef, dropdownWrapper);
        return dropdownWrapper;
    }
    /**
     * Reattach the dropdown menu to the parent container
     * @param hostRef container to append to
     */
    appendToDropdown(hostRef) {
        // if the instance is already removed don't try and remove it again
        if (!this.menuInstance) {
            return;
        }
        const instance = this.menuInstance;
        const menu = instance.firstElementChild;
        // clean up the instance
        this.menuInstance = null;
        menu.style.display = "none";
        hostRef.appendChild(menu);
        this.animationFrameSubscription.unsubscribe();
        if (this.placeholderService.hasPlaceholderRef() && this.placeholderService.hasElement(instance)) {
            this.placeholderService.removeElement(instance);
        }
        else if (document.body.contains(instance)) {
            document.body.removeChild(instance);
        }
        return instance;
    }
    /**
     * position an open dropdown relative to the given parentRef
     */
    updatePosition(parentRef) {
        this.positionDropdown(parentRef, this.menuInstance);
    }
    ngOnDestroy() {
        this.animationFrameSubscription.unsubscribe();
    }
    positionDropdown(parentRef, menuRef) {
        if (!menuRef) {
            return;
        }
        let leftOffset = 0;
        const boxMenu = menuRef.querySelector(".cds--list-box__menu");
        if (boxMenu) {
            // If the parentRef and boxMenu are in a different left position relative to the
            // window, the the boxMenu position has already been flipped and a check needs to be done
            // to see if it needs to stay flipped.
            if (parentRef.getBoundingClientRect().left !== boxMenu.getBoundingClientRect().left) {
                // The getBoundingClientRect().right of the boxMenu if it were hypothetically flipped
                // back into the original position before the flip.
                const testBoxMenuRightEdgePos = parentRef.getBoundingClientRect().left - boxMenu.getBoundingClientRect().left + boxMenu.getBoundingClientRect().right;
                if (testBoxMenuRightEdgePos > (window.innerWidth || document.documentElement.clientWidth)) {
                    leftOffset = parentRef.offsetWidth - boxMenu.offsetWidth;
                }
                // If it has not already been flipped, check if it is necessary to flip, ie. if the
                // boxMenu is outside of the right viewPort.
            }
            else if (boxMenu.getBoundingClientRect().right > (window.innerWidth || document.documentElement.clientWidth)) {
                leftOffset = parentRef.offsetWidth - boxMenu.offsetWidth;
            }
        }
        // If cds-placeholder has a parent with a position(relative|fixed|absolute) account for the parent offset
        const closestMenuWithPos = (0,carbon_components_angular_utils__WEBPACK_IMPORTED_MODULE_4__.closestAttr)("position", ["relative", "fixed", "absolute"], menuRef.parentElement);
        const topPos = closestMenuWithPos ? closestMenuWithPos.getBoundingClientRect().top * -1 : this.offset.top;
        const leftPos = closestMenuWithPos ? closestMenuWithPos.getBoundingClientRect().left * -1 : this.offset.left + leftOffset;
        let pos = _carbon_utils_position__WEBPACK_IMPORTED_MODULE_2__.position.findAbsolute(parentRef, menuRef, "bottom");
        pos = _carbon_utils_position__WEBPACK_IMPORTED_MODULE_2__.position.addOffset(pos, topPos, leftPos);
        _carbon_utils_position__WEBPACK_IMPORTED_MODULE_2__.position.setElement(menuRef, pos);
    }
}
DropdownService.fac = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareFactory"]({ minVersion: "12.0.0", version: "14.3.0", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: DropdownService, deps: [{ token: carbon_components_angular_placeholder__WEBPACK_IMPORTED_MODULE_5__.PlaceholderService }, { token: carbon_components_angular_utils__WEBPACK_IMPORTED_MODULE_4__.AnimationFrameService }], target: _angular_core__WEBPACK_IMPORTED_MODULE_0__["FactoryTarget"].Injectable });
DropdownService.prov = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareInjectable"]({ minVersion: "12.0.0", version: "14.3.0", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: DropdownService });
_angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareClassMetadata"]({ minVersion: "12.0.0", version: "14.3.0", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: DropdownService, decorators: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Injectable
        }], ctorParameters: function () { return [{ type: carbon_components_angular_placeholder__WEBPACK_IMPORTED_MODULE_5__.PlaceholderService }, { type: carbon_components_angular_utils__WEBPACK_IMPORTED_MODULE_4__.AnimationFrameService }]; } });

/**
 * Drop-down lists enable users to select one or more items from a list.
 *
 * #### Opening behavior/List DOM placement
 * By default the dropdown will try to figure out the best placement for the dropdown list.
 *
 * If it's not contained within any scrolling elements, it will open inline, if it _is_
 * contained within a scrolling container it will try to open in the body, or an `cds-placeholder`.
 *
 * To control this behavior you can use the `appendInline` input:
 * - `[appendInline]="null"` is the default (auto detection)
 * - `[appendInline]="false"` will always append to the body/`cds-placeholder`
 * - `[appendInline]="true"` will always append inline (next to the dropdown button)
 *
 * Get started with importing the module:
 *
 * ```typescript
 * import { DropdownModule } from 'carbon-components-angular';
 * ```
 *
 * [See demo](../../?path=/story/components-dropdown--basic)
 */
class Dropdown {
    /**
     * Creates an instance of Dropdown.
     */
    constructor(elementRef, i18n, dropdownService, elementService) {
        this.elementRef = elementRef;
        this.i18n = i18n;
        this.dropdownService = dropdownService;
        this.elementService = elementService;
        this.id = `dropdown-${Dropdown.dropdownCount++}`;
        /**
         * Hide label while keeping it accessible for screen readers
         */
        this.hideLabel = false;
        /**
         * Value displayed if no item is selected.
         */
        this.placeholder = "";
        /**
         * The selected value from the `Dropdown`. Can be a string or template.
         */
        this.displayValue = "";
        /**
         * Sets the optional clear button tooltip text.
         */
        this.clearText = this.i18n.get().DROPDOWN.CLEAR;
        /**
         * Size to render the dropdown field.
         */
        this.size = "md";
        /**
         * Defines whether or not the `Dropdown` supports selecting multiple items as opposed to single
         * item selection.
         */
        this.type = "single";
        /**
         * @deprecated since v5 - Use `cdsLayer` directive instead
         * `light` or `dark` dropdown theme
         */
        this.theme = "dark";
        /**
         * Set to `true` to disable the dropdown.
         */
        this.disabled = false;
        /**
         * Set to `true` for a loading dropdown.
         */
        this.skeleton = false;
        /**
         * Set to `true` for an inline dropdown.
         */
        this.inline = false;
        /**
         * Set to `true` for a dropdown without arrow key activation.
         */
        this.disableArrowKeys = false;
        /**
         * Set to `true` for invalid state.
         */
        this.invalid = false;
        /**
          * Set to `true` to show a warning (contents set by warningText)
          */
        this.warn = false;
        /**
         * set to `true` to place the dropdown view inline with the component
         */
        this.appendInline = null;
        /**
         * Specify feedback (mode) of the selection.
         * `top`: selected item jumps to top
         * `fixed`: selected item stays at it's position
         * `top-after-reopen`: selected item jump to top after reopen dropdown
         */
        this.selectionFeedback = "top-after-reopen";
        /**
         * Accessible label for the button that opens the dropdown list.
         * Defaults to the `DROPDOWN.OPEN` value from the i18n service.
         */
        this.menuButtonLabel = this.i18n.get().DROPDOWN.OPEN;
        /**
         * Provides the label for the "# selected" text.
         * Defaults to the `DROPDOWN.SELECTED` value from the i18n service.
         */
        this.selectedLabel = this.i18n.get().DROPDOWN.SELECTED;
        /**
         * Emits selection events.
         */
        this.selected = new _angular_core__WEBPACK_IMPORTED_MODULE_0__.EventEmitter();
        /**
         * Emits event notifying to other classes that the `Dropdown` has been closed (collapsed).
         */
        this.onClose = new _angular_core__WEBPACK_IMPORTED_MODULE_0__.EventEmitter();
        /**
         * Emits event notifying to other classes that the `Dropdown` has been closed (collapsed).
         */
        this.close = new _angular_core__WEBPACK_IMPORTED_MODULE_0__.EventEmitter();
        this.hostClass = true;
        /**
         * Set to `true` if the dropdown is closed (not expanded).
         */
        this.menuIsClosed = true;
        /**
         * controls whether the `drop-up` class is applied
         */
        this._dropUp = false;
        // .bind creates a new function, so we declare the methods below
        // but .bind them up here
        this.noop = this._noop.bind(this);
        this.outsideClick = this._outsideClick.bind(this);
        this.outsideKey = this._outsideKey.bind(this);
        this.keyboardNav = this._keyboardNav.bind(this);
        this.visibilitySubscription = new rxjs__WEBPACK_IMPORTED_MODULE_1__.Subscription();
        this.onTouchedCallback = this._noop;
        // primarily used to capture and propagate input to `writeValue` before the content is available
        this._writtenValue = [];
        /**
         * function passed in by `registerOnChange`
         */
        this.propagateChange = (_) => { };
    }
    get writtenValue() {
        return this._writtenValue;
    }
    set writtenValue(val) {
        if (val && val.length === 0) {
            this.clearSelected();
        }
        this._writtenValue = val;
    }
    /**
     * Updates the `type` property in the `@ContentChild`.
     * The `type` property specifies whether the `Dropdown` allows single selection or multi selection.
     */
    ngOnInit() {
        if (this.view) {
            this.view.type = this.type;
        }
    }
    /**
     * Initializes classes and subscribes to events for single or multi selection.
     */
    ngAfterContentInit() {
        if (!this.view) {
            return;
        }
        if ((this.writtenValue && this.writtenValue.length) || typeof this.writtenValue === "number") {
            this.writeValue(this.writtenValue);
        }
        this.view.type = this.type;
        this.view.size = this.size;
        // function to check if the event is organic (isUpdate === false) or programmatic
        const isUpdate = event => event && event.isUpdate;
        this.view.select.subscribe(event => {
            if (this.type === "single" && !isUpdate(event) && !Array.isArray(event)) {
                this.closeMenu();
                if (event.item && event.item.selected) {
                    if (this.itemValueKey) {
                        this.propagateChange(event.item[this.itemValueKey]);
                    }
                    else {
                        this.propagateChange(event.item);
                    }
                }
                else {
                    this.propagateChange(null);
                }
            }
            if (this.type === "multi" && !isUpdate(event)) {
                // if we have a `value` selector and selected items map them appropriately
                if (this.itemValueKey && this.view.getSelected()) {
                    const values = this.view.getSelected().map(item => item[this.itemValueKey]);
                    this.propagateChange(values);
                    // otherwise just pass up the values from `getSelected`
                }
                else {
                    this.propagateChange(this.view.getSelected());
                }
            }
            // only emit selected for "organic" selections
            if (!isUpdate(event)) {
                this.checkForReorder();
                this.selected.emit(event);
            }
        });
    }
    ngAfterViewInit() {
        // if appendInline is default valued (null) we should:
        // 1. if there are scrollable parents (not including body) don't append inline
        //    this should also cover the case where the dropdown is in a modal
        //    (where we _do_ want to append to the placeholder)
        if (this.appendInline === null && (0,carbon_components_angular_utils__WEBPACK_IMPORTED_MODULE_4__.hasScrollableParents)(this.elementRef.nativeElement)) {
            this.appendInline = false;
            // 2. otherwise we should append inline
        }
        else if (this.appendInline === null) {
            this.appendInline = true;
        }
        this.checkForReorder();
    }
    /**
     * Removing the `Dropdown` from the body if it is appended to the body.
     */
    ngOnDestroy() {
        if (!this.appendInline) {
            this._appendToDropdown();
        }
    }
    /**
     * Propagates the injected `value`.
     */
    writeValue(value) {
        // cache the written value so we can use it in `AfterContentInit`
        this.writtenValue = value;
        this.view.onItemsReady(() => {
            // propagate null/falsey as an array (deselect everything)
            if (!value) {
                this.view.propagateSelected([value]);
            }
            else if (this.type === "single") {
                if (this.itemValueKey) {
                    // clone the specified item and update its state
                    const newValue = Object.assign({}, this.view.getListItems().find(item => item[this.itemValueKey] === value));
                    newValue.selected = true;
                    this.view.propagateSelected([newValue]);
                }
                else {
                    // pass the singular value as an array of ListItem
                    this.view.propagateSelected([value]);
                }
            }
            else {
                if (this.itemValueKey) {
                    // clone the items and update their state based on the received value array
                    // this way we don't lose any additional metadata that may be passed in via the `items` Input
                    let newValues = [];
                    for (const v of value) {
                        for (const item of this.view.getListItems()) {
                            if (item[this.itemValueKey] === v) {
                                newValues.push(Object.assign({}, item, { selected: true }));
                            }
                        }
                    }
                    this.view.propagateSelected(newValues);
                }
                else {
                    // we can safely assume we're passing an array of `ListItem`s
                    this.view.propagateSelected(value);
                }
            }
            this.checkForReorder();
        });
    }
    onBlur() {
        this.onTouchedCallback();
    }
    registerOnChange(fn) {
        this.propagateChange = fn;
    }
    /**
     * Registering the function injected to control the touch use of the `Dropdown`.
     */
    registerOnTouched(fn) {
        this.onTouchedCallback = fn;
    }
    /**
     * `ControlValueAccessor` method to programmatically disable the dropdown.
     *
     * ex: `this.formGroup.get("myDropdown").disable();`
     *
     * @param isDisabled `true` to disable the input
     */
    setDisabledState(isDisabled) {
        this.disabled = isDisabled;
    }
    /**
     * Adds keyboard functionality for navigation, selection and closing of the `Dropdown`.
     */
    onKeyDown(event) {
        if ((event.key === "Escape") && !this.menuIsClosed) {
            event.stopImmediatePropagation(); // don't unintentionally close other widgets that listen for Escape
        }
        if (event.key === "Escape") {
            event.preventDefault();
            this.closeMenu();
            this.dropdownButton.nativeElement.focus();
        }
        else if (this.menuIsClosed && (event.key === " " || event.key === "ArrowDown" || event.key === "ArrowUp")) {
            if (this.disableArrowKeys && (event.key === "ArrowDown" || event.key === "ArrowUp")) {
                return;
            }
            event.preventDefault();
            this.openMenu();
        }
        if (!this.menuIsClosed && event.key === "Tab" && this.dropdownMenu.nativeElement.contains(event.target)) {
            this.closeMenu();
        }
        if (!this.menuIsClosed && event.key === "Tab" && event.shiftKey) {
            this.closeMenu();
        }
        if (this.type === "multi") {
            return;
        }
        if (this.menuIsClosed) {
            this.closedDropdownNavigation(event);
        }
    }
    closedDropdownNavigation(event) {
        if (event.key === "ArrowDown") {
            event.preventDefault();
            this.view.getCurrentItem().selected = false;
            let item = this.view.getNextItem();
            if (item) {
                item.selected = true;
            }
        }
        else if (event.key === "ArrowUp") {
            event.preventDefault();
            this.view.getCurrentItem().selected = false;
            let item = this.view.getPrevItem();
            if (item) {
                item.selected = true;
            }
        }
    }
    /**
     * Returns the display value if there is a selection and displayValue is set,
     * if there is just a selection the ListItem content property will be returned,
     * otherwise the placeholder will be returned.
     */
    getDisplayStringValue() {
        if (!this.view || this.skeleton) {
            return;
        }
        let selected = this.view.getSelected();
        if (selected.length && (!this.displayValue || !this.isRenderString())) {
            if (this.type === "multi") {
                return (0,rxjs__WEBPACK_IMPORTED_MODULE_1__.of)(this.placeholder);
            }
            else {
                return (0,rxjs__WEBPACK_IMPORTED_MODULE_1__.of)(selected[0].content);
            }
        }
        else if (selected.length && this.isRenderString()) {
            return (0,rxjs__WEBPACK_IMPORTED_MODULE_1__.of)(this.displayValue);
        }
        return (0,rxjs__WEBPACK_IMPORTED_MODULE_1__.of)(this.placeholder);
    }
    isRenderString() {
        return typeof this.displayValue === "string";
    }
    getRenderTemplateContext() {
        if (!this.view) {
            return;
        }
        let selected = this.view.getSelected();
        if (this.type === "multi") {
            return { items: selected };
        }
        else if (selected && selected.length > 0) {
            return { item: selected[0] }; // this is to be compatible with the dropdown-list template
        }
        else {
            return {};
        }
    }
    getSelectedCount() {
        if (this.view.getSelected()) {
            return this.view.getSelected().length;
        }
    }
    clearSelected() {
        if (this.disabled || this.getSelectedCount() === 0) {
            return;
        }
        for (const item of this.view.getListItems()) {
            item.selected = false;
        }
        this.selected.emit([]);
        this.propagateChange([]);
    }
    /**
     * Returns `true` if there is a value selected.
     */
    valueSelected() {
        if (this.view.getSelected()) {
            return true;
        }
        return false;
    }
    _noop() { }
    /**
     * Handles clicks outside of the `Dropdown`.
     */
    _outsideClick(event) {
        if (!this.elementRef.nativeElement.contains(event.target) &&
            // if we're appendToBody the list isn't within the _elementRef,
            // so we've got to check if our target is possibly in there too.
            !this.dropdownMenu.nativeElement.contains(event.target)) {
            this.closeMenu();
        }
    }
    _outsideKey(event) {
        if (!this.menuIsClosed && event.key === "Tab" && this.dropdownMenu.nativeElement.contains(event.target)) {
            this.closeMenu();
        }
    }
    /**
     * Handles keyboard events so users are controlling the `Dropdown` instead of unintentionally controlling outside elements.
     */
    _keyboardNav(event) {
        if (event.key === "Escape" && !this.menuIsClosed) {
            event.stopImmediatePropagation(); // don't unintentionally close modal if inside of it
        }
        if (event.key === "Escape") {
            event.preventDefault();
            this.closeMenu();
            this.dropdownButton.nativeElement.focus();
        }
        else if (!this.menuIsClosed && event.key === "Tab") {
            // this way focus will start on the next focusable item from the dropdown
            // not the top of the body!
            this.dropdownButton.nativeElement.focus();
            this.dropdownButton.nativeElement.dispatchEvent(new KeyboardEvent("keydown", { bubbles: true, cancelable: true, key: "Tab" }));
            this.closeMenu();
        }
    }
    /**
     * Creates the `Dropdown` list appending it to the dropdown parent object instead of the body.
     */
    _appendToDropdown() {
        this.dropdownService.appendToDropdown(this.elementRef.nativeElement);
        this.dropdownMenu.nativeElement.removeEventListener("keydown", this.keyboardNav, true);
    }
    /**
     * Creates the `Dropdown` list as an element that is appended to the DOM body.
     */
    _appendToBody() {
        const lightClass = this.theme === "light" ? " cds--list-box--light" : "";
        const expandedClass = !this.menuIsClosed ? " cds--list-box--expanded" : "";
        this.dropdownService.appendToBody(this.dropdownButton.nativeElement, this.dropdownMenu.nativeElement, `${this.elementRef.nativeElement.className}${lightClass}${expandedClass}`);
        this.dropdownMenu.nativeElement.addEventListener("keydown", this.keyboardNav, true);
    }
    /**
     * Detects whether or not the `Dropdown` list is visible within all scrollable parents.
     * This can be overridden by passing in a value to the `dropUp` input.
     */
    _shouldDropUp() {
        // check if dropdownMenu exists first.
        const menu = this.dropdownMenu && this.dropdownMenu.nativeElement.querySelector(".cds--list-box__menu");
        // check if menu exists first.
        const menuRect = menu && menu.getBoundingClientRect();
        if (menu && menuRect) {
            const scrollableParents = (0,carbon_components_angular_utils__WEBPACK_IMPORTED_MODULE_4__.getScrollableParents)(menu);
            return scrollableParents.reduce((shouldDropUp, parent) => {
                const parentRect = parent.getBoundingClientRect();
                const isBelowParent = !(menuRect.bottom <= parentRect.bottom);
                return shouldDropUp || isBelowParent;
            }, false);
        }
        return false;
    }
    /**
     * Expands the dropdown menu in the view.
     */
    openMenu() {
        // prevents the dropdown from opening when list of items is empty
        if (this.view.getListItems().length === 0) {
            return;
        }
        this._dropUp = false;
        this.menuIsClosed = false;
        // move the dropdown list to the body if we're not appending inline
        // and position it relative to the dropdown wrapper
        if (!this.appendInline) {
            const target = this.dropdownButton.nativeElement;
            const parent = this.elementRef.nativeElement;
            this.visibilitySubscription = this.elementService
                .visibility(target, parent)
                .subscribe(value => {
                if (!value.visible) {
                    this.closeMenu();
                }
            });
            this._appendToBody();
        }
        // set the dropdown menu to drop up if it's near the bottom of the screen
        // setTimeout lets us measure after it's visible in the DOM
        setTimeout(() => {
            if (this.dropUp === null || this.dropUp === undefined) {
                this._dropUp = this._shouldDropUp();
            }
        }, 0);
        // we bind noop to document.body.firstElementChild to allow safari to fire events
        // from document. Then we unbind everything later to keep things light.
        document.body.firstElementChild.addEventListener("click", this.noop, true);
        document.body.firstElementChild.addEventListener("keydown", this.noop, true);
        document.addEventListener("click", this.outsideClick, true);
        document.addEventListener("keydown", this.outsideKey, true);
        setTimeout(() => this.view.initFocus(), 0);
    }
    /**
     * Collapsing the dropdown menu and removing unnecessary `EventListeners`.
     */
    closeMenu() {
        // return early if the menu is already closed
        if (this.menuIsClosed) {
            return;
        }
        this.menuIsClosed = true;
        this.checkForReorder();
        this.onClose.emit();
        this.close.emit();
        // focus the trigger button when we close ...
        this.dropdownButton.nativeElement.focus();
        // remove the conditional once this api is settled and part of abstract-dropdown-view.class
        if (this.view["disableScroll"]) {
            this.view["disableScroll"]();
        }
        // move the list back in the component on close
        if (!this.appendInline) {
            this.visibilitySubscription.unsubscribe();
            this._appendToDropdown();
        }
        document.body.firstElementChild.removeEventListener("click", this.noop, true);
        document.body.firstElementChild.removeEventListener("keydown", this.noop, true);
        document.removeEventListener("click", this.outsideClick, true);
        document.removeEventListener("keydown", this.outsideKey, true);
    }
    /**
     * Controls toggling menu states between open/expanded and closed/collapsed.
     */
    toggleMenu() {
        if (this.menuIsClosed) {
            this.openMenu();
        }
        else {
            this.closeMenu();
        }
    }
    isTemplate(value) {
        return value instanceof _angular_core__WEBPACK_IMPORTED_MODULE_0__.TemplateRef;
    }
    /**
     * Controls when it's needed to apply the selection feedback
     */
    checkForReorder() {
        const topAfterReopen = this.menuIsClosed && this.selectionFeedback === "top-after-reopen";
        if ((this.type === "multi") && (topAfterReopen || this.selectionFeedback === "top")) {
            this.view.reorderSelected();
        }
    }
}
Dropdown.dropdownCount = 0;
Dropdown.fac = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareFactory"]({ minVersion: "12.0.0", version: "14.3.0", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: Dropdown, deps: [{ token: _angular_core__WEBPACK_IMPORTED_MODULE_0__.ElementRef }, { token: carbon_components_angular_i18n__WEBPACK_IMPORTED_MODULE_6__.I18n }, { token: DropdownService }, { token: carbon_components_angular_utils__WEBPACK_IMPORTED_MODULE_4__.ElementService }], target: _angular_core__WEBPACK_IMPORTED_MODULE_0__["FactoryTarget"].Component });
Dropdown.cmp = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareComponent"]({ minVersion: "14.0.0", version: "14.3.0", type: Dropdown, selector: "cds-dropdown, ibm-dropdown", inputs: { id: "id", label: "label", hideLabel: "hideLabel", helperText: "helperText", placeholder: "placeholder", displayValue: "displayValue", clearText: "clearText", size: "size", type: "type", theme: "theme", disabled: "disabled", skeleton: "skeleton", inline: "inline", disableArrowKeys: "disableArrowKeys", invalid: "invalid", invalidText: "invalidText", warn: "warn", warnText: "warnText", appendInline: "appendInline", scrollableContainer: "scrollableContainer", itemValueKey: "itemValueKey", selectionFeedback: "selectionFeedback", menuButtonLabel: "menuButtonLabel", selectedLabel: "selectedLabel", dropUp: "dropUp" }, outputs: { selected: "selected", onClose: "onClose", close: "close" }, host: { listeners: { "keydown": "onKeyDown($event)" }, properties: { "class.cds--dropdown__wrapper": "this.hostClass" } }, providers: [
        {
            provide: _angular_forms__WEBPACK_IMPORTED_MODULE_7__.NG_VALUE_ACCESSOR,
            useExisting: Dropdown,
            multi: true
        }
    ], queries: [{ propertyName: "view", first: true, predicate: AbstractDropdownView, descendants: true, static: true }], viewQueries: [{ propertyName: "dropdownButton", first: true, predicate: ["dropdownButton"], descendants: true, static: true }, { propertyName: "dropdownMenu", first: true, predicate: ["dropdownMenu"], descendants: true, static: true }], ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), template: `
	<label
		*ngIf="label && !skeleton"
		[for]="id"
		class="cds--label"
		[ngClass]="{
			'cds--label--disabled': disabled,
			'cds--visually-hidden': hideLabel
		}">
		<ng-container *ngIf="!isTemplate(label)">{{label}}</ng-container>
		<ng-template *ngIf="isTemplate(label)" [ngTemplateOutlet]="label"></ng-template>
	</label>
	<div
		class="cds--list-box"
		[ngClass]="{
			'cds--dropdown': type !== 'multi',
			'cds--multiselect': type === 'multi',
			'cds--multi-select--selected': type === 'multi' && getSelectedCount() > 0,
			'cds--dropdown--light': theme === 'light',
			'cds--list-box--light': theme === 'light',
			'cds--list-box--inline': inline,
			'cds--skeleton': skeleton,
			'cds--dropdown--disabled cds--list-box--disabled': disabled,
			'cds--dropdown--invalid': invalid,
			'cds--dropdown--warning cds--list-box--warning': warn,
			'cds--dropdown--sm cds--list-box--sm': size === 'sm',
			'cds--dropdown--md cds--list-box--md': size === 'md',
			'cds--dropdown--lg cds--list-box--lg': size === 'lg',
			'cds--list-box--expanded': !menuIsClosed
		}">
		<button
			#dropdownButton
			[id]="id"
			type="button"
			class="cds--list-box__field"
			[ngClass]="{'a': !menuIsClosed}"
			[attr.aria-expanded]="!menuIsClosed"
			[attr.aria-disabled]="disabled"
			aria-haspopup="listbox"
			(click)="disabled ? $event.stopPropagation() : toggleMenu()"
			(blur)="onBlur()"
			[attr.disabled]="disabled ? true : null">
			<div
				(click)="clearSelected()"
				(keydown.enter)="clearSelected()"
				*ngIf="type === 'multi' && getSelectedCount() > 0"
				class="cds--list-box__selection cds--tag--filter cds--list-box__selection--multi"
				tabindex="0"
				[title]="clearText">
				{{getSelectedCount()}}
				<svg
					focusable="false"
					preserveAspectRatio="xMidYMid meet"
					style="will-change: transform;"
					role="img"
					xmlns="http://www.w3.org/2000/svg"
					width="16"
					height="16"
					viewBox="0 0 16 16"
					aria-hidden="true">
					<path d="M12 4.7l-.7-.7L8 7.3 4.7 4l-.7.7L7.3 8 4 11.3l.7.7L8 8.7l3.3 3.3.7-.7L8.7 8z"></path>
				</svg>
			</div>
			<span *ngIf="isRenderString()" class="cds--list-box__label">{{getDisplayStringValue() | async}}</span>
			<ng-template
				*ngIf="!isRenderString()"
				[ngTemplateOutletContext]="getRenderTemplateContext()"
				[ngTemplateOutlet]="displayValue">
			</ng-template>
			<svg
				*ngIf="invalid"
				class="cds--dropdown__invalid-icon"
				cdsIcon="warning--filled"
				size="16">
			</svg>
			<svg
				*ngIf="!invalid && warn"
				cdsIcon="warning--alt--filled"
				size="16"
				class="cds--list-box__invalid-icon cds--list-box__invalid-icon--warning">
			</svg>
			<span class="cds--list-box__menu-icon">
				<svg
					*ngIf="!skeleton"
					cdsIcon="chevron--down"
					size="16"
					[attr.aria-label]="menuButtonLabel"
					[ngClass]="{'cds--list-box__menu-icon--open': !menuIsClosed }">
				</svg>
			</span>
		</button>
		<div
			#dropdownMenu
			[ngClass]="{
				'cds--list-box--up': this.dropUp !== null && this.dropUp !== undefined ? dropUp : _dropUp
			}">
			<ng-content *ngIf="!menuIsClosed"></ng-content>
		</div>
	</div>
	<div
		*ngIf="helperText && !invalid && !warn && !skeleton"
		class="cds--form__helper-text"
		[ngClass]="{
			'cds--form__helper-text--disabled': disabled
		}">
		<ng-container *ngIf="!isTemplate(helperText)">{{helperText}}</ng-container>
		<ng-template *ngIf="isTemplate(helperText)" [ngTemplateOutlet]="helperText"></ng-template>
	</div>
	<div *ngIf="invalid" class="cds--form-requirement">
		<ng-container *ngIf="!isTemplate(invalidText)">{{ invalidText }}</ng-container>
		<ng-template *ngIf="isTemplate(invalidText)" [ngTemplateOutlet]="invalidText"></ng-template>
	</div>
	<div *ngIf="!invalid && warn" class="cds--form-requirement">
		<ng-container *ngIf="!isTemplate(warnText)">{{warnText}}</ng-container>
		<ng-template *ngIf="isTemplate(warnText)" [ngTemplateOutlet]="warnText"></ng-template>
	</div>
	`, isInline: true, dependencies: [{ kind: "directive", type: _angular_common__WEBPACK_IMPORTED_MODULE_3__.NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }, { kind: "directive", type: _angular_common__WEBPACK_IMPORTED_MODULE_3__.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: _angular_common__WEBPACK_IMPORTED_MODULE_3__.NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet", "ngTemplateOutletInjector"] }, { kind: "directive", type: carbon_components_angular_icon__WEBPACK_IMPORTED_MODULE_8__.IconDirective, selector: "[cdsIcon], [ibmIcon]", inputs: ["ibmIcon", "cdsIcon", "size", "title", "ariaLabel", "ariaLabelledBy", "ariaHidden", "isFocusable"] }, { kind: "pipe", type: _angular_common__WEBPACK_IMPORTED_MODULE_3__.AsyncPipe, name: "async" }] });
_angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareClassMetadata"]({ minVersion: "12.0.0", version: "14.3.0", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: Dropdown, decorators: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Component,
            args: [{
                    selector: "cds-dropdown, ibm-dropdown",
                    template: `
	<label
		*ngIf="label && !skeleton"
		[for]="id"
		class="cds--label"
		[ngClass]="{
			'cds--label--disabled': disabled,
			'cds--visually-hidden': hideLabel
		}">
		<ng-container *ngIf="!isTemplate(label)">{{label}}</ng-container>
		<ng-template *ngIf="isTemplate(label)" [ngTemplateOutlet]="label"></ng-template>
	</label>
	<div
		class="cds--list-box"
		[ngClass]="{
			'cds--dropdown': type !== 'multi',
			'cds--multiselect': type === 'multi',
			'cds--multi-select--selected': type === 'multi' && getSelectedCount() > 0,
			'cds--dropdown--light': theme === 'light',
			'cds--list-box--light': theme === 'light',
			'cds--list-box--inline': inline,
			'cds--skeleton': skeleton,
			'cds--dropdown--disabled cds--list-box--disabled': disabled,
			'cds--dropdown--invalid': invalid,
			'cds--dropdown--warning cds--list-box--warning': warn,
			'cds--dropdown--sm cds--list-box--sm': size === 'sm',
			'cds--dropdown--md cds--list-box--md': size === 'md',
			'cds--dropdown--lg cds--list-box--lg': size === 'lg',
			'cds--list-box--expanded': !menuIsClosed
		}">
		<button
			#dropdownButton
			[id]="id"
			type="button"
			class="cds--list-box__field"
			[ngClass]="{'a': !menuIsClosed}"
			[attr.aria-expanded]="!menuIsClosed"
			[attr.aria-disabled]="disabled"
			aria-haspopup="listbox"
			(click)="disabled ? $event.stopPropagation() : toggleMenu()"
			(blur)="onBlur()"
			[attr.disabled]="disabled ? true : null">
			<div
				(click)="clearSelected()"
				(keydown.enter)="clearSelected()"
				*ngIf="type === 'multi' && getSelectedCount() > 0"
				class="cds--list-box__selection cds--tag--filter cds--list-box__selection--multi"
				tabindex="0"
				[title]="clearText">
				{{getSelectedCount()}}
				<svg
					focusable="false"
					preserveAspectRatio="xMidYMid meet"
					style="will-change: transform;"
					role="img"
					xmlns="http://www.w3.org/2000/svg"
					width="16"
					height="16"
					viewBox="0 0 16 16"
					aria-hidden="true">
					<path d="M12 4.7l-.7-.7L8 7.3 4.7 4l-.7.7L7.3 8 4 11.3l.7.7L8 8.7l3.3 3.3.7-.7L8.7 8z"></path>
				</svg>
			</div>
			<span *ngIf="isRenderString()" class="cds--list-box__label">{{getDisplayStringValue() | async}}</span>
			<ng-template
				*ngIf="!isRenderString()"
				[ngTemplateOutletContext]="getRenderTemplateContext()"
				[ngTemplateOutlet]="displayValue">
			</ng-template>
			<svg
				*ngIf="invalid"
				class="cds--dropdown__invalid-icon"
				cdsIcon="warning--filled"
				size="16">
			</svg>
			<svg
				*ngIf="!invalid && warn"
				cdsIcon="warning--alt--filled"
				size="16"
				class="cds--list-box__invalid-icon cds--list-box__invalid-icon--warning">
			</svg>
			<span class="cds--list-box__menu-icon">
				<svg
					*ngIf="!skeleton"
					cdsIcon="chevron--down"
					size="16"
					[attr.aria-label]="menuButtonLabel"
					[ngClass]="{'cds--list-box__menu-icon--open': !menuIsClosed }">
				</svg>
			</span>
		</button>
		<div
			#dropdownMenu
			[ngClass]="{
				'cds--list-box--up': this.dropUp !== null && this.dropUp !== undefined ? dropUp : _dropUp
			}">
			<ng-content *ngIf="!menuIsClosed"></ng-content>
		</div>
	</div>
	<div
		*ngIf="helperText && !invalid && !warn && !skeleton"
		class="cds--form__helper-text"
		[ngClass]="{
			'cds--form__helper-text--disabled': disabled
		}">
		<ng-container *ngIf="!isTemplate(helperText)">{{helperText}}</ng-container>
		<ng-template *ngIf="isTemplate(helperText)" [ngTemplateOutlet]="helperText"></ng-template>
	</div>
	<div *ngIf="invalid" class="cds--form-requirement">
		<ng-container *ngIf="!isTemplate(invalidText)">{{ invalidText }}</ng-container>
		<ng-template *ngIf="isTemplate(invalidText)" [ngTemplateOutlet]="invalidText"></ng-template>
	</div>
	<div *ngIf="!invalid && warn" class="cds--form-requirement">
		<ng-container *ngIf="!isTemplate(warnText)">{{warnText}}</ng-container>
		<ng-template *ngIf="isTemplate(warnText)" [ngTemplateOutlet]="warnText"></ng-template>
	</div>
	`,
                    providers: [
                        {
                            provide: _angular_forms__WEBPACK_IMPORTED_MODULE_7__.NG_VALUE_ACCESSOR,
                            useExisting: Dropdown,
                            multi: true
                        }
                    ]
                }]
        }], ctorParameters: function () { return [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.ElementRef }, { type: carbon_components_angular_i18n__WEBPACK_IMPORTED_MODULE_6__.I18n }, { type: DropdownService }, { type: carbon_components_angular_utils__WEBPACK_IMPORTED_MODULE_4__.ElementService }]; }, propDecorators: { id: [{
                type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input
            }], label: [{
                type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input
            }], hideLabel: [{
                type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input
            }], helperText: [{
                type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input
            }], placeholder: [{
                type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input
            }], displayValue: [{
                type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input
            }], clearText: [{
                type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input
            }], size: [{
                type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input
            }], type: [{
                type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input
            }], theme: [{
                type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input
            }], disabled: [{
                type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input
            }], skeleton: [{
                type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input
            }], inline: [{
                type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input
            }], disableArrowKeys: [{
                type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input
            }], invalid: [{
                type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input
            }], invalidText: [{
                type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input
            }], warn: [{
                type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input
            }], warnText: [{
                type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input
            }], appendInline: [{
                type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input
            }], scrollableContainer: [{
                type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input
            }], itemValueKey: [{
                type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input
            }], selectionFeedback: [{
                type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input
            }], menuButtonLabel: [{
                type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input
            }], selectedLabel: [{
                type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input
            }], dropUp: [{
                type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input
            }], selected: [{
                type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Output
            }], onClose: [{
                type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Output
            }], close: [{
                type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Output
            }], view: [{
                type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.ContentChild,
                args: [AbstractDropdownView, { static: true }]
            }], dropdownButton: [{
                type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.ViewChild,
                args: ["dropdownButton", { static: true }]
            }], dropdownMenu: [{
                type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.ViewChild,
                args: ["dropdownMenu", { static: true }]
            }], hostClass: [{
                type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.HostBinding,
                args: ["class.cds--dropdown__wrapper"]
            }], onKeyDown: [{
                type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.HostListener,
                args: ["keydown", ["$event"]]
            }] } });

/**
 * returns an observable bound to keydown events that
 * filters to a single element where the first letter of
 * it's textContent matches the key pressed
 *
 * @param target element to watch
 * @param elements elements to search
 */
function watchFocusJump(target, elements) {
    return (0,rxjs__WEBPACK_IMPORTED_MODULE_1__.fromEvent)(target, "keydown")
        .pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_9__.debounceTime)(150), (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_10__.map)((ev) => {
        let el = elements.find((itemEl) => itemEl.textContent.trim().toLowerCase().startsWith(ev.key));
        if (el) {
            return el;
        }
    }), (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_11__.filter)(el => !!el));
}
/** bundle of functions to aid in manipulating tree structures */
const treetools = {
    /** finds an item in a set of items and returns the item and path to the item as an array */
    find: function (items, itemToFind, path = []) {
        let found;
        for (let i of items) {
            if (i === itemToFind) {
                path.push(i);
                found = i;
            }
            if (i.items && !found) {
                path.push(i);
                found = this.find(i.items, itemToFind, path).found;
                if (!found) {
                    path = [];
                }
            }
        }
        return { found, path };
    }
};

/**
 * ```html
 * <cds-dropdown-list [items]="listItems"></cds-dropdown-list>
 * ```
 * ```typescript
 * listItems = [
 * 	{
 * 		content: "item one",
 * 		selected: false
 * 	},
 * 	{
 * 		content: "item two",
 * 		selected: false,
 * 	},
 * 	{
 * 		content: "item three",
 * 		selected: false
 * 	},
 * 	{
 * 		content: "item four",
 * 		selected: false
 * 	}
 * ];
 * ```
 */
class DropdownList {
    /**
     * Creates an instance of `DropdownList`.
     */
    constructor(elementRef, i18n, appRef) {
        this.elementRef = elementRef;
        this.i18n = i18n;
        this.appRef = appRef;
        this.ariaLabel = this.i18n.get().DROPDOWN_LIST.LABEL;
        /**
         * Template to bind to items in the `DropdownList` (optional).
         */
        this.listTpl = null;
        /**
         * Event to emit selection of a list item within the `DropdownList`.
         */
        this.select = new _angular_core__WEBPACK_IMPORTED_MODULE_0__.EventEmitter();
        /**
         * Event to emit scroll event of a list within the `DropdownList`.
         */
        this.scroll = new _angular_core__WEBPACK_IMPORTED_MODULE_0__.EventEmitter();
        /**
         * Event to suggest a blur on the view.
         * Emits _after_ the first/last item has been focused.
         * ex.
         * ArrowUp -> focus first item
         * ArrowUp -> emit event
         *
         * When this event fires focus should be placed on some element outside of the list - blurring the list as a result
         */
        this.blurIntent = new _angular_core__WEBPACK_IMPORTED_MODULE_0__.EventEmitter();
        /**
         * Defines whether or not the `DropdownList` supports selecting multiple items as opposed to single
         * item selection.
         */
        this.type = "single";
        /**
         * Defines whether to show title attribute or not
         */
        this.showTitles = true;
        /**
         * Defines the rendering size of the `DropdownList` input component.
         */
        this.size = "md";
        this.listId = `listbox-${DropdownList.listCount++}`;
        this.highlightedItem = null;
        /**
         * Holds the list of items that will be displayed in the `DropdownList`.
         * It differs from the the complete set of items when filtering is used (but
         * it is always a subset of the total items in `DropdownList`).
         */
        this.displayItems = [];
        /**
         * Maintains the index for the selected item within the `DropdownList`.
         */
        this.index = -1;
        /**
         * Useful representation of the items, should be accessed via `getListItems`.
         */
        this._items = [];
    }
    /**
     * The list items belonging to the `DropdownList`.
     */
    set items(value) {
        if ((0,rxjs__WEBPACK_IMPORTED_MODULE_1__.isObservable)(value)) {
            if (this._itemsSubscription) {
                this._itemsSubscription.unsubscribe();
            }
            this._itemsReady = new rxjs__WEBPACK_IMPORTED_MODULE_1__.Observable((observer) => {
                this._itemsSubscription = value.subscribe(v => {
                    this.updateList(v);
                    observer.next(true);
                    observer.complete();
                });
            });
            this.onItemsReady(null);
        }
        else {
            this.updateList(value);
        }
        this._originalItems = value;
    }
    get items() {
        return this._originalItems;
    }
    /**
     * Retrieves array of list items and index of the selected item after view has rendered.
     * Additionally, any Observables for the `DropdownList` are initialized.
     */
    ngAfterViewInit() {
        this.index = this.getListItems().findIndex(item => item.selected);
        this.setupFocusObservable();
        setTimeout(() => {
            this.doEmitSelect(true);
        });
    }
    /**
     * Removes any Observables on destruction of the component.
     */
    ngOnDestroy() {
        if (this.focusJump) {
            this.focusJump.unsubscribe();
        }
        if (this._itemsSubscription) {
            this._itemsSubscription.unsubscribe();
        }
    }
    doEmitSelect(isUpdate = true) {
        if (this.type === "single") {
            this.select.emit({ item: this._items.find(item => item.selected), isUpdate: isUpdate });
        }
        else {
            // abuse javascripts object mutability until we can break the API and switch to
            // { items: [], isUpdate: true }
            const selected = this.getSelected() || [];
            selected["isUpdate"] = isUpdate;
            this.select.emit(selected);
        }
    }
    getItemId(index) {
        return `${this.listId}-${index}`;
    }
    /**
     * Updates the displayed list of items and then retrieves the most current properties for the `DropdownList` from the DOM.
     */
    updateList(items) {
        this._items = items.map(item => Object.assign({}, item));
        this.displayItems = this._items;
        this.updateIndex();
        this.setupFocusObservable();
        this.doEmitSelect();
    }
    /**
     * Filters the items being displayed in the DOM list.
     */
    filterBy(query = "") {
        if (query) {
            this.displayItems = this.getListItems().filter(item => item.content.toLowerCase().includes(query.toLowerCase()));
            // Reset index if items were found
            // Prevent selecting index in list that are undefined.
            if (this.displayItems) {
                this.index = 0;
            }
        }
        else {
            this.displayItems = this.getListItems();
        }
        this.updateIndex();
    }
    /**
     * Initializes (or re-initializes) the Observable that handles switching focus to an element based on
     * key input matching the first letter of the item in the list.
     */
    setupFocusObservable() {
        if (!this.list) {
            return;
        }
        if (this.focusJump) {
            this.focusJump.unsubscribe();
        }
        let elList = Array.from(this.list.nativeElement.querySelectorAll("li"));
        this.focusJump = watchFocusJump(this.list.nativeElement, elList)
            .subscribe(el => {
            el.focus();
        });
    }
    /**
     * Returns the `ListItem` that is subsequent to the selected item in the `DropdownList`.
     */
    getNextItem() {
        if (this.index < this.displayItems.length - 1) {
            this.index++;
        }
        return this.displayItems[this.index];
    }
    /**
     * Returns `true` if the selected item is not the last item in the `DropdownList`.
     */
    hasNextElement() {
        return this.index < this.displayItems.length - 1 &&
            (!(this.index === this.displayItems.length - 2) || !this.displayItems[this.index + 1].disabled);
    }
    /**
     * Returns the `HTMLElement` for the item that is subsequent to the selected item.
     */
    getNextElement() {
        // Only return native elements if they are rendered
        const elemList = this.listElementList ? this.listElementList.toArray() : [];
        if (!elemList.length) {
            return null;
        }
        /**
         * Start checking from next index
         * Continue looping through the list until a non disabeled element is found or
         * end of list is reached
         */
        for (let i = this.index + 1; i < elemList.length; i++) {
            // If the values in the list are not disabled
            if (!this.displayItems[i].disabled) {
                this.index = i;
                return elemList[i].nativeElement;
            }
        }
        return elemList[this.index]?.nativeElement;
    }
    /**
     * Returns the `ListItem` that precedes the selected item within `DropdownList`.
     */
    getPrevItem() {
        if (this.index > 0) {
            this.index--;
        }
        return this.displayItems[this.index];
    }
    /**
     * Returns `true` if the selected item is not the first in the list.
     */
    hasPrevElement() {
        return this.index > 0 && (!(this.index === 1) || !this.displayItems[0].disabled);
    }
    /**
     * Returns the `HTMLElement` for the item that precedes the selected item.
     */
    getPrevElement() {
        // Only return native elements if they are rendered
        const elemList = this.listElementList ? this.listElementList.toArray() : [];
        if (!elemList.length) {
            return null;
        }
        /**
         * Start checking from next index
         * Continue looping through the list until a non disabeled element is found or
         * end of list is reached
         */
        for (let i = this.index - 1; i < this.index && i >= 0; i--) {
            // If the values in the list are not disabled
            if (!this.displayItems[i].disabled) {
                this.index = i;
                return elemList[i].nativeElement;
            }
        }
        return elemList[this.index].nativeElement;
    }
    /**
     * Returns the `ListItem` that is selected within `DropdownList`.
     */
    getCurrentItem() {
        if (this.index < 0) {
            return this.displayItems[0];
        }
        return this.displayItems[this.index];
    }
    /**
     * Returns the `HTMLElement` for the item that is selected within the `DropdownList`.
     */
    getCurrentElement() {
        if (this.index < 0) {
            return this.listElementList.first.nativeElement;
        }
        return this.listElementList.toArray()[this.index].nativeElement;
    }
    /**
     * Returns the items as an Array
     */
    getListItems() {
        return this._items;
    }
    /**
     * Returns a list containing the selected item(s) in the `DropdownList`.
     */
    getSelected() {
        let selected = this.getListItems().filter(item => item.selected);
        if (selected.length === 0) {
            return [];
        }
        return selected;
    }
    /**
     * Transforms array input list of items to the correct state by updating the selected item(s).
     */
    propagateSelected(value) {
        // if we get a non-array, log out an error (since it is one)
        if (!Array.isArray(value)) {
            console.error(`${this.constructor.name}.propagateSelected expects an Array<ListItem>, got ${JSON.stringify(value)}`);
        }
        this.onItemsReady(() => {
            const selectedNewItems = [];
            for (let newItem of value) {
                if (newItem && newItem.selected) {
                    // copy the item
                    let tempNewItem = Object.assign({}, newItem);
                    // deleted selected because it's what we _want_ to change
                    delete tempNewItem.selected;
                    // stringify for compare later
                    tempNewItem = JSON.stringify(tempNewItem);
                    // add to the list of selected items
                    selectedNewItems.push(tempNewItem);
                }
            }
            // loop through the list items and update the `selected` state for matching items in `value`
            for (let oldItem of this.getListItems()) {
                // fast path when no items are selected
                if (selectedNewItems.length === 0) {
                    oldItem.selected = false;
                    continue;
                }
                // copy the item
                let tempOldItem = Object.assign({}, oldItem);
                // deleted selected because it's what we _want_ to change
                delete tempOldItem.selected;
                // stringify for compare
                tempOldItem = JSON.stringify(tempOldItem);
                for (let selectedNewItem of selectedNewItems) {
                    // do the compare
                    if (tempOldItem.includes(selectedNewItem)) {
                        oldItem.selected = true;
                        // if we've found a matching item, we can stop looping
                        break;
                    }
                    else {
                        oldItem.selected = false;
                    }
                }
            }
        });
    }
    /**
     * Initializes focus in the list, effectively a wrapper for `getCurrentElement().focus()`
     */
    initFocus() {
        if (this.index < 0) {
            this.updateIndex();
        }
        this.list.nativeElement.focus();
        setTimeout(() => {
            this.highlightedItem = this.getItemId(this.index);
        });
    }
    updateIndex() {
        // initialize index on the first selected item or
        // on the next non disabled item if no items are selected
        // in case, if all items are disabled, the index value will remain same
        const selected = this.getSelected();
        if (selected.length) {
            this.index = this.displayItems.indexOf(selected[0]);
        }
        else if (this.hasNextElement()) {
            this.getNextElement();
        }
    }
    /**
     * Manages the keyboard accessibility for navigation and selection within a `DropdownList`.
     */
    navigateList(event) {
        if (event.key === "Enter" || event.key === " ") {
            if (this.listElementList.some(option => option.nativeElement === event.target)) {
                event.preventDefault();
            }
            if (event.key === "Enter") {
                this.doClick(event, this.getCurrentItem());
            }
        }
        else if (event.key === "ArrowDown" || event.key === "ArrowUp") {
            event.preventDefault();
            if (event.key === "ArrowDown") {
                if (this.hasNextElement()) {
                    this.getNextElement()?.scrollIntoView({ block: "end" });
                }
                else {
                    this.blurIntent.emit("bottom");
                }
            }
            else if (event.key === "ArrowUp") {
                if (this.hasPrevElement()) {
                    this.getPrevElement().scrollIntoView({ block: "nearest" });
                }
                else {
                    this.blurIntent.emit("top");
                }
            }
            setTimeout(() => {
                this.highlightedItem = this.getItemId(this.index);
            });
        }
    }
    /**
     * Emits the selected item or items after a mouse click event has occurred.
     */
    doClick(event, item) {
        event.preventDefault();
        if (item && !item.disabled) {
            this.list.nativeElement.focus();
            if (this.type === "single") {
                item.selected = true;
                // reset the selection
                for (let otherItem of this.getListItems()) {
                    if (item !== otherItem) {
                        otherItem.selected = false;
                    }
                }
            }
            else {
                item.selected = !item.selected;
            }
            this.index = this.displayItems.indexOf(item);
            this.highlightedItem = this.getItemId(this.index);
            this.doEmitSelect(false);
            this.appRef.tick();
        }
    }
    onItemFocus(index) {
        const element = this.listElementList.toArray()[index].nativeElement;
        element.classList.add("cds--list-box__menu-item--highlighted");
        element.tabIndex = 0;
    }
    onItemBlur(index) {
        const element = this.listElementList.toArray()[index].nativeElement;
        element.classList.remove("cds--list-box__menu-item--highlighted");
        element.tabIndex = -1;
    }
    /**
     * Emits the scroll event of the options list
     */
    emitScroll(event) {
        const atTop = event.srcElement.scrollTop === 0;
        const atBottom = event.srcElement.scrollHeight - event.srcElement.scrollTop === event.srcElement.clientHeight;
        const customScrollEvent = { atTop, atBottom, event };
        this.scroll.emit(customScrollEvent);
    }
    /**
     * Subscribe the function passed to an internal observable that will resolve once the items are ready
     */
    onItemsReady(subcription) {
        // this subscription will auto unsubscribe because of the `first()` pipe
        (this._itemsReady || (0,rxjs__WEBPACK_IMPORTED_MODULE_1__.of)(true)).pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_12__.first)()).subscribe(subcription);
    }
    reorderSelected(moveFocus = true) {
        this.displayItems = [...this.getSelected(), ...this.getListItems().filter(item => !item.selected)];
        if (moveFocus) {
            setTimeout(() => {
                this.updateIndex();
                this.highlightedItem = this.getItemId(this.index);
            });
        }
    }
}
DropdownList.listCount = 0;
DropdownList.fac = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareFactory"]({ minVersion: "12.0.0", version: "14.3.0", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: DropdownList, deps: [{ token: _angular_core__WEBPACK_IMPORTED_MODULE_0__.ElementRef }, { token: carbon_components_angular_i18n__WEBPACK_IMPORTED_MODULE_6__.I18n }, { token: _angular_core__WEBPACK_IMPORTED_MODULE_0__.ApplicationRef }], target: _angular_core__WEBPACK_IMPORTED_MODULE_0__["FactoryTarget"].Component });
DropdownList.cmp = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareComponent"]({ minVersion: "14.0.0", version: "14.3.0", type: DropdownList, selector: "cds-dropdown-list, ibm-dropdown-list", inputs: { ariaLabel: "ariaLabel", items: "items", listTpl: "listTpl", type: "type", showTitles: "showTitles" }, outputs: { select: "select", scroll: "scroll", blurIntent: "blurIntent" }, providers: [
        {
            provide: AbstractDropdownView,
            useExisting: DropdownList
        }
    ], viewQueries: [{ propertyName: "list", first: true, predicate: ["list"], descendants: true, static: true }, { propertyName: "listElementList", predicate: ["listItem"], descendants: true }], ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), template: `
		<ul
			#list
			[id]="listId"
			role="listbox"
			class="cds--list-box__menu cds--multi-select"
			(scroll)="emitScroll($event)"
			(keydown)="navigateList($event)"
			tabindex="-1"
			[attr.aria-label]="ariaLabel"
			[attr.aria-activedescendant]="highlightedItem">
			<li
				role="option"
				*ngFor="let item of displayItems; let i = index"
				(click)="doClick($event, item)"
				class="cds--list-box__menu-item"
				[attr.aria-selected]="item.selected"
				[id]="getItemId(i)"
				[attr.title]=" showTitles ? item.content : null"
				[attr.disabled]="item.disabled ? true : null"
				[ngClass]="{
					'cds--list-box__menu-item--active': item.selected,
					'cds--list-box__menu-item--highlighted': highlightedItem === getItemId(i)
				}">
				<div
					#listItem
					tabindex="-1"
					class="cds--list-box__menu-item__option">
					<div
						*ngIf="!listTpl && type === 'multi'"
						class="cds--form-item cds--checkbox-wrapper">
						<label
							[attr.data-contained-checkbox-state]="item.selected"
							class="cds--checkbox-label">
							<input
								class="cds--checkbox"
								type="checkbox"
								[checked]="item.selected"
								[disabled]="item.disabled"
								tabindex="-1">
							<span class="cds--checkbox-appearance"></span>
							<span class="cds--checkbox-label-text">{{item.content}}</span>
						</label>
					</div>
					<ng-container *ngIf="!listTpl && type === 'single'">{{item.content}}</ng-container>
					<svg
						*ngIf="!listTpl && type === 'single'"
						cdsIcon="checkmark"
						size="16"
						class="cds--list-box__menu-item__selected-icon">
					</svg>
					<ng-template
						*ngIf="listTpl"
						[ngTemplateOutletContext]="{item: item}"
						[ngTemplateOutlet]="listTpl">
					</ng-template>
				</div>
			</li>
		</ul>`, isInline: true, dependencies: [{ kind: "directive", type: _angular_common__WEBPACK_IMPORTED_MODULE_3__.NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }, { kind: "directive", type: _angular_common__WEBPACK_IMPORTED_MODULE_3__.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "directive", type: _angular_common__WEBPACK_IMPORTED_MODULE_3__.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: _angular_common__WEBPACK_IMPORTED_MODULE_3__.NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet", "ngTemplateOutletInjector"] }, { kind: "directive", type: carbon_components_angular_icon__WEBPACK_IMPORTED_MODULE_8__.IconDirective, selector: "[cdsIcon], [ibmIcon]", inputs: ["ibmIcon", "cdsIcon", "size", "title", "ariaLabel", "ariaLabelledBy", "ariaHidden", "isFocusable"] }] });
_angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareClassMetadata"]({ minVersion: "12.0.0", version: "14.3.0", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: DropdownList, decorators: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Component,
            args: [{
                    selector: "cds-dropdown-list, ibm-dropdown-list",
                    template: `
		<ul
			#list
			[id]="listId"
			role="listbox"
			class="cds--list-box__menu cds--multi-select"
			(scroll)="emitScroll($event)"
			(keydown)="navigateList($event)"
			tabindex="-1"
			[attr.aria-label]="ariaLabel"
			[attr.aria-activedescendant]="highlightedItem">
			<li
				role="option"
				*ngFor="let item of displayItems; let i = index"
				(click)="doClick($event, item)"
				class="cds--list-box__menu-item"
				[attr.aria-selected]="item.selected"
				[id]="getItemId(i)"
				[attr.title]=" showTitles ? item.content : null"
				[attr.disabled]="item.disabled ? true : null"
				[ngClass]="{
					'cds--list-box__menu-item--active': item.selected,
					'cds--list-box__menu-item--highlighted': highlightedItem === getItemId(i)
				}">
				<div
					#listItem
					tabindex="-1"
					class="cds--list-box__menu-item__option">
					<div
						*ngIf="!listTpl && type === 'multi'"
						class="cds--form-item cds--checkbox-wrapper">
						<label
							[attr.data-contained-checkbox-state]="item.selected"
							class="cds--checkbox-label">
							<input
								class="cds--checkbox"
								type="checkbox"
								[checked]="item.selected"
								[disabled]="item.disabled"
								tabindex="-1">
							<span class="cds--checkbox-appearance"></span>
							<span class="cds--checkbox-label-text">{{item.content}}</span>
						</label>
					</div>
					<ng-container *ngIf="!listTpl && type === 'single'">{{item.content}}</ng-container>
					<svg
						*ngIf="!listTpl && type === 'single'"
						cdsIcon="checkmark"
						size="16"
						class="cds--list-box__menu-item__selected-icon">
					</svg>
					<ng-template
						*ngIf="listTpl"
						[ngTemplateOutletContext]="{item: item}"
						[ngTemplateOutlet]="listTpl">
					</ng-template>
				</div>
			</li>
		</ul>`,
                    providers: [
                        {
                            provide: AbstractDropdownView,
                            useExisting: DropdownList
                        }
                    ]
                }]
        }], ctorParameters: function () { return [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.ElementRef }, { type: carbon_components_angular_i18n__WEBPACK_IMPORTED_MODULE_6__.I18n }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.ApplicationRef }]; }, propDecorators: { ariaLabel: [{
                type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input
            }], items: [{
                type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input
            }], listTpl: [{
                type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input
            }], select: [{
                type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Output
            }], scroll: [{
                type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Output
            }], blurIntent: [{
                type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Output
            }], list: [{
                type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.ViewChild,
                args: ["list", { static: true }]
            }], type: [{
                type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input
            }], showTitles: [{
                type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input
            }], listElementList: [{
                type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.ViewChildren,
                args: ["listItem"]
            }] } });

class ScrollableList {
    constructor(elementRef) {
        this.elementRef = elementRef;
        /**
         * Optional target list to scroll
         */
        this.nScrollableList = null;
        /**
         * Enables or disables scrolling for the whole directive
         */
        this.scrollEnabled = true;
        /**
         * How many lines to scroll by each time `wheel` fires
         * Defaults to 10 - based on testing this isn't too fast or slow on any platform
         */
        this.scrollBy = 10;
        this.canScrollUp = false;
        this.canScrollDown = false;
        this.list = this.elementRef.nativeElement;
    }
    ngOnChanges(changes) {
        if (changes.scrollEnabled) {
            if (changes.scrollEnabled.currentValue) {
                this.list.style.overflow = "hidden";
                this.scrollUpTarget.style.display = "flex";
                this.scrollDownTarget.style.display = "flex";
                this.canScrollUp = true;
                this.canScrollDown = true;
                this.updateScrollHeight();
                this.checkScrollArrows();
                setTimeout(() => {
                    this.checkScrollArrows();
                });
            }
            else {
                this.scrollUpTarget.style.display = "none";
                this.scrollDownTarget.style.display = "none";
                this.canScrollUp = false;
                this.canScrollDown = false;
                this.list.style.height = null;
                this.list.style.overflow = null;
                clearInterval(this.hoverScrollInterval);
            }
        }
    }
    ngAfterViewInit() {
        if (this.nScrollableList) {
            this.list = this.elementRef.nativeElement.querySelector(this.nScrollableList);
        }
        this.scrollUpTarget.addEventListener("mouseover", () => this.onHoverUp(true));
        this.scrollUpTarget.addEventListener("mouseout", () => this.onHoverUp(false));
        this.scrollDownTarget.addEventListener("mouseover", () => this.onHoverDown(true));
        this.scrollDownTarget.addEventListener("mouseout", () => this.onHoverDown(false));
    }
    updateScrollHeight() {
        if (this.scrollEnabled) {
            const container = this.elementRef.nativeElement.parentElement;
            const containerRect = container.getBoundingClientRect();
            const innerHeightDiff = this.list.getBoundingClientRect().top - containerRect.top;
            const outerHeightDiff = containerRect.height - (containerRect.bottom - window.innerHeight);
            // 40 gives us some padding between the bottom of the list,
            // the bottom of the window, and the scroll down button
            const height = outerHeightDiff - innerHeightDiff - 40;
            this.list.style.height = `${height}px`;
        }
    }
    checkScrollArrows() {
        const scrollUpHeight = this.scrollUpTarget.offsetHeight;
        const scrollDownHeight = this.scrollDownTarget.offsetHeight;
        if (this.list.scrollTop === 0) {
            if (this.canScrollUp) {
                this.list.style.height = `${parseInt(this.list.style.height, 10) + scrollUpHeight}px`;
            }
            this.scrollUpTarget.style.display = "none";
            this.canScrollUp = false;
        }
        else if (this.list.scrollTop === this.list.scrollTopMax) {
            if (this.canScrollDown) {
                this.list.style.height = `${parseInt(this.list.style.height, 10) + scrollDownHeight}px`;
            }
            this.scrollDownTarget.style.display = "none";
            this.canScrollDown = false;
        }
        else {
            if (!this.canScrollUp) {
                this.list.style.height = `${parseInt(this.list.style.height, 10) - scrollUpHeight}px`;
            }
            if (!this.canScrollDown) {
                this.list.style.height = `${parseInt(this.list.style.height, 10) - scrollDownHeight}px`;
            }
            this.scrollUpTarget.style.display = "flex";
            this.scrollDownTarget.style.display = "flex";
            this.canScrollUp = true;
            this.canScrollDown = true;
        }
    }
    onWheel(event) {
        if (event.deltaY < 0) {
            this.list.scrollTop -= this.scrollBy;
        }
        else {
            this.list.scrollTop += this.scrollBy;
        }
        // only prevent the parent/window from scrolling if we can scroll
        if (!(this.list.scrollTop === this.list.scrollTopMax || this.list.scrollTop === 0)) {
            event.preventDefault();
            event.stopPropagation();
        }
        this.checkScrollArrows();
    }
    onTouchStart(event) {
        if (event.touches[0]) {
            this.lastTouch = event.touches[0].clientY;
        }
    }
    onTouchMove(event) {
        event.preventDefault();
        event.stopPropagation();
        if (event.touches[0]) {
            const touch = event.touches[0];
            this.list.scrollTop += this.lastTouch - touch.clientY;
            this.lastTouch = touch.clientY;
            this.checkScrollArrows();
        }
    }
    hoverScrollBy(hovering, amount) {
        if (hovering) {
            this.hoverScrollInterval = setInterval(() => {
                this.list.scrollTop += amount;
                this.checkScrollArrows();
            }, 1);
        }
        else {
            clearInterval(this.hoverScrollInterval);
        }
    }
    onHoverUp(hovering) {
        // how many px/lines to scroll by on hover
        // 3 is just a random number that felt good
        // 1 and 2 are too slow, 4 works but it might be a tad fast
        this.hoverScrollBy(hovering, -3);
    }
    onHoverDown(hovering) {
        this.hoverScrollBy(hovering, 3);
    }
    onKeyDown(event) {
        if (event.key === "ArrowDown" || event.key === "ArrowUp") {
            this.checkScrollArrows();
        }
    }
}
ScrollableList.fac = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareFactory"]({ minVersion: "12.0.0", version: "14.3.0", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: ScrollableList, deps: [{ token: _angular_core__WEBPACK_IMPORTED_MODULE_0__.ElementRef }], target: _angular_core__WEBPACK_IMPORTED_MODULE_0__["FactoryTarget"].Directive });
ScrollableList.dir = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareDirective"]({ minVersion: "14.0.0", version: "14.3.0", type: ScrollableList, selector: "[cdsScrollableList], [ibmScrollableList]", inputs: { nScrollableList: "nScrollableList", scrollEnabled: "scrollEnabled", scrollUpTarget: "scrollUpTarget", scrollDownTarget: "scrollDownTarget", scrollBy: "scrollBy" }, host: { listeners: { "wheel": "onWheel($event)", "touchstart": "onTouchStart($event)", "touchmove": "onTouchMove($event)", "keydown": "onKeyDown($event)" } }, exportAs: ["scrollable-list"], usesOnChanges: true, ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))) });
_angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareClassMetadata"]({ minVersion: "12.0.0", version: "14.3.0", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: ScrollableList, decorators: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Directive,
            args: [{
                    selector: "[cdsScrollableList], [ibmScrollableList]",
                    exportAs: "scrollable-list"
                }]
        }], ctorParameters: function () { return [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.ElementRef }]; }, propDecorators: { nScrollableList: [{
                type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input
            }], scrollEnabled: [{
                type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input
            }], scrollUpTarget: [{
                type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input
            }], scrollDownTarget: [{
                type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input
            }], scrollBy: [{
                type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input
            }], onWheel: [{
                type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.HostListener,
                args: ["wheel", ["$event"]]
            }], onTouchStart: [{
                type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.HostListener,
                args: ["touchstart", ["$event"]]
            }], onTouchMove: [{
                type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.HostListener,
                args: ["touchmove", ["$event"]]
            }], onKeyDown: [{
                type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.HostListener,
                args: ["keydown", ["$event"]]
            }] } });

class DropdownModule {
}
DropdownModule.fac = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareFactory"]({ minVersion: "12.0.0", version: "14.3.0", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: DropdownModule, deps: [], target: _angular_core__WEBPACK_IMPORTED_MODULE_0__["FactoryTarget"].NgModule });
DropdownModule.mod = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareNgModule"]({ minVersion: "14.0.0", version: "14.3.0", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: DropdownModule, declarations: [Dropdown,
        DropdownList,
        ScrollableList,
        AbstractDropdownView], imports: [_angular_common__WEBPACK_IMPORTED_MODULE_3__.CommonModule,
        _angular_forms__WEBPACK_IMPORTED_MODULE_7__.FormsModule,
        carbon_components_angular_i18n__WEBPACK_IMPORTED_MODULE_6__.I18nModule,
        carbon_components_angular_placeholder__WEBPACK_IMPORTED_MODULE_5__.PlaceholderModule,
        carbon_components_angular_utils__WEBPACK_IMPORTED_MODULE_4__.UtilsModule,
        carbon_components_angular_icon__WEBPACK_IMPORTED_MODULE_8__.IconModule], exports: [Dropdown,
        DropdownList,
        ScrollableList,
        AbstractDropdownView] });
DropdownModule.inj = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareInjector"]({ minVersion: "12.0.0", version: "14.3.0", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: DropdownModule, providers: [DropdownService], imports: [_angular_common__WEBPACK_IMPORTED_MODULE_3__.CommonModule,
        _angular_forms__WEBPACK_IMPORTED_MODULE_7__.FormsModule,
        carbon_components_angular_i18n__WEBPACK_IMPORTED_MODULE_6__.I18nModule,
        carbon_components_angular_placeholder__WEBPACK_IMPORTED_MODULE_5__.PlaceholderModule,
        carbon_components_angular_utils__WEBPACK_IMPORTED_MODULE_4__.UtilsModule,
        carbon_components_angular_icon__WEBPACK_IMPORTED_MODULE_8__.IconModule] });
_angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareClassMetadata"]({ minVersion: "12.0.0", version: "14.3.0", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: DropdownModule, decorators: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.NgModule,
            args: [{
                    declarations: [
                        Dropdown,
                        DropdownList,
                        ScrollableList,
                        AbstractDropdownView
                    ],
                    exports: [
                        Dropdown,
                        DropdownList,
                        ScrollableList,
                        AbstractDropdownView
                    ],
                    imports: [
                        _angular_common__WEBPACK_IMPORTED_MODULE_3__.CommonModule,
                        _angular_forms__WEBPACK_IMPORTED_MODULE_7__.FormsModule,
                        carbon_components_angular_i18n__WEBPACK_IMPORTED_MODULE_6__.I18nModule,
                        carbon_components_angular_placeholder__WEBPACK_IMPORTED_MODULE_5__.PlaceholderModule,
                        carbon_components_angular_utils__WEBPACK_IMPORTED_MODULE_4__.UtilsModule,
                        carbon_components_angular_icon__WEBPACK_IMPORTED_MODULE_8__.IconModule
                    ],
                    providers: [DropdownService]
                }]
        }] });

/**
 * Generated bundle index. Do not edit.
 */


//# sourceMappingURL=carbon-components-angular-dropdown.mjs.map


/***/ }),

/***/ "../../../node_modules/carbon-components-angular/fesm2020/carbon-components-angular-i18n.mjs":
/*!***************************************************************************************************!*\
  !*** ../../../node_modules/carbon-components-angular/fesm2020/carbon-components-angular-i18n.mjs ***!
  \***************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

var _angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache;
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   I18N_SERVICE_PROVIDER: () => (/* binding */ I18N_SERVICE_PROVIDER),
/* harmony export */   I18N_SERVICE_PROVIDER_FACTORY: () => (/* binding */ I18N_SERVICE_PROVIDER_FACTORY),
/* harmony export */   I18n: () => (/* binding */ I18n),
/* harmony export */   I18nModule: () => (/* binding */ I18nModule),
/* harmony export */   Overridable: () => (/* binding */ Overridable),
/* harmony export */   ReplacePipe: () => (/* binding */ ReplacePipe),
/* harmony export */   replace: () => (/* binding */ replace)
/* harmony export */ });
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @angular/core */ "@angular/core");
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! rxjs */ "rxjs");
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! rxjs/operators */ "../../../node_modules/rxjs/dist/esm5/internal/operators/map.js");
/* harmony import */ var carbon_components_angular_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! carbon-components-angular/utils */ "../../../node_modules/carbon-components-angular/fesm2020/carbon-components-angular-utils.mjs");






var EN = {
    "BREADCRUMB": {
        "LABEL": "Breadcrumb"
    },
    "CODE_SNIPPET": {
        "CODE_SNIPPET_TEXT": "Code Snippet Text",
        "SHOW_MORE": "Show more",
        "SHOW_LESS": "Show less",
        "SHOW_MORE_ICON": "Show more icon",
        "COPY_CODE": "Copy code",
        "COPIED": "Copied!"
    },
    "COMBOBOX": {
        "PLACEHOLDER": "Filter...",
        "CLEAR_SELECTIONS": "Clear all selected items",
        "CLEAR_SELECTED": "Clear selected item",
        "A11Y": {
            "OPEN_MENU": "Open menu",
            "CLOSE_MENU": "Close menu",
            "CLEAR_SELECTIONS": "Clear all selected items",
            "CLEAR_SELECTED": "Clear Selection"
        }
    },
    "DROPDOWN": {
        "OPEN": "Open menu",
        "SELECTED": "Selected",
        "CLEAR": "Clear all selected items",
        "FILTER": {
            "SELECTED_ONLY": "Show selected only",
            "SEARCH": "Search",
            "NO_RESULTS": "No search results",
            "RESET_SEARCH": "Reset search"
        }
    },
    "DROPDOWN_LIST": {
        "LABEL": "Listbox"
    },
    "FILE_UPLOADER": {
        "CHECKMARK": "Checkmark",
        "OPEN": "Add file",
        "REMOVE_BUTTON": "Close button"
    },
    "LOADING": {
        "TITLE": "Loading"
    },
    "MODAL": {
        "CLOSE": "Close modal"
    },
    "NOTIFICATION": {
        "CLOSE_BUTTON": "Close alert notification"
    },
    "NUMBER": {
        "INCREMENT": "Increment value",
        "DECREMENT": "Decrement value"
    },
    "OVERFLOW_MENU": {
        "OVERFLOW": "Overflow"
    },
    "SEARCH": {
        "LABEL": "Search",
        "PLACEHOLDER": "Search",
        "CLEAR_BUTTON": "Clear search input"
    },
    "PAGINATION": {
        "ITEMS_PER_PAGE": "Items per page:",
        "OPEN_LIST_OF_OPTIONS": "Open list of options",
        "BACKWARD": "Backward",
        "FORWARD": "Forward",
        "TOTAL_ITEMS_UNKNOWN": "{{start}}-{{end}} items",
        "TOTAL_ITEMS": "{{start}}-{{end}} of {{total}} items",
        "TOTAL_ITEM": "{{start}}-{{end}} of {{total}} item",
        "PAGE": "page",
        "OF_LAST_PAGES": "of {{last}} pages",
        "OF_LAST_PAGE": "of {{last}} page",
        "NEXT": "Next",
        "PREVIOUS": "Previous",
        "SELECT_ARIA": "Select page number"
    },
    "PROGRESS_INDICATOR": {
        "CURRENT": "Current",
        "INCOMPLETE": "Incomplete",
        "COMPLETE": "Complete",
        "INVALID": "Invalid"
    },
    "TABLE": {
        "FILTER": "Filter",
        "END_OF_DATA": "You've reached the end of your content",
        "SCROLL_TOP": "Scroll to top",
        "CHECKBOX_HEADER": "Select all rows",
        "CHECKBOX_ROW": "Select {{value}}",
        "EXPAND_BUTTON": "Expand row",
        "SORT_DESCENDING": "Sort rows by this header in descending order",
        "SORT_ASCENDING": "Sort rows by this header in ascending order",
        "ROW": "row"
    },
    "TABLE_TOOLBAR": {
        "ACTION_BAR": "Table action bar",
        "BATCH_TEXT": "",
        "BATCH_TEXT_SINGLE": "1 item selected",
        "BATCH_TEXT_MULTIPLE": "{{count}} items selected",
        "CANCEL": "Cancel"
    },
    "TABS": {
        "BUTTON_ARIA_LEFT": "Go to the previous tab",
        "BUTTON_ARIA_RIGHT": "Go to the next tab",
        "HEADER_ARIA_LABEL": "List of tabs"
    },
    "TILES": {
        "TILE": "tile",
        "EXPAND": "Expand",
        "COLLAPSE": "Collapse"
    },
    "TOGGLE": {
        "OFF": "Off",
        "ON": "On"
    },
    "UI_SHELL": {
        "SKIP_TO": "Skip to content",
        "HEADER": {
            "OPEN_MENU": "Open menu",
            "CLOSE_MENU": "Close menu"
        },
        "SIDE_NAV": {
            "TOGGLE_OPEN": "Open",
            "TOGGLE_CLOSE": "Close"
        }
    }
};

/**
 * Takes the `Observable` returned from `i18n.get` and an object of variables to replace.
 *
 * The keys specify the variable name in the string.
 *
 * Example:
 * ```typescript
 * service.set({ "TEST": "{{foo}} {{bar}}" });
 *
 * service.replace(service.get("TEST"), { foo: "test", bar: "asdf" })
 * ```
 *
 * Produces: `"test asdf"`
 *
 * @param subject the translation to replace variables on
 * @param variables object of variables to replace
 */
const replace = (subject, variables) => subject.pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_2__.map)(str => {
    const keys = Object.keys(variables);
    for (const key of keys) {
        const value = variables[key];
        str = str.replace(new RegExp(`{{\\s*${key}\\s*}}`, "g"), value);
    }
    return str;
}));
/**
 * Represents an "overridable" translation value.
 *
 * Largely an internal usecase. There are situations where we want an `Observable` that
 * can emit events from a centralized source **OR** an `Observable` that will emit events
 * from a component local source. The key example being on/off text in a `Toggle` - In some cases
 * we want the `Toggle` to use `I18n`s global translations, but in others we'd prefer to use a local
 * override. We don't ever need to return to a non-overridden state, but we do need the ability to
 * switch _to_ an overridden sate.
 */
class Overridable {
    constructor(path, i18n) {
        this.path = path;
        this.i18n = i18n;
        /**
         * Our base non-overridden translation.
         */
        this.baseTranslation = this.i18n.get(this.path);
        /**
         * A boolean to flip between overridden and non-overridden states.
         */
        this.isOverridden = false;
        /**
         * ensure `$override` is initialized with the correct default value
         * in some cases `_value` can get changed for an `Observable` before `$override` is created
         */
        const value = this.i18n.getValueFromPath(this.path);
        this.$override = new rxjs__WEBPACK_IMPORTED_MODULE_1__.BehaviorSubject(value);
        this._value = value;
    }
    /**
     * The raw value of the translation. Defaults to the string value, but will return the value passed to `override`
     *
     * @readonly
     */
    get value() {
        return this._value;
    }
    set value(v) {
        this.override(v);
    }
    /**
     * The translation subject. Returns either a stream of overridden values, or our base translation values.
     *
     * @readonly
     */
    get subject() {
        /**
         * since inputs are bound on template instantiation (and thusly will always have _some_ value)
         * We can use a simple boolean and the `iif` function to determine which subject to return on subscription
         */
        return (0,rxjs__WEBPACK_IMPORTED_MODULE_1__.iif)(() => this.isOverridden, this.$override, this.baseTranslation);
    }
    /**
     * Takes a string or an `Observable` that emits strings.
     * Overrides the value provided by the `I18n` service.
     */
    override(value) {
        this.isOverridden = true;
        // To ensure that there are not multiple subscriptions created for the same observable, we
        // unsubscribe if a subscription already exists for an observable before creating a new one.
        if (this.subscription) {
            this.subscription.unsubscribe();
            this.subscription = null;
        }
        this._value = value;
        if ((0,rxjs__WEBPACK_IMPORTED_MODULE_1__.isObservable)(value)) {
            this.subscription = value.subscribe(v => {
                this.$override.next(v);
            });
        }
        else {
            this.$override.next(value);
        }
    }
}
/**
 * The I18n service is a minimal internal singleton service used to supply our components with translated strings.
 *
 * All the components that support I18n also support directly passed strings.
 * Usage of I18n is optional, and it is not recommended for application use (libraries like ngx-translate
 * are a better choice)
 *
 */
class I18n {
    constructor() {
        this.translationStrings = EN;
        this.translations = new Map();
        this.locale = new rxjs__WEBPACK_IMPORTED_MODULE_1__.BehaviorSubject("en");
    }
    /**
     * Sets the locale and optionally the translation strings. Locale is used by components that
     * are already locale aware (datepicker for example) while the translation strings are used
     * for components that are not.
     *
     * Locales set here will override locales/languages set in components
     * @param language an ISO 639-1 language code - https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes
     * @param strings an object of strings, optional
     */
    setLocale(language, strings) {
        this.locale.next(language);
        if (strings) {
            this.set(strings);
        }
    }
    /**
     * Returns the current locale
     */
    getLocale() {
        return this.locale.value;
    }
    /**
     * Returns an observable that resolves to the current locale, and will update when changed
     */
    getLocaleObservable() {
        return this.locale.asObservable();
    }
    /**
     * Set/update the translations from an object. Also notifies all participating components of the update.
     *
     * @param strings an object of strings, should follow the same format as src/i18n/en.json
     */
    set(strings) {
        this.translationStrings = (0,carbon_components_angular_utils__WEBPACK_IMPORTED_MODULE_3__.merge)({}, EN, strings);
        // iterate over all our tracked translations and update each observable
        const translations = Array.from(this.translations);
        for (const [path, subject] of translations) {
            subject.next(this.getValueFromPath(path));
        }
    }
    /**
     * When a path is specified returns an observable that will resolve to the translation string value.
     *
     * Returns the full translations object if path is not specified.
     *
     * @param path optional, looks like `"NOTIFICATION.CLOSE_BUTTON"`
     */
    get(path) {
        if (!path) {
            return this.translationStrings;
        }
        return this.getSubject(path);
    }
    /**
     * Returns all descendents of some path fragment as an object.
     *
     * @param partialPath a path fragment, for example `"NOTIFICATION"`
     */
    getMultiple(partialPath) {
        const values = this.getValueFromPath(partialPath);
        const subjects = {};
        for (const key of Object.keys(values)) {
            if (values[key] === Object(values[key])) {
                subjects[key] = this.getMultiple(`${partialPath}.${key}`);
            }
            else {
                subjects[key] = this.getSubject(`${partialPath}.${key}`);
            }
        }
        return subjects;
    }
    /**
     * Returns an instance of `Overridable` that can be used to optionally override the value provided by `I18n`
     * @param path looks like `"NOTIFICATION.CLOSE_BUTTON"`
     */
    getOverridable(path) {
        return new Overridable(path, this);
    }
    /**
     * Takes the `Observable` returned from `i18n.get` and an object of variables to replace.
     *
     * The keys specify the variable name in the string.
     *
     * Example:
     * ```
     * service.set({ "TEST": "{{foo}} {{bar}}" });
     *
     * service.replace(service.get("TEST"), { foo: "test", bar: "asdf" })
     * ```
     *
     * Produces: `"test asdf"`
     *
     * @param subject the translation to replace variables on
     * @param variables object of variables to replace
     */
    replace(subject, variables) {
        return replace(subject, variables);
    }
    /**
     * Trys to resolve a value from the provided path.
     *
     * @param path looks like `"NOTIFICATION.CLOSE_BUTTON"`
     */
    getValueFromPath(path) {
        let value = this.translationStrings;
        for (const segment of path.split(".")) {
            if (value[segment] !== undefined && value[segment] !== null) {
                value = value[segment];
            }
            else {
                throw new Error(`no key ${segment} at ${path}`);
            }
        }
        return value;
    }
    /**
     * Helper method that returns an observable from the internal cache based on the path
     *
     * @param path looks like `"NOTIFICATION.CLOSE_BUTTON"`
     */
    getSubject(path) {
        try {
            // we run this here to validate the path exists before adding it to the translation map
            const value = this.getValueFromPath(path);
            if (this.translations.has(path)) {
                return this.translations.get(path);
            }
            const translation = new rxjs__WEBPACK_IMPORTED_MODULE_1__.BehaviorSubject(value);
            this.translations.set(path, translation);
            return translation;
        }
        catch (error) {
            console.error(error);
        }
    }
}
I18n.fac = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareFactory"]({ minVersion: "12.0.0", version: "14.3.0", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: I18n, deps: [], target: _angular_core__WEBPACK_IMPORTED_MODULE_0__["FactoryTarget"].Injectable });
I18n.prov = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareInjectable"]({ minVersion: "12.0.0", version: "14.3.0", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: I18n });
_angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareClassMetadata"]({ minVersion: "12.0.0", version: "14.3.0", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: I18n, decorators: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Injectable
        }] });

class ReplacePipe {
    transform(value, variables) {
        return replace(value, variables);
    }
}
ReplacePipe.fac = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareFactory"]({ minVersion: "12.0.0", version: "14.3.0", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: ReplacePipe, deps: [], target: _angular_core__WEBPACK_IMPORTED_MODULE_0__["FactoryTarget"].Pipe });
ReplacePipe.pipe = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclarePipe"]({ minVersion: "14.0.0", version: "14.3.0", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: ReplacePipe, name: "i18nReplace" });
_angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareClassMetadata"]({ minVersion: "12.0.0", version: "14.3.0", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: ReplacePipe, decorators: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Pipe,
            args: [{
                    name: "i18nReplace"
                }]
        }] });

// either provides a new instance of I18n, or returns the parent
function I18N_SERVICE_PROVIDER_FACTORY(parentService) {
    return parentService || new I18n();
}
// I18n should provide a single instance of itself to ensure that translations are consistent through the app
const I18N_SERVICE_PROVIDER = {
    provide: I18n,
    deps: [[new _angular_core__WEBPACK_IMPORTED_MODULE_0__.Optional(), new _angular_core__WEBPACK_IMPORTED_MODULE_0__.SkipSelf(), I18n]],
    useFactory: I18N_SERVICE_PROVIDER_FACTORY
};
class I18nModule {
}
I18nModule.fac = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareFactory"]({ minVersion: "12.0.0", version: "14.3.0", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: I18nModule, deps: [], target: _angular_core__WEBPACK_IMPORTED_MODULE_0__["FactoryTarget"].NgModule });
I18nModule.mod = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareNgModule"]({ minVersion: "14.0.0", version: "14.3.0", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: I18nModule, declarations: [ReplacePipe], exports: [ReplacePipe] });
I18nModule.inj = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareInjector"]({ minVersion: "12.0.0", version: "14.3.0", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: I18nModule, providers: [
        I18n,
        I18N_SERVICE_PROVIDER
    ] });
_angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareClassMetadata"]({ minVersion: "12.0.0", version: "14.3.0", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: I18nModule, decorators: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.NgModule,
            args: [{
                    declarations: [ReplacePipe],
                    exports: [ReplacePipe],
                    providers: [
                        I18n,
                        I18N_SERVICE_PROVIDER
                    ]
                }]
        }] });

/**
 * Generated bundle index. Do not edit.
 */


//# sourceMappingURL=carbon-components-angular-i18n.mjs.map


/***/ }),

/***/ "../../../node_modules/carbon-components-angular/fesm2020/carbon-components-angular-icon.mjs":
/*!***************************************************************************************************!*\
  !*** ../../../node_modules/carbon-components-angular/fesm2020/carbon-components-angular-icon.mjs ***!
  \***************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

var _angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache;
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ICON_SERVICE_PROVIDER: () => (/* binding */ ICON_SERVICE_PROVIDER),
/* harmony export */   ICON_SERVICE_PROVIDER_FACTORY: () => (/* binding */ ICON_SERVICE_PROVIDER_FACTORY),
/* harmony export */   IconCache: () => (/* binding */ IconCache),
/* harmony export */   IconDirective: () => (/* binding */ IconDirective),
/* harmony export */   IconMemoryCache: () => (/* binding */ IconMemoryCache),
/* harmony export */   IconModule: () => (/* binding */ IconModule),
/* harmony export */   IconNameNotFoundError: () => (/* binding */ IconNameNotFoundError),
/* harmony export */   IconService: () => (/* binding */ IconService),
/* harmony export */   IconSizeNotFoundError: () => (/* binding */ IconSizeNotFoundError)
/* harmony export */ });
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @angular/core */ "@angular/core");
/* harmony import */ var _carbon_icon_helpers__WEBPACK_IMPORTED_MODULE_55__ = __webpack_require__(/*! @carbon/icon-helpers */ "../../../node_modules/@carbon/icon-helpers/es/index.js");
/* harmony import */ var _angular_common__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @angular/common */ "@angular/common");
/* harmony import */ var _carbon_icons_es_add_16__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @carbon/icons/es/add/16 */ "../../../node_modules/carbon-components-angular/node_modules/@carbon/icons/es/add/16.js");
/* harmony import */ var _carbon_icons_es_add_20__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @carbon/icons/es/add/20 */ "../../../node_modules/carbon-components-angular/node_modules/@carbon/icons/es/add/20.js");
/* harmony import */ var _carbon_icons_es_bee_16__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @carbon/icons/es/bee/16 */ "../../../node_modules/carbon-components-angular/node_modules/@carbon/icons/es/bee/16.js");
/* harmony import */ var _carbon_icons_es_bee_20__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @carbon/icons/es/bee/20 */ "../../../node_modules/carbon-components-angular/node_modules/@carbon/icons/es/bee/20.js");
/* harmony import */ var _carbon_icons_es_calendar_16__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @carbon/icons/es/calendar/16 */ "../../../node_modules/carbon-components-angular/node_modules/@carbon/icons/es/calendar/16.js");
/* harmony import */ var _carbon_icons_es_carbon_16__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @carbon/icons/es/carbon/16 */ "../../../node_modules/carbon-components-angular/node_modules/@carbon/icons/es/carbon/16.js");
/* harmony import */ var _carbon_icons_es_carbon_20__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @carbon/icons/es/carbon/20 */ "../../../node_modules/carbon-components-angular/node_modules/@carbon/icons/es/carbon/20.js");
/* harmony import */ var _carbon_icons_es_caret_down_16__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @carbon/icons/es/caret--down/16 */ "../../../node_modules/carbon-components-angular/node_modules/@carbon/icons/es/caret--down/16.js");
/* harmony import */ var _carbon_icons_es_caret_left_16__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @carbon/icons/es/caret--left/16 */ "../../../node_modules/carbon-components-angular/node_modules/@carbon/icons/es/caret--left/16.js");
/* harmony import */ var _carbon_icons_es_caret_right_16__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! @carbon/icons/es/caret--right/16 */ "../../../node_modules/carbon-components-angular/node_modules/@carbon/icons/es/caret--right/16.js");
/* harmony import */ var _carbon_icons_es_caret_up_16__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! @carbon/icons/es/caret--up/16 */ "../../../node_modules/carbon-components-angular/node_modules/@carbon/icons/es/caret--up/16.js");
/* harmony import */ var _carbon_icons_es_checkmark_16__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! @carbon/icons/es/checkmark/16 */ "../../../node_modules/carbon-components-angular/node_modules/@carbon/icons/es/checkmark/16.js");
/* harmony import */ var _carbon_icons_es_checkmark_filled_16__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! @carbon/icons/es/checkmark--filled/16 */ "../../../node_modules/carbon-components-angular/node_modules/@carbon/icons/es/checkmark--filled/16.js");
/* harmony import */ var _carbon_icons_es_checkmark_filled_20__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! @carbon/icons/es/checkmark--filled/20 */ "../../../node_modules/carbon-components-angular/node_modules/@carbon/icons/es/checkmark--filled/20.js");
/* harmony import */ var _carbon_icons_es_checkmark_outline_16__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! @carbon/icons/es/checkmark--outline/16 */ "../../../node_modules/carbon-components-angular/node_modules/@carbon/icons/es/checkmark--outline/16.js");
/* harmony import */ var _carbon_icons_es_chevron_down_16__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! @carbon/icons/es/chevron--down/16 */ "../../../node_modules/carbon-components-angular/node_modules/@carbon/icons/es/chevron--down/16.js");
/* harmony import */ var _carbon_icons_es_chevron_right_16__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! @carbon/icons/es/chevron--right/16 */ "../../../node_modules/carbon-components-angular/node_modules/@carbon/icons/es/chevron--right/16.js");
/* harmony import */ var _carbon_icons_es_circle_dash_16__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! @carbon/icons/es/circle-dash/16 */ "../../../node_modules/carbon-components-angular/node_modules/@carbon/icons/es/circle-dash/16.js");
/* harmony import */ var _carbon_icons_es_close_16__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! @carbon/icons/es/close/16 */ "../../../node_modules/carbon-components-angular/node_modules/@carbon/icons/es/close/16.js");
/* harmony import */ var _carbon_icons_es_close_20__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! @carbon/icons/es/close/20 */ "../../../node_modules/carbon-components-angular/node_modules/@carbon/icons/es/close/20.js");
/* harmony import */ var _carbon_icons_es_copy_16__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! @carbon/icons/es/copy/16 */ "../../../node_modules/carbon-components-angular/node_modules/@carbon/icons/es/copy/16.js");
/* harmony import */ var _carbon_icons_es_copy_20__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! @carbon/icons/es/copy/20 */ "../../../node_modules/carbon-components-angular/node_modules/@carbon/icons/es/copy/20.js");
/* harmony import */ var _carbon_icons_es_data_2_16__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! @carbon/icons/es/data--2/16 */ "../../../node_modules/carbon-components-angular/node_modules/@carbon/icons/es/data--2/16.js");
/* harmony import */ var _carbon_icons_es_data_2_20__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! @carbon/icons/es/data--2/20 */ "../../../node_modules/carbon-components-angular/node_modules/@carbon/icons/es/data--2/20.js");
/* harmony import */ var _carbon_icons_es_document_16__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! @carbon/icons/es/document/16 */ "../../../node_modules/carbon-components-angular/node_modules/@carbon/icons/es/document/16.js");
/* harmony import */ var _carbon_icons_es_document_20__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! @carbon/icons/es/document/20 */ "../../../node_modules/carbon-components-angular/node_modules/@carbon/icons/es/document/20.js");
/* harmony import */ var _carbon_icons_es_download_16__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(/*! @carbon/icons/es/download/16 */ "../../../node_modules/carbon-components-angular/node_modules/@carbon/icons/es/download/16.js");
/* harmony import */ var _carbon_icons_es_error_filled_16__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(/*! @carbon/icons/es/error--filled/16 */ "../../../node_modules/carbon-components-angular/node_modules/@carbon/icons/es/error--filled/16.js");
/* harmony import */ var _carbon_icons_es_error_filled_20__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__(/*! @carbon/icons/es/error--filled/20 */ "../../../node_modules/carbon-components-angular/node_modules/@carbon/icons/es/error--filled/20.js");
/* harmony import */ var _carbon_icons_es_fade_16__WEBPACK_IMPORTED_MODULE_31__ = __webpack_require__(/*! @carbon/icons/es/fade/16 */ "../../../node_modules/carbon-components-angular/node_modules/@carbon/icons/es/fade/16.js");
/* harmony import */ var _carbon_icons_es_fade_20__WEBPACK_IMPORTED_MODULE_32__ = __webpack_require__(/*! @carbon/icons/es/fade/20 */ "../../../node_modules/carbon-components-angular/node_modules/@carbon/icons/es/fade/20.js");
/* harmony import */ var _carbon_icons_es_folder_16__WEBPACK_IMPORTED_MODULE_33__ = __webpack_require__(/*! @carbon/icons/es/folder/16 */ "../../../node_modules/carbon-components-angular/node_modules/@carbon/icons/es/folder/16.js");
/* harmony import */ var _carbon_icons_es_incomplete_16__WEBPACK_IMPORTED_MODULE_34__ = __webpack_require__(/*! @carbon/icons/es/incomplete/16 */ "../../../node_modules/carbon-components-angular/node_modules/@carbon/icons/es/incomplete/16.js");
/* harmony import */ var _carbon_icons_es_information_filled_16__WEBPACK_IMPORTED_MODULE_35__ = __webpack_require__(/*! @carbon/icons/es/information--filled/16 */ "../../../node_modules/carbon-components-angular/node_modules/@carbon/icons/es/information--filled/16.js");
/* harmony import */ var _carbon_icons_es_information_filled_20__WEBPACK_IMPORTED_MODULE_36__ = __webpack_require__(/*! @carbon/icons/es/information--filled/20 */ "../../../node_modules/carbon-components-angular/node_modules/@carbon/icons/es/information--filled/20.js");
/* harmony import */ var _carbon_icons_es_information_square_filled_20__WEBPACK_IMPORTED_MODULE_37__ = __webpack_require__(/*! @carbon/icons/es/information--square--filled/20 */ "../../../node_modules/carbon-components-angular/node_modules/@carbon/icons/es/information--square--filled/20.js");
/* harmony import */ var _carbon_icons_es_menu_16__WEBPACK_IMPORTED_MODULE_38__ = __webpack_require__(/*! @carbon/icons/es/menu/16 */ "../../../node_modules/carbon-components-angular/node_modules/@carbon/icons/es/menu/16.js");
/* harmony import */ var _carbon_icons_es_menu_20__WEBPACK_IMPORTED_MODULE_39__ = __webpack_require__(/*! @carbon/icons/es/menu/20 */ "../../../node_modules/carbon-components-angular/node_modules/@carbon/icons/es/menu/20.js");
/* harmony import */ var _carbon_icons_es_overflow_menu_vertical_16__WEBPACK_IMPORTED_MODULE_40__ = __webpack_require__(/*! @carbon/icons/es/overflow-menu--vertical/16 */ "../../../node_modules/carbon-components-angular/node_modules/@carbon/icons/es/overflow-menu--vertical/16.js");
/* harmony import */ var _carbon_icons_es_overflow_menu_horizontal_16__WEBPACK_IMPORTED_MODULE_41__ = __webpack_require__(/*! @carbon/icons/es/overflow-menu--horizontal/16 */ "../../../node_modules/carbon-components-angular/node_modules/@carbon/icons/es/overflow-menu--horizontal/16.js");
/* harmony import */ var _carbon_icons_es_save_16__WEBPACK_IMPORTED_MODULE_42__ = __webpack_require__(/*! @carbon/icons/es/save/16 */ "../../../node_modules/carbon-components-angular/node_modules/@carbon/icons/es/save/16.js");
/* harmony import */ var _carbon_icons_es_search_16__WEBPACK_IMPORTED_MODULE_43__ = __webpack_require__(/*! @carbon/icons/es/search/16 */ "../../../node_modules/carbon-components-angular/node_modules/@carbon/icons/es/search/16.js");
/* harmony import */ var _carbon_icons_es_settings_16__WEBPACK_IMPORTED_MODULE_44__ = __webpack_require__(/*! @carbon/icons/es/settings/16 */ "../../../node_modules/carbon-components-angular/node_modules/@carbon/icons/es/settings/16.js");
/* harmony import */ var _carbon_icons_es_settings_adjust_16__WEBPACK_IMPORTED_MODULE_45__ = __webpack_require__(/*! @carbon/icons/es/settings--adjust/16 */ "../../../node_modules/carbon-components-angular/node_modules/@carbon/icons/es/settings--adjust/16.js");
/* harmony import */ var _carbon_icons_es_subtract_16__WEBPACK_IMPORTED_MODULE_46__ = __webpack_require__(/*! @carbon/icons/es/subtract/16 */ "../../../node_modules/carbon-components-angular/node_modules/@carbon/icons/es/subtract/16.js");
/* harmony import */ var _carbon_icons_es_trash_can_16__WEBPACK_IMPORTED_MODULE_47__ = __webpack_require__(/*! @carbon/icons/es/trash-can/16 */ "../../../node_modules/carbon-components-angular/node_modules/@carbon/icons/es/trash-can/16.js");
/* harmony import */ var _carbon_icons_es_warning_16__WEBPACK_IMPORTED_MODULE_48__ = __webpack_require__(/*! @carbon/icons/es/warning/16 */ "../../../node_modules/carbon-components-angular/node_modules/@carbon/icons/es/warning/16.js");
/* harmony import */ var _carbon_icons_es_warning_filled_16__WEBPACK_IMPORTED_MODULE_49__ = __webpack_require__(/*! @carbon/icons/es/warning--filled/16 */ "../../../node_modules/carbon-components-angular/node_modules/@carbon/icons/es/warning--filled/16.js");
/* harmony import */ var _carbon_icons_es_warning_filled_20__WEBPACK_IMPORTED_MODULE_50__ = __webpack_require__(/*! @carbon/icons/es/warning--filled/20 */ "../../../node_modules/carbon-components-angular/node_modules/@carbon/icons/es/warning--filled/20.js");
/* harmony import */ var _carbon_icons_es_warning_alt_filled_16__WEBPACK_IMPORTED_MODULE_51__ = __webpack_require__(/*! @carbon/icons/es/warning--alt--filled/16 */ "../../../node_modules/carbon-components-angular/node_modules/@carbon/icons/es/warning--alt--filled/16.js");
/* harmony import */ var _carbon_icons_es_warning_alt_filled_20__WEBPACK_IMPORTED_MODULE_52__ = __webpack_require__(/*! @carbon/icons/es/warning--alt--filled/20 */ "../../../node_modules/carbon-components-angular/node_modules/@carbon/icons/es/warning--alt--filled/20.js");
/* harmony import */ var _carbon_icons_es_view_16__WEBPACK_IMPORTED_MODULE_53__ = __webpack_require__(/*! @carbon/icons/es/view/16 */ "../../../node_modules/carbon-components-angular/node_modules/@carbon/icons/es/view/16.js");
/* harmony import */ var _carbon_icons_es_view_off_16__WEBPACK_IMPORTED_MODULE_54__ = __webpack_require__(/*! @carbon/icons/es/view--off/16 */ "../../../node_modules/carbon-components-angular/node_modules/@carbon/icons/es/view--off/16.js");


























































/**
 * Abstract class that represent a cache of icons.
 *
 * The actual caching mechanism will be implementation specific,
 * but it's likely a good idea to key by the icons name and/or size.
 * Icon name and size will always be strings, and they will be the two consistent
 * identifiers of an icon. For the purposes of storage additonal descriptor properties may
 * be used, but the name and size are the only ones guarenteed to be passed for lookup purposes.
 */
class IconCache {
}
/**
 * Custom error for when a name can't be found
 */
class IconNameNotFoundError extends Error {
    constructor(name) {
        super(`Icon ${name} not found`);
    }
}
/**
 * Custom error for when a specific size can't be found
 */
class IconSizeNotFoundError extends Error {
    constructor(size, name) {
        super("Size ${size} for ${name} not found");
    }
}
/**
 * Concrete implementation of `IconCache` as a simple in memory cache
 */
class IconMemoryCache extends IconCache {
    constructor() {
        super(...arguments);
        this.iconMap = new Map();
    }
    get(name, size) {
        if (!this.iconMap.has(name)) {
            throw new IconNameNotFoundError(name);
        }
        const sizeMap = this.iconMap.get(name);
        if (!sizeMap.has(size)) {
            throw new IconSizeNotFoundError(size, name);
        }
        return sizeMap.get(size);
    }
    set(name, size, descriptor) {
        if (!this.iconMap.has(name)) {
            this.iconMap.set(name, new Map());
        }
        const sizeMap = this.iconMap.get(name);
        sizeMap.set(size, descriptor);
    }
}
/**
 * The icon service is a singleton service responsible for registering and retriving icons from `@carbon/icons`.
 *
 * It's important to register icons before use. It's reccommended to register your icons early, likely in your app.component.
 *
 * To allow for improved tree shaking _do not_ import all the icons from `@carbon/icons` and register them.
 * Instead register only the icons in use by your application. If your application makes use of lazy loaded
 * modules you may also lazy load the icons used in that module by registering them early on in that module.
 *
 * `ngOnInit` should be sufficiantly early to register icons.
 *
 * Example:
 * ```
 * import { Accessibility16 } from "@carbon/icons";
 *
 * // ...
 *
 * class MyComponent implements OnInit {
 * 	constructor(protected iconService: IconService) {}
 *
 * 	// ...
 *
 * 	ngOnInit() {
 * 		this.iconService.register(Accessibility16);
 * 	}
 *
 * 	// ...
 * }
 * ```
 *
 * If needed it is possible to register an icon under a different name, via `registerAs`.
 */
class IconService {
    constructor() {
        this.iconCache = new IconMemoryCache();
    }
    /**
     * Registers an array of icons based on the metadata provided by `@carbon/icons`
     */
    registerAll(descriptors) {
        descriptors.forEach(icon => this.register(icon));
    }
    /**
     * Registers an icon based on the metadata provided by `@carbon/icons`
     */
    register(descriptor) {
        const { name } = descriptor;
        this.registerAs(name, descriptor);
    }
    /**
     * Registers an icon based on a uniqe name and metadata provided by `@carbon/icons`
     */
    registerAs(name, descriptor) {
        const { size } = descriptor;
        this.iconCache.set(name, size.toString(), descriptor);
    }
    /**
     * Gets an icon, converts it to a string, and caches the result
     */
    get(name, size) {
        try {
            const icon = this.iconCache.get(name, size.toString());
            if (!icon.svg) {
                icon.svg = (0,_carbon_icon_helpers__WEBPACK_IMPORTED_MODULE_55__.toString)(icon);
            }
            return icon;
        }
        catch (e) {
            throw e;
        }
    }
    /**
     * Configure various service settings (caching strategy ...)
     */
    configure(options) {
        this.iconCache = options.cache;
    }
}
IconService.fac = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareFactory"]({ minVersion: "12.0.0", version: "14.3.0", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: IconService, deps: [], target: _angular_core__WEBPACK_IMPORTED_MODULE_0__["FactoryTarget"].Injectable });
IconService.prov = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareInjectable"]({ minVersion: "12.0.0", version: "14.3.0", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: IconService });
_angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareClassMetadata"]({ minVersion: "12.0.0", version: "14.3.0", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: IconService, decorators: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Injectable
        }] });

/**
 * A directive for populating a svg element based on the provided carbon icon name.
 *
 * Get started with importing the module:
 *
 * ```typescript
 * import { IconModule } from 'carbon-components-angular';
 * ```
 *
 * [See demo](../../?path=/story/components-icon--basic)
 */
class IconDirective {
    constructor(elementRef, iconService) {
        this.elementRef = elementRef;
        this.iconService = iconService;
        this.cdsIcon = "";
        this.size = "16";
        this.title = "";
        this.ariaLabel = "";
        this.ariaLabelledBy = "";
        this.ariaHidden = "";
        this.isFocusable = false;
    }
    /**
     * @deprecated since v5 - Use `cdsIcon` input property instead
     */
    set ibmIcon(iconName) {
        this.cdsIcon = iconName;
    }
    renderIcon(iconName) {
        const root = this.elementRef.nativeElement;
        let icon;
        try {
            icon = this.iconService.get(iconName, this.size.toString());
        }
        catch (error) {
            console.warn(error);
            // bail out
            return;
        }
        const domParser = new DOMParser();
        const rawSVG = icon.svg;
        const svgElement = domParser.parseFromString(rawSVG, "image/svg+xml").documentElement;
        let node = root.tagName.toUpperCase() !== "SVG" ? svgElement : svgElement.firstChild;
        root.innerHTML = ""; // Clear root element
        while (node) {
            // importNode makes a clone of the node
            // this ensures we keep looping over the nodes in the parsed document
            root.appendChild(root.ownerDocument.importNode(node, true));
            // type the node because the angular compiler freaks out if it
            // ends up thinking it's a `Node` instead of a `ChildNode`
            node = node.nextSibling;
        }
        const svg = root.tagName.toUpperCase() !== "SVG" ? svgElement : root;
        svg.setAttribute("xmlns", "http://www.w3.org/2000/svg");
        const attributes = (0,_carbon_icon_helpers__WEBPACK_IMPORTED_MODULE_55__.getAttributes)({
            width: icon.attrs.width,
            height: icon.attrs.height,
            viewBox: icon.attrs.viewBox,
            title: this.title,
            "aria-label": this.ariaLabel,
            "aria-labelledby": this.ariaLabelledBy,
            "aria-hidden": this.ariaHidden,
            focusable: this.isFocusable.toString()
        });
        const attrKeys = Object.keys(attributes);
        for (let i = 0; i < attrKeys.length; i++) {
            const key = attrKeys[i];
            const value = attributes[key];
            if (key === "title") {
                continue;
            }
            if (value) {
                svg.setAttribute(key, value);
            }
        }
        if (attributes["title"]) {
            const title = document.createElement("title");
            title.textContent = attributes.title;
            IconDirective.titleIdCounter++;
            title.setAttribute("id", `${icon.name}-title-${IconDirective.titleIdCounter}`);
            // title must be first for screen readers
            svg.insertBefore(title, svg.firstElementChild);
            svg.setAttribute("aria-labelledby", `${icon.name}-title-${IconDirective.titleIdCounter}`);
        }
    }
    ngAfterViewInit() {
        this.renderIcon(this.cdsIcon);
    }
    ngOnChanges({ cdsIcon }) {
        // We want to ignore first change to let the icon register
        // and add only after view has been initialized
        if (cdsIcon && !cdsIcon.isFirstChange()) {
            this.renderIcon(this.cdsIcon);
        }
    }
}
IconDirective.titleIdCounter = 0;
IconDirective.fac = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareFactory"]({ minVersion: "12.0.0", version: "14.3.0", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: IconDirective, deps: [{ token: _angular_core__WEBPACK_IMPORTED_MODULE_0__.ElementRef }, { token: IconService }], target: _angular_core__WEBPACK_IMPORTED_MODULE_0__["FactoryTarget"].Directive });
IconDirective.dir = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareDirective"]({ minVersion: "14.0.0", version: "14.3.0", type: IconDirective, selector: "[cdsIcon], [ibmIcon]", inputs: { ibmIcon: "ibmIcon", cdsIcon: "cdsIcon", size: "size", title: "title", ariaLabel: "ariaLabel", ariaLabelledBy: "ariaLabelledBy", ariaHidden: "ariaHidden", isFocusable: "isFocusable" }, usesOnChanges: true, ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))) });
_angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareClassMetadata"]({ minVersion: "12.0.0", version: "14.3.0", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: IconDirective, decorators: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Directive,
            args: [{
                    selector: "[cdsIcon], [ibmIcon]"
                }]
        }], ctorParameters: function () { return [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.ElementRef }, { type: IconService }]; }, propDecorators: { ibmIcon: [{
                type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input
            }], cdsIcon: [{
                type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input
            }], size: [{
                type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input
            }], title: [{
                type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input
            }], ariaLabel: [{
                type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input
            }], ariaLabelledBy: [{
                type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input
            }], ariaHidden: [{
                type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input
            }], isFocusable: [{
                type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input
            }] } });

// modules
// either provides a new instance of IconService, or returns the parent
function ICON_SERVICE_PROVIDER_FACTORY(parentService) {
    return parentService || new IconService();
}
// icon service *must* be a singleton to ensure that icons are accessible globally and not duplicated
const ICON_SERVICE_PROVIDER = {
    provide: IconService,
    deps: [[new _angular_core__WEBPACK_IMPORTED_MODULE_0__.Optional(), new _angular_core__WEBPACK_IMPORTED_MODULE_0__.SkipSelf(), IconService]],
    useFactory: ICON_SERVICE_PROVIDER_FACTORY
};
class IconModule {
    constructor(iconService) {
        this.iconService = iconService;
        iconService.registerAll([
            _carbon_icons_es_add_16__WEBPACK_IMPORTED_MODULE_2__["default"],
            _carbon_icons_es_add_20__WEBPACK_IMPORTED_MODULE_3__["default"],
            _carbon_icons_es_bee_16__WEBPACK_IMPORTED_MODULE_4__["default"],
            _carbon_icons_es_bee_20__WEBPACK_IMPORTED_MODULE_5__["default"],
            _carbon_icons_es_calendar_16__WEBPACK_IMPORTED_MODULE_6__["default"],
            _carbon_icons_es_carbon_16__WEBPACK_IMPORTED_MODULE_7__["default"],
            _carbon_icons_es_carbon_20__WEBPACK_IMPORTED_MODULE_8__["default"],
            _carbon_icons_es_caret_down_16__WEBPACK_IMPORTED_MODULE_9__["default"],
            _carbon_icons_es_caret_left_16__WEBPACK_IMPORTED_MODULE_10__["default"],
            _carbon_icons_es_caret_right_16__WEBPACK_IMPORTED_MODULE_11__["default"],
            _carbon_icons_es_caret_up_16__WEBPACK_IMPORTED_MODULE_12__["default"],
            _carbon_icons_es_checkmark_16__WEBPACK_IMPORTED_MODULE_13__["default"],
            _carbon_icons_es_checkmark_filled_16__WEBPACK_IMPORTED_MODULE_14__["default"],
            _carbon_icons_es_checkmark_filled_20__WEBPACK_IMPORTED_MODULE_15__["default"],
            _carbon_icons_es_checkmark_outline_16__WEBPACK_IMPORTED_MODULE_16__["default"],
            _carbon_icons_es_chevron_down_16__WEBPACK_IMPORTED_MODULE_17__["default"],
            _carbon_icons_es_chevron_right_16__WEBPACK_IMPORTED_MODULE_18__["default"],
            _carbon_icons_es_circle_dash_16__WEBPACK_IMPORTED_MODULE_19__["default"],
            _carbon_icons_es_close_16__WEBPACK_IMPORTED_MODULE_20__["default"],
            _carbon_icons_es_close_20__WEBPACK_IMPORTED_MODULE_21__["default"],
            _carbon_icons_es_copy_16__WEBPACK_IMPORTED_MODULE_22__["default"],
            _carbon_icons_es_copy_20__WEBPACK_IMPORTED_MODULE_23__["default"],
            _carbon_icons_es_data_2_16__WEBPACK_IMPORTED_MODULE_24__["default"],
            _carbon_icons_es_data_2_20__WEBPACK_IMPORTED_MODULE_25__["default"],
            _carbon_icons_es_document_16__WEBPACK_IMPORTED_MODULE_26__["default"],
            _carbon_icons_es_document_20__WEBPACK_IMPORTED_MODULE_27__["default"],
            _carbon_icons_es_download_16__WEBPACK_IMPORTED_MODULE_28__["default"],
            _carbon_icons_es_error_filled_16__WEBPACK_IMPORTED_MODULE_29__["default"],
            _carbon_icons_es_error_filled_20__WEBPACK_IMPORTED_MODULE_30__["default"],
            _carbon_icons_es_fade_16__WEBPACK_IMPORTED_MODULE_31__["default"],
            _carbon_icons_es_fade_20__WEBPACK_IMPORTED_MODULE_32__["default"],
            _carbon_icons_es_folder_16__WEBPACK_IMPORTED_MODULE_33__["default"],
            _carbon_icons_es_incomplete_16__WEBPACK_IMPORTED_MODULE_34__["default"],
            _carbon_icons_es_information_filled_16__WEBPACK_IMPORTED_MODULE_35__["default"],
            _carbon_icons_es_information_filled_20__WEBPACK_IMPORTED_MODULE_36__["default"],
            _carbon_icons_es_information_square_filled_20__WEBPACK_IMPORTED_MODULE_37__["default"],
            _carbon_icons_es_menu_16__WEBPACK_IMPORTED_MODULE_38__["default"],
            _carbon_icons_es_menu_20__WEBPACK_IMPORTED_MODULE_39__["default"],
            _carbon_icons_es_overflow_menu_vertical_16__WEBPACK_IMPORTED_MODULE_40__["default"],
            _carbon_icons_es_overflow_menu_horizontal_16__WEBPACK_IMPORTED_MODULE_41__["default"],
            _carbon_icons_es_save_16__WEBPACK_IMPORTED_MODULE_42__["default"],
            _carbon_icons_es_search_16__WEBPACK_IMPORTED_MODULE_43__["default"],
            _carbon_icons_es_settings_16__WEBPACK_IMPORTED_MODULE_44__["default"],
            _carbon_icons_es_settings_adjust_16__WEBPACK_IMPORTED_MODULE_45__["default"],
            _carbon_icons_es_subtract_16__WEBPACK_IMPORTED_MODULE_46__["default"],
            _carbon_icons_es_trash_can_16__WEBPACK_IMPORTED_MODULE_47__["default"],
            _carbon_icons_es_view_16__WEBPACK_IMPORTED_MODULE_53__["default"],
            _carbon_icons_es_view_off_16__WEBPACK_IMPORTED_MODULE_54__["default"],
            _carbon_icons_es_warning_16__WEBPACK_IMPORTED_MODULE_48__["default"],
            _carbon_icons_es_warning_filled_16__WEBPACK_IMPORTED_MODULE_49__["default"],
            _carbon_icons_es_warning_filled_20__WEBPACK_IMPORTED_MODULE_50__["default"],
            _carbon_icons_es_warning_alt_filled_16__WEBPACK_IMPORTED_MODULE_51__["default"],
            _carbon_icons_es_warning_alt_filled_20__WEBPACK_IMPORTED_MODULE_52__["default"]
        ]);
    }
}
IconModule.fac = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareFactory"]({ minVersion: "12.0.0", version: "14.3.0", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: IconModule, deps: [{ token: IconService }], target: _angular_core__WEBPACK_IMPORTED_MODULE_0__["FactoryTarget"].NgModule });
IconModule.mod = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareNgModule"]({ minVersion: "14.0.0", version: "14.3.0", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: IconModule, declarations: [IconDirective], imports: [_angular_common__WEBPACK_IMPORTED_MODULE_1__.CommonModule], exports: [IconDirective] });
IconModule.inj = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareInjector"]({ minVersion: "12.0.0", version: "14.3.0", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: IconModule, providers: [
        ICON_SERVICE_PROVIDER
    ], imports: [_angular_common__WEBPACK_IMPORTED_MODULE_1__.CommonModule] });
_angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareClassMetadata"]({ minVersion: "12.0.0", version: "14.3.0", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: IconModule, decorators: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.NgModule,
            args: [{
                    declarations: [
                        IconDirective
                    ],
                    exports: [
                        IconDirective
                    ],
                    imports: [
                        _angular_common__WEBPACK_IMPORTED_MODULE_1__.CommonModule
                    ],
                    providers: [
                        ICON_SERVICE_PROVIDER
                    ]
                }]
        }], ctorParameters: function () { return [{ type: IconService }]; } });

/**
 * Generated bundle index. Do not edit.
 */


//# sourceMappingURL=carbon-components-angular-icon.mjs.map


/***/ }),

/***/ "../../../node_modules/carbon-components-angular/fesm2020/carbon-components-angular-placeholder.mjs":
/*!**********************************************************************************************************!*\
  !*** ../../../node_modules/carbon-components-angular/fesm2020/carbon-components-angular-placeholder.mjs ***!
  \**********************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

var _angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache;
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   PLACEHOLDER_SERVICE_PROVIDER: () => (/* binding */ PLACEHOLDER_SERVICE_PROVIDER),
/* harmony export */   PLACEHOLDER_SERVICE_PROVIDER_FACTORY: () => (/* binding */ PLACEHOLDER_SERVICE_PROVIDER_FACTORY),
/* harmony export */   Placeholder: () => (/* binding */ Placeholder),
/* harmony export */   PlaceholderModule: () => (/* binding */ PlaceholderModule),
/* harmony export */   PlaceholderService: () => (/* binding */ PlaceholderService)
/* harmony export */ });
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @angular/core */ "@angular/core");
/* harmony import */ var _angular_common__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @angular/common */ "@angular/common");




/**
 * Singleton service used to register the container for out-of-flow components to insert into.
 * Also used to insert/remove components from that view.
 */
class PlaceholderService {
    constructor() {
        /**
         * Main `ViewContainerRef` to insert components into
         */
        this.viewContainerRef = null;
        /**
         * Map of id's to secondary `ViewContainerRef`s
         */
        this.viewContainerMap = new Map();
    }
    /**
     * Used by `Placeholder` to register view-container reference.
     */
    registerViewContainerRef(vcRef, id) {
        if (id) {
            this.viewContainerMap.set(id, vcRef);
        }
        else {
            this.viewContainerRef = vcRef;
        }
    }
    /**
     * Creates and returns component in the view.
     */
    createComponent(component, injector, id) {
        if (id) {
            if (!this.viewContainerMap.has(id)) {
                console.error(`No view container with id ${id} found`);
                return;
            }
            return this.viewContainerMap.get(id).createComponent(component, { index: this.viewContainerMap.size, injector });
        }
        if (!this.viewContainerRef) {
            console.error("No view container defined! Likely due to a missing `cds-placeholder`");
            return;
        }
        return this.viewContainerRef.createComponent(component, { index: this.viewContainerRef.length, injector });
    }
    destroyComponent(component) {
        component.destroy();
    }
    hasComponentRef(component, id) {
        if (id) {
            return !(this.viewContainerMap.get(id).indexOf(component.hostView) < 0);
        }
        return !(this.viewContainerRef.indexOf(component.hostView) < 0);
    }
    hasPlaceholderRef(id) {
        if (id) {
            return this.viewContainerMap.has(id);
        }
        return !!this.viewContainerRef;
    }
    appendElement(element, id) {
        if (id) {
            return this.viewContainerMap.get(id).element.nativeElement.appendChild(element);
        }
        return this.viewContainerRef.element.nativeElement.appendChild(element);
    }
    removeElement(element, id) {
        if (id) {
            return this.viewContainerMap.get(id).element.nativeElement.removeChild(element);
        }
        return this.viewContainerRef.element.nativeElement.removeChild(element);
    }
    hasElement(element, id) {
        if (id) {
            return this.viewContainerMap.get(id).element.nativeElement.contains(element);
        }
        return this.viewContainerRef.element.nativeElement.contains(element);
    }
}
PlaceholderService.fac = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareFactory"]({ minVersion: "12.0.0", version: "14.3.0", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: PlaceholderService, deps: [], target: _angular_core__WEBPACK_IMPORTED_MODULE_0__["FactoryTarget"].Injectable });
PlaceholderService.prov = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareInjectable"]({ minVersion: "12.0.0", version: "14.3.0", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: PlaceholderService });
_angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareClassMetadata"]({ minVersion: "12.0.0", version: "14.3.0", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: PlaceholderService, decorators: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Injectable
        }] });

/**
 * Using a modal, dialog (Tooltip, OverflowMenu), or any other component that draws out of the normal page flow
 * in your application *requires* this component (`cds-placeholder`).
 * It would generally be placed near the end of your root app component template
 * (app.component.ts or app.component.html) as:
 *
 * ```
 * <cds-placeholder></cds-placeholder>
 * ```
 */
class Placeholder {
    /**
     * Creates an instance of `Placeholder`.
     */
    constructor(placeholderService) {
        this.placeholderService = placeholderService;
    }
    /**
     * Registers the components view with `PlaceholderService`
     */
    ngOnInit() {
        // TODO use `id` to register with the placeholderService
        this.placeholderService.registerViewContainerRef(this.viewContainerRef);
    }
}
Placeholder.fac = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareFactory"]({ minVersion: "12.0.0", version: "14.3.0", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: Placeholder, deps: [{ token: PlaceholderService }], target: _angular_core__WEBPACK_IMPORTED_MODULE_0__["FactoryTarget"].Component });
Placeholder.cmp = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareComponent"]({ minVersion: "14.0.0", version: "14.3.0", type: Placeholder, selector: "cds-placeholder, ibm-placeholder", inputs: { id: "id" }, viewQueries: [{ propertyName: "viewContainerRef", first: true, predicate: ["placeholder"], descendants: true, read: _angular_core__WEBPACK_IMPORTED_MODULE_0__.ViewContainerRef, static: true }], ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), template: `<div #placeholder></div>`, isInline: true });
_angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareClassMetadata"]({ minVersion: "12.0.0", version: "14.3.0", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: Placeholder, decorators: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Component,
            args: [{
                    selector: "cds-placeholder, ibm-placeholder",
                    template: `<div #placeholder></div>`
                }]
        }], ctorParameters: function () { return [{ type: PlaceholderService }]; }, propDecorators: { id: [{
                type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input
            }], viewContainerRef: [{
                type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.ViewChild,
                args: ["placeholder", { read: _angular_core__WEBPACK_IMPORTED_MODULE_0__.ViewContainerRef, static: true }]
            }] } });

// modules
// either provides a new instance of PlaceholderService, or returns the parent
function PLACEHOLDER_SERVICE_PROVIDER_FACTORY(parentService) {
    return parentService || new PlaceholderService();
}
// placeholder service *must* be a singleton to ensure the placeholder viewRef is accessible globally
const PLACEHOLDER_SERVICE_PROVIDER = {
    provide: PlaceholderService,
    deps: [[new _angular_core__WEBPACK_IMPORTED_MODULE_0__.Optional(), new _angular_core__WEBPACK_IMPORTED_MODULE_0__.SkipSelf(), PlaceholderService]],
    useFactory: PLACEHOLDER_SERVICE_PROVIDER_FACTORY
};
class PlaceholderModule {
}
PlaceholderModule.fac = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareFactory"]({ minVersion: "12.0.0", version: "14.3.0", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: PlaceholderModule, deps: [], target: _angular_core__WEBPACK_IMPORTED_MODULE_0__["FactoryTarget"].NgModule });
PlaceholderModule.mod = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareNgModule"]({ minVersion: "14.0.0", version: "14.3.0", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: PlaceholderModule, declarations: [Placeholder], imports: [_angular_common__WEBPACK_IMPORTED_MODULE_1__.CommonModule], exports: [Placeholder] });
PlaceholderModule.inj = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareInjector"]({ minVersion: "12.0.0", version: "14.3.0", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: PlaceholderModule, providers: [PLACEHOLDER_SERVICE_PROVIDER], imports: [_angular_common__WEBPACK_IMPORTED_MODULE_1__.CommonModule] });
_angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareClassMetadata"]({ minVersion: "12.0.0", version: "14.3.0", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: PlaceholderModule, decorators: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.NgModule,
            args: [{
                    declarations: [Placeholder],
                    exports: [Placeholder],
                    providers: [PLACEHOLDER_SERVICE_PROVIDER],
                    imports: [_angular_common__WEBPACK_IMPORTED_MODULE_1__.CommonModule]
                }]
        }] });

/**
 * Generated bundle index. Do not edit.
 */


//# sourceMappingURL=carbon-components-angular-placeholder.mjs.map


/***/ }),

/***/ "../../../node_modules/carbon-components-angular/fesm2020/carbon-components-angular-utils.mjs":
/*!****************************************************************************************************!*\
  !*** ../../../node_modules/carbon-components-angular/fesm2020/carbon-components-angular-utils.mjs ***!
  \****************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

var _angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache;
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ANIMATION_FRAME_SERVICE_SINGLETON_PROVIDER: () => (/* binding */ ANIMATION_FRAME_SERVICE_SINGLETON_PROVIDER),
/* harmony export */   ANIMATION_FRAME_SERVICE_SINGLETON_PROVIDER_FACTORY: () => (/* binding */ ANIMATION_FRAME_SERVICE_SINGLETON_PROVIDER_FACTORY),
/* harmony export */   AnimationFrameService: () => (/* binding */ AnimationFrameService),
/* harmony export */   AnimationFrameServiceSingleton: () => (/* binding */ AnimationFrameServiceSingleton),
/* harmony export */   DOCUMENT_SERVICE_PROVIDER: () => (/* binding */ DOCUMENT_SERVICE_PROVIDER),
/* harmony export */   DOCUMENT_SERVICE_PROVIDER_FACTORY: () => (/* binding */ DOCUMENT_SERVICE_PROVIDER_FACTORY),
/* harmony export */   DocumentService: () => (/* binding */ DocumentService),
/* harmony export */   ElementService: () => (/* binding */ ElementService),
/* harmony export */   EventService: () => (/* binding */ EventService),
/* harmony export */   HcModeChecker: () => (/* binding */ HcModeChecker),
/* harmony export */   PLACEMENTS: () => (/* reexport safe */ _carbon_utils_position__WEBPACK_IMPORTED_MODULE_2__.PLACEMENTS),
/* harmony export */   Position: () => (/* reexport safe */ _carbon_utils_position__WEBPACK_IMPORTED_MODULE_2__.Position),
/* harmony export */   UtilsModule: () => (/* binding */ UtilsModule),
/* harmony export */   clone: () => (/* binding */ clone),
/* harmony export */   closestAttr: () => (/* binding */ closestAttr),
/* harmony export */   defaultPositions: () => (/* reexport safe */ _carbon_utils_position__WEBPACK_IMPORTED_MODULE_2__.defaultPositions),
/* harmony export */   findNextElem: () => (/* binding */ findNextElem),
/* harmony export */   findPrevElem: () => (/* binding */ findPrevElem),
/* harmony export */   focusNextElem: () => (/* binding */ focusNextElem),
/* harmony export */   focusNextTree: () => (/* binding */ focusNextTree),
/* harmony export */   focusPrevElem: () => (/* binding */ focusPrevElem),
/* harmony export */   getEventObservable: () => (/* binding */ getEventObservable),
/* harmony export */   getScrollableParents: () => (/* binding */ getScrollableParents),
/* harmony export */   getScrollbarWidth: () => (/* binding */ getScrollbarWidth),
/* harmony export */   hasScrollableParents: () => (/* binding */ hasScrollableParents),
/* harmony export */   isScrollableElement: () => (/* binding */ isScrollableElement),
/* harmony export */   isVisibleInContainer: () => (/* binding */ isVisibleInContainer),
/* harmony export */   merge: () => (/* binding */ merge),
/* harmony export */   position: () => (/* reexport safe */ _carbon_utils_position__WEBPACK_IMPORTED_MODULE_2__.position),
/* harmony export */   scrollableParentsObservable: () => (/* binding */ scrollableParentsObservable)
/* harmony export */ });
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @angular/core */ "@angular/core");
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! rxjs */ "rxjs");
/* harmony import */ var _carbon_utils_position__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @carbon/utils-position */ "../../../node_modules/carbon-components-angular/node_modules/@carbon/utils-position/index.js");
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! rxjs/operators */ "../../../node_modules/rxjs/dist/esm5/internal/operators/map.js");






function findSiblingElem(target, direction) {
    if (target[direction]) {
        if (target[direction].classList.contains("disabled")) {
            return findSiblingElem(target[direction], direction);
        }
        return target[direction];
    }
}
function findNextElem(target) {
    return findSiblingElem(target, "nextElementSibling");
}
function findPrevElem(target) {
    return findSiblingElem(target, "previousElementSibling");
}
// check for Hight contrast mode
function HcModeChecker() {
    let colorTest = "rgb(255, 0, 0)";
    let htmlChecker = document.createElement("div");
    htmlChecker.classList.add("hc-checker");
    document.body.appendChild(htmlChecker);
    if (window.getComputedStyle(htmlChecker).backgroundColor.toString() !== colorTest) {
        document.body.classList.add("a11y");
    }
    document.body.removeChild(htmlChecker);
}
function focusNextTree(elem, rootElem = null) {
    if (elem) {
        let focusable = elem.querySelector("[tabindex='0']");
        if (focusable) {
            focusable.focus();
        }
        else {
            focusNextElem(elem, rootElem);
        }
    }
}
function focusNextElem(elem, rootElem = null) {
    if (elem) {
        let nextElem = elem.nextElementSibling;
        if (nextElem) {
            let focusableElem = nextElem.querySelector("[tabindex='0']");
            if (focusableElem) {
                focusableElem.focus();
            }
            else {
                focusNextElem(nextElem, rootElem);
            }
        }
        else {
            if (rootElem) {
                let nextRootElem = rootElem.nextElementSibling;
                if (nextRootElem) {
                    focusNextTree(nextRootElem, rootElem);
                }
            }
        }
    }
}
function focusPrevElem(elem, parentRef = null) {
    if (elem) {
        let prevElem = elem.previousElementSibling;
        if (prevElem) {
            let focusableElem = prevElem.querySelector("[tabindex='0']");
            if (focusableElem) {
                if (focusableElem.getAttribute("aria-expanded") === "true") {
                    let lastFocElms = prevElem.querySelectorAll("[tabindex='0']");
                    let arrLen = lastFocElms.length - 1;
                    for (let i = arrLen; i >= 0; i--) {
                        if (!!(lastFocElms[i].offsetWidth || lastFocElms[i].offsetHeight ||
                            lastFocElms[i].getClientRects().length)) {
                            focusableElem = lastFocElms[i];
                            break;
                        }
                    }
                }
                focusableElem.focus();
            }
            else {
                focusPrevElem(prevElem, parentRef);
            }
        }
        else {
            if (parentRef) {
                parentRef.querySelector("[tabindex='0']").focus();
            }
        }
    }
}

class AnimationFrameServiceSingleton {
    constructor(ngZone) {
        this.ngZone = ngZone;
        this.frameSource = new rxjs__WEBPACK_IMPORTED_MODULE_1__.Subject();
        this.tick = this.frameSource.asObservable();
        this.ngZone.runOutsideAngular(() => {
            this.animationFrameId = requestAnimationFrame(this.doTick.bind(this));
        });
    }
    ngOnDestroy() {
        cancelAnimationFrame(this.animationFrameId);
    }
    doTick(frame) {
        this.frameSource.next(frame);
        this.ngZone.runOutsideAngular(() => {
            requestAnimationFrame(this.doTick.bind(this));
        });
    }
}
AnimationFrameServiceSingleton.fac = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareFactory"]({ minVersion: "12.0.0", version: "14.3.0", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: AnimationFrameServiceSingleton, deps: [{ token: _angular_core__WEBPACK_IMPORTED_MODULE_0__.NgZone }], target: _angular_core__WEBPACK_IMPORTED_MODULE_0__["FactoryTarget"].Injectable });
AnimationFrameServiceSingleton.prov = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareInjectable"]({ minVersion: "12.0.0", version: "14.3.0", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: AnimationFrameServiceSingleton });
_angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareClassMetadata"]({ minVersion: "12.0.0", version: "14.3.0", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: AnimationFrameServiceSingleton, decorators: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Injectable
        }], ctorParameters: function () { return [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.NgZone }]; } });
class AnimationFrameService {
    constructor(singleton) {
        this.singleton = singleton;
        this.tick = (0,rxjs__WEBPACK_IMPORTED_MODULE_1__.from)(this.singleton.tick);
    }
}
AnimationFrameService.fac = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareFactory"]({ minVersion: "12.0.0", version: "14.3.0", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: AnimationFrameService, deps: [{ token: AnimationFrameServiceSingleton }], target: _angular_core__WEBPACK_IMPORTED_MODULE_0__["FactoryTarget"].Injectable });
AnimationFrameService.prov = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareInjectable"]({ minVersion: "12.0.0", version: "14.3.0", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: AnimationFrameService });
_angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareClassMetadata"]({ minVersion: "12.0.0", version: "14.3.0", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: AnimationFrameService, decorators: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Injectable
        }], ctorParameters: function () { return [{ type: AnimationFrameServiceSingleton }]; } });

// custom deep object merge
const merge = (target, ...objects) => {
    for (const object of objects) {
        for (const key in object) {
            if (object.hasOwnProperty(key)) {
                // since we're dealing just with JSON this simple check should be enough
                if (object[key] instanceof Object) {
                    if (!target[key]) {
                        target[key] = {};
                    }
                    // recursively merge into the target
                    // most translations only run 3 or 4 levels deep, so no stack explosions
                    target[key] = merge(target[key], object[key]);
                }
                else {
                    target[key] = object[key];
                }
            }
        }
    }
    return target;
};

/**
 * Checks if a given element is scrollable.
 * If the element has an overflow set as part of its computed style it can scroll.
 * @param element the element to check scrollability
 */
const isScrollableElement = (element) => {
    const computedStyle = getComputedStyle(element);
    return (computedStyle.overflow === "auto" ||
        computedStyle.overflow === "scroll" ||
        computedStyle["overflow-y"] === "auto" ||
        computedStyle["overflow-y"] === "scroll" ||
        computedStyle["overflow-x"] === "auto" ||
        computedStyle["overflow-x"] === "scroll");
};
/**
 * Checks if an element is visible within a container
 * @param element the element to check
 * @param container the container to check
 */
const isVisibleInContainer = (element, container) => {
    const elementRect = element.getBoundingClientRect();
    const containerRect = container.getBoundingClientRect();
    // If there exists `height: 100%` on the `html` or `body` tag of an application,
    // it causes the calculation to return true if you need to scroll before the element is seen.
    // In that case we calculate its visibility based on the window viewport.
    if (container.tagName === "BODY" || container.tagName === "HTML") {
        // This checks if element is within the top, bottom, left and right of viewport, ie. if the element is visible in
        // the screen. This also takes into account partial visibility of an element.
        const isAboveViewport = elementRect.top < 0 && (elementRect.top + element.clientHeight) < 0;
        const isLeftOfViewport = elementRect.left < 0;
        const isBelowViewport = (elementRect.bottom - element.clientHeight) > (window.innerHeight || document.documentElement.clientHeight);
        const isRightOfViewport = elementRect.right > (window.innerWidth || document.documentElement.clientWidth);
        const isVisibleInViewport = !(isAboveViewport || isBelowViewport || isLeftOfViewport || isRightOfViewport);
        return isVisibleInViewport;
    }
    return (
    // This also accounts for partial visibility. It will still return true if the element is partially visible inside the container.
    (elementRect.bottom - element.clientHeight) <= (containerRect.bottom + (container.offsetHeight - container.clientHeight) / 2) &&
        elementRect.top >= (-element.clientHeight));
};
const getScrollableParents = (node) => {
    const elements = [document.body];
    while (node.parentElement && node !== document.body) {
        if (isScrollableElement(node)) {
            elements.push(node);
        }
        node = node.parentElement;
    }
    return elements;
};
const hasScrollableParents = (node) => {
    while (node.parentElement && node !== document.body) {
        if (isScrollableElement(node)) {
            return true;
        }
        node = node.parentElement;
    }
    return false;
};
/**
 * Returns an observable that emits whenever any scrollable parent element scrolls
 *
 * @param node root element to start finding scrolling parents from
 */
const scrollableParentsObservable = (node) => {
    const windowScroll = (0,rxjs__WEBPACK_IMPORTED_MODULE_1__.fromEvent)(window, "scroll", { passive: true }).pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_3__.map)(event => 
    // update the event target to be something useful. In this case `body` is a sensible replacement
    Object.assign({}, event, { target: document.body })));
    let observables = [windowScroll];
    // walk the parents and subscribe to all the scroll events we can
    while (node.parentElement && node !== document.body) {
        if (isScrollableElement(node)) {
            observables.push((0,rxjs__WEBPACK_IMPORTED_MODULE_1__.fromEvent)(node, "scroll", { passive: true }));
        }
        node = node.parentElement;
    }
    return (0,rxjs__WEBPACK_IMPORTED_MODULE_1__.merge)(...observables);
};

function clone(obj) {
    return JSON.parse(JSON.stringify(obj));
}
function matchesAttr(el, attr, val) {
    const styles = window.getComputedStyle(el);
    return val.includes(styles[attr]);
}
function closestAttr(s, t, element) {
    let el = element;
    if (!element) {
        return null;
    }
    do {
        if (matchesAttr(el, s, t)) {
            return el;
        }
        el = el.parentElement || el.parentNode;
    } while (el !== null && el.nodeType === 1);
    return null;
}

class ElementService {
    constructor(singleton) {
        this.singleton = singleton;
        this.tick = (0,rxjs__WEBPACK_IMPORTED_MODULE_1__.from)(this.singleton.tick);
    }
    visibility(target, parentElement = target) {
        const scrollableParents = getScrollableParents(parentElement);
        return this.tick.pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_3__.map)(() => {
            for (const parent of scrollableParents) {
                if (!isVisibleInContainer(target, parent)) {
                    return {
                        visible: false
                    };
                }
            }
            return {
                visible: true
            };
        }));
    }
}
ElementService.fac = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareFactory"]({ minVersion: "12.0.0", version: "14.3.0", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: ElementService, deps: [{ token: AnimationFrameServiceSingleton }], target: _angular_core__WEBPACK_IMPORTED_MODULE_0__["FactoryTarget"].Injectable });
ElementService.prov = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareInjectable"]({ minVersion: "12.0.0", version: "14.3.0", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: ElementService });
_angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareClassMetadata"]({ minVersion: "12.0.0", version: "14.3.0", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: ElementService, decorators: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Injectable
        }], ctorParameters: function () { return [{ type: AnimationFrameServiceSingleton }]; } });

const getEventObservable = (targetElement, eventType) => {
    switch (eventType) {
        case "scroll":
        case "resize":
        case "touchstart":
        case "touchmove":
        case "touchend":
            return (0,rxjs__WEBPACK_IMPORTED_MODULE_1__.fromEvent)(targetElement, eventType, { passive: true });
        default:
            return (0,rxjs__WEBPACK_IMPORTED_MODULE_1__.fromEvent)(targetElement, eventType);
    }
};

class DocumentService {
    constructor() {
        this.globalEvents = new Map();
        this.documentRef = document;
        this.subscriptions = new rxjs__WEBPACK_IMPORTED_MODULE_1__.Subscription();
    }
    handleEvent(eventType, callback) {
        if (!this.globalEvents.has(eventType)) {
            if (this.documentRef) {
                this.globalEvents.set(eventType, getEventObservable(this.documentRef, eventType));
            }
            else {
                this.globalEvents.set(eventType, new rxjs__WEBPACK_IMPORTED_MODULE_1__.Observable());
            }
        }
        const observable = this.globalEvents.get(eventType);
        this.subscriptions.add(observable.subscribe(callback));
    }
    handleClick(callback) {
        this.handleEvent("click", callback);
    }
    ngOnDestroy() {
        this.subscriptions.unsubscribe();
        this.globalEvents = null;
    }
}
DocumentService.fac = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareFactory"]({ minVersion: "12.0.0", version: "14.3.0", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: DocumentService, deps: [], target: _angular_core__WEBPACK_IMPORTED_MODULE_0__["FactoryTarget"].Injectable });
DocumentService.prov = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareInjectable"]({ minVersion: "12.0.0", version: "14.3.0", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: DocumentService });
_angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareClassMetadata"]({ minVersion: "12.0.0", version: "14.3.0", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: DocumentService, decorators: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Injectable
        }] });

class EventService {
    constructor(documentService) {
        this.documentService = documentService;
        this.subscriptions = new rxjs__WEBPACK_IMPORTED_MODULE_1__.Subscription();
        this.targets = new WeakMap();
    }
    on(targetElement, eventType, callback) {
        if (!this.targets.has(targetElement)) {
            this.targets.set(targetElement, new Map());
        }
        const eventMap = this.targets.get(targetElement);
        if (!eventMap.has(eventType)) {
            eventMap.set(eventType, getEventObservable(targetElement, eventType));
        }
        const subscription = eventMap.get(eventType).subscribe(callback);
        this.subscriptions.add(subscription);
    }
    onDocument(eventType, callback) {
        this.documentService.handleEvent(eventType, callback);
    }
    ngOnDestroy() {
        this.subscriptions.unsubscribe();
    }
}
EventService.fac = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareFactory"]({ minVersion: "12.0.0", version: "14.3.0", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: EventService, deps: [{ token: DocumentService }], target: _angular_core__WEBPACK_IMPORTED_MODULE_0__["FactoryTarget"].Injectable });
EventService.prov = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareInjectable"]({ minVersion: "12.0.0", version: "14.3.0", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: EventService });
_angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareClassMetadata"]({ minVersion: "12.0.0", version: "14.3.0", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: EventService, decorators: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Injectable
        }], ctorParameters: function () { return [{ type: DocumentService }]; } });

// either provides a new instance of DocumentService, or returns the parent
function DOCUMENT_SERVICE_PROVIDER_FACTORY(parentService) {
    return parentService || new DocumentService();
}
// DocumentService *must* be a singleton to ensure that we handle events and other document level settings once (and only once)
const DOCUMENT_SERVICE_PROVIDER = {
    provide: DocumentService,
    deps: [[new _angular_core__WEBPACK_IMPORTED_MODULE_0__.Optional(), new _angular_core__WEBPACK_IMPORTED_MODULE_0__.SkipSelf(), DocumentService]],
    useFactory: DOCUMENT_SERVICE_PROVIDER_FACTORY
};
// either provides a new instance of AnimationFrameServiceSingleton, or returns the parent
function ANIMATION_FRAME_SERVICE_SINGLETON_PROVIDER_FACTORY(parentService, ngZone) {
    return parentService || new AnimationFrameServiceSingleton(ngZone);
}
// AnimationFrameServiceSingleton is a singleton so we don't have a ton of duplicate RAFs firing (better for scheduling)
const ANIMATION_FRAME_SERVICE_SINGLETON_PROVIDER = {
    provide: AnimationFrameServiceSingleton,
    deps: [[new _angular_core__WEBPACK_IMPORTED_MODULE_0__.Optional(), new _angular_core__WEBPACK_IMPORTED_MODULE_0__.SkipSelf(), AnimationFrameServiceSingleton], _angular_core__WEBPACK_IMPORTED_MODULE_0__.NgZone],
    useFactory: ANIMATION_FRAME_SERVICE_SINGLETON_PROVIDER_FACTORY
};
class UtilsModule {
}
UtilsModule.fac = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareFactory"]({ minVersion: "12.0.0", version: "14.3.0", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: UtilsModule, deps: [], target: _angular_core__WEBPACK_IMPORTED_MODULE_0__["FactoryTarget"].NgModule });
UtilsModule.mod = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareNgModule"]({ minVersion: "14.0.0", version: "14.3.0", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: UtilsModule });
UtilsModule.inj = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareInjector"]({ minVersion: "12.0.0", version: "14.3.0", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: UtilsModule, providers: [
        DOCUMENT_SERVICE_PROVIDER,
        ANIMATION_FRAME_SERVICE_SINGLETON_PROVIDER,
        AnimationFrameServiceSingleton,
        DocumentService,
        AnimationFrameService,
        ElementService,
        EventService
    ] });
_angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareClassMetadata"]({ minVersion: "12.0.0", version: "14.3.0", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: UtilsModule, decorators: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.NgModule,
            args: [{
                    providers: [
                        DOCUMENT_SERVICE_PROVIDER,
                        ANIMATION_FRAME_SERVICE_SINGLETON_PROVIDER,
                        AnimationFrameServiceSingleton,
                        DocumentService,
                        AnimationFrameService,
                        ElementService,
                        EventService
                    ]
                }]
        }] });

let _scrollbarWidth = -1;
function getScrollbarWidth() {
    // lets not recreate this whole thing every time
    if (_scrollbarWidth >= 0) {
        return _scrollbarWidth;
    }
    // do the calculations the first time
    const outer = document.createElement("div");
    outer.style.visibility = "hidden";
    outer.style.width = "100px";
    outer.style["msOverflowStyle"] = "scrollbar"; // needed for WinJS apps
    document.body.appendChild(outer);
    const widthNoScroll = outer.offsetWidth;
    // force scrollbars
    outer.style.overflow = "scroll";
    // add innerdiv
    const inner = document.createElement("div");
    inner.style.width = "100%";
    outer.appendChild(inner);
    const widthWithScroll = inner.offsetWidth;
    // remove divs
    outer.parentNode.removeChild(outer);
    _scrollbarWidth = widthNoScroll - widthWithScroll;
    return _scrollbarWidth;
}

/**
 * Generated bundle index. Do not edit.
 */


//# sourceMappingURL=carbon-components-angular-utils.mjs.map


/***/ })

/******/ });
/************************************************************************/
/******/ // The module cache
/******/ var __webpack_module_cache__ = {};
/******/ 
/******/ // The require function
/******/ function __webpack_require__(moduleId) {
/******/ 	// Check if module is in cache
/******/ 	var cachedModule = __webpack_module_cache__[moduleId];
/******/ 	if (cachedModule !== undefined) {
/******/ 		return cachedModule.exports;
/******/ 	}
/******/ 	// Create a new module (and put it into the cache)
/******/ 	var module = __webpack_module_cache__[moduleId] = {
/******/ 		// no module.id needed
/******/ 		// no module.loaded needed
/******/ 		exports: {}
/******/ 	};
/******/ 
/******/ 	// Execute the module function
/******/ 	__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 
/******/ 	// Return the exports of the module
/******/ 	return module.exports;
/******/ }
/******/ 
/************************************************************************/
/******/ /* webpack/runtime/compat get default export */
/******/ (() => {
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = (module) => {
/******/ 		var getter = module && module.__esModule ?
/******/ 			() => (module['default']) :
/******/ 			() => (module);
/******/ 		__webpack_require__.d(getter, { a: getter });
/******/ 		return getter;
/******/ 	};
/******/ })();
/******/ 
/******/ /* webpack/runtime/create fake namespace object */
/******/ (() => {
/******/ 	var getProto = Object.getPrototypeOf ? (obj) => (Object.getPrototypeOf(obj)) : (obj) => (obj.__proto__);
/******/ 	var leafPrototypes;
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 16: return value when it's Promise-like
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = this(value);
/******/ 		if(mode & 8) return value;
/******/ 		if(typeof value === 'object' && value) {
/******/ 			if((mode & 4) && value.__esModule) return value;
/******/ 			if((mode & 16) && typeof value.then === 'function') return value;
/******/ 		}
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		var def = {};
/******/ 		leafPrototypes = leafPrototypes || [null, getProto({}), getProto([]), getProto(getProto)];
/******/ 		for(var current = mode & 2 && value; typeof current == 'object' && !~leafPrototypes.indexOf(current); current = getProto(current)) {
/******/ 			Object.getOwnPropertyNames(current).forEach((key) => (def[key] = () => (value[key])));
/******/ 		}
/******/ 		def['default'] = () => (value);
/******/ 		__webpack_require__.d(ns, def);
/******/ 		return ns;
/******/ 	};
/******/ })();
/******/ 
/******/ /* webpack/runtime/define property getters */
/******/ (() => {
/******/ 	// define getter functions for harmony exports
/******/ 	__webpack_require__.d = (exports, definition) => {
/******/ 		for(var key in definition) {
/******/ 			if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 				Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 			}
/******/ 		}
/******/ 	};
/******/ })();
/******/ 
/******/ /* webpack/runtime/hasOwnProperty shorthand */
/******/ (() => {
/******/ 	__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ })();
/******/ 
/******/ /* webpack/runtime/make namespace object */
/******/ (() => {
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = (exports) => {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/ })();
/******/ 
/************************************************************************/
var __webpack_exports__ = {};
// This entry needs to be wrapped in an IIFE because it needs to be isolated against other modules in the chunk.
(() => {
/*!***************************!*\
  !*** ./src/public_api.ts ***!
  \***************************/
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   SendMailActionConfigurationComponent: () => (/* reexport safe */ _lib_components_send_mail_configuration_send_mail_action_configuration_component__WEBPACK_IMPORTED_MODULE_4__.SendMailActionConfigurationComponent),
/* harmony export */   SpotlerPluginConfigurationComponent: () => (/* reexport safe */ _lib_components_plugin_configuration_spotler_plugin_configuration_component__WEBPACK_IMPORTED_MODULE_3__.SpotlerPluginConfigurationComponent),
/* harmony export */   SpotlerPluginModule: () => (/* reexport safe */ _lib_spotler_plugin_module__WEBPACK_IMPORTED_MODULE_1__.SpotlerPluginModule),
/* harmony export */   spotlerPluginSpecification: () => (/* reexport safe */ _lib_spotler_plugin_specification__WEBPACK_IMPORTED_MODULE_2__.spotlerPluginSpecification)
/* harmony export */ });
/* harmony import */ var _lib_models__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lib/models */ "./src/lib/models/index.ts");
/* harmony import */ var _lib_spotler_plugin_module__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./lib/spotler-plugin-module */ "./src/lib/spotler-plugin-module.ts");
/* harmony import */ var _lib_spotler_plugin_specification__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./lib/spotler-plugin.specification */ "./src/lib/spotler-plugin.specification.ts");
/* harmony import */ var _lib_components_plugin_configuration_spotler_plugin_configuration_component__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./lib/components/plugin-configuration/spotler-plugin-configuration.component */ "./src/lib/components/plugin-configuration/spotler-plugin-configuration.component.ts");
/* harmony import */ var _lib_components_send_mail_configuration_send_mail_action_configuration_component__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./lib/components/send-mail-configuration/send-mail-action-configuration.component */ "./src/lib/components/send-mail-configuration/send-mail-action-configuration.component.ts");
/*
 * Copyright 2015-2024. Ritense BV, the Netherlands.
 *
 * Licensed under EUPL, Version 1.2 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * https://joinup.ec.europa.eu/collection/eupl/eupl-text-eupl-12
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" basis,
 *
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
/*
 * Public API Surface of slack
 */






})();

var __webpack_exports__SendMailActionConfigurationComponent = __webpack_exports__.SendMailActionConfigurationComponent;
var __webpack_exports__SpotlerPluginConfigurationComponent = __webpack_exports__.SpotlerPluginConfigurationComponent;
var __webpack_exports__SpotlerPluginModule = __webpack_exports__.SpotlerPluginModule;
var __webpack_exports__spotlerPluginSpecification = __webpack_exports__.spotlerPluginSpecification;
export { __webpack_exports__SendMailActionConfigurationComponent as SendMailActionConfigurationComponent, __webpack_exports__SpotlerPluginConfigurationComponent as SpotlerPluginConfigurationComponent, __webpack_exports__SpotlerPluginModule as SpotlerPluginModule, __webpack_exports__spotlerPluginSpecification as spotlerPluginSpecification };

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZnJvbnRlbmQtYnVuZGxlLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0Isc0JBQXNCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxjQUFjLHVCQUF1QjtBQUNyQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxnQkFBZ0IsNkJBQTZCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUZBQW1GO0FBQ25GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxzRUFBc0UsK0JBQStCO0FBQ3JHO0FBQ0E7QUFDQTtBQUNBLEdBQUcsR0FBRztBQUNOOzs7QUFHQTtBQUNBLGlDQUFpQztBQUNqQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdEO0FBQ2hEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdEO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUgsa0JBQWtCLG9CQUFvQjtBQUN0QztBQUNBOztBQUVBO0FBQ0E7O0FBRStFOzs7Ozs7Ozs7Ozs7Ozs7QUN4TS9FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUUwQjs7Ozs7Ozs7Ozs7Ozs7O0FDM0IxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFMEI7Ozs7Ozs7Ozs7Ozs7OztBQzNCMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRTBCOzs7Ozs7Ozs7Ozs7Ozs7QUMzQjFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUUwQjs7Ozs7Ozs7Ozs7Ozs7O0FDM0IxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFMEI7Ozs7Ozs7Ozs7Ozs7OztBQzNCMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRTBCOzs7Ozs7Ozs7Ozs7Ozs7QUNoQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUUwQjs7Ozs7Ozs7Ozs7Ozs7O0FDaEMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFMEI7Ozs7Ozs7Ozs7Ozs7OztBQzNCMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRTBCOzs7Ozs7Ozs7Ozs7Ozs7QUMzQjFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUUwQjs7Ozs7Ozs7Ozs7Ozs7O0FDM0IxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFMEI7Ozs7Ozs7Ozs7Ozs7OztBQzNCMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUUwQjs7Ozs7Ozs7Ozs7Ozs7O0FDbEMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFMEI7Ozs7Ozs7Ozs7Ozs7OztBQ25DMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRTBCOzs7Ozs7Ozs7Ozs7Ozs7QUNoQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUUwQjs7Ozs7Ozs7Ozs7Ozs7O0FDM0IxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFMEI7Ozs7Ozs7Ozs7Ozs7OztBQzNCMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRTBCOzs7Ozs7Ozs7Ozs7Ozs7QUMzQjFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUUwQjs7Ozs7Ozs7Ozs7Ozs7O0FDM0IxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFMEI7Ozs7Ozs7Ozs7Ozs7OztBQzNCMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRTBCOzs7Ozs7Ozs7Ozs7Ozs7QUMzQjFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUUwQjs7Ozs7Ozs7Ozs7Ozs7O0FDaEMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFMEI7Ozs7Ozs7Ozs7Ozs7OztBQ2hDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRTBCOzs7Ozs7Ozs7Ozs7Ozs7QUMzQjFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUUwQjs7Ozs7Ozs7Ozs7Ozs7O0FDM0IxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFMEI7Ozs7Ozs7Ozs7Ozs7OztBQ2hDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRTBCOzs7Ozs7Ozs7Ozs7Ozs7QUNoQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUUwQjs7Ozs7Ozs7Ozs7Ozs7O0FDM0IxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFMEI7Ozs7Ozs7Ozs7Ozs7OztBQ25DMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUUwQjs7Ozs7Ozs7Ozs7Ozs7O0FDbEMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFMEI7Ozs7Ozs7Ozs7Ozs7OztBQzNCMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRTBCOzs7Ozs7Ozs7Ozs7Ozs7QUMzQjFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUUwQjs7Ozs7Ozs7Ozs7Ozs7O0FDM0IxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFMEI7Ozs7Ozs7Ozs7Ozs7OztBQzNCMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUUwQjs7Ozs7Ozs7Ozs7Ozs7O0FDbEMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRTBCOzs7Ozs7Ozs7Ozs7Ozs7QUNsQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFMEI7Ozs7Ozs7Ozs7Ozs7OztBQ2xDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRTBCOzs7Ozs7Ozs7Ozs7Ozs7QUMzQjFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUUwQjs7Ozs7Ozs7Ozs7Ozs7O0FDM0IxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFMEI7Ozs7Ozs7Ozs7Ozs7OztBQzNDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRTBCOzs7Ozs7Ozs7Ozs7Ozs7QUMzQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUUwQjs7Ozs7Ozs7Ozs7Ozs7O0FDM0IxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFMEI7Ozs7Ozs7Ozs7Ozs7OztBQzNCMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRTBCOzs7Ozs7Ozs7Ozs7Ozs7QUMzQjFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUUwQjs7Ozs7Ozs7Ozs7Ozs7O0FDaEMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFMEI7Ozs7Ozs7Ozs7Ozs7OztBQzNCMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRTBCOzs7Ozs7Ozs7Ozs7Ozs7QUNoQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUUwQjs7Ozs7Ozs7Ozs7Ozs7O0FDaEMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFMEI7Ozs7Ozs7Ozs7Ozs7OztBQ2hDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUUwQjs7Ozs7Ozs7Ozs7Ozs7O0FDdkMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRTBCOzs7Ozs7Ozs7Ozs7Ozs7QUN2QzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFMEI7Ozs7Ozs7Ozs7Ozs7OztBQ2xDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUUwQjs7Ozs7Ozs7Ozs7Ozs7O0FDbEMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFMEI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNo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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxJQUFJLE1BQU07QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxJQUFJO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxJQUFJO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxJQUFJO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsSUFBSSxZQUFZO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxJQUFJLFlBQVk7QUFDcEQ7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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLDJCQUEyQjtBQUM3RCxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsMkJBQTJCO0FBQzdELFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QUNuQztBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEVBQThFO0FBQzlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtGQUFrRjtBQUNsRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNEO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNEO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixhQUFhO0FBQ2IsYUFB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQ7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4Qyw4QkFBOEI7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxrQkFBa0I7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Qsd0NBQXdDLGtCQUFrQjtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxrQkFBa0I7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELGtCQUFrQjtBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qix1REFBWTtBQUN4QztBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsdURBQVk7QUFDdkM7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLHVEQUFZO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyw4Q0FBWTtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxxRkFBb0I7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLHFCQUFxQjtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQywwQkFBMEI7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLHNCQUFzQixxREFBcUQsc0JBQXNCO0FBQzlIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRDtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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O1VBQ0EsZ0RBQWdELGFBQWE7VUFDN0Q7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNOQTs7Ozs7Ozs7Ozs7Ozs7Ozs7R0FpQkc7QUFFSDs7R0FFRztBQUUwQjtBQUNlO0FBQ087QUFDMEM7QUFDSyIsInNvdXJjZXMiOlsid2VicGFjazovL0B2YWx0aW1vLXBsdWdpbnMvc3BvdGxlci8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQGNhcmJvbi9pY29uLWhlbHBlcnMvZXMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vQHZhbHRpbW8tcGx1Z2lucy9zcG90bGVyLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jYXJib24tY29tcG9uZW50cy1hbmd1bGFyL25vZGVfbW9kdWxlcy9AY2FyYm9uL2ljb25zL2VzL2FkZC8xNi5qcyIsIndlYnBhY2s6Ly9AdmFsdGltby1wbHVnaW5zL3Nwb3RsZXIvLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NhcmJvbi1jb21wb25lbnRzLWFuZ3VsYXIvbm9kZV9tb2R1bGVzL0BjYXJib24vaWNvbnMvZXMvYWRkLzIwLmpzIiwid2VicGFjazovL0B2YWx0aW1vLXBsdWdpbnMvc3BvdGxlci8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY2FyYm9uLWNvbXBvbmVudHMtYW5ndWxhci9ub2RlX21vZHVsZXMvQGNhcmJvbi9pY29ucy9lcy9iZWUvMTYuanMiLCJ3ZWJwYWNrOi8vQHZhbHRpbW8tcGx1Z2lucy9zcG90bGVyLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jYXJib24tY29tcG9uZW50cy1hbmd1bGFyL25vZGVfbW9kdWxlcy9AY2FyYm9uL2ljb25zL2VzL2JlZS8yMC5qcyIsIndlYnBhY2s6Ly9AdmFsdGltby1wbHVnaW5zL3Nwb3RsZXIvLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NhcmJvbi1jb21wb25lbnRzLWFuZ3VsYXIvbm9kZV9tb2R1bGVzL0BjYXJib24vaWNvbnMvZXMvY2FsZW5kYXIvMTYuanMiLCJ3ZWJwYWNrOi8vQHZhbHRpbW8tcGx1Z2lucy9zcG90bGVyLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jYXJib24tY29tcG9uZW50cy1hbmd1bGFyL25vZGVfbW9kdWxlcy9AY2FyYm9uL2ljb25zL2VzL2NhcmJvbi8xNi5qcyIsIndlYnBhY2s6Ly9AdmFsdGltby1wbHVnaW5zL3Nwb3RsZXIvLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NhcmJvbi1jb21wb25lbnRzLWFuZ3VsYXIvbm9kZV9tb2R1bGVzL0BjYXJib24vaWNvbnMvZXMvY2FyYm9uLzIwLmpzIiwid2VicGFjazovL0B2YWx0aW1vLXBsdWdpbnMvc3BvdGxlci8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY2FyYm9uLWNvbXBvbmVudHMtYW5ndWxhci9ub2RlX21vZHVsZXMvQGNhcmJvbi9pY29ucy9lcy9jYXJldC0tZG93bi8xNi5qcyIsIndlYnBhY2s6Ly9AdmFsdGltby1wbHVnaW5zL3Nwb3RsZXIvLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NhcmJvbi1jb21wb25lbnRzLWFuZ3VsYXIvbm9kZV9tb2R1bGVzL0BjYXJib24vaWNvbnMvZXMvY2FyZXQtLWxlZnQvMTYuanMiLCJ3ZWJwYWNrOi8vQHZhbHRpbW8tcGx1Z2lucy9zcG90bGVyLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jYXJib24tY29tcG9uZW50cy1hbmd1bGFyL25vZGVfbW9kdWxlcy9AY2FyYm9uL2ljb25zL2VzL2NhcmV0LS1yaWdodC8xNi5qcyIsIndlYnBhY2s6Ly9AdmFsdGltby1wbHVnaW5zL3Nwb3RsZXIvLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NhcmJvbi1jb21wb25lbnRzLWFuZ3VsYXIvbm9kZV9tb2R1bGVzL0BjYXJib24vaWNvbnMvZXMvY2FyZXQtLXVwLzE2LmpzIiwid2VicGFjazovL0B2YWx0aW1vLXBsdWdpbnMvc3BvdGxlci8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY2FyYm9uLWNvbXBvbmVudHMtYW5ndWxhci9ub2RlX21vZHVsZXMvQGNhcmJvbi9pY29ucy9lcy9jaGVja21hcmstLWZpbGxlZC8xNi5qcyIsIndlYnBhY2s6Ly9AdmFsdGltby1wbHVnaW5zL3Nwb3RsZXIvLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NhcmJvbi1jb21wb25lbnRzLWFuZ3VsYXIvbm9kZV9tb2R1bGVzL0BjYXJib24vaWNvbnMvZXMvY2hlY2ttYXJrLS1maWxsZWQvMjAuanMiLCJ3ZWJwYWNrOi8vQHZhbHRpbW8tcGx1Z2lucy9zcG90bGVyLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jYXJib24tY29tcG9uZW50cy1hbmd1bGFyL25vZGVfbW9kdWxlcy9AY2FyYm9uL2ljb25zL2VzL2NoZWNrbWFyay0tb3V0bGluZS8xNi5qcyIsIndlYnBhY2s6Ly9AdmFsdGltby1wbHVnaW5zL3Nwb3RsZXIvLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NhcmJvbi1jb21wb25lbnRzLWFuZ3VsYXIvbm9kZV9tb2R1bGVzL0BjYXJib24vaWNvbnMvZXMvY2hlY2ttYXJrLzE2LmpzIiwid2VicGFjazovL0B2YWx0aW1vLXBsdWdpbnMvc3BvdGxlci8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY2FyYm9uLWNvbXBvbmVudHMtYW5ndWxhci9ub2RlX21vZHVsZXMvQGNhcmJvbi9pY29ucy9lcy9jaGV2cm9uLS1kb3duLzE2LmpzIiwid2VicGFjazovL0B2YWx0aW1vLXBsdWdpbnMvc3BvdGxlci8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY2FyYm9uLWNvbXBvbmVudHMtYW5ndWxhci9ub2RlX21vZHVsZXMvQGNhcmJvbi9pY29ucy9lcy9jaGV2cm9uLS1yaWdodC8xNi5qcyIsIndlYnBhY2s6Ly9AdmFsdGltby1wbHVnaW5zL3Nwb3RsZXIvLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NhcmJvbi1jb21wb25lbnRzLWFuZ3VsYXIvbm9kZV9tb2R1bGVzL0BjYXJib24vaWNvbnMvZXMvY2lyY2xlLWRhc2gvMTYuanMiLCJ3ZWJwYWNrOi8vQHZhbHRpbW8tcGx1Z2lucy9zcG90bGVyLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jYXJib24tY29tcG9uZW50cy1hbmd1bGFyL25vZGVfbW9kdWxlcy9AY2FyYm9uL2ljb25zL2VzL2Nsb3NlLzE2LmpzIiwid2VicGFjazovL0B2YWx0aW1vLXBsdWdpbnMvc3BvdGxlci8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY2FyYm9uLWNvbXBvbmVudHMtYW5ndWxhci9ub2RlX21vZHVsZXMvQGNhcmJvbi9pY29ucy9lcy9jbG9zZS8yMC5qcyIsIndlYnBhY2s6Ly9AdmFsdGltby1wbHVnaW5zL3Nwb3RsZXIvLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NhcmJvbi1jb21wb25lbnRzLWFuZ3VsYXIvbm9kZV9tb2R1bGVzL0BjYXJib24vaWNvbnMvZXMvY29weS8xNi5qcyIsIndlYnBhY2s6Ly9AdmFsdGltby1wbHVnaW5zL3Nwb3RsZXIvLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NhcmJvbi1jb21wb25lbnRzLWFuZ3VsYXIvbm9kZV9tb2R1bGVzL0BjYXJib24vaWNvbnMvZXMvY29weS8yMC5qcyIsIndlYnBhY2s6Ly9AdmFsdGltby1wbHVnaW5zL3Nwb3RsZXIvLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NhcmJvbi1jb21wb25lbnRzLWFuZ3VsYXIvbm9kZV9tb2R1bGVzL0BjYXJib24vaWNvbnMvZXMvZGF0YS0tMi8xNi5qcyIsIndlYnBhY2s6Ly9AdmFsdGltby1wbHVnaW5zL3Nwb3RsZXIvLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NhcmJvbi1jb21wb25lbnRzLWFuZ3VsYXIvbm9kZV9tb2R1bGVzL0BjYXJib24vaWNvbnMvZXMvZGF0YS0tMi8yMC5qcyIsIndlYnBhY2s6Ly9AdmFsdGltby1wbHVnaW5zL3Nwb3RsZXIvLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NhcmJvbi1jb21wb25lbnRzLWFuZ3VsYXIvbm9kZV9tb2R1bGVzL0BjYXJib24vaWNvbnMvZXMvZG9jdW1lbnQvMTYuanMiLCJ3ZWJwYWNrOi8vQHZhbHRpbW8tcGx1Z2lucy9zcG90bGVyLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jYXJib24tY29tcG9uZW50cy1hbmd1bGFyL25vZGVfbW9kdWxlcy9AY2FyYm9uL2ljb25zL2VzL2RvY3VtZW50LzIwLmpzIiwid2VicGFjazovL0B2YWx0aW1vLXBsdWdpbnMvc3BvdGxlci8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY2FyYm9uLWNvbXBvbmVudHMtYW5ndWxhci9ub2RlX21vZHVsZXMvQGNhcmJvbi9pY29ucy9lcy9kb3dubG9hZC8xNi5qcyIsIndlYnBhY2s6Ly9AdmFsdGltby1wbHVnaW5zL3Nwb3RsZXIvLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NhcmJvbi1jb21wb25lbnRzLWFuZ3VsYXIvbm9kZV9tb2R1bGVzL0BjYXJib24vaWNvbnMvZXMvZXJyb3ItLWZpbGxlZC8xNi5qcyIsIndlYnBhY2s6Ly9AdmFsdGltby1wbHVnaW5zL3Nwb3RsZXIvLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NhcmJvbi1jb21wb25lbnRzLWFuZ3VsYXIvbm9kZV9tb2R1bGVzL0BjYXJib24vaWNvbnMvZXMvZXJyb3ItLWZpbGxlZC8yMC5qcyIsIndlYnBhY2s6Ly9AdmFsdGltby1wbHVnaW5zL3Nwb3RsZXIvLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NhcmJvbi1jb21wb25lbnRzLWFuZ3VsYXIvbm9kZV9tb2R1bGVzL0BjYXJib24vaWNvbnMvZXMvZmFkZS8xNi5qcyIsIndlYnBhY2s6Ly9AdmFsdGltby1wbHVnaW5zL3Nwb3RsZXIvLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NhcmJvbi1jb21wb25lbnRzLWFuZ3VsYXIvbm9kZV9tb2R1bGVzL0BjYXJib24vaWNvbnMvZXMvZmFkZS8yMC5qcyIsIndlYnBhY2s6Ly9AdmFsdGltby1wbHVnaW5zL3Nwb3RsZXIvLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NhcmJvbi1jb21wb25lbnRzLWFuZ3VsYXIvbm9kZV9tb2R1bGVzL0BjYXJib24vaWNvbnMvZXMvZm9sZGVyLzE2LmpzIiwid2VicGFjazovL0B2YWx0aW1vLXBsdWdpbnMvc3BvdGxlci8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY2FyYm9uLWNvbXBvbmVudHMtYW5ndWxhci9ub2RlX21vZHVsZXMvQGNhcmJvbi9pY29ucy9lcy9pbmNvbXBsZXRlLzE2LmpzIiwid2VicGFjazovL0B2YWx0aW1vLXBsdWdpbnMvc3BvdGxlci8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY2FyYm9uLWNvbXBvbmVudHMtYW5ndWxhci9ub2RlX21vZHVsZXMvQGNhcmJvbi9pY29ucy9lcy9pbmZvcm1hdGlvbi0tZmlsbGVkLzE2LmpzIiwid2VicGFjazovL0B2YWx0aW1vLXBsdWdpbnMvc3BvdGxlci8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY2FyYm9uLWNvbXBvbmVudHMtYW5ndWxhci9ub2RlX21vZHVsZXMvQGNhcmJvbi9pY29ucy9lcy9pbmZvcm1hdGlvbi0tZmlsbGVkLzIwLmpzIiwid2VicGFjazovL0B2YWx0aW1vLXBsdWdpbnMvc3BvdGxlci8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY2FyYm9uLWNvbXBvbmVudHMtYW5ndWxhci9ub2RlX21vZHVsZXMvQGNhcmJvbi9pY29ucy9lcy9pbmZvcm1hdGlvbi0tc3F1YXJlLS1maWxsZWQvMjAuanMiLCJ3ZWJwYWNrOi8vQHZhbHRpbW8tcGx1Z2lucy9zcG90bGVyLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jYXJib24tY29tcG9uZW50cy1hbmd1bGFyL25vZGVfbW9kdWxlcy9AY2FyYm9uL2ljb25zL2VzL21lbnUvMTYuanMiLCJ3ZWJwYWNrOi8vQHZhbHRpbW8tcGx1Z2lucy9zcG90bGVyLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jYXJib24tY29tcG9uZW50cy1hbmd1bGFyL25vZGVfbW9kdWxlcy9AY2FyYm9uL2ljb25zL2VzL21lbnUvMjAuanMiLCJ3ZWJwYWNrOi8vQHZhbHRpbW8tcGx1Z2lucy9zcG90bGVyLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jYXJib24tY29tcG9uZW50cy1hbmd1bGFyL25vZGVfbW9kdWxlcy9AY2FyYm9uL2ljb25zL2VzL292ZXJmbG93LW1lbnUtLWhvcml6b250YWwvMTYuanMiLCJ3ZWJwYWNrOi8vQHZhbHRpbW8tcGx1Z2lucy9zcG90bGVyLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jYXJib24tY29tcG9uZW50cy1hbmd1bGFyL25vZGVfbW9kdWxlcy9AY2FyYm9uL2ljb25zL2VzL292ZXJmbG93LW1lbnUtLXZlcnRpY2FsLzE2LmpzIiwid2VicGFjazovL0B2YWx0aW1vLXBsdWdpbnMvc3BvdGxlci8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY2FyYm9uLWNvbXBvbmVudHMtYW5ndWxhci9ub2RlX21vZHVsZXMvQGNhcmJvbi9pY29ucy9lcy9zYXZlLzE2LmpzIiwid2VicGFjazovL0B2YWx0aW1vLXBsdWdpbnMvc3BvdGxlci8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY2FyYm9uLWNvbXBvbmVudHMtYW5ndWxhci9ub2RlX21vZHVsZXMvQGNhcmJvbi9pY29ucy9lcy9zZWFyY2gvMTYuanMiLCJ3ZWJwYWNrOi8vQHZhbHRpbW8tcGx1Z2lucy9zcG90bGVyLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jYXJib24tY29tcG9uZW50cy1hbmd1bGFyL25vZGVfbW9kdWxlcy9AY2FyYm9uL2ljb25zL2VzL3NldHRpbmdzLS1hZGp1c3QvMTYuanMiLCJ3ZWJwYWNrOi8vQHZhbHRpbW8tcGx1Z2lucy9zcG90bGVyLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jYXJib24tY29tcG9uZW50cy1hbmd1bGFyL25vZGVfbW9kdWxlcy9AY2FyYm9uL2ljb25zL2VzL3NldHRpbmdzLzE2LmpzIiwid2VicGFjazovL0B2YWx0aW1vLXBsdWdpbnMvc3BvdGxlci8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY2FyYm9uLWNvbXBvbmVudHMtYW5ndWxhci9ub2RlX21vZHVsZXMvQGNhcmJvbi9pY29ucy9lcy9zdWJ0cmFjdC8xNi5qcyIsIndlYnBhY2s6Ly9AdmFsdGltby1wbHVnaW5zL3Nwb3RsZXIvLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NhcmJvbi1jb21wb25lbnRzLWFuZ3VsYXIvbm9kZV9tb2R1bGVzL0BjYXJib24vaWNvbnMvZXMvdHJhc2gtY2FuLzE2LmpzIiwid2VicGFjazovL0B2YWx0aW1vLXBsdWdpbnMvc3BvdGxlci8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY2FyYm9uLWNvbXBvbmVudHMtYW5ndWxhci9ub2RlX21vZHVsZXMvQGNhcmJvbi9pY29ucy9lcy92aWV3LS1vZmYvMTYuanMiLCJ3ZWJwYWNrOi8vQHZhbHRpbW8tcGx1Z2lucy9zcG90bGVyLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jYXJib24tY29tcG9uZW50cy1hbmd1bGFyL25vZGVfbW9kdWxlcy9AY2FyYm9uL2ljb25zL2VzL3ZpZXcvMTYuanMiLCJ3ZWJwYWNrOi8vQHZhbHRpbW8tcGx1Z2lucy9zcG90bGVyLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jYXJib24tY29tcG9uZW50cy1hbmd1bGFyL25vZGVfbW9kdWxlcy9AY2FyYm9uL2ljb25zL2VzL3dhcm5pbmctLWFsdC0tZmlsbGVkLzE2LmpzIiwid2VicGFjazovL0B2YWx0aW1vLXBsdWdpbnMvc3BvdGxlci8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY2FyYm9uLWNvbXBvbmVudHMtYW5ndWxhci9ub2RlX21vZHVsZXMvQGNhcmJvbi9pY29ucy9lcy93YXJuaW5nLS1hbHQtLWZpbGxlZC8yMC5qcyIsIndlYnBhY2s6Ly9AdmFsdGltby1wbHVnaW5zL3Nwb3RsZXIvLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NhcmJvbi1jb21wb25lbnRzLWFuZ3VsYXIvbm9kZV9tb2R1bGVzL0BjYXJib24vaWNvbnMvZXMvd2FybmluZy0tZmlsbGVkLzE2LmpzIiwid2VicGFjazovL0B2YWx0aW1vLXBsdWdpbnMvc3BvdGxlci8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY2FyYm9uLWNvbXBvbmVudHMtYW5ndWxhci9ub2RlX21vZHVsZXMvQGNhcmJvbi9pY29ucy9lcy93YXJuaW5nLS1maWxsZWQvMjAuanMiLCJ3ZWJwYWNrOi8vQHZhbHRpbW8tcGx1Z2lucy9zcG90bGVyLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jYXJib24tY29tcG9uZW50cy1hbmd1bGFyL25vZGVfbW9kdWxlcy9AY2FyYm9uL2ljb25zL2VzL3dhcm5pbmcvMTYuanMiLCJ3ZWJwYWNrOi8vQHZhbHRpbW8tcGx1Z2lucy9zcG90bGVyLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jYXJib24tY29tcG9uZW50cy1hbmd1bGFyL25vZGVfbW9kdWxlcy9AY2FyYm9uL3V0aWxzLXBvc2l0aW9uL2luZGV4LmpzIiwid2VicGFjazovL0B2YWx0aW1vLXBsdWdpbnMvc3BvdGxlci8uLi8uLi8uLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2VzbTUvaW50ZXJuYWwvTm90aWZpY2F0aW9uRmFjdG9yaWVzLmpzIiwid2VicGFjazovL0B2YWx0aW1vLXBsdWdpbnMvc3BvdGxlci8uLi8uLi8uLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2VzbTUvaW50ZXJuYWwvT2JzZXJ2YWJsZS5qcyIsIndlYnBhY2s6Ly9AdmFsdGltby1wbHVnaW5zL3Nwb3RsZXIvLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9lc201L2ludGVybmFsL1NjaGVkdWxlci5qcyIsIndlYnBhY2s6Ly9AdmFsdGltby1wbHVnaW5zL3Nwb3RsZXIvLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9lc201L2ludGVybmFsL1N1YnNjcmliZXIuanMiLCJ3ZWJwYWNrOi8vQHZhbHRpbW8tcGx1Z2lucy9zcG90bGVyLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvZXNtNS9pbnRlcm5hbC9TdWJzY3JpcHRpb24uanMiLCJ3ZWJwYWNrOi8vQHZhbHRpbW8tcGx1Z2lucy9zcG90bGVyLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvZXNtNS9pbnRlcm5hbC9jb25maWcuanMiLCJ3ZWJwYWNrOi8vQHZhbHRpbW8tcGx1Z2lucy9zcG90bGVyLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvZXNtNS9pbnRlcm5hbC9vYnNlcnZhYmxlL2VtcHR5LmpzIiwid2VicGFjazovL0B2YWx0aW1vLXBsdWdpbnMvc3BvdGxlci8uLi8uLi8uLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2VzbTUvaW50ZXJuYWwvb3BlcmF0b3JzL09wZXJhdG9yU3Vic2NyaWJlci5qcyIsIndlYnBhY2s6Ly9AdmFsdGltby1wbHVnaW5zL3Nwb3RsZXIvLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9lc201L2ludGVybmFsL29wZXJhdG9ycy9kZWJvdW5jZVRpbWUuanMiLCJ3ZWJwYWNrOi8vQHZhbHRpbW8tcGx1Z2lucy9zcG90bGVyLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvZXNtNS9pbnRlcm5hbC9vcGVyYXRvcnMvZGVmYXVsdElmRW1wdHkuanMiLCJ3ZWJwYWNrOi8vQHZhbHRpbW8tcGx1Z2lucy9zcG90bGVyLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvZXNtNS9pbnRlcm5hbC9vcGVyYXRvcnMvZmlsdGVyLmpzIiwid2VicGFjazovL0B2YWx0aW1vLXBsdWdpbnMvc3BvdGxlci8uLi8uLi8uLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2VzbTUvaW50ZXJuYWwvb3BlcmF0b3JzL2ZpcnN0LmpzIiwid2VicGFjazovL0B2YWx0aW1vLXBsdWdpbnMvc3BvdGxlci8uLi8uLi8uLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2VzbTUvaW50ZXJuYWwvb3BlcmF0b3JzL21hcC5qcyIsIndlYnBhY2s6Ly9AdmFsdGltby1wbHVnaW5zL3Nwb3RsZXIvLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9lc201L2ludGVybmFsL29wZXJhdG9ycy90YWtlLmpzIiwid2VicGFjazovL0B2YWx0aW1vLXBsdWdpbnMvc3BvdGxlci8uLi8uLi8uLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2VzbTUvaW50ZXJuYWwvb3BlcmF0b3JzL3Rocm93SWZFbXB0eS5qcyIsIndlYnBhY2s6Ly9AdmFsdGltby1wbHVnaW5zL3Nwb3RsZXIvLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9lc201L2ludGVybmFsL3NjaGVkdWxlci9BY3Rpb24uanMiLCJ3ZWJwYWNrOi8vQHZhbHRpbW8tcGx1Z2lucy9zcG90bGVyLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvZXNtNS9pbnRlcm5hbC9zY2hlZHVsZXIvQXN5bmNBY3Rpb24uanMiLCJ3ZWJwYWNrOi8vQHZhbHRpbW8tcGx1Z2lucy9zcG90bGVyLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvZXNtNS9pbnRlcm5hbC9zY2hlZHVsZXIvQXN5bmNTY2hlZHVsZXIuanMiLCJ3ZWJwYWNrOi8vQHZhbHRpbW8tcGx1Z2lucy9zcG90bGVyLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvZXNtNS9pbnRlcm5hbC9zY2hlZHVsZXIvYXN5bmMuanMiLCJ3ZWJwYWNrOi8vQHZhbHRpbW8tcGx1Z2lucy9zcG90bGVyLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvZXNtNS9pbnRlcm5hbC9zY2hlZHVsZXIvZGF0ZVRpbWVzdGFtcFByb3ZpZGVyLmpzIiwid2VicGFjazovL0B2YWx0aW1vLXBsdWdpbnMvc3BvdGxlci8uLi8uLi8uLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2VzbTUvaW50ZXJuYWwvc2NoZWR1bGVyL2ludGVydmFsUHJvdmlkZXIuanMiLCJ3ZWJwYWNrOi8vQHZhbHRpbW8tcGx1Z2lucy9zcG90bGVyLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvZXNtNS9pbnRlcm5hbC9zY2hlZHVsZXIvdGltZW91dFByb3ZpZGVyLmpzIiwid2VicGFjazovL0B2YWx0aW1vLXBsdWdpbnMvc3BvdGxlci8uLi8uLi8uLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2VzbTUvaW50ZXJuYWwvc3ltYm9sL29ic2VydmFibGUuanMiLCJ3ZWJwYWNrOi8vQHZhbHRpbW8tcGx1Z2lucy9zcG90bGVyLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvZXNtNS9pbnRlcm5hbC91dGlsL0VtcHR5RXJyb3IuanMiLCJ3ZWJwYWNrOi8vQHZhbHRpbW8tcGx1Z2lucy9zcG90bGVyLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvZXNtNS9pbnRlcm5hbC91dGlsL1Vuc3Vic2NyaXB0aW9uRXJyb3IuanMiLCJ3ZWJwYWNrOi8vQHZhbHRpbW8tcGx1Z2lucy9zcG90bGVyLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvZXNtNS9pbnRlcm5hbC91dGlsL2FyclJlbW92ZS5qcyIsIndlYnBhY2s6Ly9AdmFsdGltby1wbHVnaW5zL3Nwb3RsZXIvLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9lc201L2ludGVybmFsL3V0aWwvY3JlYXRlRXJyb3JDbGFzcy5qcyIsIndlYnBhY2s6Ly9AdmFsdGltby1wbHVnaW5zL3Nwb3RsZXIvLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9lc201L2ludGVybmFsL3V0aWwvZXJyb3JDb250ZXh0LmpzIiwid2VicGFjazovL0B2YWx0aW1vLXBsdWdpbnMvc3BvdGxlci8uLi8uLi8uLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2VzbTUvaW50ZXJuYWwvdXRpbC9pZGVudGl0eS5qcyIsIndlYnBhY2s6Ly9AdmFsdGltby1wbHVnaW5zL3Nwb3RsZXIvLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9lc201L2ludGVybmFsL3V0aWwvaXNGdW5jdGlvbi5qcyIsIndlYnBhY2s6Ly9AdmFsdGltby1wbHVnaW5zL3Nwb3RsZXIvLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9lc201L2ludGVybmFsL3V0aWwvbGlmdC5qcyIsIndlYnBhY2s6Ly9AdmFsdGltby1wbHVnaW5zL3Nwb3RsZXIvLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9lc201L2ludGVybmFsL3V0aWwvbm9vcC5qcyIsIndlYnBhY2s6Ly9AdmFsdGltby1wbHVnaW5zL3Nwb3RsZXIvLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9lc201L2ludGVybmFsL3V0aWwvcGlwZS5qcyIsIndlYnBhY2s6Ly9AdmFsdGltby1wbHVnaW5zL3Nwb3RsZXIvLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9lc201L2ludGVybmFsL3V0aWwvcmVwb3J0VW5oYW5kbGVkRXJyb3IuanMiLCJ3ZWJwYWNrOi8vQHZhbHRpbW8tcGx1Z2lucy9zcG90bGVyLy4vc3JjL2xpYi9hc3NldHMvaW5kZXgudHMiLCJ3ZWJwYWNrOi8vQHZhbHRpbW8tcGx1Z2lucy9zcG90bGVyLy4vc3JjL2xpYi9hc3NldHMvc3BvdGxlci1wbHVnaW4tbG9nby50cyIsIndlYnBhY2s6Ly9AdmFsdGltby1wbHVnaW5zL3Nwb3RsZXIvLi9zcmMvbGliL2NvbXBvbmVudHMvcGx1Z2luLWNvbmZpZ3VyYXRpb24vc3BvdGxlci1wbHVnaW4tY29uZmlndXJhdGlvbi5jb21wb25lbnQudHMiLCJ3ZWJwYWNrOi8vQHZhbHRpbW8tcGx1Z2lucy9zcG90bGVyLy4vc3JjL2xpYi9jb21wb25lbnRzL3NlbmQtbWFpbC1jb25maWd1cmF0aW9uL3NlbmQtbWFpbC1hY3Rpb24tY29uZmlndXJhdGlvbi5jb21wb25lbnQudHMiLCJ3ZWJwYWNrOi8vQHZhbHRpbW8tcGx1Z2lucy9zcG90bGVyLy4vc3JjL2xpYi9tb2RlbHMvY29uZmlnLnRzIiwid2VicGFjazovL0B2YWx0aW1vLXBsdWdpbnMvc3BvdGxlci8uL3NyYy9saWIvbW9kZWxzL2luZGV4LnRzIiwid2VicGFjazovL0B2YWx0aW1vLXBsdWdpbnMvc3BvdGxlci8uL3NyYy9saWIvc3BvdGxlci1wbHVnaW4tbW9kdWxlLnRzIiwid2VicGFjazovL0B2YWx0aW1vLXBsdWdpbnMvc3BvdGxlci8uL3NyYy9saWIvc3BvdGxlci1wbHVnaW4uc3BlY2lmaWNhdGlvbi50cyIsIndlYnBhY2s6Ly9AdmFsdGltby1wbHVnaW5zL3Nwb3RsZXIvZXh0ZXJuYWwgd2luZG93IFwiQGFuZ3VsYXIvY29tbW9uXCIiLCJ3ZWJwYWNrOi8vQHZhbHRpbW8tcGx1Z2lucy9zcG90bGVyL2V4dGVybmFsIHdpbmRvdyBcIkBhbmd1bGFyL2NvcmVcIiIsIndlYnBhY2s6Ly9AdmFsdGltby1wbHVnaW5zL3Nwb3RsZXIvZXh0ZXJuYWwgd2luZG93IFwiQHZhbHRpbW8vY29tcG9uZW50c1wiIiwid2VicGFjazovL0B2YWx0aW1vLXBsdWdpbnMvc3BvdGxlci9leHRlcm5hbCB3aW5kb3cgXCJAdmFsdGltby9wbHVnaW5cIiIsIndlYnBhY2s6Ly9AdmFsdGltby1wbHVnaW5zL3Nwb3RsZXIvZXh0ZXJuYWwgd2luZG93IFwicnhqc1wiIiwid2VicGFjazovL0B2YWx0aW1vLXBsdWdpbnMvc3BvdGxlci9leHRlcm5hbCB3aW5kb3cgXCJ0c2xpYlwiIiwid2VicGFjazovL0B2YWx0aW1vLXBsdWdpbnMvc3BvdGxlci8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQGFuZ3VsYXIvZm9ybXMvZmVzbTIwMjIvZm9ybXMubWpzIiwid2VicGFjazovL0B2YWx0aW1vLXBsdWdpbnMvc3BvdGxlci8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY2FyYm9uLWNvbXBvbmVudHMtYW5ndWxhci9mZXNtMjAyMC9jYXJib24tY29tcG9uZW50cy1hbmd1bGFyLWNoZWNrYm94Lm1qcyIsIndlYnBhY2s6Ly9AdmFsdGltby1wbHVnaW5zL3Nwb3RsZXIvLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NhcmJvbi1jb21wb25lbnRzLWFuZ3VsYXIvZmVzbTIwMjAvY2FyYm9uLWNvbXBvbmVudHMtYW5ndWxhci1kcm9wZG93bi5tanMiLCJ3ZWJwYWNrOi8vQHZhbHRpbW8tcGx1Z2lucy9zcG90bGVyLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jYXJib24tY29tcG9uZW50cy1hbmd1bGFyL2Zlc20yMDIwL2NhcmJvbi1jb21wb25lbnRzLWFuZ3VsYXItaTE4bi5tanMiLCJ3ZWJwYWNrOi8vQHZhbHRpbW8tcGx1Z2lucy9zcG90bGVyLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jYXJib24tY29tcG9uZW50cy1hbmd1bGFyL2Zlc20yMDIwL2NhcmJvbi1jb21wb25lbnRzLWFuZ3VsYXItaWNvbi5tanMiLCJ3ZWJwYWNrOi8vQHZhbHRpbW8tcGx1Z2lucy9zcG90bGVyLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jYXJib24tY29tcG9uZW50cy1hbmd1bGFyL2Zlc20yMDIwL2NhcmJvbi1jb21wb25lbnRzLWFuZ3VsYXItcGxhY2Vob2xkZXIubWpzIiwid2VicGFjazovL0B2YWx0aW1vLXBsdWdpbnMvc3BvdGxlci8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY2FyYm9uLWNvbXBvbmVudHMtYW5ndWxhci9mZXNtMjAyMC9jYXJib24tY29tcG9uZW50cy1hbmd1bGFyLXV0aWxzLm1qcyIsIndlYnBhY2s6Ly9AdmFsdGltby1wbHVnaW5zL3Nwb3RsZXIvd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8vQHZhbHRpbW8tcGx1Z2lucy9zcG90bGVyL3dlYnBhY2svcnVudGltZS9jb21wYXQgZ2V0IGRlZmF1bHQgZXhwb3J0Iiwid2VicGFjazovL0B2YWx0aW1vLXBsdWdpbnMvc3BvdGxlci93ZWJwYWNrL3J1bnRpbWUvY3JlYXRlIGZha2UgbmFtZXNwYWNlIG9iamVjdCIsIndlYnBhY2s6Ly9AdmFsdGltby1wbHVnaW5zL3Nwb3RsZXIvd2VicGFjay9ydW50aW1lL2RlZmluZSBwcm9wZXJ0eSBnZXR0ZXJzIiwid2VicGFjazovL0B2YWx0aW1vLXBsdWdpbnMvc3BvdGxlci93ZWJwYWNrL3J1bnRpbWUvaGFzT3duUHJvcGVydHkgc2hvcnRoYW5kIiwid2VicGFjazovL0B2YWx0aW1vLXBsdWdpbnMvc3BvdGxlci93ZWJwYWNrL3J1bnRpbWUvbWFrZSBuYW1lc3BhY2Ugb2JqZWN0Iiwid2VicGFjazovL0B2YWx0aW1vLXBsdWdpbnMvc3BvdGxlci8uL3NyYy9wdWJsaWNfYXBpLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIG93bktleXMob2JqZWN0LCBlbnVtZXJhYmxlT25seSkge1xuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7XG5cbiAgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcbiAgICB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTtcbiAgICBlbnVtZXJhYmxlT25seSAmJiAoc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHtcbiAgICAgIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlO1xuICAgIH0pKSwga2V5cy5wdXNoLmFwcGx5KGtleXMsIHN5bWJvbHMpO1xuICB9XG5cbiAgcmV0dXJuIGtleXM7XG59XG5cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQyKHRhcmdldCkge1xuICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBzb3VyY2UgPSBudWxsICE9IGFyZ3VtZW50c1tpXSA/IGFyZ3VtZW50c1tpXSA6IHt9O1xuICAgIGkgJSAyID8gb3duS2V5cyhPYmplY3Qoc291cmNlKSwgITApLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgX2RlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7XG4gICAgfSkgOiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoc291cmNlKSkgOiBvd25LZXlzKE9iamVjdChzb3VyY2UpKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpO1xuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkge1xuICBpZiAoa2V5IGluIG9iaikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xuICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgb2JqW2tleV0gPSB2YWx1ZTtcbiAgfVxuXG4gIHJldHVybiBvYmo7XG59XG5cbmZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpIHtcbiAgaWYgKHNvdXJjZSA9PSBudWxsKSByZXR1cm4ge307XG4gIHZhciB0YXJnZXQgPSB7fTtcbiAgdmFyIHNvdXJjZUtleXMgPSBPYmplY3Qua2V5cyhzb3VyY2UpO1xuICB2YXIga2V5LCBpO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBzb3VyY2VLZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAga2V5ID0gc291cmNlS2V5c1tpXTtcbiAgICBpZiAoZXhjbHVkZWQuaW5kZXhPZihrZXkpID49IDApIGNvbnRpbnVlO1xuICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufVxuXG5mdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoc291cmNlLCBleGNsdWRlZCkge1xuICBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTtcblxuICB2YXIgdGFyZ2V0ID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2Uoc291cmNlLCBleGNsdWRlZCk7XG5cbiAgdmFyIGtleSwgaTtcblxuICBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykge1xuICAgIHZhciBzb3VyY2VTeW1ib2xLZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzb3VyY2UpO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IHNvdXJjZVN5bWJvbEtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGtleSA9IHNvdXJjZVN5bWJvbEtleXNbaV07XG4gICAgICBpZiAoZXhjbHVkZWQuaW5kZXhPZihrZXkpID49IDApIGNvbnRpbnVlO1xuICAgICAgaWYgKCFPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwoc291cmNlLCBrZXkpKSBjb250aW51ZTtcbiAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn1cblxudmFyIF9leGNsdWRlZCA9IFtcIndpZHRoXCIsIFwiaGVpZ2h0XCIsIFwidmlld0JveFwiXSxcbiAgICBfZXhjbHVkZWQyID0gW1widGFiaW5kZXhcIl07XG5cbi8qKlxuICogQ29weXJpZ2h0IElCTSBDb3JwLiAyMDE4LCAyMDE4XG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlLTIuMCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG52YXIgZGVmYXVsdEF0dHJpYnV0ZXMgPSB7XG4gIC8vIFJlZmVyZW5jZTpcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL0lCTS9jYXJib24tY29tcG9uZW50cy1yZWFjdC9pc3N1ZXMvMTM5MlxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vUG9seW1lckVsZW1lbnRzL2lyb24taWNvbnNldC1zdmcvcHVsbC80N1xuICAvLyBgZm9jdXNhYmxlYCBpcyBhIHN0cmluZyBhdHRyaWJ1dGUgd2hpY2ggaXMgd2h5IHdlIGRvIG5vdCB1c2UgYSBib29sZWFuIGhlcmVcbiAgZm9jdXNhYmxlOiAnZmFsc2UnLFxuICBwcmVzZXJ2ZUFzcGVjdFJhdGlvOiAneE1pZFlNaWQgbWVldCdcbn07XG4vKipcbiAqIEdldCBzdXBwbGVtZW50YXJ5IEhUTUwgYXR0cmlidXRlcyBmb3IgYSBnaXZlbiA8c3ZnPiBlbGVtZW50IGJhc2VkIG9uIGV4aXN0aW5nXG4gKiBhdHRyaWJ1dGVzLlxuICovXG5cbmZ1bmN0aW9uIGdldEF0dHJpYnV0ZXMoKSB7XG4gIHZhciBfcmVmID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fSxcbiAgICAgIHdpZHRoID0gX3JlZi53aWR0aCxcbiAgICAgIGhlaWdodCA9IF9yZWYuaGVpZ2h0LFxuICAgICAgX3JlZiR2aWV3Qm94ID0gX3JlZi52aWV3Qm94LFxuICAgICAgdmlld0JveCA9IF9yZWYkdmlld0JveCA9PT0gdm9pZCAwID8gXCIwIDAgXCIuY29uY2F0KHdpZHRoLCBcIiBcIikuY29uY2F0KGhlaWdodCkgOiBfcmVmJHZpZXdCb3gsXG4gICAgICBhdHRyaWJ1dGVzID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF9yZWYsIF9leGNsdWRlZCk7XG5cbiAgdmFyIHRhYmluZGV4ID0gYXR0cmlidXRlcy50YWJpbmRleCxcbiAgICAgIHJlc3QgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoYXR0cmlidXRlcywgX2V4Y2x1ZGVkMik7XG5cbiAgdmFyIGljb25BdHRyaWJ1dGVzID0gX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoe30sIGRlZmF1bHRBdHRyaWJ1dGVzKSwgcmVzdCksIHt9LCB7XG4gICAgd2lkdGg6IHdpZHRoLFxuICAgIGhlaWdodDogaGVpZ2h0LFxuICAgIHZpZXdCb3g6IHZpZXdCb3hcbiAgfSk7IC8vIFRPRE86IGF0dHJpYnV0ZXMudGl0bGUgYXNzdW1lcyB0aGF0IHRoZSBjb25zdW1lciB3aWxsIGltcGxlbWVudCA8dGl0bGU+IGFuZFxuICAvLyBjb3JyZWN0bHkgc2V0IGBhcmlhLWxhYmVsbGVkYnlgLlxuXG5cbiAgaWYgKGljb25BdHRyaWJ1dGVzWydhcmlhLWxhYmVsJ10gfHwgaWNvbkF0dHJpYnV0ZXNbJ2FyaWEtbGFiZWxsZWRieSddIHx8IGljb25BdHRyaWJ1dGVzLnRpdGxlKSB7XG4gICAgaWNvbkF0dHJpYnV0ZXMucm9sZSA9ICdpbWcnOyAvLyBSZWZlcmVuY2U6XG4gICAgLy8gaHR0cHM6Ly9hbGx5anMuaW8vdHV0b3JpYWxzL2ZvY3VzaW5nLWluLXN2Zy5odG1sXG5cbiAgICBpZiAodGFiaW5kZXggIT09IHVuZGVmaW5lZCAmJiB0YWJpbmRleCAhPT0gbnVsbCkge1xuICAgICAgaWNvbkF0dHJpYnV0ZXMuZm9jdXNhYmxlID0gJ3RydWUnO1xuICAgICAgaWNvbkF0dHJpYnV0ZXMudGFiaW5kZXggPSB0YWJpbmRleDtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWNvbkF0dHJpYnV0ZXNbJ2FyaWEtaGlkZGVuJ10gPSB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIGljb25BdHRyaWJ1dGVzO1xufVxuXG4vKipcbiAqIENvcHlyaWdodCBJQk0gQ29ycC4gMjAxOCwgMjAxOFxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZS0yLjAgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuLyoqXG4gKiBDb252ZXJ0IGFuIGljb24gZGVzY3JpcHRvciB0byBhIFN0cmluZ1xuICovXG5cbmZ1bmN0aW9uIHRvU3RyaW5nKGRlc2NyaXB0b3IpIHtcbiAgdmFyIF9kZXNjcmlwdG9yJGVsZW0gPSBkZXNjcmlwdG9yLmVsZW0sXG4gICAgICBlbGVtID0gX2Rlc2NyaXB0b3IkZWxlbSA9PT0gdm9pZCAwID8gJ3N2ZycgOiBfZGVzY3JpcHRvciRlbGVtLFxuICAgICAgX2Rlc2NyaXB0b3IkYXR0cnMgPSBkZXNjcmlwdG9yLmF0dHJzLFxuICAgICAgYXR0cnMgPSBfZGVzY3JpcHRvciRhdHRycyA9PT0gdm9pZCAwID8ge30gOiBfZGVzY3JpcHRvciRhdHRycyxcbiAgICAgIF9kZXNjcmlwdG9yJGNvbnRlbnQgPSBkZXNjcmlwdG9yLmNvbnRlbnQsXG4gICAgICBjb250ZW50ID0gX2Rlc2NyaXB0b3IkY29udGVudCA9PT0gdm9pZCAwID8gW10gOiBfZGVzY3JpcHRvciRjb250ZW50O1xuICB2YXIgY2hpbGRyZW4gPSBjb250ZW50Lm1hcCh0b1N0cmluZykuam9pbignJyk7XG5cbiAgaWYgKGVsZW0gIT09ICdzdmcnKSB7XG4gICAgcmV0dXJuIFwiPFwiLmNvbmNhdChlbGVtLCBcIiBcIikuY29uY2F0KGZvcm1hdEF0dHJpYnV0ZXMoYXR0cnMpLCBcIj5cIikuY29uY2F0KGNoaWxkcmVuLCBcIjwvXCIpLmNvbmNhdChlbGVtLCBcIj5cIik7XG4gIH1cblxuICByZXR1cm4gXCI8XCIuY29uY2F0KGVsZW0sIFwiIFwiKS5jb25jYXQoZm9ybWF0QXR0cmlidXRlcyhnZXRBdHRyaWJ1dGVzKGF0dHJzKSksIFwiPlwiKS5jb25jYXQoY2hpbGRyZW4sIFwiPC9cIikuY29uY2F0KGVsZW0sIFwiPlwiKTtcbn1cbmZ1bmN0aW9uIGZvcm1hdEF0dHJpYnV0ZXMoYXR0cnMpIHtcbiAgcmV0dXJuIE9iamVjdC5rZXlzKGF0dHJzKS5yZWR1Y2UoZnVuY3Rpb24gKGFjYywga2V5LCBpbmRleCkge1xuICAgIHZhciBhdHRyaWJ1dGUgPSBcIlwiLmNvbmNhdChrZXksIFwiPVxcXCJcIikuY29uY2F0KGF0dHJzW2tleV0sIFwiXFxcIlwiKTtcblxuICAgIGlmIChpbmRleCA9PT0gMCkge1xuICAgICAgcmV0dXJuIGF0dHJpYnV0ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gYWNjICsgJyAnICsgYXR0cmlidXRlO1xuICB9LCAnJyk7XG59XG5cbi8qKlxuICogQ29weXJpZ2h0IElCTSBDb3JwLiAyMDE4LCAyMDE4XG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlLTIuMCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG4vKipcbiAqIENvbnZlcnQgYW4gaWNvbiBkZXNjcmlwdG9yIHRvIGEgRE9NIG5vZGUuXG4gKi9cblxuZnVuY3Rpb24gdG9TVkcoZGVzY3JpcHRvcikge1xuICB2YXIgX2Rlc2NyaXB0b3IkZWxlbSA9IGRlc2NyaXB0b3IuZWxlbSxcbiAgICAgIGVsZW0gPSBfZGVzY3JpcHRvciRlbGVtID09PSB2b2lkIDAgPyAnc3ZnJyA6IF9kZXNjcmlwdG9yJGVsZW0sXG4gICAgICBfZGVzY3JpcHRvciRhdHRycyA9IGRlc2NyaXB0b3IuYXR0cnMsXG4gICAgICBhdHRycyA9IF9kZXNjcmlwdG9yJGF0dHJzID09PSB2b2lkIDAgPyB7fSA6IF9kZXNjcmlwdG9yJGF0dHJzLFxuICAgICAgX2Rlc2NyaXB0b3IkY29udGVudCA9IGRlc2NyaXB0b3IuY29udGVudCxcbiAgICAgIGNvbnRlbnQgPSBfZGVzY3JpcHRvciRjb250ZW50ID09PSB2b2lkIDAgPyBbXSA6IF9kZXNjcmlwdG9yJGNvbnRlbnQ7XG4gIHZhciBub2RlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKCdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZycsIGVsZW0pO1xuICB2YXIgYXR0cmlidXRlcyA9IGVsZW0gIT09ICdzdmcnID8gYXR0cnMgOiBnZXRBdHRyaWJ1dGVzKGF0dHJzKTtcbiAgT2JqZWN0LmtleXMoYXR0cmlidXRlcykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgbm9kZS5zZXRBdHRyaWJ1dGUoa2V5LCBhdHRyc1trZXldKTtcbiAgfSk7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb250ZW50Lmxlbmd0aDsgaSsrKSB7XG4gICAgbm9kZS5hcHBlbmRDaGlsZCh0b1NWRyhjb250ZW50W2ldKSk7XG4gIH1cblxuICByZXR1cm4gbm9kZTtcbn1cblxuZXhwb3J0IHsgZGVmYXVsdEF0dHJpYnV0ZXMsIGZvcm1hdEF0dHJpYnV0ZXMsIGdldEF0dHJpYnV0ZXMsIHRvU1ZHLCB0b1N0cmluZyB9O1xuIiwiLyoqXG4gKiBDb3B5cmlnaHQgSUJNIENvcnAuIDIwMTYsIDIwMjBcbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUtMi4wIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogQ29kZSBnZW5lcmF0ZWQgYnkgQGNhcmJvbi9pY29uLWJ1aWxkLWhlbHBlcnMuIERPIE5PVCBFRElULlxuICovXG52YXIgXzE2ID0ge1xuICBcImVsZW1cIjogXCJzdmdcIixcbiAgXCJhdHRyc1wiOiB7XG4gICAgXCJ4bWxuc1wiOiBcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsXG4gICAgXCJ2aWV3Qm94XCI6IFwiMCAwIDMyIDMyXCIsXG4gICAgXCJmaWxsXCI6IFwiY3VycmVudENvbG9yXCIsXG4gICAgXCJ3aWR0aFwiOiAxNixcbiAgICBcImhlaWdodFwiOiAxNlxuICB9LFxuICBcImNvbnRlbnRcIjogW3tcbiAgICBcImVsZW1cIjogXCJwYXRoXCIsXG4gICAgXCJhdHRyc1wiOiB7XG4gICAgICBcImRcIjogXCJNMTcgMTVMMTcgOCAxNSA4IDE1IDE1IDggMTUgOCAxNyAxNSAxNyAxNSAyNCAxNyAyNCAxNyAxNyAyNCAxNyAyNCAxNXpcIlxuICAgIH1cbiAgfV0sXG4gIFwibmFtZVwiOiBcImFkZFwiLFxuICBcInNpemVcIjogMTZcbn07XG5cbmV4cG9ydCB7IF8xNiBhcyBkZWZhdWx0IH07XG4iLCIvKipcbiAqIENvcHlyaWdodCBJQk0gQ29ycC4gMjAxNiwgMjAyMFxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZS0yLjAgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBDb2RlIGdlbmVyYXRlZCBieSBAY2FyYm9uL2ljb24tYnVpbGQtaGVscGVycy4gRE8gTk9UIEVESVQuXG4gKi9cbnZhciBfMjAgPSB7XG4gIFwiZWxlbVwiOiBcInN2Z1wiLFxuICBcImF0dHJzXCI6IHtcbiAgICBcInhtbG5zXCI6IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIixcbiAgICBcInZpZXdCb3hcIjogXCIwIDAgMzIgMzJcIixcbiAgICBcImZpbGxcIjogXCJjdXJyZW50Q29sb3JcIixcbiAgICBcIndpZHRoXCI6IDIwLFxuICAgIFwiaGVpZ2h0XCI6IDIwXG4gIH0sXG4gIFwiY29udGVudFwiOiBbe1xuICAgIFwiZWxlbVwiOiBcInBhdGhcIixcbiAgICBcImF0dHJzXCI6IHtcbiAgICAgIFwiZFwiOiBcIk0xNyAxNUwxNyA4IDE1IDggMTUgMTUgOCAxNSA4IDE3IDE1IDE3IDE1IDI0IDE3IDI0IDE3IDE3IDI0IDE3IDI0IDE1elwiXG4gICAgfVxuICB9XSxcbiAgXCJuYW1lXCI6IFwiYWRkXCIsXG4gIFwic2l6ZVwiOiAyMFxufTtcblxuZXhwb3J0IHsgXzIwIGFzIGRlZmF1bHQgfTtcbiIsIi8qKlxuICogQ29weXJpZ2h0IElCTSBDb3JwLiAyMDE2LCAyMDIwXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlLTIuMCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIENvZGUgZ2VuZXJhdGVkIGJ5IEBjYXJib24vaWNvbi1idWlsZC1oZWxwZXJzLiBETyBOT1QgRURJVC5cbiAqL1xudmFyIF8xNiA9IHtcbiAgXCJlbGVtXCI6IFwic3ZnXCIsXG4gIFwiYXR0cnNcIjoge1xuICAgIFwieG1sbnNcIjogXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLFxuICAgIFwidmlld0JveFwiOiBcIjAgMCAzMiAzMlwiLFxuICAgIFwiZmlsbFwiOiBcImN1cnJlbnRDb2xvclwiLFxuICAgIFwid2lkdGhcIjogMTYsXG4gICAgXCJoZWlnaHRcIjogMTZcbiAgfSxcbiAgXCJjb250ZW50XCI6IFt7XG4gICAgXCJlbGVtXCI6IFwicGF0aFwiLFxuICAgIFwiYXR0cnNcIjoge1xuICAgICAgXCJkXCI6IFwiTTE2IDEwYTYgNiAwIDAwLTYgNnY4YTYgNiAwIDAwMTIgMFYxNkE2IDYgMCAwMDE2IDEwem0tNC4yNSA3Ljg3aDguNXY0LjI1aC04LjV6TTE2IDI4LjI1QTQuMjcgNC4yNyAwIDAxMTEuNzUgMjR2LS4xM2g4LjVWMjRBNC4yNyA0LjI3IDAgMDExNiAyOC4yNXptNC4yNS0xMi4xM2gtOC41VjE2YTQuMjUgNC4yNSAwIDAxOC41IDB6TTMwLjY2IDE5LjIxTDI0IDEzdjkuMWE0IDQgMCAwMDggMEEzLjgzIDMuODMgMCAwMDMwLjY2IDE5LjIxek0yOCAyNC4zNWEyLjI1IDIuMjUgMCAwMS0yLjI1LTIuMjVWMTdsMy43MiAzLjQ3aDBBMi4wNSAyLjA1IDAgMDEzMC4yIDIyIDIuMjUgMi4yNSAwIDAxMjggMjQuMzV6TTAgMjIuMWE0IDQgMCAwMDggMFYxM0wxLjM0IDE5LjIxQTMuODggMy44OCAwIDAwMCAyMi4xem0yLjQ4LTEuNTZoMEw2LjI1IDE3djUuMWEyLjI1IDIuMjUgMCAwMS00LjUgMEEyLjA1IDIuMDUgMCAwMTIuNDggMjAuNTR6TTE1IDUuNUEzLjUgMy41IDAgMTAxMS41IDkgMy41IDMuNSAwIDAwMTUgNS41em0tNS4yNSAwQTEuNzUgMS43NSAwIDExMTEuNSA3LjI1IDEuNzcgMS43NyAwIDAxOS43NSA1LjV6TTIwLjUgMkEzLjUgMy41IDAgMTAyNCA1LjUgMy41IDMuNSAwIDAwMjAuNSAyem0wIDUuMjVBMS43NSAxLjc1IDAgMTEyMi4yNSA1LjUgMS43NyAxLjc3IDAgMDEyMC41IDcuMjV6XCJcbiAgICB9XG4gIH1dLFxuICBcIm5hbWVcIjogXCJiZWVcIixcbiAgXCJzaXplXCI6IDE2XG59O1xuXG5leHBvcnQgeyBfMTYgYXMgZGVmYXVsdCB9O1xuIiwiLyoqXG4gKiBDb3B5cmlnaHQgSUJNIENvcnAuIDIwMTYsIDIwMjBcbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUtMi4wIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogQ29kZSBnZW5lcmF0ZWQgYnkgQGNhcmJvbi9pY29uLWJ1aWxkLWhlbHBlcnMuIERPIE5PVCBFRElULlxuICovXG52YXIgXzIwID0ge1xuICBcImVsZW1cIjogXCJzdmdcIixcbiAgXCJhdHRyc1wiOiB7XG4gICAgXCJ4bWxuc1wiOiBcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsXG4gICAgXCJ2aWV3Qm94XCI6IFwiMCAwIDMyIDMyXCIsXG4gICAgXCJmaWxsXCI6IFwiY3VycmVudENvbG9yXCIsXG4gICAgXCJ3aWR0aFwiOiAyMCxcbiAgICBcImhlaWdodFwiOiAyMFxuICB9LFxuICBcImNvbnRlbnRcIjogW3tcbiAgICBcImVsZW1cIjogXCJwYXRoXCIsXG4gICAgXCJhdHRyc1wiOiB7XG4gICAgICBcImRcIjogXCJNMTYgMTBhNiA2IDAgMDAtNiA2djhhNiA2IDAgMDAxMiAwVjE2QTYgNiAwIDAwMTYgMTB6bS00LjI1IDcuODdoOC41djQuMjVoLTguNXpNMTYgMjguMjVBNC4yNyA0LjI3IDAgMDExMS43NSAyNHYtLjEzaDguNVYyNEE0LjI3IDQuMjcgMCAwMTE2IDI4LjI1em00LjI1LTEyLjEzaC04LjVWMTZhNC4yNSA0LjI1IDAgMDE4LjUgMHpNMzAuNjYgMTkuMjFMMjQgMTN2OS4xYTQgNCAwIDAwOCAwQTMuODMgMy44MyAwIDAwMzAuNjYgMTkuMjF6TTI4IDI0LjM1YTIuMjUgMi4yNSAwIDAxLTIuMjUtMi4yNVYxN2wzLjcyIDMuNDdoMEEyLjA1IDIuMDUgMCAwMTMwLjIgMjIgMi4yNSAyLjI1IDAgMDEyOCAyNC4zNXpNMCAyMi4xYTQgNCAwIDAwOCAwVjEzTDEuMzQgMTkuMjFBMy44OCAzLjg4IDAgMDAwIDIyLjF6bTIuNDgtMS41NmgwTDYuMjUgMTd2NS4xYTIuMjUgMi4yNSAwIDAxLTQuNSAwQTIuMDUgMi4wNSAwIDAxMi40OCAyMC41NHpNMTUgNS41QTMuNSAzLjUgMCAxMDExLjUgOSAzLjUgMy41IDAgMDAxNSA1LjV6bS01LjI1IDBBMS43NSAxLjc1IDAgMTExMS41IDcuMjUgMS43NyAxLjc3IDAgMDE5Ljc1IDUuNXpNMjAuNSAyQTMuNSAzLjUgMCAxMDI0IDUuNSAzLjUgMy41IDAgMDAyMC41IDJ6bTAgNS4yNUExLjc1IDEuNzUgMCAxMTIyLjI1IDUuNSAxLjc3IDEuNzcgMCAwMTIwLjUgNy4yNXpcIlxuICAgIH1cbiAgfV0sXG4gIFwibmFtZVwiOiBcImJlZVwiLFxuICBcInNpemVcIjogMjBcbn07XG5cbmV4cG9ydCB7IF8yMCBhcyBkZWZhdWx0IH07XG4iLCIvKipcbiAqIENvcHlyaWdodCBJQk0gQ29ycC4gMjAxNiwgMjAyMFxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZS0yLjAgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBDb2RlIGdlbmVyYXRlZCBieSBAY2FyYm9uL2ljb24tYnVpbGQtaGVscGVycy4gRE8gTk9UIEVESVQuXG4gKi9cbnZhciBfMTYgPSB7XG4gIFwiZWxlbVwiOiBcInN2Z1wiLFxuICBcImF0dHJzXCI6IHtcbiAgICBcInhtbG5zXCI6IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIixcbiAgICBcInZpZXdCb3hcIjogXCIwIDAgMzIgMzJcIixcbiAgICBcImZpbGxcIjogXCJjdXJyZW50Q29sb3JcIixcbiAgICBcIndpZHRoXCI6IDE2LFxuICAgIFwiaGVpZ2h0XCI6IDE2XG4gIH0sXG4gIFwiY29udGVudFwiOiBbe1xuICAgIFwiZWxlbVwiOiBcInBhdGhcIixcbiAgICBcImF0dHJzXCI6IHtcbiAgICAgIFwiZFwiOiBcIk0yNiw0aC00VjJoLTJ2MmgtOFYyaC0ydjJINkM0LjksNCw0LDQuOSw0LDZ2MjBjMCwxLjEsMC45LDIsMiwyaDIwYzEuMSwwLDItMC45LDItMlY2QzI4LDQuOSwyNy4xLDQsMjYsNHogTTI2LDI2SDZWMTJoMjBcXHRWMjZ6IE0yNiwxMEg2VjZoNHYyaDJWNmg4djJoMlY2aDRWMTB6XCJcbiAgICB9XG4gIH1dLFxuICBcIm5hbWVcIjogXCJjYWxlbmRhclwiLFxuICBcInNpemVcIjogMTZcbn07XG5cbmV4cG9ydCB7IF8xNiBhcyBkZWZhdWx0IH07XG4iLCIvKipcbiAqIENvcHlyaWdodCBJQk0gQ29ycC4gMjAxNiwgMjAyMFxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZS0yLjAgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBDb2RlIGdlbmVyYXRlZCBieSBAY2FyYm9uL2ljb24tYnVpbGQtaGVscGVycy4gRE8gTk9UIEVESVQuXG4gKi9cbnZhciBfMTYgPSB7XG4gIFwiZWxlbVwiOiBcInN2Z1wiLFxuICBcImF0dHJzXCI6IHtcbiAgICBcInhtbG5zXCI6IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIixcbiAgICBcInZpZXdCb3hcIjogXCIwIDAgMzIgMzJcIixcbiAgICBcImZpbGxcIjogXCJjdXJyZW50Q29sb3JcIixcbiAgICBcIndpZHRoXCI6IDE2LFxuICAgIFwiaGVpZ2h0XCI6IDE2XG4gIH0sXG4gIFwiY29udGVudFwiOiBbe1xuICAgIFwiZWxlbVwiOiBcInBhdGhcIixcbiAgICBcImF0dHJzXCI6IHtcbiAgICAgIFwiZFwiOiBcIk0xMy41LDMwLjgxNDlhMS4wMDExLDEuMDAxMSwwLDAsMS0uNDkyNy0uMTNsLTguNS00LjgxNUExLDEsMCwwLDEsNCwyNVYxNWExLDEsMCwwLDEsLjUwNzMtLjg3bDguNS00LjgxNWExLjAwMTMsMS4wMDEzLDAsMCwxLC45ODU0LDBsOC41LDQuODE1QTEsMSwwLDAsMSwyMywxNVYyNWExLDEsMCwwLDEtLjUwNzMuODdsLTguNSw0LjgxNUExLjAwMTEsMS4wMDExLDAsMCwxLDEzLjUsMzAuODE0OVpNNiwyNC40MTdsNy41LDQuMjQ4NUwyMSwyNC40MTdWMTUuNTgzbC03LjUtNC4yNDg1TDYsMTUuNTgzWlwiXG4gICAgfVxuICB9LCB7XG4gICAgXCJlbGVtXCI6IFwicGF0aFwiLFxuICAgIFwiYXR0cnNcIjoge1xuICAgICAgXCJkXCI6IFwiTTI4LDE3SDI2VjcuNTgzTDE4LjUsMy4zMzQ1LDEwLjQ5MjcsNy44Nyw5LjUwNzMsNi4xM2w4LjUtNC44MTVhMS4wMDEzLDEuMDAxMywwLDAsMSwuOTg1NCwwbDguNSw0LjgxNUExLDEsMCwwLDEsMjgsN1pcIlxuICAgIH1cbiAgfV0sXG4gIFwibmFtZVwiOiBcImNhcmJvblwiLFxuICBcInNpemVcIjogMTZcbn07XG5cbmV4cG9ydCB7IF8xNiBhcyBkZWZhdWx0IH07XG4iLCIvKipcbiAqIENvcHlyaWdodCBJQk0gQ29ycC4gMjAxNiwgMjAyMFxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZS0yLjAgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBDb2RlIGdlbmVyYXRlZCBieSBAY2FyYm9uL2ljb24tYnVpbGQtaGVscGVycy4gRE8gTk9UIEVESVQuXG4gKi9cbnZhciBfMjAgPSB7XG4gIFwiZWxlbVwiOiBcInN2Z1wiLFxuICBcImF0dHJzXCI6IHtcbiAgICBcInhtbG5zXCI6IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIixcbiAgICBcInZpZXdCb3hcIjogXCIwIDAgMzIgMzJcIixcbiAgICBcImZpbGxcIjogXCJjdXJyZW50Q29sb3JcIixcbiAgICBcIndpZHRoXCI6IDIwLFxuICAgIFwiaGVpZ2h0XCI6IDIwXG4gIH0sXG4gIFwiY29udGVudFwiOiBbe1xuICAgIFwiZWxlbVwiOiBcInBhdGhcIixcbiAgICBcImF0dHJzXCI6IHtcbiAgICAgIFwiZFwiOiBcIk0xMy41LDMwLjgxNDlhMS4wMDExLDEuMDAxMSwwLDAsMS0uNDkyNy0uMTNsLTguNS00LjgxNUExLDEsMCwwLDEsNCwyNVYxNWExLDEsMCwwLDEsLjUwNzMtLjg3bDguNS00LjgxNWExLjAwMTMsMS4wMDEzLDAsMCwxLC45ODU0LDBsOC41LDQuODE1QTEsMSwwLDAsMSwyMywxNVYyNWExLDEsMCwwLDEtLjUwNzMuODdsLTguNSw0LjgxNUExLjAwMTEsMS4wMDExLDAsMCwxLDEzLjUsMzAuODE0OVpNNiwyNC40MTdsNy41LDQuMjQ4NUwyMSwyNC40MTdWMTUuNTgzbC03LjUtNC4yNDg1TDYsMTUuNTgzWlwiXG4gICAgfVxuICB9LCB7XG4gICAgXCJlbGVtXCI6IFwicGF0aFwiLFxuICAgIFwiYXR0cnNcIjoge1xuICAgICAgXCJkXCI6IFwiTTI4LDE3SDI2VjcuNTgzTDE4LjUsMy4zMzQ1LDEwLjQ5MjcsNy44Nyw5LjUwNzMsNi4xM2w4LjUtNC44MTVhMS4wMDEzLDEuMDAxMywwLDAsMSwuOTg1NCwwbDguNSw0LjgxNUExLDEsMCwwLDEsMjgsN1pcIlxuICAgIH1cbiAgfV0sXG4gIFwibmFtZVwiOiBcImNhcmJvblwiLFxuICBcInNpemVcIjogMjBcbn07XG5cbmV4cG9ydCB7IF8yMCBhcyBkZWZhdWx0IH07XG4iLCIvKipcbiAqIENvcHlyaWdodCBJQk0gQ29ycC4gMjAxNiwgMjAyMFxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZS0yLjAgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBDb2RlIGdlbmVyYXRlZCBieSBAY2FyYm9uL2ljb24tYnVpbGQtaGVscGVycy4gRE8gTk9UIEVESVQuXG4gKi9cbnZhciBfMTYgPSB7XG4gIFwiZWxlbVwiOiBcInN2Z1wiLFxuICBcImF0dHJzXCI6IHtcbiAgICBcInhtbG5zXCI6IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIixcbiAgICBcInZpZXdCb3hcIjogXCIwIDAgMzIgMzJcIixcbiAgICBcImZpbGxcIjogXCJjdXJyZW50Q29sb3JcIixcbiAgICBcIndpZHRoXCI6IDE2LFxuICAgIFwiaGVpZ2h0XCI6IDE2XG4gIH0sXG4gIFwiY29udGVudFwiOiBbe1xuICAgIFwiZWxlbVwiOiBcInBhdGhcIixcbiAgICBcImF0dHJzXCI6IHtcbiAgICAgIFwiZFwiOiBcIk0yNCAxMkwxNiAyMiA4IDEyelwiXG4gICAgfVxuICB9XSxcbiAgXCJuYW1lXCI6IFwiY2FyZXQtLWRvd25cIixcbiAgXCJzaXplXCI6IDE2XG59O1xuXG5leHBvcnQgeyBfMTYgYXMgZGVmYXVsdCB9O1xuIiwiLyoqXG4gKiBDb3B5cmlnaHQgSUJNIENvcnAuIDIwMTYsIDIwMjBcbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUtMi4wIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogQ29kZSBnZW5lcmF0ZWQgYnkgQGNhcmJvbi9pY29uLWJ1aWxkLWhlbHBlcnMuIERPIE5PVCBFRElULlxuICovXG52YXIgXzE2ID0ge1xuICBcImVsZW1cIjogXCJzdmdcIixcbiAgXCJhdHRyc1wiOiB7XG4gICAgXCJ4bWxuc1wiOiBcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsXG4gICAgXCJ2aWV3Qm94XCI6IFwiMCAwIDMyIDMyXCIsXG4gICAgXCJmaWxsXCI6IFwiY3VycmVudENvbG9yXCIsXG4gICAgXCJ3aWR0aFwiOiAxNixcbiAgICBcImhlaWdodFwiOiAxNlxuICB9LFxuICBcImNvbnRlbnRcIjogW3tcbiAgICBcImVsZW1cIjogXCJwYXRoXCIsXG4gICAgXCJhdHRyc1wiOiB7XG4gICAgICBcImRcIjogXCJNMjAgMjRMMTAgMTYgMjAgOHpcIlxuICAgIH1cbiAgfV0sXG4gIFwibmFtZVwiOiBcImNhcmV0LS1sZWZ0XCIsXG4gIFwic2l6ZVwiOiAxNlxufTtcblxuZXhwb3J0IHsgXzE2IGFzIGRlZmF1bHQgfTtcbiIsIi8qKlxuICogQ29weXJpZ2h0IElCTSBDb3JwLiAyMDE2LCAyMDIwXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlLTIuMCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIENvZGUgZ2VuZXJhdGVkIGJ5IEBjYXJib24vaWNvbi1idWlsZC1oZWxwZXJzLiBETyBOT1QgRURJVC5cbiAqL1xudmFyIF8xNiA9IHtcbiAgXCJlbGVtXCI6IFwic3ZnXCIsXG4gIFwiYXR0cnNcIjoge1xuICAgIFwieG1sbnNcIjogXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLFxuICAgIFwidmlld0JveFwiOiBcIjAgMCAzMiAzMlwiLFxuICAgIFwiZmlsbFwiOiBcImN1cnJlbnRDb2xvclwiLFxuICAgIFwid2lkdGhcIjogMTYsXG4gICAgXCJoZWlnaHRcIjogMTZcbiAgfSxcbiAgXCJjb250ZW50XCI6IFt7XG4gICAgXCJlbGVtXCI6IFwicGF0aFwiLFxuICAgIFwiYXR0cnNcIjoge1xuICAgICAgXCJkXCI6IFwiTTEyIDhMMjIgMTYgMTIgMjR6XCJcbiAgICB9XG4gIH1dLFxuICBcIm5hbWVcIjogXCJjYXJldC0tcmlnaHRcIixcbiAgXCJzaXplXCI6IDE2XG59O1xuXG5leHBvcnQgeyBfMTYgYXMgZGVmYXVsdCB9O1xuIiwiLyoqXG4gKiBDb3B5cmlnaHQgSUJNIENvcnAuIDIwMTYsIDIwMjBcbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUtMi4wIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogQ29kZSBnZW5lcmF0ZWQgYnkgQGNhcmJvbi9pY29uLWJ1aWxkLWhlbHBlcnMuIERPIE5PVCBFRElULlxuICovXG52YXIgXzE2ID0ge1xuICBcImVsZW1cIjogXCJzdmdcIixcbiAgXCJhdHRyc1wiOiB7XG4gICAgXCJ4bWxuc1wiOiBcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsXG4gICAgXCJ2aWV3Qm94XCI6IFwiMCAwIDMyIDMyXCIsXG4gICAgXCJmaWxsXCI6IFwiY3VycmVudENvbG9yXCIsXG4gICAgXCJ3aWR0aFwiOiAxNixcbiAgICBcImhlaWdodFwiOiAxNlxuICB9LFxuICBcImNvbnRlbnRcIjogW3tcbiAgICBcImVsZW1cIjogXCJwYXRoXCIsXG4gICAgXCJhdHRyc1wiOiB7XG4gICAgICBcImRcIjogXCJNOCAyMEwxNiAxMCAyNCAyMHpcIlxuICAgIH1cbiAgfV0sXG4gIFwibmFtZVwiOiBcImNhcmV0LS11cFwiLFxuICBcInNpemVcIjogMTZcbn07XG5cbmV4cG9ydCB7IF8xNiBhcyBkZWZhdWx0IH07XG4iLCIvKipcbiAqIENvcHlyaWdodCBJQk0gQ29ycC4gMjAxNiwgMjAyMFxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZS0yLjAgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBDb2RlIGdlbmVyYXRlZCBieSBAY2FyYm9uL2ljb24tYnVpbGQtaGVscGVycy4gRE8gTk9UIEVESVQuXG4gKi9cbnZhciBfMTYgPSB7XG4gIFwiZWxlbVwiOiBcInN2Z1wiLFxuICBcImF0dHJzXCI6IHtcbiAgICBcInhtbG5zXCI6IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIixcbiAgICBcInZpZXdCb3hcIjogXCIwIDAgMTYgMTZcIixcbiAgICBcImZpbGxcIjogXCJjdXJyZW50Q29sb3JcIixcbiAgICBcIndpZHRoXCI6IDE2LFxuICAgIFwiaGVpZ2h0XCI6IDE2XG4gIH0sXG4gIFwiY29udGVudFwiOiBbe1xuICAgIFwiZWxlbVwiOiBcInBhdGhcIixcbiAgICBcImF0dHJzXCI6IHtcbiAgICAgIFwiZFwiOiBcIk04LDFDNC4xLDEsMSw0LjEsMSw4YzAsMy45LDMuMSw3LDcsN3M3LTMuMSw3LTdDMTUsNC4xLDExLjksMSw4LDF6IE03LDExTDQuMyw4LjNsMC45LTAuOEw3LDkuM2w0LTMuOWwwLjksMC44TDcsMTF6XCJcbiAgICB9XG4gIH0sIHtcbiAgICBcImVsZW1cIjogXCJwYXRoXCIsXG4gICAgXCJhdHRyc1wiOiB7XG4gICAgICBcImRcIjogXCJNNywxMUw0LjMsOC4zbDAuOS0wLjhMNyw5LjNsNC0zLjlsMC45LDAuOEw3LDExelwiLFxuICAgICAgXCJkYXRhLWljb24tcGF0aFwiOiBcImlubmVyLXBhdGhcIixcbiAgICAgIFwib3BhY2l0eVwiOiBcIjBcIlxuICAgIH1cbiAgfV0sXG4gIFwibmFtZVwiOiBcImNoZWNrbWFyay0tZmlsbGVkXCIsXG4gIFwic2l6ZVwiOiAxNlxufTtcblxuZXhwb3J0IHsgXzE2IGFzIGRlZmF1bHQgfTtcbiIsIi8qKlxuICogQ29weXJpZ2h0IElCTSBDb3JwLiAyMDE2LCAyMDIwXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlLTIuMCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIENvZGUgZ2VuZXJhdGVkIGJ5IEBjYXJib24vaWNvbi1idWlsZC1oZWxwZXJzLiBETyBOT1QgRURJVC5cbiAqL1xudmFyIF8yMCA9IHtcbiAgXCJlbGVtXCI6IFwic3ZnXCIsXG4gIFwiYXR0cnNcIjoge1xuICAgIFwieG1sbnNcIjogXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLFxuICAgIFwidmlld0JveFwiOiBcIjAgMCAyMCAyMFwiLFxuICAgIFwiZmlsbFwiOiBcImN1cnJlbnRDb2xvclwiLFxuICAgIFwid2lkdGhcIjogMjAsXG4gICAgXCJoZWlnaHRcIjogMjBcbiAgfSxcbiAgXCJjb250ZW50XCI6IFt7XG4gICAgXCJlbGVtXCI6IFwicGF0aFwiLFxuICAgIFwiYXR0cnNcIjoge1xuICAgICAgXCJkXCI6IFwiTTEwLDFjLTQuOSwwLTksNC4xLTksOXM0LjEsOSw5LDlzOS00LDktOVMxNSwxLDEwLDF6IE04LjcsMTMuNWwtMy4yLTMuMmwxLTFsMi4yLDIuMmw0LjgtNC44bDEsMUw4LjcsMTMuNXpcIlxuICAgIH1cbiAgfSwge1xuICAgIFwiZWxlbVwiOiBcInBhdGhcIixcbiAgICBcImF0dHJzXCI6IHtcbiAgICAgIFwiZmlsbFwiOiBcIm5vbmVcIixcbiAgICAgIFwiZFwiOiBcIk04LjcsMTMuNWwtMy4yLTMuMmwxLTFsMi4yLDIuMmw0LjgtNC44bDEsMUw4LjcsMTMuNXpcIixcbiAgICAgIFwiZGF0YS1pY29uLXBhdGhcIjogXCJpbm5lci1wYXRoXCIsXG4gICAgICBcIm9wYWNpdHlcIjogXCIwXCJcbiAgICB9XG4gIH1dLFxuICBcIm5hbWVcIjogXCJjaGVja21hcmstLWZpbGxlZFwiLFxuICBcInNpemVcIjogMjBcbn07XG5cbmV4cG9ydCB7IF8yMCBhcyBkZWZhdWx0IH07XG4iLCIvKipcbiAqIENvcHlyaWdodCBJQk0gQ29ycC4gMjAxNiwgMjAyMFxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZS0yLjAgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBDb2RlIGdlbmVyYXRlZCBieSBAY2FyYm9uL2ljb24tYnVpbGQtaGVscGVycy4gRE8gTk9UIEVESVQuXG4gKi9cbnZhciBfMTYgPSB7XG4gIFwiZWxlbVwiOiBcInN2Z1wiLFxuICBcImF0dHJzXCI6IHtcbiAgICBcInhtbG5zXCI6IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIixcbiAgICBcInZpZXdCb3hcIjogXCIwIDAgMzIgMzJcIixcbiAgICBcImZpbGxcIjogXCJjdXJyZW50Q29sb3JcIixcbiAgICBcIndpZHRoXCI6IDE2LFxuICAgIFwiaGVpZ2h0XCI6IDE2XG4gIH0sXG4gIFwiY29udGVudFwiOiBbe1xuICAgIFwiZWxlbVwiOiBcInBhdGhcIixcbiAgICBcImF0dHJzXCI6IHtcbiAgICAgIFwiZFwiOiBcIk0xNCAyMS40MTRMOSAxNi40MTMgMTAuNDEzIDE1IDE0IDE4LjU4NiAyMS41ODUgMTEgMjMgMTIuNDE1IDE0IDIxLjQxNHpcIlxuICAgIH1cbiAgfSwge1xuICAgIFwiZWxlbVwiOiBcInBhdGhcIixcbiAgICBcImF0dHJzXCI6IHtcbiAgICAgIFwiZFwiOiBcIk0xNiwyQTE0LDE0LDAsMSwwLDMwLDE2LDE0LDE0LDAsMCwwLDE2LDJabTAsMjZBMTIsMTIsMCwxLDEsMjgsMTYsMTIsMTIsMCwwLDEsMTYsMjhaXCJcbiAgICB9XG4gIH1dLFxuICBcIm5hbWVcIjogXCJjaGVja21hcmstLW91dGxpbmVcIixcbiAgXCJzaXplXCI6IDE2XG59O1xuXG5leHBvcnQgeyBfMTYgYXMgZGVmYXVsdCB9O1xuIiwiLyoqXG4gKiBDb3B5cmlnaHQgSUJNIENvcnAuIDIwMTYsIDIwMjBcbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUtMi4wIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogQ29kZSBnZW5lcmF0ZWQgYnkgQGNhcmJvbi9pY29uLWJ1aWxkLWhlbHBlcnMuIERPIE5PVCBFRElULlxuICovXG52YXIgXzE2ID0ge1xuICBcImVsZW1cIjogXCJzdmdcIixcbiAgXCJhdHRyc1wiOiB7XG4gICAgXCJ4bWxuc1wiOiBcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsXG4gICAgXCJ2aWV3Qm94XCI6IFwiMCAwIDMyIDMyXCIsXG4gICAgXCJmaWxsXCI6IFwiY3VycmVudENvbG9yXCIsXG4gICAgXCJ3aWR0aFwiOiAxNixcbiAgICBcImhlaWdodFwiOiAxNlxuICB9LFxuICBcImNvbnRlbnRcIjogW3tcbiAgICBcImVsZW1cIjogXCJwYXRoXCIsXG4gICAgXCJhdHRyc1wiOiB7XG4gICAgICBcImRcIjogXCJNMTMgMjRMNCAxNSA1LjQxNCAxMy41ODYgMTMgMjEuMTcxIDI2LjU4NiA3LjU4NiAyOCA5IDEzIDI0elwiXG4gICAgfVxuICB9XSxcbiAgXCJuYW1lXCI6IFwiY2hlY2ttYXJrXCIsXG4gIFwic2l6ZVwiOiAxNlxufTtcblxuZXhwb3J0IHsgXzE2IGFzIGRlZmF1bHQgfTtcbiIsIi8qKlxuICogQ29weXJpZ2h0IElCTSBDb3JwLiAyMDE2LCAyMDIwXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlLTIuMCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIENvZGUgZ2VuZXJhdGVkIGJ5IEBjYXJib24vaWNvbi1idWlsZC1oZWxwZXJzLiBETyBOT1QgRURJVC5cbiAqL1xudmFyIF8xNiA9IHtcbiAgXCJlbGVtXCI6IFwic3ZnXCIsXG4gIFwiYXR0cnNcIjoge1xuICAgIFwieG1sbnNcIjogXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLFxuICAgIFwidmlld0JveFwiOiBcIjAgMCAxNiAxNlwiLFxuICAgIFwiZmlsbFwiOiBcImN1cnJlbnRDb2xvclwiLFxuICAgIFwid2lkdGhcIjogMTYsXG4gICAgXCJoZWlnaHRcIjogMTZcbiAgfSxcbiAgXCJjb250ZW50XCI6IFt7XG4gICAgXCJlbGVtXCI6IFwicGF0aFwiLFxuICAgIFwiYXR0cnNcIjoge1xuICAgICAgXCJkXCI6IFwiTTggMTFMMyA2IDMuNyA1LjMgOCA5LjYgMTIuMyA1LjMgMTMgNnpcIlxuICAgIH1cbiAgfV0sXG4gIFwibmFtZVwiOiBcImNoZXZyb24tLWRvd25cIixcbiAgXCJzaXplXCI6IDE2XG59O1xuXG5leHBvcnQgeyBfMTYgYXMgZGVmYXVsdCB9O1xuIiwiLyoqXG4gKiBDb3B5cmlnaHQgSUJNIENvcnAuIDIwMTYsIDIwMjBcbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUtMi4wIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogQ29kZSBnZW5lcmF0ZWQgYnkgQGNhcmJvbi9pY29uLWJ1aWxkLWhlbHBlcnMuIERPIE5PVCBFRElULlxuICovXG52YXIgXzE2ID0ge1xuICBcImVsZW1cIjogXCJzdmdcIixcbiAgXCJhdHRyc1wiOiB7XG4gICAgXCJ4bWxuc1wiOiBcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsXG4gICAgXCJ2aWV3Qm94XCI6IFwiMCAwIDE2IDE2XCIsXG4gICAgXCJmaWxsXCI6IFwiY3VycmVudENvbG9yXCIsXG4gICAgXCJ3aWR0aFwiOiAxNixcbiAgICBcImhlaWdodFwiOiAxNlxuICB9LFxuICBcImNvbnRlbnRcIjogW3tcbiAgICBcImVsZW1cIjogXCJwYXRoXCIsXG4gICAgXCJhdHRyc1wiOiB7XG4gICAgICBcImRcIjogXCJNMTEgOEw2IDEzIDUuMyAxMi4zIDkuNiA4IDUuMyAzLjcgNiAzelwiXG4gICAgfVxuICB9XSxcbiAgXCJuYW1lXCI6IFwiY2hldnJvbi0tcmlnaHRcIixcbiAgXCJzaXplXCI6IDE2XG59O1xuXG5leHBvcnQgeyBfMTYgYXMgZGVmYXVsdCB9O1xuIiwiLyoqXG4gKiBDb3B5cmlnaHQgSUJNIENvcnAuIDIwMTYsIDIwMjBcbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUtMi4wIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogQ29kZSBnZW5lcmF0ZWQgYnkgQGNhcmJvbi9pY29uLWJ1aWxkLWhlbHBlcnMuIERPIE5PVCBFRElULlxuICovXG52YXIgXzE2ID0ge1xuICBcImVsZW1cIjogXCJzdmdcIixcbiAgXCJhdHRyc1wiOiB7XG4gICAgXCJ4bWxuc1wiOiBcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsXG4gICAgXCJ2aWV3Qm94XCI6IFwiMCAwIDMyIDMyXCIsXG4gICAgXCJmaWxsXCI6IFwiY3VycmVudENvbG9yXCIsXG4gICAgXCJ3aWR0aFwiOiAxNixcbiAgICBcImhlaWdodFwiOiAxNlxuICB9LFxuICBcImNvbnRlbnRcIjogW3tcbiAgICBcImVsZW1cIjogXCJwYXRoXCIsXG4gICAgXCJhdHRyc1wiOiB7XG4gICAgICBcImRcIjogXCJNNy43IDQuN2ExNC43IDE0LjcgMCAwMC0zIDMuMUw2LjMgOUExMy4yNiAxMy4yNiAwIDAxOC45IDYuM3pNNC42IDEyLjNsLTEuOS0uNkExMi41MSAxMi41MSAwIDAwMiAxNkg0QTExLjQ4IDExLjQ4IDAgMDE0LjYgMTIuM3pNMi43IDIwLjRhMTQuNCAxNC40IDAgMDAyIDMuOWwxLjYtMS4yYTEyLjg5IDEyLjg5IDAgMDEtMS43LTMuM3pNNy44IDI3LjNhMTQuNCAxNC40IDAgMDAzLjkgMmwuNi0xLjlBMTIuODkgMTIuODkgMCAwMTkgMjUuN3pNMTEuNyAyLjdsLjYgMS45QTExLjQ4IDExLjQ4IDAgMDExNiA0VjJBMTIuNTEgMTIuNTEgMCAwMDExLjcgMi43ek0yNC4yIDI3LjNhMTUuMTggMTUuMTggMCAwMDMuMS0zLjFMMjUuNyAyM0ExMS41MyAxMS41MyAwIDAxMjMgMjUuN3pNMjcuNCAxOS43bDEuOS42QTE1LjQ3IDE1LjQ3IDAgMDAzMCAxNkgyOEExMS40OCAxMS40OCAwIDAxMjcuNCAxOS43ek0yOS4yIDExLjZhMTQuNCAxNC40IDAgMDAtMi0zLjlMMjUuNiA4LjlhMTIuODkgMTIuODkgMCAwMTEuNyAzLjN6TTI0LjEgNC42YTE0LjQgMTQuNCAwIDAwLTMuOS0ybC0uNiAxLjlhMTIuODkgMTIuODkgMCAwMTMuMyAxLjd6TTIwLjMgMjkuM2wtLjYtMS45QTExLjQ4IDExLjQ4IDAgMDExNiAyOHYyQTIxLjQyIDIxLjQyIDAgMDAyMC4zIDI5LjN6XCJcbiAgICB9XG4gIH1dLFxuICBcIm5hbWVcIjogXCJjaXJjbGUtZGFzaFwiLFxuICBcInNpemVcIjogMTZcbn07XG5cbmV4cG9ydCB7IF8xNiBhcyBkZWZhdWx0IH07XG4iLCIvKipcbiAqIENvcHlyaWdodCBJQk0gQ29ycC4gMjAxNiwgMjAyMFxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZS0yLjAgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBDb2RlIGdlbmVyYXRlZCBieSBAY2FyYm9uL2ljb24tYnVpbGQtaGVscGVycy4gRE8gTk9UIEVESVQuXG4gKi9cbnZhciBfMTYgPSB7XG4gIFwiZWxlbVwiOiBcInN2Z1wiLFxuICBcImF0dHJzXCI6IHtcbiAgICBcInhtbG5zXCI6IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIixcbiAgICBcInZpZXdCb3hcIjogXCIwIDAgMzIgMzJcIixcbiAgICBcImZpbGxcIjogXCJjdXJyZW50Q29sb3JcIixcbiAgICBcIndpZHRoXCI6IDE2LFxuICAgIFwiaGVpZ2h0XCI6IDE2XG4gIH0sXG4gIFwiY29udGVudFwiOiBbe1xuICAgIFwiZWxlbVwiOiBcInBhdGhcIixcbiAgICBcImF0dHJzXCI6IHtcbiAgICAgIFwiZFwiOiBcIk0yNCA5LjRMMjIuNiA4IDE2IDE0LjYgOS40IDggOCA5LjQgMTQuNiAxNiA4IDIyLjYgOS40IDI0IDE2IDE3LjQgMjIuNiAyNCAyNCAyMi42IDE3LjQgMTYgMjQgOS40elwiXG4gICAgfVxuICB9XSxcbiAgXCJuYW1lXCI6IFwiY2xvc2VcIixcbiAgXCJzaXplXCI6IDE2XG59O1xuXG5leHBvcnQgeyBfMTYgYXMgZGVmYXVsdCB9O1xuIiwiLyoqXG4gKiBDb3B5cmlnaHQgSUJNIENvcnAuIDIwMTYsIDIwMjBcbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUtMi4wIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogQ29kZSBnZW5lcmF0ZWQgYnkgQGNhcmJvbi9pY29uLWJ1aWxkLWhlbHBlcnMuIERPIE5PVCBFRElULlxuICovXG52YXIgXzIwID0ge1xuICBcImVsZW1cIjogXCJzdmdcIixcbiAgXCJhdHRyc1wiOiB7XG4gICAgXCJ4bWxuc1wiOiBcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsXG4gICAgXCJ2aWV3Qm94XCI6IFwiMCAwIDMyIDMyXCIsXG4gICAgXCJmaWxsXCI6IFwiY3VycmVudENvbG9yXCIsXG4gICAgXCJ3aWR0aFwiOiAyMCxcbiAgICBcImhlaWdodFwiOiAyMFxuICB9LFxuICBcImNvbnRlbnRcIjogW3tcbiAgICBcImVsZW1cIjogXCJwYXRoXCIsXG4gICAgXCJhdHRyc1wiOiB7XG4gICAgICBcImRcIjogXCJNMjQgOS40TDIyLjYgOCAxNiAxNC42IDkuNCA4IDggOS40IDE0LjYgMTYgOCAyMi42IDkuNCAyNCAxNiAxNy40IDIyLjYgMjQgMjQgMjIuNiAxNy40IDE2IDI0IDkuNHpcIlxuICAgIH1cbiAgfV0sXG4gIFwibmFtZVwiOiBcImNsb3NlXCIsXG4gIFwic2l6ZVwiOiAyMFxufTtcblxuZXhwb3J0IHsgXzIwIGFzIGRlZmF1bHQgfTtcbiIsIi8qKlxuICogQ29weXJpZ2h0IElCTSBDb3JwLiAyMDE2LCAyMDIwXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlLTIuMCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIENvZGUgZ2VuZXJhdGVkIGJ5IEBjYXJib24vaWNvbi1idWlsZC1oZWxwZXJzLiBETyBOT1QgRURJVC5cbiAqL1xudmFyIF8xNiA9IHtcbiAgXCJlbGVtXCI6IFwic3ZnXCIsXG4gIFwiYXR0cnNcIjoge1xuICAgIFwieG1sbnNcIjogXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLFxuICAgIFwidmlld0JveFwiOiBcIjAgMCAzMiAzMlwiLFxuICAgIFwiZmlsbFwiOiBcImN1cnJlbnRDb2xvclwiLFxuICAgIFwid2lkdGhcIjogMTYsXG4gICAgXCJoZWlnaHRcIjogMTZcbiAgfSxcbiAgXCJjb250ZW50XCI6IFt7XG4gICAgXCJlbGVtXCI6IFwicGF0aFwiLFxuICAgIFwiYXR0cnNcIjoge1xuICAgICAgXCJkXCI6IFwiTTI4LDEwVjI4SDEwVjEwSDI4bTAtMkgxMGEyLDIsMCwwLDAtMiwyVjI4YTIsMiwwLDAsMCwyLDJIMjhhMiwyLDAsMCwwLDItMlYxMGEyLDIsMCwwLDAtMi0yWlwiXG4gICAgfVxuICB9LCB7XG4gICAgXCJlbGVtXCI6IFwicGF0aFwiLFxuICAgIFwiYXR0cnNcIjoge1xuICAgICAgXCJkXCI6IFwiTTQsMThIMlY0QTIsMiwwLDAsMSw0LDJIMThWNEg0WlwiXG4gICAgfVxuICB9XSxcbiAgXCJuYW1lXCI6IFwiY29weVwiLFxuICBcInNpemVcIjogMTZcbn07XG5cbmV4cG9ydCB7IF8xNiBhcyBkZWZhdWx0IH07XG4iLCIvKipcbiAqIENvcHlyaWdodCBJQk0gQ29ycC4gMjAxNiwgMjAyMFxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZS0yLjAgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBDb2RlIGdlbmVyYXRlZCBieSBAY2FyYm9uL2ljb24tYnVpbGQtaGVscGVycy4gRE8gTk9UIEVESVQuXG4gKi9cbnZhciBfMjAgPSB7XG4gIFwiZWxlbVwiOiBcInN2Z1wiLFxuICBcImF0dHJzXCI6IHtcbiAgICBcInhtbG5zXCI6IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIixcbiAgICBcInZpZXdCb3hcIjogXCIwIDAgMzIgMzJcIixcbiAgICBcImZpbGxcIjogXCJjdXJyZW50Q29sb3JcIixcbiAgICBcIndpZHRoXCI6IDIwLFxuICAgIFwiaGVpZ2h0XCI6IDIwXG4gIH0sXG4gIFwiY29udGVudFwiOiBbe1xuICAgIFwiZWxlbVwiOiBcInBhdGhcIixcbiAgICBcImF0dHJzXCI6IHtcbiAgICAgIFwiZFwiOiBcIk0yOCwxMFYyOEgxMFYxMEgyOG0wLTJIMTBhMiwyLDAsMCwwLTIsMlYyOGEyLDIsMCwwLDAsMiwySDI4YTIsMiwwLDAsMCwyLTJWMTBhMiwyLDAsMCwwLTItMlpcIlxuICAgIH1cbiAgfSwge1xuICAgIFwiZWxlbVwiOiBcInBhdGhcIixcbiAgICBcImF0dHJzXCI6IHtcbiAgICAgIFwiZFwiOiBcIk00LDE4SDJWNEEyLDIsMCwwLDEsNCwySDE4VjRINFpcIlxuICAgIH1cbiAgfV0sXG4gIFwibmFtZVwiOiBcImNvcHlcIixcbiAgXCJzaXplXCI6IDIwXG59O1xuXG5leHBvcnQgeyBfMjAgYXMgZGVmYXVsdCB9O1xuIiwiLyoqXG4gKiBDb3B5cmlnaHQgSUJNIENvcnAuIDIwMTYsIDIwMjBcbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUtMi4wIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogQ29kZSBnZW5lcmF0ZWQgYnkgQGNhcmJvbi9pY29uLWJ1aWxkLWhlbHBlcnMuIERPIE5PVCBFRElULlxuICovXG52YXIgXzE2ID0ge1xuICBcImVsZW1cIjogXCJzdmdcIixcbiAgXCJhdHRyc1wiOiB7XG4gICAgXCJ4bWxuc1wiOiBcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsXG4gICAgXCJ2aWV3Qm94XCI6IFwiMCAwIDMyIDMyXCIsXG4gICAgXCJmaWxsXCI6IFwiY3VycmVudENvbG9yXCIsXG4gICAgXCJ3aWR0aFwiOiAxNixcbiAgICBcImhlaWdodFwiOiAxNlxuICB9LFxuICBcImNvbnRlbnRcIjogW3tcbiAgICBcImVsZW1cIjogXCJwYXRoXCIsXG4gICAgXCJhdHRyc1wiOiB7XG4gICAgICBcImRcIjogXCJNNCA2SDE1VjhINHpNMTggNkgyOFY4SDE4ek0yMSAxMkgyOFYxNEgyMXpNMTEgMTJIMThWMTRIMTF6TTQgMTJIOFYxNEg0ek00IDE4SDI4VjIwSDR6TTQgMjRIMjFWMjZINHpNMjQgMjRIMjhWMjZIMjR6XCJcbiAgICB9XG4gIH1dLFxuICBcIm5hbWVcIjogXCJkYXRhLS0yXCIsXG4gIFwic2l6ZVwiOiAxNlxufTtcblxuZXhwb3J0IHsgXzE2IGFzIGRlZmF1bHQgfTtcbiIsIi8qKlxuICogQ29weXJpZ2h0IElCTSBDb3JwLiAyMDE2LCAyMDIwXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlLTIuMCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIENvZGUgZ2VuZXJhdGVkIGJ5IEBjYXJib24vaWNvbi1idWlsZC1oZWxwZXJzLiBETyBOT1QgRURJVC5cbiAqL1xudmFyIF8yMCA9IHtcbiAgXCJlbGVtXCI6IFwic3ZnXCIsXG4gIFwiYXR0cnNcIjoge1xuICAgIFwieG1sbnNcIjogXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLFxuICAgIFwidmlld0JveFwiOiBcIjAgMCAzMiAzMlwiLFxuICAgIFwiZmlsbFwiOiBcImN1cnJlbnRDb2xvclwiLFxuICAgIFwid2lkdGhcIjogMjAsXG4gICAgXCJoZWlnaHRcIjogMjBcbiAgfSxcbiAgXCJjb250ZW50XCI6IFt7XG4gICAgXCJlbGVtXCI6IFwicGF0aFwiLFxuICAgIFwiYXR0cnNcIjoge1xuICAgICAgXCJkXCI6IFwiTTQgNkgxNVY4SDR6TTE4IDZIMjhWOEgxOHpNMjEgMTJIMjhWMTRIMjF6TTExIDEySDE4VjE0SDExek00IDEySDhWMTRINHpNNCAxOEgyOFYyMEg0ek00IDI0SDIxVjI2SDR6TTI0IDI0SDI4VjI2SDI0elwiXG4gICAgfVxuICB9XSxcbiAgXCJuYW1lXCI6IFwiZGF0YS0tMlwiLFxuICBcInNpemVcIjogMjBcbn07XG5cbmV4cG9ydCB7IF8yMCBhcyBkZWZhdWx0IH07XG4iLCIvKipcbiAqIENvcHlyaWdodCBJQk0gQ29ycC4gMjAxNiwgMjAyMFxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZS0yLjAgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBDb2RlIGdlbmVyYXRlZCBieSBAY2FyYm9uL2ljb24tYnVpbGQtaGVscGVycy4gRE8gTk9UIEVESVQuXG4gKi9cbnZhciBfMTYgPSB7XG4gIFwiZWxlbVwiOiBcInN2Z1wiLFxuICBcImF0dHJzXCI6IHtcbiAgICBcInhtbG5zXCI6IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIixcbiAgICBcInZpZXdCb3hcIjogXCIwIDAgMzIgMzJcIixcbiAgICBcImZpbGxcIjogXCJjdXJyZW50Q29sb3JcIixcbiAgICBcIndpZHRoXCI6IDE2LFxuICAgIFwiaGVpZ2h0XCI6IDE2XG4gIH0sXG4gIFwiY29udGVudFwiOiBbe1xuICAgIFwiZWxlbVwiOiBcInBhdGhcIixcbiAgICBcImF0dHJzXCI6IHtcbiAgICAgIFwiZFwiOiBcIk0yNS43LDkuM2wtNy03QzE4LjUsMi4xLDE4LjMsMiwxOCwySDhDNi45LDIsNiwyLjksNiw0djI0YzAsMS4xLDAuOSwyLDIsMmgxNmMxLjEsMCwyLTAuOSwyLTJWMTBDMjYsOS43LDI1LjksOS41LDI1LjcsOS4zXFx0eiBNMTgsNC40bDUuNiw1LjZIMThWNC40eiBNMjQsMjhIOFY0aDh2NmMwLDEuMSwwLjksMiwyLDJoNlYyOHpcIlxuICAgIH1cbiAgfSwge1xuICAgIFwiZWxlbVwiOiBcInBhdGhcIixcbiAgICBcImF0dHJzXCI6IHtcbiAgICAgIFwiZFwiOiBcIk0xMCAyMkgyMlYyNEgxMHpNMTAgMTZIMjJWMThIMTB6XCJcbiAgICB9XG4gIH1dLFxuICBcIm5hbWVcIjogXCJkb2N1bWVudFwiLFxuICBcInNpemVcIjogMTZcbn07XG5cbmV4cG9ydCB7IF8xNiBhcyBkZWZhdWx0IH07XG4iLCIvKipcbiAqIENvcHlyaWdodCBJQk0gQ29ycC4gMjAxNiwgMjAyMFxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZS0yLjAgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBDb2RlIGdlbmVyYXRlZCBieSBAY2FyYm9uL2ljb24tYnVpbGQtaGVscGVycy4gRE8gTk9UIEVESVQuXG4gKi9cbnZhciBfMjAgPSB7XG4gIFwiZWxlbVwiOiBcInN2Z1wiLFxuICBcImF0dHJzXCI6IHtcbiAgICBcInhtbG5zXCI6IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIixcbiAgICBcInZpZXdCb3hcIjogXCIwIDAgMzIgMzJcIixcbiAgICBcImZpbGxcIjogXCJjdXJyZW50Q29sb3JcIixcbiAgICBcIndpZHRoXCI6IDIwLFxuICAgIFwiaGVpZ2h0XCI6IDIwXG4gIH0sXG4gIFwiY29udGVudFwiOiBbe1xuICAgIFwiZWxlbVwiOiBcInBhdGhcIixcbiAgICBcImF0dHJzXCI6IHtcbiAgICAgIFwiZFwiOiBcIk0yNS43LDkuM2wtNy03QzE4LjUsMi4xLDE4LjMsMiwxOCwySDhDNi45LDIsNiwyLjksNiw0djI0YzAsMS4xLDAuOSwyLDIsMmgxNmMxLjEsMCwyLTAuOSwyLTJWMTBDMjYsOS43LDI1LjksOS41LDI1LjcsOS4zXFx0eiBNMTgsNC40bDUuNiw1LjZIMThWNC40eiBNMjQsMjhIOFY0aDh2NmMwLDEuMSwwLjksMiwyLDJoNlYyOHpcIlxuICAgIH1cbiAgfSwge1xuICAgIFwiZWxlbVwiOiBcInBhdGhcIixcbiAgICBcImF0dHJzXCI6IHtcbiAgICAgIFwiZFwiOiBcIk0xMCAyMkgyMlYyNEgxMHpNMTAgMTZIMjJWMThIMTB6XCJcbiAgICB9XG4gIH1dLFxuICBcIm5hbWVcIjogXCJkb2N1bWVudFwiLFxuICBcInNpemVcIjogMjBcbn07XG5cbmV4cG9ydCB7IF8yMCBhcyBkZWZhdWx0IH07XG4iLCIvKipcbiAqIENvcHlyaWdodCBJQk0gQ29ycC4gMjAxNiwgMjAyMFxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZS0yLjAgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBDb2RlIGdlbmVyYXRlZCBieSBAY2FyYm9uL2ljb24tYnVpbGQtaGVscGVycy4gRE8gTk9UIEVESVQuXG4gKi9cbnZhciBfMTYgPSB7XG4gIFwiZWxlbVwiOiBcInN2Z1wiLFxuICBcImF0dHJzXCI6IHtcbiAgICBcInhtbG5zXCI6IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIixcbiAgICBcInZpZXdCb3hcIjogXCIwIDAgMTYgMTZcIixcbiAgICBcImZpbGxcIjogXCJjdXJyZW50Q29sb3JcIixcbiAgICBcIndpZHRoXCI6IDE2LFxuICAgIFwiaGVpZ2h0XCI6IDE2XG4gIH0sXG4gIFwiY29udGVudFwiOiBbe1xuICAgIFwiZWxlbVwiOiBcInBhdGhcIixcbiAgICBcImF0dHJzXCI6IHtcbiAgICAgIFwiZFwiOiBcIk0xMyA3TDEyLjMgNi4zIDguNSAxMC4xIDguNSAxIDcuNSAxIDcuNSAxMC4xIDMuNyA2LjMgMyA3IDggMTJ6TTEzIDEydjJIM3YtMkgydjJsMCAwYzAgLjYuNCAxIDEgMWgxMGMuNiAwIDEtLjQgMS0xbDAgMHYtMkgxM3pcIlxuICAgIH1cbiAgfV0sXG4gIFwibmFtZVwiOiBcImRvd25sb2FkXCIsXG4gIFwic2l6ZVwiOiAxNlxufTtcblxuZXhwb3J0IHsgXzE2IGFzIGRlZmF1bHQgfTtcbiIsIi8qKlxuICogQ29weXJpZ2h0IElCTSBDb3JwLiAyMDE2LCAyMDIwXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlLTIuMCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIENvZGUgZ2VuZXJhdGVkIGJ5IEBjYXJib24vaWNvbi1idWlsZC1oZWxwZXJzLiBETyBOT1QgRURJVC5cbiAqL1xudmFyIF8xNiA9IHtcbiAgXCJlbGVtXCI6IFwic3ZnXCIsXG4gIFwiYXR0cnNcIjoge1xuICAgIFwieG1sbnNcIjogXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLFxuICAgIFwidmlld0JveFwiOiBcIjAgMCAxNiAxNlwiLFxuICAgIFwiZmlsbFwiOiBcImN1cnJlbnRDb2xvclwiLFxuICAgIFwid2lkdGhcIjogMTYsXG4gICAgXCJoZWlnaHRcIjogMTZcbiAgfSxcbiAgXCJjb250ZW50XCI6IFt7XG4gICAgXCJlbGVtXCI6IFwicGF0aFwiLFxuICAgIFwiYXR0cnNcIjoge1xuICAgICAgXCJkXCI6IFwiTTgsMUM0LjEsMSwxLDQuMSwxLDhzMy4xLDcsNyw3czctMy4xLDctN1MxMS45LDEsOCwxeiBNMTAuNywxMS41TDQuNSw1LjNsMC44LTAuOGw2LjIsNi4yTDEwLjcsMTEuNXpcIlxuICAgIH1cbiAgfSwge1xuICAgIFwiZWxlbVwiOiBcInBhdGhcIixcbiAgICBcImF0dHJzXCI6IHtcbiAgICAgIFwiZmlsbFwiOiBcIm5vbmVcIixcbiAgICAgIFwiZFwiOiBcIk0xMC43LDExLjVMNC41LDUuM2wwLjgtMC44bDYuMiw2LjJMMTAuNywxMS41elwiLFxuICAgICAgXCJkYXRhLWljb24tcGF0aFwiOiBcImlubmVyLXBhdGhcIixcbiAgICAgIFwib3BhY2l0eVwiOiBcIjBcIlxuICAgIH1cbiAgfV0sXG4gIFwibmFtZVwiOiBcImVycm9yLS1maWxsZWRcIixcbiAgXCJzaXplXCI6IDE2XG59O1xuXG5leHBvcnQgeyBfMTYgYXMgZGVmYXVsdCB9O1xuIiwiLyoqXG4gKiBDb3B5cmlnaHQgSUJNIENvcnAuIDIwMTYsIDIwMjBcbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUtMi4wIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogQ29kZSBnZW5lcmF0ZWQgYnkgQGNhcmJvbi9pY29uLWJ1aWxkLWhlbHBlcnMuIERPIE5PVCBFRElULlxuICovXG52YXIgXzIwID0ge1xuICBcImVsZW1cIjogXCJzdmdcIixcbiAgXCJhdHRyc1wiOiB7XG4gICAgXCJ4bWxuc1wiOiBcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsXG4gICAgXCJ2aWV3Qm94XCI6IFwiMCAwIDIwIDIwXCIsXG4gICAgXCJmaWxsXCI6IFwiY3VycmVudENvbG9yXCIsXG4gICAgXCJ3aWR0aFwiOiAyMCxcbiAgICBcImhlaWdodFwiOiAyMFxuICB9LFxuICBcImNvbnRlbnRcIjogW3tcbiAgICBcImVsZW1cIjogXCJwYXRoXCIsXG4gICAgXCJhdHRyc1wiOiB7XG4gICAgICBcImRcIjogXCJNMTAsMWMtNSwwLTksNC05LDlzNCw5LDksOXM5LTQsOS05UzE1LDEsMTAsMXogTTEzLjUsMTQuNWwtOC04bDEtMWw4LDhMMTMuNSwxNC41elwiXG4gICAgfVxuICB9LCB7XG4gICAgXCJlbGVtXCI6IFwicGF0aFwiLFxuICAgIFwiYXR0cnNcIjoge1xuICAgICAgXCJkXCI6IFwiTTEzLjUsMTQuNWwtOC04bDEtMWw4LDhMMTMuNSwxNC41elwiLFxuICAgICAgXCJkYXRhLWljb24tcGF0aFwiOiBcImlubmVyLXBhdGhcIixcbiAgICAgIFwib3BhY2l0eVwiOiBcIjBcIlxuICAgIH1cbiAgfV0sXG4gIFwibmFtZVwiOiBcImVycm9yLS1maWxsZWRcIixcbiAgXCJzaXplXCI6IDIwXG59O1xuXG5leHBvcnQgeyBfMjAgYXMgZGVmYXVsdCB9O1xuIiwiLyoqXG4gKiBDb3B5cmlnaHQgSUJNIENvcnAuIDIwMTYsIDIwMjBcbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUtMi4wIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogQ29kZSBnZW5lcmF0ZWQgYnkgQGNhcmJvbi9pY29uLWJ1aWxkLWhlbHBlcnMuIERPIE5PVCBFRElULlxuICovXG52YXIgXzE2ID0ge1xuICBcImVsZW1cIjogXCJzdmdcIixcbiAgXCJhdHRyc1wiOiB7XG4gICAgXCJ4bWxuc1wiOiBcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsXG4gICAgXCJ2aWV3Qm94XCI6IFwiMCAwIDE2IDE2XCIsXG4gICAgXCJmaWxsXCI6IFwiY3VycmVudENvbG9yXCIsXG4gICAgXCJ3aWR0aFwiOiAxNixcbiAgICBcImhlaWdodFwiOiAxNlxuICB9LFxuICBcImNvbnRlbnRcIjogW3tcbiAgICBcImVsZW1cIjogXCJwYXRoXCIsXG4gICAgXCJhdHRyc1wiOiB7XG4gICAgICBcImRcIjogXCJNNC4xIDEyLjZsLS42LjhjLjYuNSAxLjMuOSAyLjEgMS4ybC4zLS45QzUuMyAxMy40IDQuNyAxMyA0LjEgMTIuNnpNMi4xIDlsLTEgLjJjLjEuOC40IDEuNi44IDIuM0wyLjggMTFDMi40IDEwLjQgMi4yIDkuNyAyLjEgOXpNNS45IDIuNEw1LjYgMS40QzQuOCAxLjcgNC4xIDIuMSAzLjUgMi43bC42LjhDNC43IDMgNS4zIDIuNiA1LjkgMi40ek0yLjggNUwxLjkgNC41QzEuNSA1LjIgMS4zIDYgMS4xIDYuOGwxIC4yQzIuMiA2LjMgMi41IDUuNiAyLjggNXpNOCAxdjFjMy4zIDAgNiAyLjcgNiA2cy0yLjcgNi02IDZ2MWMzLjkgMCA3LTMuMSA3LTdTMTEuOSAxIDggMXpcIlxuICAgIH1cbiAgfV0sXG4gIFwibmFtZVwiOiBcImZhZGVcIixcbiAgXCJzaXplXCI6IDE2XG59O1xuXG5leHBvcnQgeyBfMTYgYXMgZGVmYXVsdCB9O1xuIiwiLyoqXG4gKiBDb3B5cmlnaHQgSUJNIENvcnAuIDIwMTYsIDIwMjBcbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUtMi4wIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogQ29kZSBnZW5lcmF0ZWQgYnkgQGNhcmJvbi9pY29uLWJ1aWxkLWhlbHBlcnMuIERPIE5PVCBFRElULlxuICovXG52YXIgXzIwID0ge1xuICBcImVsZW1cIjogXCJzdmdcIixcbiAgXCJhdHRyc1wiOiB7XG4gICAgXCJ4bWxuc1wiOiBcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsXG4gICAgXCJ2aWV3Qm94XCI6IFwiMCAwIDMyIDMyXCIsXG4gICAgXCJmaWxsXCI6IFwiY3VycmVudENvbG9yXCIsXG4gICAgXCJ3aWR0aFwiOiAyMCxcbiAgICBcImhlaWdodFwiOiAyMFxuICB9LFxuICBcImNvbnRlbnRcIjogW3tcbiAgICBcImVsZW1cIjogXCJwYXRoXCIsXG4gICAgXCJhdHRyc1wiOiB7XG4gICAgICBcImRcIjogXCJNOC4yNCAyNS4xNEw3IDI2LjY3YTEzLjc5IDEzLjc5IDAgMDA0LjE4IDIuNDRsLjY5LTEuODdBMTIgMTIgMCAwMTguMjQgMjUuMTR6TTQuMTkgMThsLTIgLjQxQTE0LjA5IDE0LjA5IDAgMDAzLjg2IDIzTDUuNTkgMjJBMTIuNDQgMTIuNDQgMCAwMTQuMTkgMTh6TTExLjgyIDQuNzZsLS42OS0xLjg3QTEzLjc5IDEzLjc5IDAgMDA3IDUuMzNMOC4yNCA2Ljg2QTEyIDEyIDAgMDExMS44MiA0Ljc2ek01LjU5IDEwTDMuODYgOWExNC4zNyAxNC4zNyAwIDAwLTEuNjQgNC41OWwyIC4zNEExMi4wNSAxMi4wNSAwIDAxNS41OSAxMHpNMTYgMlY0YTEyIDEyIDAgMDEwIDI0djJBMTQgMTQgMCAwMDE2IDJ6XCJcbiAgICB9XG4gIH1dLFxuICBcIm5hbWVcIjogXCJmYWRlXCIsXG4gIFwic2l6ZVwiOiAyMFxufTtcblxuZXhwb3J0IHsgXzIwIGFzIGRlZmF1bHQgfTtcbiIsIi8qKlxuICogQ29weXJpZ2h0IElCTSBDb3JwLiAyMDE2LCAyMDIwXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlLTIuMCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIENvZGUgZ2VuZXJhdGVkIGJ5IEBjYXJib24vaWNvbi1idWlsZC1oZWxwZXJzLiBETyBOT1QgRURJVC5cbiAqL1xudmFyIF8xNiA9IHtcbiAgXCJlbGVtXCI6IFwic3ZnXCIsXG4gIFwiYXR0cnNcIjoge1xuICAgIFwieG1sbnNcIjogXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLFxuICAgIFwidmlld0JveFwiOiBcIjAgMCAzMiAzMlwiLFxuICAgIFwiZmlsbFwiOiBcImN1cnJlbnRDb2xvclwiLFxuICAgIFwid2lkdGhcIjogMTYsXG4gICAgXCJoZWlnaHRcIjogMTZcbiAgfSxcbiAgXCJjb250ZW50XCI6IFt7XG4gICAgXCJlbGVtXCI6IFwicGF0aFwiLFxuICAgIFwiYXR0cnNcIjoge1xuICAgICAgXCJkXCI6IFwiTTExLjE3LDZsMy40MiwzLjQxLjU4LjU5SDI4VjI2SDRWNmg3LjE3bTAtMkg0QTIsMiwwLDAsMCwyLDZWMjZhMiwyLDAsMCwwLDIsMkgyOGEyLDIsMCwwLDAsMi0yVjEwYTIsMiwwLDAsMC0yLTJIMTZMMTIuNTksNC41OUEyLDIsMCwwLDAsMTEuMTcsNFpcIlxuICAgIH1cbiAgfV0sXG4gIFwibmFtZVwiOiBcImZvbGRlclwiLFxuICBcInNpemVcIjogMTZcbn07XG5cbmV4cG9ydCB7IF8xNiBhcyBkZWZhdWx0IH07XG4iLCIvKipcbiAqIENvcHlyaWdodCBJQk0gQ29ycC4gMjAxNiwgMjAyMFxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZS0yLjAgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBDb2RlIGdlbmVyYXRlZCBieSBAY2FyYm9uL2ljb24tYnVpbGQtaGVscGVycy4gRE8gTk9UIEVESVQuXG4gKi9cbnZhciBfMTYgPSB7XG4gIFwiZWxlbVwiOiBcInN2Z1wiLFxuICBcImF0dHJzXCI6IHtcbiAgICBcInhtbG5zXCI6IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIixcbiAgICBcInZpZXdCb3hcIjogXCIwIDAgMzIgMzJcIixcbiAgICBcImZpbGxcIjogXCJjdXJyZW50Q29sb3JcIixcbiAgICBcIndpZHRoXCI6IDE2LFxuICAgIFwiaGVpZ2h0XCI6IDE2XG4gIH0sXG4gIFwiY29udGVudFwiOiBbe1xuICAgIFwiZWxlbVwiOiBcInBhdGhcIixcbiAgICBcImF0dHJzXCI6IHtcbiAgICAgIFwiZFwiOiBcIk0yMy43NjQyIDYuODU5M2wxLjI4NTEtMS41MzE1QTEzLjk3NiAxMy45NzYgMCAwMDIwLjg2NzIgMi44ODdsLS42ODM2IDEuODc3NkExMS45NzI5IDExLjk3MjkgMCAwMTIzLjc2NDIgNi44NTkzek0yNy44MSAxNGwxLjk2NzctLjQxMjhBMTMuODg4OCAxMy44ODg4IDAgMDAyOC4xNCA5LjA0NTdMMjYuNDA4NyAxMEExMi41MiAxMi41MiAwIDAxMjcuODEgMTR6TTIwLjE4MzYgMjcuMjM1NGwuNjgzNiAxLjg3NzZhMTMuOTc2IDEzLjk3NiAwIDAwNC4xODIxLTIuNDQwOGwtMS4yODUxLTEuNTMxNUExMS45NzI5IDExLjk3MjkgMCAwMTIwLjE4MzYgMjcuMjM1NHpNMjYuNDA4NyAyMkwyOC4xNCAyM2ExNC4xNCAxNC4xNCAwIDAwMS42MzgyLTQuNTg3MkwyNy44MSAxOC4wNjU5QTEyLjE1MTkgMTIuMTUxOSAwIDAxMjYuNDA4NyAyMnpNMTYgMzBWMmExNCAxNCAwIDAwMCAyOHpcIlxuICAgIH1cbiAgfV0sXG4gIFwibmFtZVwiOiBcImluY29tcGxldGVcIixcbiAgXCJzaXplXCI6IDE2XG59O1xuXG5leHBvcnQgeyBfMTYgYXMgZGVmYXVsdCB9O1xuIiwiLyoqXG4gKiBDb3B5cmlnaHQgSUJNIENvcnAuIDIwMTYsIDIwMjBcbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUtMi4wIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogQ29kZSBnZW5lcmF0ZWQgYnkgQGNhcmJvbi9pY29uLWJ1aWxkLWhlbHBlcnMuIERPIE5PVCBFRElULlxuICovXG52YXIgXzE2ID0ge1xuICBcImVsZW1cIjogXCJzdmdcIixcbiAgXCJhdHRyc1wiOiB7XG4gICAgXCJ4bWxuc1wiOiBcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsXG4gICAgXCJ2aWV3Qm94XCI6IFwiMCAwIDMyIDMyXCIsXG4gICAgXCJmaWxsXCI6IFwiY3VycmVudENvbG9yXCIsXG4gICAgXCJ3aWR0aFwiOiAxNixcbiAgICBcImhlaWdodFwiOiAxNlxuICB9LFxuICBcImNvbnRlbnRcIjogW3tcbiAgICBcImVsZW1cIjogXCJwYXRoXCIsXG4gICAgXCJhdHRyc1wiOiB7XG4gICAgICBcImZpbGxcIjogXCJub25lXCIsXG4gICAgICBcImRcIjogXCJNMTYsOGExLjUsMS41LDAsMSwxLTEuNSwxLjVBMS41LDEuNSwwLDAsMSwxNiw4Wm00LDEzLjg3NUgxNy4xMjV2LThIMTN2Mi4yNWgxLjg3NXY1Ljc1SDEydjIuMjVoOFpcIixcbiAgICAgIFwiZGF0YS1pY29uLXBhdGhcIjogXCJpbm5lci1wYXRoXCJcbiAgICB9XG4gIH0sIHtcbiAgICBcImVsZW1cIjogXCJwYXRoXCIsXG4gICAgXCJhdHRyc1wiOiB7XG4gICAgICBcImRcIjogXCJNMTYsMkExNCwxNCwwLDEsMCwzMCwxNiwxNCwxNCwwLDAsMCwxNiwyWm0wLDZhMS41LDEuNSwwLDEsMS0xLjUsMS41QTEuNSwxLjUsMCwwLDEsMTYsOFptNCwxNi4xMjVIMTJ2LTIuMjVoMi44NzV2LTUuNzVIMTN2LTIuMjVoNC4xMjV2OEgyMFpcIlxuICAgIH1cbiAgfV0sXG4gIFwibmFtZVwiOiBcImluZm9ybWF0aW9uLS1maWxsZWRcIixcbiAgXCJzaXplXCI6IDE2XG59O1xuXG5leHBvcnQgeyBfMTYgYXMgZGVmYXVsdCB9O1xuIiwiLyoqXG4gKiBDb3B5cmlnaHQgSUJNIENvcnAuIDIwMTYsIDIwMjBcbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUtMi4wIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogQ29kZSBnZW5lcmF0ZWQgYnkgQGNhcmJvbi9pY29uLWJ1aWxkLWhlbHBlcnMuIERPIE5PVCBFRElULlxuICovXG52YXIgXzIwID0ge1xuICBcImVsZW1cIjogXCJzdmdcIixcbiAgXCJhdHRyc1wiOiB7XG4gICAgXCJ4bWxuc1wiOiBcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsXG4gICAgXCJ2aWV3Qm94XCI6IFwiMCAwIDMyIDMyXCIsXG4gICAgXCJmaWxsXCI6IFwiY3VycmVudENvbG9yXCIsXG4gICAgXCJ3aWR0aFwiOiAyMCxcbiAgICBcImhlaWdodFwiOiAyMFxuICB9LFxuICBcImNvbnRlbnRcIjogW3tcbiAgICBcImVsZW1cIjogXCJwYXRoXCIsXG4gICAgXCJhdHRyc1wiOiB7XG4gICAgICBcImZpbGxcIjogXCJub25lXCIsXG4gICAgICBcImRcIjogXCJNMTYsOGExLjUsMS41LDAsMSwxLTEuNSwxLjVBMS41LDEuNSwwLDAsMSwxNiw4Wm00LDEzLjg3NUgxNy4xMjV2LThIMTN2Mi4yNWgxLjg3NXY1Ljc1SDEydjIuMjVoOFpcIixcbiAgICAgIFwiZGF0YS1pY29uLXBhdGhcIjogXCJpbm5lci1wYXRoXCJcbiAgICB9XG4gIH0sIHtcbiAgICBcImVsZW1cIjogXCJwYXRoXCIsXG4gICAgXCJhdHRyc1wiOiB7XG4gICAgICBcImRcIjogXCJNMTYsMkExNCwxNCwwLDEsMCwzMCwxNiwxNCwxNCwwLDAsMCwxNiwyWm0wLDZhMS41LDEuNSwwLDEsMS0xLjUsMS41QTEuNSwxLjUsMCwwLDEsMTYsOFptNCwxNi4xMjVIMTJ2LTIuMjVoMi44NzV2LTUuNzVIMTN2LTIuMjVoNC4xMjV2OEgyMFpcIlxuICAgIH1cbiAgfV0sXG4gIFwibmFtZVwiOiBcImluZm9ybWF0aW9uLS1maWxsZWRcIixcbiAgXCJzaXplXCI6IDIwXG59O1xuXG5leHBvcnQgeyBfMjAgYXMgZGVmYXVsdCB9O1xuIiwiLyoqXG4gKiBDb3B5cmlnaHQgSUJNIENvcnAuIDIwMTYsIDIwMjBcbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUtMi4wIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogQ29kZSBnZW5lcmF0ZWQgYnkgQGNhcmJvbi9pY29uLWJ1aWxkLWhlbHBlcnMuIERPIE5PVCBFRElULlxuICovXG52YXIgXzIwID0ge1xuICBcImVsZW1cIjogXCJzdmdcIixcbiAgXCJhdHRyc1wiOiB7XG4gICAgXCJ4bWxuc1wiOiBcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsXG4gICAgXCJ2aWV3Qm94XCI6IFwiMCAwIDMyIDMyXCIsXG4gICAgXCJmaWxsXCI6IFwiY3VycmVudENvbG9yXCIsXG4gICAgXCJ3aWR0aFwiOiAyMCxcbiAgICBcImhlaWdodFwiOiAyMFxuICB9LFxuICBcImNvbnRlbnRcIjogW3tcbiAgICBcImVsZW1cIjogXCJwYXRoXCIsXG4gICAgXCJhdHRyc1wiOiB7XG4gICAgICBcImZpbGxcIjogXCJub25lXCIsXG4gICAgICBcImRcIjogXCJNMTYsOGExLjUsMS41LDAsMSwxLTEuNSwxLjVBMS41LDEuNSwwLDAsMSwxNiw4Wm00LDEzLjg3NUgxNy4xMjV2LThIMTN2Mi4yNWgxLjg3NXY1Ljc1SDEydjIuMjVoOFpcIixcbiAgICAgIFwiZGF0YS1pY29uLXBhdGhcIjogXCJpbm5lci1wYXRoXCJcbiAgICB9XG4gIH0sIHtcbiAgICBcImVsZW1cIjogXCJwYXRoXCIsXG4gICAgXCJhdHRyc1wiOiB7XG4gICAgICBcImRcIjogXCJNMjYsNEg2QTIsMiwwLDAsMCw0LDZWMjZhMiwyLDAsMCwwLDIsMkgyNmEyLDIsMCwwLDAsMi0yVjZBMiwyLDAsMCwwLDI2LDRaTTE2LDhhMS41LDEuNSwwLDEsMS0xLjUsMS41QTEuNSwxLjUsMCwwLDEsMTYsOFptNCwxNi4xMjVIMTJ2LTIuMjVoMi44NzV2LTUuNzVIMTN2LTIuMjVoNC4xMjV2OEgyMFpcIlxuICAgIH1cbiAgfV0sXG4gIFwibmFtZVwiOiBcImluZm9ybWF0aW9uLS1zcXVhcmUtLWZpbGxlZFwiLFxuICBcInNpemVcIjogMjBcbn07XG5cbmV4cG9ydCB7IF8yMCBhcyBkZWZhdWx0IH07XG4iLCIvKipcbiAqIENvcHlyaWdodCBJQk0gQ29ycC4gMjAxNiwgMjAyMFxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZS0yLjAgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBDb2RlIGdlbmVyYXRlZCBieSBAY2FyYm9uL2ljb24tYnVpbGQtaGVscGVycy4gRE8gTk9UIEVESVQuXG4gKi9cbnZhciBfMTYgPSB7XG4gIFwiZWxlbVwiOiBcInN2Z1wiLFxuICBcImF0dHJzXCI6IHtcbiAgICBcInhtbG5zXCI6IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIixcbiAgICBcInZpZXdCb3hcIjogXCIwIDAgMTYgMTZcIixcbiAgICBcImZpbGxcIjogXCJjdXJyZW50Q29sb3JcIixcbiAgICBcIndpZHRoXCI6IDE2LFxuICAgIFwiaGVpZ2h0XCI6IDE2XG4gIH0sXG4gIFwiY29udGVudFwiOiBbe1xuICAgIFwiZWxlbVwiOiBcInBhdGhcIixcbiAgICBcImF0dHJzXCI6IHtcbiAgICAgIFwiZFwiOiBcIk0yIDEySDE0VjEzSDJ6TTIgOUgxNFYxMEgyek0yIDZIMTRWN0gyek0yIDNIMTRWNEgyelwiXG4gICAgfVxuICB9XSxcbiAgXCJuYW1lXCI6IFwibWVudVwiLFxuICBcInNpemVcIjogMTZcbn07XG5cbmV4cG9ydCB7IF8xNiBhcyBkZWZhdWx0IH07XG4iLCIvKipcbiAqIENvcHlyaWdodCBJQk0gQ29ycC4gMjAxNiwgMjAyMFxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZS0yLjAgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBDb2RlIGdlbmVyYXRlZCBieSBAY2FyYm9uL2ljb24tYnVpbGQtaGVscGVycy4gRE8gTk9UIEVESVQuXG4gKi9cbnZhciBfMjAgPSB7XG4gIFwiZWxlbVwiOiBcInN2Z1wiLFxuICBcImF0dHJzXCI6IHtcbiAgICBcInhtbG5zXCI6IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIixcbiAgICBcInZpZXdCb3hcIjogXCIwIDAgMjAgMjBcIixcbiAgICBcImZpbGxcIjogXCJjdXJyZW50Q29sb3JcIixcbiAgICBcIndpZHRoXCI6IDIwLFxuICAgIFwiaGVpZ2h0XCI6IDIwXG4gIH0sXG4gIFwiY29udGVudFwiOiBbe1xuICAgIFwiZWxlbVwiOiBcInBhdGhcIixcbiAgICBcImF0dHJzXCI6IHtcbiAgICAgIFwiZFwiOiBcIk0yIDE0LjhIMThWMTZIMnpNMiAxMS4ySDE4VjEyLjM5OTk5OTk5OTk5OTk5OUgyek0yIDcuNkgxOFY4Ljc5OTk5OTk5OTk5OTk5OUgyek0yIDRIMThWNS4ySDJ6XCJcbiAgICB9XG4gIH1dLFxuICBcIm5hbWVcIjogXCJtZW51XCIsXG4gIFwic2l6ZVwiOiAyMFxufTtcblxuZXhwb3J0IHsgXzIwIGFzIGRlZmF1bHQgfTtcbiIsIi8qKlxuICogQ29weXJpZ2h0IElCTSBDb3JwLiAyMDE2LCAyMDIwXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlLTIuMCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIENvZGUgZ2VuZXJhdGVkIGJ5IEBjYXJib24vaWNvbi1idWlsZC1oZWxwZXJzLiBETyBOT1QgRURJVC5cbiAqL1xudmFyIF8xNiA9IHtcbiAgXCJlbGVtXCI6IFwic3ZnXCIsXG4gIFwiYXR0cnNcIjoge1xuICAgIFwieG1sbnNcIjogXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLFxuICAgIFwidmlld0JveFwiOiBcIjAgMCAzMiAzMlwiLFxuICAgIFwiZmlsbFwiOiBcImN1cnJlbnRDb2xvclwiLFxuICAgIFwid2lkdGhcIjogMTYsXG4gICAgXCJoZWlnaHRcIjogMTZcbiAgfSxcbiAgXCJjb250ZW50XCI6IFt7XG4gICAgXCJlbGVtXCI6IFwiY2lyY2xlXCIsXG4gICAgXCJhdHRyc1wiOiB7XG4gICAgICBcImN4XCI6IFwiOFwiLFxuICAgICAgXCJjeVwiOiBcIjE2XCIsXG4gICAgICBcInJcIjogXCIyXCJcbiAgICB9XG4gIH0sIHtcbiAgICBcImVsZW1cIjogXCJjaXJjbGVcIixcbiAgICBcImF0dHJzXCI6IHtcbiAgICAgIFwiY3hcIjogXCIxNlwiLFxuICAgICAgXCJjeVwiOiBcIjE2XCIsXG4gICAgICBcInJcIjogXCIyXCJcbiAgICB9XG4gIH0sIHtcbiAgICBcImVsZW1cIjogXCJjaXJjbGVcIixcbiAgICBcImF0dHJzXCI6IHtcbiAgICAgIFwiY3hcIjogXCIyNFwiLFxuICAgICAgXCJjeVwiOiBcIjE2XCIsXG4gICAgICBcInJcIjogXCIyXCJcbiAgICB9XG4gIH1dLFxuICBcIm5hbWVcIjogXCJvdmVyZmxvdy1tZW51LS1ob3Jpem9udGFsXCIsXG4gIFwic2l6ZVwiOiAxNlxufTtcblxuZXhwb3J0IHsgXzE2IGFzIGRlZmF1bHQgfTtcbiIsIi8qKlxuICogQ29weXJpZ2h0IElCTSBDb3JwLiAyMDE2LCAyMDIwXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlLTIuMCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIENvZGUgZ2VuZXJhdGVkIGJ5IEBjYXJib24vaWNvbi1idWlsZC1oZWxwZXJzLiBETyBOT1QgRURJVC5cbiAqL1xudmFyIF8xNiA9IHtcbiAgXCJlbGVtXCI6IFwic3ZnXCIsXG4gIFwiYXR0cnNcIjoge1xuICAgIFwieG1sbnNcIjogXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLFxuICAgIFwidmlld0JveFwiOiBcIjAgMCAzMiAzMlwiLFxuICAgIFwiZmlsbFwiOiBcImN1cnJlbnRDb2xvclwiLFxuICAgIFwid2lkdGhcIjogMTYsXG4gICAgXCJoZWlnaHRcIjogMTZcbiAgfSxcbiAgXCJjb250ZW50XCI6IFt7XG4gICAgXCJlbGVtXCI6IFwiY2lyY2xlXCIsXG4gICAgXCJhdHRyc1wiOiB7XG4gICAgICBcImN4XCI6IFwiMTZcIixcbiAgICAgIFwiY3lcIjogXCI4XCIsXG4gICAgICBcInJcIjogXCIyXCJcbiAgICB9XG4gIH0sIHtcbiAgICBcImVsZW1cIjogXCJjaXJjbGVcIixcbiAgICBcImF0dHJzXCI6IHtcbiAgICAgIFwiY3hcIjogXCIxNlwiLFxuICAgICAgXCJjeVwiOiBcIjE2XCIsXG4gICAgICBcInJcIjogXCIyXCJcbiAgICB9XG4gIH0sIHtcbiAgICBcImVsZW1cIjogXCJjaXJjbGVcIixcbiAgICBcImF0dHJzXCI6IHtcbiAgICAgIFwiY3hcIjogXCIxNlwiLFxuICAgICAgXCJjeVwiOiBcIjI0XCIsXG4gICAgICBcInJcIjogXCIyXCJcbiAgICB9XG4gIH1dLFxuICBcIm5hbWVcIjogXCJvdmVyZmxvdy1tZW51LS12ZXJ0aWNhbFwiLFxuICBcInNpemVcIjogMTZcbn07XG5cbmV4cG9ydCB7IF8xNiBhcyBkZWZhdWx0IH07XG4iLCIvKipcbiAqIENvcHlyaWdodCBJQk0gQ29ycC4gMjAxNiwgMjAyMFxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZS0yLjAgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBDb2RlIGdlbmVyYXRlZCBieSBAY2FyYm9uL2ljb24tYnVpbGQtaGVscGVycy4gRE8gTk9UIEVESVQuXG4gKi9cbnZhciBfMTYgPSB7XG4gIFwiZWxlbVwiOiBcInN2Z1wiLFxuICBcImF0dHJzXCI6IHtcbiAgICBcInhtbG5zXCI6IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIixcbiAgICBcInZpZXdCb3hcIjogXCIwIDAgMTYgMTZcIixcbiAgICBcImZpbGxcIjogXCJjdXJyZW50Q29sb3JcIixcbiAgICBcIndpZHRoXCI6IDE2LFxuICAgIFwiaGVpZ2h0XCI6IDE2XG4gIH0sXG4gIFwiY29udGVudFwiOiBbe1xuICAgIFwiZWxlbVwiOiBcInBhdGhcIixcbiAgICBcImF0dHJzXCI6IHtcbiAgICAgIFwiZFwiOiBcIk0xMy45LDQuNmwtMi41LTIuNUMxMS4zLDIuMSwxMS4xLDIsMTEsMkgzQzIuNCwyLDIsMi40LDIsM3YxMGMwLDAuNiwwLjQsMSwxLDFoMTBjMC42LDAsMS0wLjQsMS0xVjVcXHRDMTQsNC45LDEzLjksNC43LDEzLjksNC42eiBNNiwzaDR2Mkg2VjN6IE0xMCwxM0g2VjloNFYxM3ogTTExLDEzVjljMC0wLjYtMC40LTEtMS0xSDZDNS40LDgsNSw4LjQsNSw5djRIM1YzaDJ2MmMwLDAuNiwwLjQsMSwxLDFcXHRoNGMwLjYsMCwxLTAuNCwxLTFWMy4ybDIsMlYxM0gxMXpcIlxuICAgIH1cbiAgfV0sXG4gIFwibmFtZVwiOiBcInNhdmVcIixcbiAgXCJzaXplXCI6IDE2XG59O1xuXG5leHBvcnQgeyBfMTYgYXMgZGVmYXVsdCB9O1xuIiwiLyoqXG4gKiBDb3B5cmlnaHQgSUJNIENvcnAuIDIwMTYsIDIwMjBcbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUtMi4wIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogQ29kZSBnZW5lcmF0ZWQgYnkgQGNhcmJvbi9pY29uLWJ1aWxkLWhlbHBlcnMuIERPIE5PVCBFRElULlxuICovXG52YXIgXzE2ID0ge1xuICBcImVsZW1cIjogXCJzdmdcIixcbiAgXCJhdHRyc1wiOiB7XG4gICAgXCJ4bWxuc1wiOiBcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsXG4gICAgXCJ2aWV3Qm94XCI6IFwiMCAwIDE2IDE2XCIsXG4gICAgXCJmaWxsXCI6IFwiY3VycmVudENvbG9yXCIsXG4gICAgXCJ3aWR0aFwiOiAxNixcbiAgICBcImhlaWdodFwiOiAxNlxuICB9LFxuICBcImNvbnRlbnRcIjogW3tcbiAgICBcImVsZW1cIjogXCJwYXRoXCIsXG4gICAgXCJhdHRyc1wiOiB7XG4gICAgICBcImRcIjogXCJNMTUsMTQuM0wxMC43LDEwYzEuOS0yLjMsMS42LTUuOC0wLjctNy43UzQuMiwwLjcsMi4zLDNTMC43LDguOCwzLDEwLjdjMiwxLjcsNSwxLjcsNywwbDQuMyw0LjNMMTUsMTQuM3ogTTIsNi41XFx0QzIsNCw0LDIsNi41LDJTMTEsNCwxMSw2LjVTOSwxMSw2LjUsMTFTMiw5LDIsNi41elwiXG4gICAgfVxuICB9XSxcbiAgXCJuYW1lXCI6IFwic2VhcmNoXCIsXG4gIFwic2l6ZVwiOiAxNlxufTtcblxuZXhwb3J0IHsgXzE2IGFzIGRlZmF1bHQgfTtcbiIsIi8qKlxuICogQ29weXJpZ2h0IElCTSBDb3JwLiAyMDE2LCAyMDIwXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlLTIuMCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIENvZGUgZ2VuZXJhdGVkIGJ5IEBjYXJib24vaWNvbi1idWlsZC1oZWxwZXJzLiBETyBOT1QgRURJVC5cbiAqL1xudmFyIF8xNiA9IHtcbiAgXCJlbGVtXCI6IFwic3ZnXCIsXG4gIFwiYXR0cnNcIjoge1xuICAgIFwieG1sbnNcIjogXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLFxuICAgIFwidmlld0JveFwiOiBcIjAgMCAzMiAzMlwiLFxuICAgIFwiZmlsbFwiOiBcImN1cnJlbnRDb2xvclwiLFxuICAgIFwid2lkdGhcIjogMTYsXG4gICAgXCJoZWlnaHRcIjogMTZcbiAgfSxcbiAgXCJjb250ZW50XCI6IFt7XG4gICAgXCJlbGVtXCI6IFwicGF0aFwiLFxuICAgIFwiYXR0cnNcIjoge1xuICAgICAgXCJkXCI6IFwiTTMwIDhoLTQuMWMtLjUtMi4zLTIuNS00LTQuOS00cy00LjQgMS43LTQuOSA0SDJ2MmgxNC4xYy41IDIuMyAyLjUgNCA0LjkgNHM0LjQtMS43IDQuOS00SDMwVjh6TTIxIDEyYy0xLjcgMC0zLTEuMy0zLTNzMS4zLTMgMy0zIDMgMS4zIDMgM1MyMi43IDEyIDIxIDEyek0yIDI0aDQuMWMuNSAyLjMgMi41IDQgNC45IDRzNC40LTEuNyA0LjktNEgzMHYtMkgxNS45Yy0uNS0yLjMtMi41LTQtNC45LTRzLTQuNCAxLjctNC45IDRIMlYyNHpNMTEgMjBjMS43IDAgMyAxLjMgMyAzcy0xLjMgMy0zIDMtMy0xLjMtMy0zUzkuMyAyMCAxMSAyMHpcIlxuICAgIH1cbiAgfV0sXG4gIFwibmFtZVwiOiBcInNldHRpbmdzLS1hZGp1c3RcIixcbiAgXCJzaXplXCI6IDE2XG59O1xuXG5leHBvcnQgeyBfMTYgYXMgZGVmYXVsdCB9O1xuIiwiLyoqXG4gKiBDb3B5cmlnaHQgSUJNIENvcnAuIDIwMTYsIDIwMjBcbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUtMi4wIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogQ29kZSBnZW5lcmF0ZWQgYnkgQGNhcmJvbi9pY29uLWJ1aWxkLWhlbHBlcnMuIERPIE5PVCBFRElULlxuICovXG52YXIgXzE2ID0ge1xuICBcImVsZW1cIjogXCJzdmdcIixcbiAgXCJhdHRyc1wiOiB7XG4gICAgXCJ4bWxuc1wiOiBcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsXG4gICAgXCJ2aWV3Qm94XCI6IFwiMCAwIDE2IDE2XCIsXG4gICAgXCJmaWxsXCI6IFwiY3VycmVudENvbG9yXCIsXG4gICAgXCJ3aWR0aFwiOiAxNixcbiAgICBcImhlaWdodFwiOiAxNlxuICB9LFxuICBcImNvbnRlbnRcIjogW3tcbiAgICBcImVsZW1cIjogXCJwYXRoXCIsXG4gICAgXCJhdHRyc1wiOiB7XG4gICAgICBcImRcIjogXCJNMTMuNSw4LjRjMC0wLjEsMC0wLjMsMC0wLjRjMC0wLjEsMC0wLjMsMC0wLjRsMS0wLjhjMC40LTAuMywwLjQtMC45LDAuMi0xLjNsLTEuMi0yQzEzLjMsMy4yLDEzLDMsMTIuNiwzXFx0Yy0wLjEsMC0wLjIsMC0wLjMsMC4xbC0xLjIsMC40Yy0wLjItMC4xLTAuNC0wLjMtMC43LTAuNGwtMC4zLTEuM0MxMC4xLDEuMyw5LjcsMSw5LjIsMUg2LjhjLTAuNSwwLTAuOSwwLjMtMSwwLjhMNS42LDMuMVxcdEM1LjMsMy4yLDUuMSwzLjMsNC45LDMuNEwzLjcsM0MzLjYsMywzLjUsMywzLjQsM0MzLDMsMi43LDMuMiwyLjUsMy41bC0xLjIsMkMxLjEsNS45LDEuMiw2LjQsMS42LDYuOGwwLjksMC45YzAsMC4xLDAsMC4zLDAsMC40XFx0YzAsMC4xLDAsMC4zLDAsMC40TDEuNiw5LjJjLTAuNCwwLjMtMC41LDAuOS0wLjIsMS4zbDEuMiwyQzIuNywxMi44LDMsMTMsMy40LDEzYzAuMSwwLDAuMiwwLDAuMy0wLjFsMS4yLTAuNFxcdGMwLjIsMC4xLDAuNCwwLjMsMC43LDAuNGwwLjMsMS4zYzAuMSwwLjUsMC41LDAuOCwxLDAuOGgyLjRjMC41LDAsMC45LTAuMywxLTAuOGwwLjMtMS4zYzAuMi0wLjEsMC40LTAuMiwwLjctMC40bDEuMiwwLjRcXHRjMC4xLDAsMC4yLDAuMSwwLjMsMC4xYzAuNCwwLDAuNy0wLjIsMC45LTAuNWwxLjEtMmMwLjItMC40LDAuMi0wLjktMC4yLTEuM0wxMy41LDguNHogTTEyLjYsMTJsLTEuNy0wLjZjLTAuNCwwLjMtMC45LDAuNi0xLjQsMC44XFx0TDkuMiwxNEg2LjhsLTAuNC0xLjhjLTAuNS0wLjItMC45LTAuNS0xLjQtMC44TDMuNCwxMmwtMS4yLTJsMS40LTEuMmMtMC4xLTAuNS0wLjEtMS4xLDAtMS42TDIuMiw2bDEuMi0ybDEuNywwLjZcXHRDNS41LDQuMiw2LDQsNi41LDMuOEw2LjgsMmgyLjRsMC40LDEuOGMwLjUsMC4yLDAuOSwwLjUsMS40LDAuOEwxMi42LDRsMS4yLDJsLTEuNCwxLjJjMC4xLDAuNSwwLjEsMS4xLDAsMS42bDEuNCwxLjJMMTIuNiwxMnpcIlxuICAgIH1cbiAgfSwge1xuICAgIFwiZWxlbVwiOiBcInBhdGhcIixcbiAgICBcImF0dHJzXCI6IHtcbiAgICAgIFwiZFwiOiBcIk04LDExYy0xLjcsMC0zLTEuMy0zLTNzMS4zLTMsMy0zczMsMS4zLDMsM0MxMSw5LjYsOS43LDExLDgsMTFDOCwxMSw4LDExLDgsMTF6IE04LDZDNi45LDYsNiw2LjgsNiw3LjlDNiw3LjksNiw4LDYsOFxcdGMwLDEuMSwwLjgsMiwxLjksMmMwLDAsMC4xLDAsMC4xLDBjMS4xLDAsMi0wLjgsMi0xLjljMCwwLDAtMC4xLDAtMC4xQzEwLDYuOSw5LjIsNiw4LDZDOC4xLDYsOCw2LDgsNnpcIlxuICAgIH1cbiAgfV0sXG4gIFwibmFtZVwiOiBcInNldHRpbmdzXCIsXG4gIFwic2l6ZVwiOiAxNlxufTtcblxuZXhwb3J0IHsgXzE2IGFzIGRlZmF1bHQgfTtcbiIsIi8qKlxuICogQ29weXJpZ2h0IElCTSBDb3JwLiAyMDE2LCAyMDIwXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlLTIuMCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIENvZGUgZ2VuZXJhdGVkIGJ5IEBjYXJib24vaWNvbi1idWlsZC1oZWxwZXJzLiBETyBOT1QgRURJVC5cbiAqL1xudmFyIF8xNiA9IHtcbiAgXCJlbGVtXCI6IFwic3ZnXCIsXG4gIFwiYXR0cnNcIjoge1xuICAgIFwieG1sbnNcIjogXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLFxuICAgIFwidmlld0JveFwiOiBcIjAgMCAzMiAzMlwiLFxuICAgIFwiZmlsbFwiOiBcImN1cnJlbnRDb2xvclwiLFxuICAgIFwid2lkdGhcIjogMTYsXG4gICAgXCJoZWlnaHRcIjogMTZcbiAgfSxcbiAgXCJjb250ZW50XCI6IFt7XG4gICAgXCJlbGVtXCI6IFwicGF0aFwiLFxuICAgIFwiYXR0cnNcIjoge1xuICAgICAgXCJkXCI6IFwiTTggMTVIMjRWMTdIOHpcIlxuICAgIH1cbiAgfV0sXG4gIFwibmFtZVwiOiBcInN1YnRyYWN0XCIsXG4gIFwic2l6ZVwiOiAxNlxufTtcblxuZXhwb3J0IHsgXzE2IGFzIGRlZmF1bHQgfTtcbiIsIi8qKlxuICogQ29weXJpZ2h0IElCTSBDb3JwLiAyMDE2LCAyMDIwXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlLTIuMCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIENvZGUgZ2VuZXJhdGVkIGJ5IEBjYXJib24vaWNvbi1idWlsZC1oZWxwZXJzLiBETyBOT1QgRURJVC5cbiAqL1xudmFyIF8xNiA9IHtcbiAgXCJlbGVtXCI6IFwic3ZnXCIsXG4gIFwiYXR0cnNcIjoge1xuICAgIFwieG1sbnNcIjogXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLFxuICAgIFwidmlld0JveFwiOiBcIjAgMCAzMiAzMlwiLFxuICAgIFwiZmlsbFwiOiBcImN1cnJlbnRDb2xvclwiLFxuICAgIFwid2lkdGhcIjogMTYsXG4gICAgXCJoZWlnaHRcIjogMTZcbiAgfSxcbiAgXCJjb250ZW50XCI6IFt7XG4gICAgXCJlbGVtXCI6IFwicGF0aFwiLFxuICAgIFwiYXR0cnNcIjoge1xuICAgICAgXCJkXCI6IFwiTTEyIDEySDE0VjI0SDEyek0xOCAxMkgyMFYyNEgxOHpcIlxuICAgIH1cbiAgfSwge1xuICAgIFwiZWxlbVwiOiBcInBhdGhcIixcbiAgICBcImF0dHJzXCI6IHtcbiAgICAgIFwiZFwiOiBcIk00IDZWOEg2VjI4YTIgMiAwIDAwMiAySDI0YTIgMiAwIDAwMi0yVjhoMlY2ek04IDI4VjhIMjRWMjh6TTEyIDJIMjBWNEgxMnpcIlxuICAgIH1cbiAgfV0sXG4gIFwibmFtZVwiOiBcInRyYXNoLWNhblwiLFxuICBcInNpemVcIjogMTZcbn07XG5cbmV4cG9ydCB7IF8xNiBhcyBkZWZhdWx0IH07XG4iLCIvKipcbiAqIENvcHlyaWdodCBJQk0gQ29ycC4gMjAxNiwgMjAyMFxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZS0yLjAgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBDb2RlIGdlbmVyYXRlZCBieSBAY2FyYm9uL2ljb24tYnVpbGQtaGVscGVycy4gRE8gTk9UIEVESVQuXG4gKi9cbnZhciBfMTYgPSB7XG4gIFwiZWxlbVwiOiBcInN2Z1wiLFxuICBcImF0dHJzXCI6IHtcbiAgICBcInhtbG5zXCI6IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIixcbiAgICBcInZpZXdCb3hcIjogXCIwIDAgMTYgMTZcIixcbiAgICBcImZpbGxcIjogXCJjdXJyZW50Q29sb3JcIixcbiAgICBcIndpZHRoXCI6IDE2LFxuICAgIFwiaGVpZ2h0XCI6IDE2XG4gIH0sXG4gIFwiY29udGVudFwiOiBbe1xuICAgIFwiZWxlbVwiOiBcInBhdGhcIixcbiAgICBcImF0dHJzXCI6IHtcbiAgICAgIFwiZFwiOiBcIk0yLjYsMTEuM2wwLjctMC43QzIuNiw5LjgsMS45LDksMS41LDhjMS0yLjUsMy44LTQuNSw2LjUtNC41YzAuNywwLDEuNCwwLjEsMiwwLjRsMC44LTAuOEM5LjksMi43LDksMi41LDgsMi41XFx0QzQuNywyLjYsMS43LDQuNywwLjUsNy44YzAsMC4xLDAsMC4yLDAsMC4zQzEsOS4zLDEuNywxMC40LDIuNiwxMS4zelwiXG4gICAgfVxuICB9LCB7XG4gICAgXCJlbGVtXCI6IFwicGF0aFwiLFxuICAgIFwiYXR0cnNcIjoge1xuICAgICAgXCJkXCI6IFwiTTYgNy45Yy4xLTEgLjktMS44IDEuOC0xLjhsLjktLjlDNy4yIDQuNyA1LjUgNS42IDUuMSA3LjIgNSA3LjcgNSA4LjMgNS4xIDguOEw2IDcuOXpNMTUuNSA3LjhjLS42LTEuNS0xLjYtMi44LTIuOS0zLjdMMTUgMS43IDE0LjMgMSAxIDE0LjMgMS43IDE1bDIuNi0yLjZjMS4xLjcgMi40IDEgMy43IDEuMSAzLjMtLjEgNi4zLTIuMiA3LjUtNS4zQzE1LjUgOC4xIDE1LjUgNy45IDE1LjUgNy44ek0xMCA4YzAgMS4xLS45IDItMiAyLS4zIDAtLjctLjEtMS0uM0w5LjcgN0M5LjkgNy4zIDEwIDcuNiAxMCA4ek04IDEyLjVjLTEgMC0yLjEtLjMtMy0uOGwxLjMtMS4zYzEuNC45IDMuMi42IDQuMi0uOC43LTEgLjctMi40IDAtMy40bDEuNC0xLjRjMS4xLjggMiAxLjkgMi42IDMuMkMxMy40IDEwLjUgMTAuNiAxMi41IDggMTIuNXpcIlxuICAgIH1cbiAgfV0sXG4gIFwibmFtZVwiOiBcInZpZXctLW9mZlwiLFxuICBcInNpemVcIjogMTZcbn07XG5cbmV4cG9ydCB7IF8xNiBhcyBkZWZhdWx0IH07XG4iLCIvKipcbiAqIENvcHlyaWdodCBJQk0gQ29ycC4gMjAxNiwgMjAyMFxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZS0yLjAgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBDb2RlIGdlbmVyYXRlZCBieSBAY2FyYm9uL2ljb24tYnVpbGQtaGVscGVycy4gRE8gTk9UIEVESVQuXG4gKi9cbnZhciBfMTYgPSB7XG4gIFwiZWxlbVwiOiBcInN2Z1wiLFxuICBcImF0dHJzXCI6IHtcbiAgICBcInhtbG5zXCI6IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIixcbiAgICBcInZpZXdCb3hcIjogXCIwIDAgMTYgMTZcIixcbiAgICBcImZpbGxcIjogXCJjdXJyZW50Q29sb3JcIixcbiAgICBcIndpZHRoXCI6IDE2LFxuICAgIFwiaGVpZ2h0XCI6IDE2XG4gIH0sXG4gIFwiY29udGVudFwiOiBbe1xuICAgIFwiZWxlbVwiOiBcInBhdGhcIixcbiAgICBcImF0dHJzXCI6IHtcbiAgICAgIFwiZFwiOiBcIk0xNS41LDcuOEMxNC4zLDQuNywxMS4zLDIuNiw4LDIuNUM0LjcsMi42LDEuNyw0LjcsMC41LDcuOGMwLDAuMSwwLDAuMiwwLDAuM2MxLjIsMy4xLDQuMSw1LjIsNy41LDUuM1xcdGMzLjMtMC4xLDYuMy0yLjIsNy41LTUuM0MxNS41LDguMSwxNS41LDcuOSwxNS41LDcuOHogTTgsMTIuNWMtMi43LDAtNS40LTItNi41LTQuNWMxLTIuNSwzLjgtNC41LDYuNS00LjVzNS40LDIsNi41LDQuNVxcdEMxMy40LDEwLjUsMTAuNiwxMi41LDgsMTIuNXpcIlxuICAgIH1cbiAgfSwge1xuICAgIFwiZWxlbVwiOiBcInBhdGhcIixcbiAgICBcImF0dHJzXCI6IHtcbiAgICAgIFwiZFwiOiBcIk04LDVDNi4zLDUsNSw2LjMsNSw4czEuMywzLDMsM3MzLTEuMywzLTNTOS43LDUsOCw1eiBNOCwxMGMtMS4xLDAtMi0wLjktMi0yczAuOS0yLDItMnMyLDAuOSwyLDJTOS4xLDEwLDgsMTB6XCJcbiAgICB9XG4gIH1dLFxuICBcIm5hbWVcIjogXCJ2aWV3XCIsXG4gIFwic2l6ZVwiOiAxNlxufTtcblxuZXhwb3J0IHsgXzE2IGFzIGRlZmF1bHQgfTtcbiIsIi8qKlxuICogQ29weXJpZ2h0IElCTSBDb3JwLiAyMDE2LCAyMDIwXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlLTIuMCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIENvZGUgZ2VuZXJhdGVkIGJ5IEBjYXJib24vaWNvbi1idWlsZC1oZWxwZXJzLiBETyBOT1QgRURJVC5cbiAqL1xudmFyIF8xNiA9IHtcbiAgXCJlbGVtXCI6IFwic3ZnXCIsXG4gIFwiYXR0cnNcIjoge1xuICAgIFwieG1sbnNcIjogXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLFxuICAgIFwidmlld0JveFwiOiBcIjAgMCAzMiAzMlwiLFxuICAgIFwiZmlsbFwiOiBcImN1cnJlbnRDb2xvclwiLFxuICAgIFwid2lkdGhcIjogMTYsXG4gICAgXCJoZWlnaHRcIjogMTZcbiAgfSxcbiAgXCJjb250ZW50XCI6IFt7XG4gICAgXCJlbGVtXCI6IFwicGF0aFwiLFxuICAgIFwiYXR0cnNcIjoge1xuICAgICAgXCJmaWxsXCI6IFwibm9uZVwiLFxuICAgICAgXCJkXCI6IFwiTTE2LDI2YTEuNSwxLjUsMCwxLDEsMS41LTEuNUExLjUsMS41LDAsMCwxLDE2LDI2Wm0tMS4xMjUtNWgyLjI1VjEyaC0yLjI1WlwiLFxuICAgICAgXCJkYXRhLWljb24tcGF0aFwiOiBcImlubmVyLXBhdGhcIlxuICAgIH1cbiAgfSwge1xuICAgIFwiZWxlbVwiOiBcInBhdGhcIixcbiAgICBcImF0dHJzXCI6IHtcbiAgICAgIFwiZFwiOiBcIk0xNi4wMDIsNi4xNzE0aC0uMDA0TDQuNjQ4NywyNy45OTY2LDQuNjUwNiwyOEgyNy4zNDk0bC4wMDE5LS4wMDM0Wk0xNC44NzUsMTJoMi4yNXY5aC0yLjI1Wk0xNiwyNmExLjUsMS41LDAsMSwxLDEuNS0xLjVBMS41LDEuNSwwLDAsMSwxNiwyNlpcIlxuICAgIH1cbiAgfSwge1xuICAgIFwiZWxlbVwiOiBcInBhdGhcIixcbiAgICBcImF0dHJzXCI6IHtcbiAgICAgIFwiZFwiOiBcIk0yOSwzMEgzYTEsMSwwLDAsMS0uODg3Mi0xLjQ2MTRsMTMtMjVhMSwxLDAsMCwxLDEuNzc0NCwwbDEzLDI1QTEsMSwwLDAsMSwyOSwzMFpNNC42NTA3LDI4SDI3LjM0OTNsLjAwMi0uMDAzM0wxNi4wMDIsNi4xNzE0aC0uMDA0TDQuNjQ4NywyNy45OTY3WlwiXG4gICAgfVxuICB9XSxcbiAgXCJuYW1lXCI6IFwid2FybmluZy0tYWx0LS1maWxsZWRcIixcbiAgXCJzaXplXCI6IDE2XG59O1xuXG5leHBvcnQgeyBfMTYgYXMgZGVmYXVsdCB9O1xuIiwiLyoqXG4gKiBDb3B5cmlnaHQgSUJNIENvcnAuIDIwMTYsIDIwMjBcbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUtMi4wIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogQ29kZSBnZW5lcmF0ZWQgYnkgQGNhcmJvbi9pY29uLWJ1aWxkLWhlbHBlcnMuIERPIE5PVCBFRElULlxuICovXG52YXIgXzIwID0ge1xuICBcImVsZW1cIjogXCJzdmdcIixcbiAgXCJhdHRyc1wiOiB7XG4gICAgXCJ4bWxuc1wiOiBcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsXG4gICAgXCJ2aWV3Qm94XCI6IFwiMCAwIDMyIDMyXCIsXG4gICAgXCJmaWxsXCI6IFwiY3VycmVudENvbG9yXCIsXG4gICAgXCJ3aWR0aFwiOiAyMCxcbiAgICBcImhlaWdodFwiOiAyMFxuICB9LFxuICBcImNvbnRlbnRcIjogW3tcbiAgICBcImVsZW1cIjogXCJwYXRoXCIsXG4gICAgXCJhdHRyc1wiOiB7XG4gICAgICBcImZpbGxcIjogXCJub25lXCIsXG4gICAgICBcImRcIjogXCJNMTYsMjZhMS41LDEuNSwwLDEsMSwxLjUtMS41QTEuNSwxLjUsMCwwLDEsMTYsMjZabS0xLjEyNS01aDIuMjVWMTJoLTIuMjVaXCIsXG4gICAgICBcImRhdGEtaWNvbi1wYXRoXCI6IFwiaW5uZXItcGF0aFwiXG4gICAgfVxuICB9LCB7XG4gICAgXCJlbGVtXCI6IFwicGF0aFwiLFxuICAgIFwiYXR0cnNcIjoge1xuICAgICAgXCJkXCI6IFwiTTE2LjAwMiw2LjE3MTRoLS4wMDRMNC42NDg3LDI3Ljk5NjYsNC42NTA2LDI4SDI3LjM0OTRsLjAwMTktLjAwMzRaTTE0Ljg3NSwxMmgyLjI1djloLTIuMjVaTTE2LDI2YTEuNSwxLjUsMCwxLDEsMS41LTEuNUExLjUsMS41LDAsMCwxLDE2LDI2WlwiXG4gICAgfVxuICB9LCB7XG4gICAgXCJlbGVtXCI6IFwicGF0aFwiLFxuICAgIFwiYXR0cnNcIjoge1xuICAgICAgXCJkXCI6IFwiTTI5LDMwSDNhMSwxLDAsMCwxLS44ODcyLTEuNDYxNGwxMy0yNWExLDEsMCwwLDEsMS43NzQ0LDBsMTMsMjVBMSwxLDAsMCwxLDI5LDMwWk00LjY1MDcsMjhIMjcuMzQ5M2wuMDAyLS4wMDMzTDE2LjAwMiw2LjE3MTRoLS4wMDRMNC42NDg3LDI3Ljk5NjdaXCJcbiAgICB9XG4gIH1dLFxuICBcIm5hbWVcIjogXCJ3YXJuaW5nLS1hbHQtLWZpbGxlZFwiLFxuICBcInNpemVcIjogMjBcbn07XG5cbmV4cG9ydCB7IF8yMCBhcyBkZWZhdWx0IH07XG4iLCIvKipcbiAqIENvcHlyaWdodCBJQk0gQ29ycC4gMjAxNiwgMjAyMFxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZS0yLjAgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBDb2RlIGdlbmVyYXRlZCBieSBAY2FyYm9uL2ljb24tYnVpbGQtaGVscGVycy4gRE8gTk9UIEVESVQuXG4gKi9cbnZhciBfMTYgPSB7XG4gIFwiZWxlbVwiOiBcInN2Z1wiLFxuICBcImF0dHJzXCI6IHtcbiAgICBcInhtbG5zXCI6IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIixcbiAgICBcInZpZXdCb3hcIjogXCIwIDAgMTYgMTZcIixcbiAgICBcImZpbGxcIjogXCJjdXJyZW50Q29sb3JcIixcbiAgICBcIndpZHRoXCI6IDE2LFxuICAgIFwiaGVpZ2h0XCI6IDE2XG4gIH0sXG4gIFwiY29udGVudFwiOiBbe1xuICAgIFwiZWxlbVwiOiBcInBhdGhcIixcbiAgICBcImF0dHJzXCI6IHtcbiAgICAgIFwiZFwiOiBcIk04LDFDNC4yLDEsMSw0LjIsMSw4czMuMiw3LDcsN3M3LTMuMSw3LTdTMTEuOSwxLDgsMXogTTcuNSw0aDF2NWgtMUM3LjUsOSw3LjUsNCw3LjUsNHogTTgsMTIuMlxcdGMtMC40LDAtMC44LTAuNC0wLjgtMC44czAuMy0wLjgsMC44LTAuOGMwLjQsMCwwLjgsMC40LDAuOCwwLjhTOC40LDEyLjIsOCwxMi4yelwiXG4gICAgfVxuICB9LCB7XG4gICAgXCJlbGVtXCI6IFwicGF0aFwiLFxuICAgIFwiYXR0cnNcIjoge1xuICAgICAgXCJkXCI6IFwiTTcuNSw0aDF2NWgtMUM3LjUsOSw3LjUsNCw3LjUsNHogTTgsMTIuMmMtMC40LDAtMC44LTAuNC0wLjgtMC44czAuMy0wLjgsMC44LTAuOFxcdGMwLjQsMCwwLjgsMC40LDAuOCwwLjhTOC40LDEyLjIsOCwxMi4yelwiLFxuICAgICAgXCJkYXRhLWljb24tcGF0aFwiOiBcImlubmVyLXBhdGhcIixcbiAgICAgIFwib3BhY2l0eVwiOiBcIjBcIlxuICAgIH1cbiAgfV0sXG4gIFwibmFtZVwiOiBcIndhcm5pbmctLWZpbGxlZFwiLFxuICBcInNpemVcIjogMTZcbn07XG5cbmV4cG9ydCB7IF8xNiBhcyBkZWZhdWx0IH07XG4iLCIvKipcbiAqIENvcHlyaWdodCBJQk0gQ29ycC4gMjAxNiwgMjAyMFxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZS0yLjAgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBDb2RlIGdlbmVyYXRlZCBieSBAY2FyYm9uL2ljb24tYnVpbGQtaGVscGVycy4gRE8gTk9UIEVESVQuXG4gKi9cbnZhciBfMjAgPSB7XG4gIFwiZWxlbVwiOiBcInN2Z1wiLFxuICBcImF0dHJzXCI6IHtcbiAgICBcInhtbG5zXCI6IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIixcbiAgICBcInZpZXdCb3hcIjogXCIwIDAgMjAgMjBcIixcbiAgICBcImZpbGxcIjogXCJjdXJyZW50Q29sb3JcIixcbiAgICBcIndpZHRoXCI6IDIwLFxuICAgIFwiaGVpZ2h0XCI6IDIwXG4gIH0sXG4gIFwiY29udGVudFwiOiBbe1xuICAgIFwiZWxlbVwiOiBcInBhdGhcIixcbiAgICBcImF0dHJzXCI6IHtcbiAgICAgIFwiZFwiOiBcIk0xMCwxYy01LDAtOSw0LTksOXM0LDksOSw5czktNCw5LTlTMTUsMSwxMCwxeiBNOS4yLDVoMS41djdIOS4yVjV6IE0xMCwxNmMtMC42LDAtMS0wLjQtMS0xczAuNC0xLDEtMVxcdHMxLDAuNCwxLDFTMTAuNiwxNiwxMCwxNnpcIlxuICAgIH1cbiAgfSwge1xuICAgIFwiZWxlbVwiOiBcInBhdGhcIixcbiAgICBcImF0dHJzXCI6IHtcbiAgICAgIFwiZFwiOiBcIk05LjIsNWgxLjV2N0g5LjJWNXogTTEwLDE2Yy0wLjYsMC0xLTAuNC0xLTFzMC40LTEsMS0xczEsMC40LDEsMVMxMC42LDE2LDEwLDE2elwiLFxuICAgICAgXCJkYXRhLWljb24tcGF0aFwiOiBcImlubmVyLXBhdGhcIixcbiAgICAgIFwib3BhY2l0eVwiOiBcIjBcIlxuICAgIH1cbiAgfV0sXG4gIFwibmFtZVwiOiBcIndhcm5pbmctLWZpbGxlZFwiLFxuICBcInNpemVcIjogMjBcbn07XG5cbmV4cG9ydCB7IF8yMCBhcyBkZWZhdWx0IH07XG4iLCIvKipcbiAqIENvcHlyaWdodCBJQk0gQ29ycC4gMjAxNiwgMjAyMFxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZS0yLjAgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBDb2RlIGdlbmVyYXRlZCBieSBAY2FyYm9uL2ljb24tYnVpbGQtaGVscGVycy4gRE8gTk9UIEVESVQuXG4gKi9cbnZhciBfMTYgPSB7XG4gIFwiZWxlbVwiOiBcInN2Z1wiLFxuICBcImF0dHJzXCI6IHtcbiAgICBcInhtbG5zXCI6IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIixcbiAgICBcInZpZXdCb3hcIjogXCIwIDAgMTYgMTZcIixcbiAgICBcImZpbGxcIjogXCJjdXJyZW50Q29sb3JcIixcbiAgICBcIndpZHRoXCI6IDE2LFxuICAgIFwiaGVpZ2h0XCI6IDE2XG4gIH0sXG4gIFwiY29udGVudFwiOiBbe1xuICAgIFwiZWxlbVwiOiBcInBhdGhcIixcbiAgICBcImF0dHJzXCI6IHtcbiAgICAgIFwiZFwiOiBcIk04LDFDNC4xLDEsMSw0LjEsMSw4czMuMSw3LDcsN3M3LTMuMSw3LTdTMTEuOSwxLDgsMXogTTgsMTRjLTMuMywwLTYtMi43LTYtNnMyLjctNiw2LTZzNiwyLjcsNiw2UzExLjMsMTQsOCwxNHpcIlxuICAgIH1cbiAgfSwge1xuICAgIFwiZWxlbVwiOiBcInBhdGhcIixcbiAgICBcImF0dHJzXCI6IHtcbiAgICAgIFwiZFwiOiBcIk03LjUgNEg4LjVWOUg3LjV6TTggMTAuMmMtLjQgMC0uOC4zLS44LjhzLjMuOC44LjhjLjQgMCAuOC0uMy44LS44UzguNCAxMC4yIDggMTAuMnpcIlxuICAgIH1cbiAgfV0sXG4gIFwibmFtZVwiOiBcIndhcm5pbmdcIixcbiAgXCJzaXplXCI6IDE2XG59O1xuXG5leHBvcnQgeyBfMTYgYXMgZGVmYXVsdCB9O1xuIiwiLyoqXG4gKiBVdGlsaXRlcyB0byBtYW5pcHVsYXRlIHRoZSBwb3NpdGlvbiBvZiBlbGVtZW50cyByZWxhdGl2ZSB0byBvdGhlciBlbGVtZW50c1xuICovXG52YXIgX2E7XG5leHBvcnQgdmFyIFBMQUNFTUVOVFM7XG4oZnVuY3Rpb24gKFBMQUNFTUVOVFMpIHtcbiAgICBQTEFDRU1FTlRTW1wiTEVGVFwiXSA9IFwibGVmdFwiO1xuICAgIFBMQUNFTUVOVFNbXCJSSUdIVFwiXSA9IFwicmlnaHRcIjtcbiAgICBQTEFDRU1FTlRTW1wiVE9QXCJdID0gXCJ0b3BcIjtcbiAgICBQTEFDRU1FTlRTW1wiQk9UVE9NXCJdID0gXCJib3R0b21cIjtcbn0pKFBMQUNFTUVOVFMgfHwgKFBMQUNFTUVOVFMgPSB7fSkpO1xuZXhwb3J0IHZhciBkZWZhdWx0UG9zaXRpb25zID0gKF9hID0ge30sXG4gICAgX2FbUExBQ0VNRU5UUy5MRUZUXSA9IGZ1bmN0aW9uIChyZWZlcmVuY2VPZmZzZXQsIHRhcmdldCwgcmVmZXJlbmNlUmVjdCkgeyByZXR1cm4gKHtcbiAgICAgICAgdG9wOiByZWZlcmVuY2VPZmZzZXQudG9wIC0gTWF0aC5yb3VuZCh0YXJnZXQub2Zmc2V0SGVpZ2h0IC8gMikgKyBNYXRoLnJvdW5kKHJlZmVyZW5jZVJlY3QuaGVpZ2h0IC8gMiksXG4gICAgICAgIGxlZnQ6IE1hdGgucm91bmQocmVmZXJlbmNlT2Zmc2V0LmxlZnQgLSB0YXJnZXQub2Zmc2V0V2lkdGgpXG4gICAgfSk7IH0sXG4gICAgX2FbUExBQ0VNRU5UUy5SSUdIVF0gPSBmdW5jdGlvbiAocmVmZXJlbmNlT2Zmc2V0LCB0YXJnZXQsIHJlZmVyZW5jZVJlY3QpIHsgcmV0dXJuICh7XG4gICAgICAgIHRvcDogcmVmZXJlbmNlT2Zmc2V0LnRvcCAtIE1hdGgucm91bmQodGFyZ2V0Lm9mZnNldEhlaWdodCAvIDIpICsgTWF0aC5yb3VuZChyZWZlcmVuY2VSZWN0LmhlaWdodCAvIDIpLFxuICAgICAgICBsZWZ0OiBNYXRoLnJvdW5kKHJlZmVyZW5jZU9mZnNldC5sZWZ0ICsgcmVmZXJlbmNlUmVjdC53aWR0aClcbiAgICB9KTsgfSxcbiAgICBfYVtQTEFDRU1FTlRTLlRPUF0gPSBmdW5jdGlvbiAocmVmZXJlbmNlT2Zmc2V0LCB0YXJnZXQsIHJlZmVyZW5jZVJlY3QpIHsgcmV0dXJuICh7XG4gICAgICAgIHRvcDogTWF0aC5yb3VuZChyZWZlcmVuY2VPZmZzZXQudG9wIC0gdGFyZ2V0Lm9mZnNldEhlaWdodCksXG4gICAgICAgIGxlZnQ6IHJlZmVyZW5jZU9mZnNldC5sZWZ0IC0gTWF0aC5yb3VuZCh0YXJnZXQub2Zmc2V0V2lkdGggLyAyKSArIE1hdGgucm91bmQocmVmZXJlbmNlUmVjdC53aWR0aCAvIDIpXG4gICAgfSk7IH0sXG4gICAgX2FbUExBQ0VNRU5UUy5CT1RUT01dID0gZnVuY3Rpb24gKHJlZmVyZW5jZU9mZnNldCwgdGFyZ2V0LCByZWZlcmVuY2VSZWN0KSB7IHJldHVybiAoe1xuICAgICAgICB0b3A6IE1hdGgucm91bmQocmVmZXJlbmNlT2Zmc2V0LnRvcCArIHJlZmVyZW5jZVJlY3QuaGVpZ2h0KSxcbiAgICAgICAgbGVmdDogcmVmZXJlbmNlT2Zmc2V0LmxlZnQgLSBNYXRoLnJvdW5kKHRhcmdldC5vZmZzZXRXaWR0aCAvIDIpICsgTWF0aC5yb3VuZChyZWZlcmVuY2VSZWN0LndpZHRoIC8gMilcbiAgICB9KTsgfSxcbiAgICBfYSk7XG52YXIgd2luZG93UmVmID0gdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHtcbiAgICBpbm5lckhlaWdodDogMCxcbiAgICBzY3JvbGxZOiAwLFxuICAgIGlubmVyV2lkdGg6IDAsXG4gICAgc2Nyb2xsWDogMFxufTtcbnZhciBQb3NpdGlvbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBQb3NpdGlvbihwb3NpdGlvbnMpIHtcbiAgICAgICAgaWYgKHBvc2l0aW9ucyA9PT0gdm9pZCAwKSB7IHBvc2l0aW9ucyA9IHt9OyB9XG4gICAgICAgIHRoaXMucG9zaXRpb25zID0gZGVmYXVsdFBvc2l0aW9ucztcbiAgICAgICAgdGhpcy5wb3NpdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBkZWZhdWx0UG9zaXRpb25zLCBwb3NpdGlvbnMpO1xuICAgIH1cbiAgICBQb3NpdGlvbi5wcm90b3R5cGUuZ2V0UmVsYXRpdmVPZmZzZXQgPSBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gICAgICAgIC8vIHN0YXJ0IHdpdGggdGhlIGluaXRpYWwgZWxlbWVudCBvZmZzZXRzXG4gICAgICAgIHZhciBvZmZzZXRzID0ge1xuICAgICAgICAgICAgbGVmdDogdGFyZ2V0Lm9mZnNldExlZnQsXG4gICAgICAgICAgICB0b3A6IHRhcmdldC5vZmZzZXRUb3BcbiAgICAgICAgfTtcbiAgICAgICAgLy8gZ2V0IGVhY2ggc3RhdGljIChpLmUuIG5vdCBhYnNvbHV0ZSBvciByZWxhdGl2ZSkgb2Zmc2V0UGFyZW50IGFuZCBzdW0gdGhlIGxlZnQvcmlnaHQgb2Zmc2V0c1xuICAgICAgICB3aGlsZSAodGFyZ2V0Lm9mZnNldFBhcmVudCAmJiBnZXRDb21wdXRlZFN0eWxlKHRhcmdldC5vZmZzZXRQYXJlbnQpLnBvc2l0aW9uID09PSBcInN0YXRpY1wiKSB7XG4gICAgICAgICAgICBvZmZzZXRzLmxlZnQgKz0gdGFyZ2V0Lm9mZnNldExlZnQ7XG4gICAgICAgICAgICBvZmZzZXRzLnRvcCArPSB0YXJnZXQub2Zmc2V0VG9wO1xuICAgICAgICAgICAgdGFyZ2V0ID0gdGFyZ2V0Lm9mZnNldFBhcmVudDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb2Zmc2V0cztcbiAgICB9O1xuICAgIFBvc2l0aW9uLnByb3RvdHlwZS5nZXRBYnNvbHV0ZU9mZnNldCA9IGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICAgICAgdmFyIGN1cnJlbnROb2RlID0gdGFyZ2V0O1xuICAgICAgICB2YXIgbWFyZ2lucyA9IHtcbiAgICAgICAgICAgIHRvcDogMCxcbiAgICAgICAgICAgIGxlZnQ6IDBcbiAgICAgICAgfTtcbiAgICAgICAgLy8gc2VhcmNoZXMgZm9yIGNvbnRhaW5pbmcgZWxlbWVudHMgd2l0aCBhZGRpdGlvbmFsIG1hcmdpbnNcbiAgICAgICAgd2hpbGUgKGN1cnJlbnROb2RlLm9mZnNldFBhcmVudCkge1xuICAgICAgICAgICAgdmFyIGNvbXB1dGVkID0gZ2V0Q29tcHV0ZWRTdHlsZShjdXJyZW50Tm9kZS5vZmZzZXRQYXJlbnQpO1xuICAgICAgICAgICAgLy8gZmluZCBzdGF0aWMgZWxlbWVudHMgd2l0aCBhZGRpdGlvbmFsIG1hcmdpbnNcbiAgICAgICAgICAgIC8vIHNpbmNlIHRoZXkgdGVuZCB0byB0aHJvdyBvZmYgb3VyIHBvc2l0aW9uaW5nXG4gICAgICAgICAgICAvLyAodXN1YWxseSB0aGlzIGlzIGp1c3QgdGhlIGJvZHkpXG4gICAgICAgICAgICBpZiAoY29tcHV0ZWQucG9zaXRpb24gPT09IFwic3RhdGljXCIgJiZcbiAgICAgICAgICAgICAgICBjb21wdXRlZC5tYXJnaW5MZWZ0ICYmXG4gICAgICAgICAgICAgICAgY29tcHV0ZWQubWFyZ2luVG9wKSB7XG4gICAgICAgICAgICAgICAgaWYgKHBhcnNlSW50KGNvbXB1dGVkLm1hcmdpblRvcCwgMTApKSB7XG4gICAgICAgICAgICAgICAgICAgIG1hcmdpbnMudG9wICs9IHBhcnNlSW50KGNvbXB1dGVkLm1hcmdpblRvcCwgMTApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocGFyc2VJbnQoY29tcHV0ZWQubWFyZ2luTGVmdCwgMTApKSB7XG4gICAgICAgICAgICAgICAgICAgIG1hcmdpbnMubGVmdCArPSBwYXJzZUludChjb21wdXRlZC5tYXJnaW5MZWZ0LCAxMCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3VycmVudE5vZGUgPSBjdXJyZW50Tm9kZS5vZmZzZXRQYXJlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHRhcmdldFJlY3QgPSB0YXJnZXQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIHZhciByZWxhdGl2ZVJlY3QgPSBkb2N1bWVudC5ib2R5LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdG9wOiB0YXJnZXRSZWN0LnRvcCAtIHJlbGF0aXZlUmVjdC50b3AgKyBtYXJnaW5zLnRvcCxcbiAgICAgICAgICAgIGxlZnQ6IHRhcmdldFJlY3QubGVmdCAtIHJlbGF0aXZlUmVjdC5sZWZ0ICsgbWFyZ2lucy5sZWZ0XG4gICAgICAgIH07XG4gICAgfTtcbiAgICAvLyBmaW5kcyB0aGUgcG9zaXRpb24gcmVsYXRpdmUgdG8gdGhlIGByZWZlcmVuY2VgIGVsZW1lbnRcbiAgICBQb3NpdGlvbi5wcm90b3R5cGUuZmluZFJlbGF0aXZlID0gZnVuY3Rpb24gKHJlZmVyZW5jZSwgdGFyZ2V0LCBwbGFjZW1lbnQpIHtcbiAgICAgICAgdmFyIHJlZmVyZW5jZU9mZnNldCA9IHRoaXMuZ2V0UmVsYXRpdmVPZmZzZXQocmVmZXJlbmNlKTtcbiAgICAgICAgdmFyIHJlZmVyZW5jZVJlY3QgPSByZWZlcmVuY2UuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIHJldHVybiB0aGlzLmNhbGN1bGF0ZVBvc2l0aW9uKHJlZmVyZW5jZU9mZnNldCwgcmVmZXJlbmNlUmVjdCwgdGFyZ2V0LCBwbGFjZW1lbnQpO1xuICAgIH07XG4gICAgUG9zaXRpb24ucHJvdG90eXBlLmZpbmRBYnNvbHV0ZSA9IGZ1bmN0aW9uIChyZWZlcmVuY2UsIHRhcmdldCwgcGxhY2VtZW50KSB7XG4gICAgICAgIHZhciByZWZlcmVuY2VPZmZzZXQgPSB0aGlzLmdldEFic29sdXRlT2Zmc2V0KHJlZmVyZW5jZSk7XG4gICAgICAgIHZhciByZWZlcmVuY2VSZWN0ID0gcmVmZXJlbmNlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICByZXR1cm4gdGhpcy5jYWxjdWxhdGVQb3NpdGlvbihyZWZlcmVuY2VPZmZzZXQsIHJlZmVyZW5jZVJlY3QsIHRhcmdldCwgcGxhY2VtZW50KTtcbiAgICB9O1xuICAgIFBvc2l0aW9uLnByb3RvdHlwZS5maW5kUG9zaXRpb24gPSBmdW5jdGlvbiAocmVmZXJlbmNlLCB0YXJnZXQsIHBsYWNlbWVudCwgb2Zmc2V0RnVuY3Rpb24pIHtcbiAgICAgICAgaWYgKG9mZnNldEZ1bmN0aW9uID09PSB2b2lkIDApIHsgb2Zmc2V0RnVuY3Rpb24gPSB0aGlzLmdldEFic29sdXRlT2Zmc2V0LmJpbmQodGhpcyk7IH1cbiAgICAgICAgdmFyIHJlZmVyZW5jZU9mZnNldCA9IG9mZnNldEZ1bmN0aW9uKHJlZmVyZW5jZSk7XG4gICAgICAgIHZhciByZWZlcmVuY2VSZWN0ID0gcmVmZXJlbmNlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICByZXR1cm4gdGhpcy5jYWxjdWxhdGVQb3NpdGlvbihyZWZlcmVuY2VPZmZzZXQsIHJlZmVyZW5jZVJlY3QsIHRhcmdldCwgcGxhY2VtZW50KTtcbiAgICB9O1xuICAgIFBvc2l0aW9uLnByb3RvdHlwZS5maW5kUG9zaXRpb25BdCA9IGZ1bmN0aW9uIChvZmZzZXQsIHRhcmdldCwgcGxhY2VtZW50KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNhbGN1bGF0ZVBvc2l0aW9uKG9mZnNldCwgeyB0b3A6IDAsIGxlZnQ6IDAsIGhlaWdodDogMCwgd2lkdGg6IDAgfSwgdGFyZ2V0LCBwbGFjZW1lbnQpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBkaW1lbnNpb25zIG9mIGFuIGVsZW1lbnQgZnJvbSBhbiBBYnNvbHV0ZVBvc2l0aW9uIGFuZCBhIHJlZmVyZW5jZSBlbGVtZW50XG4gICAgICovXG4gICAgUG9zaXRpb24ucHJvdG90eXBlLmdldFBsYWNlbWVudEJveCA9IGZ1bmN0aW9uICh0YXJnZXQsIHBvc2l0aW9uKSB7XG4gICAgICAgIHZhciB0YXJnZXRCb3R0b20gPSB0YXJnZXQub2Zmc2V0SGVpZ2h0ICsgcG9zaXRpb24udG9wO1xuICAgICAgICB2YXIgdGFyZ2V0UmlnaHQgPSB0YXJnZXQub2Zmc2V0V2lkdGggKyBwb3NpdGlvbi5sZWZ0O1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdG9wOiBwb3NpdGlvbi50b3AsXG4gICAgICAgICAgICBib3R0b206IHRhcmdldEJvdHRvbSxcbiAgICAgICAgICAgIGxlZnQ6IHBvc2l0aW9uLmxlZnQsXG4gICAgICAgICAgICByaWdodDogdGFyZ2V0UmlnaHRcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIFBvc2l0aW9uLnByb3RvdHlwZS5hZGRPZmZzZXQgPSBmdW5jdGlvbiAocG9zaXRpb24sIHRvcCwgbGVmdCkge1xuICAgICAgICBpZiAodG9wID09PSB2b2lkIDApIHsgdG9wID0gMDsgfVxuICAgICAgICBpZiAobGVmdCA9PT0gdm9pZCAwKSB7IGxlZnQgPSAwOyB9XG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBwb3NpdGlvbiwge1xuICAgICAgICAgICAgdG9wOiBwb3NpdGlvbi50b3AgKyB0b3AsXG4gICAgICAgICAgICBsZWZ0OiBwb3NpdGlvbi5sZWZ0ICsgbGVmdFxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFBvc2l0aW9uLnByb3RvdHlwZS5zZXRFbGVtZW50ID0gZnVuY3Rpb24gKGVsZW1lbnQsIHBvc2l0aW9uKSB7XG4gICAgICAgIGVsZW1lbnQuc3R5bGUudG9wID0gcG9zaXRpb24udG9wICsgXCJweFwiO1xuICAgICAgICBlbGVtZW50LnN0eWxlLmxlZnQgPSBwb3NpdGlvbi5sZWZ0ICsgXCJweFwiO1xuICAgIH07XG4gICAgUG9zaXRpb24ucHJvdG90eXBlLmZpbmRCZXN0UGxhY2VtZW50ID0gZnVuY3Rpb24gKHJlZmVyZW5jZSwgdGFyZ2V0LCBwbGFjZW1lbnRzLCBjb250YWluZXJGdW5jdGlvbiwgcG9zaXRpb25GdW5jdGlvbikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAoY29udGFpbmVyRnVuY3Rpb24gPT09IHZvaWQgMCkgeyBjb250YWluZXJGdW5jdGlvbiA9IHRoaXMuZGVmYXVsdENvbnRhaW5lckZ1bmN0aW9uLmJpbmQodGhpcyk7IH1cbiAgICAgICAgaWYgKHBvc2l0aW9uRnVuY3Rpb24gPT09IHZvaWQgMCkgeyBwb3NpdGlvbkZ1bmN0aW9uID0gdGhpcy5maW5kUG9zaXRpb24uYmluZCh0aGlzKTsgfVxuICAgICAgICAvKipcbiAgICAgICAgICogbWFwIG92ZXIgdGhlIGFycmF5IG9mIHBsYWNlbWVudHMgYW5kIHdlaWdodCB0aGVtIGJhc2VkIG9uIHRoZSBwZXJjZW50YWdlIG9mIHZpc2libGUgYXJlYVxuICAgICAgICAgKiB3aGVyZSB2aXNpYmxlIGFyZWEgaXMgZGVmaW5lZCBhcyB0aGUgYXJlYSBub3Qgb2JzY3VyZWQgYnkgdGhlIHdpbmRvdyBib3JkZXJzXG4gICAgICAgICAqL1xuICAgICAgICB2YXIgd2VpZ2h0ZWRQbGFjZW1lbnRzID0gcGxhY2VtZW50cy5tYXAoZnVuY3Rpb24gKHBsYWNlbWVudCkge1xuICAgICAgICAgICAgdmFyIHBvcyA9IHBvc2l0aW9uRnVuY3Rpb24ocmVmZXJlbmNlLCB0YXJnZXQsIHBsYWNlbWVudCk7XG4gICAgICAgICAgICB2YXIgYm94ID0gX3RoaXMuZ2V0UGxhY2VtZW50Qm94KHRhcmdldCwgcG9zKTtcbiAgICAgICAgICAgIHZhciBoaWRkZW5IZWlnaHQgPSAwO1xuICAgICAgICAgICAgdmFyIGhpZGRlbldpZHRoID0gMDtcbiAgICAgICAgICAgIHZhciBjb250YWluZXIgPSBjb250YWluZXJGdW5jdGlvbigpO1xuICAgICAgICAgICAgLy8gdGhlIGVsZW1lbnQgaXMgZXhjZWVkaW5nIGZyb20gdG9wIG9yIGJvdHRvbSBvZiBpdHMgY29udGFpbmVyXG4gICAgICAgICAgICBpZiAoYm94LnRvcCA8IGNvbnRhaW5lci50b3ApIHtcbiAgICAgICAgICAgICAgICBoaWRkZW5IZWlnaHQgPSBjb250YWluZXIudG9wIC0gYm94LnRvcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGJveC5ib3R0b20gPiBjb250YWluZXIuaGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgaGlkZGVuSGVpZ2h0ID0gYm94LmJvdHRvbSAtIGNvbnRhaW5lci5oZWlnaHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyB0aGUgZWxlbWVudCBpcyBleGNlZWRpbmcgZnJvbSBsZWZ0IG9yIHJpZ2h0IG9mIGl0cyBjb250YWluZXJcbiAgICAgICAgICAgIGlmIChib3gubGVmdCA8IGNvbnRhaW5lci5sZWZ0KSB7XG4gICAgICAgICAgICAgICAgaGlkZGVuV2lkdGggPSBjb250YWluZXIubGVmdCAtIGJveC5sZWZ0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYm94LnJpZ2h0ID4gY29udGFpbmVyLndpZHRoKSB7XG4gICAgICAgICAgICAgICAgaGlkZGVuV2lkdGggPSBib3gucmlnaHQgLSBjb250YWluZXIud2lkdGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBpZiBvbmUgb2YgdGhlIGhpZGRlbiBkaW1lbnNpb25zIGlzIDAgYnV0IHRoZSBvdGhlciBpcyA+IDBcbiAgICAgICAgICAgIC8vIHdlIHdhbnQgdG8gaGF2ZSBhIHBvc2l0aXZlIGFyZWEsIHNvIHNldHRpbmcgdGhlIG51bGwgb25lIHRvIDFcbiAgICAgICAgICAgIGlmIChoaWRkZW5IZWlnaHQgJiYgIWhpZGRlbldpZHRoKSB7XG4gICAgICAgICAgICAgICAgaGlkZGVuV2lkdGggPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaGlkZGVuV2lkdGggJiYgIWhpZGRlbkhlaWdodCkge1xuICAgICAgICAgICAgICAgIGhpZGRlbkhlaWdodCA9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgYXJlYSA9IHRhcmdldC5vZmZzZXRIZWlnaHQgKiB0YXJnZXQub2Zmc2V0V2lkdGg7XG4gICAgICAgICAgICB2YXIgaGlkZGVuQXJlYSA9IGhpZGRlbkhlaWdodCAqIGhpZGRlbldpZHRoO1xuICAgICAgICAgICAgLy8gaWYgdmlzaWJsZUFyZWEgaXMgMCBpdCBtZWFucyB0aGUgZWxlbWVudCBpcyBmdWxseSBvdXRzaWRlIGNvbnRhaW5lciBib3VuZHNcbiAgICAgICAgICAgIC8vIGFuZCB2aXNpYmxlUGVyY2VudCB3aWxsIHRoZW4gYmUgMFxuICAgICAgICAgICAgdmFyIHZpc2libGVBcmVhID0gYXJlYSAtIGhpZGRlbkFyZWE7XG4gICAgICAgICAgICB2YXIgdmlzaWJsZVBlcmNlbnQgPSB2aXNpYmxlQXJlYSAvIGFyZWE7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHBsYWNlbWVudDogcGxhY2VtZW50LFxuICAgICAgICAgICAgICAgIHdlaWdodDogdmlzaWJsZVBlcmNlbnRcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBzb3J0IHRoZSBwbGFjZW1lbnRzIGZyb20gYmVzdCB0byB3b3JzdFxuICAgICAgICB3ZWlnaHRlZFBsYWNlbWVudHMuc29ydChmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gYi53ZWlnaHQgLSBhLndlaWdodDsgfSk7XG4gICAgICAgIC8vIHBpY2sgdGhlIGJlc3QhXG4gICAgICAgIHJldHVybiB3ZWlnaHRlZFBsYWNlbWVudHNbMF0ucGxhY2VtZW50O1xuICAgIH07XG4gICAgUG9zaXRpb24ucHJvdG90eXBlLmZpbmRCZXN0UGxhY2VtZW50QXQgPSBmdW5jdGlvbiAob2Zmc2V0LCB0YXJnZXQsIHBsYWNlbWVudHMsIGNvbnRhaW5lckZ1bmN0aW9uKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmIChjb250YWluZXJGdW5jdGlvbiA9PT0gdm9pZCAwKSB7IGNvbnRhaW5lckZ1bmN0aW9uID0gdGhpcy5kZWZhdWx0Q29udGFpbmVyRnVuY3Rpb24uYmluZCh0aGlzKTsgfVxuICAgICAgICB2YXIgcG9zaXRpb25BdCA9IGZ1bmN0aW9uIChfLCB0YXJnZXQsIHBsYWNlbWVudCkge1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzLmZpbmRQb3NpdGlvbkF0KG9mZnNldCwgdGFyZ2V0LCBwbGFjZW1lbnQpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gdGhpcy5maW5kQmVzdFBsYWNlbWVudChudWxsLCB0YXJnZXQsIHBsYWNlbWVudHMsIGNvbnRhaW5lckZ1bmN0aW9uLCBwb3NpdGlvbkF0KTtcbiAgICB9O1xuICAgIFBvc2l0aW9uLnByb3RvdHlwZS5kZWZhdWx0Q29udGFpbmVyRnVuY3Rpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAvLyB3ZSBnbyB3aXRoIHdpbmRvdyBoZXJlLCBiZWNhdXNlIHRoYXQncyBnb2luZyB0byBiZSB0aGUgc2ltcGxlL2NvbW1vbiBjYXNlXG4gICAgICAgICAgICB0b3A6IDAsXG4gICAgICAgICAgICBsZWZ0OiAwLFxuICAgICAgICAgICAgaGVpZ2h0OiB3aW5kb3dSZWYuaW5uZXJIZWlnaHQsXG4gICAgICAgICAgICB3aWR0aDogd2luZG93UmVmLmlubmVyV2lkdGhcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIFBvc2l0aW9uLnByb3RvdHlwZS5jYWxjdWxhdGVQb3NpdGlvbiA9IGZ1bmN0aW9uIChyZWZlcmVuY2VPZmZzZXQsIHJlZmVyZW5jZVJlY3QsIHRhcmdldCwgcGxhY2VtZW50KSB7XG4gICAgICAgIGlmICh0aGlzLnBvc2l0aW9uc1twbGFjZW1lbnRdKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wb3NpdGlvbnNbcGxhY2VtZW50XShyZWZlcmVuY2VPZmZzZXQsIHRhcmdldCwgcmVmZXJlbmNlUmVjdCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc29sZS5lcnJvcihcIk5vIGZ1bmN0aW9uIGZvdW5kIGZvciBwbGFjZW1lbnQsIGRlZmF1bHRpbmcgdG8gMCwwXCIpO1xuICAgICAgICByZXR1cm4geyBsZWZ0OiAwLCB0b3A6IDAgfTtcbiAgICB9O1xuICAgIHJldHVybiBQb3NpdGlvbjtcbn0oKSk7XG5leHBvcnQgeyBQb3NpdGlvbiB9O1xuZXhwb3J0IHZhciBwb3NpdGlvbiA9IG5ldyBQb3NpdGlvbigpO1xuZXhwb3J0IGRlZmF1bHQgUG9zaXRpb247XG4vLyMgc291cmNlTWFwcGluZ1VSTD0uLi9zcmMvaW5kZXguanMubWFwIiwiZXhwb3J0IHZhciBDT01QTEVURV9OT1RJRklDQVRJT04gPSAoZnVuY3Rpb24gKCkgeyByZXR1cm4gY3JlYXRlTm90aWZpY2F0aW9uKCdDJywgdW5kZWZpbmVkLCB1bmRlZmluZWQpOyB9KSgpO1xuZXhwb3J0IGZ1bmN0aW9uIGVycm9yTm90aWZpY2F0aW9uKGVycm9yKSB7XG4gICAgcmV0dXJuIGNyZWF0ZU5vdGlmaWNhdGlvbignRScsIHVuZGVmaW5lZCwgZXJyb3IpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIG5leHROb3RpZmljYXRpb24odmFsdWUpIHtcbiAgICByZXR1cm4gY3JlYXRlTm90aWZpY2F0aW9uKCdOJywgdmFsdWUsIHVuZGVmaW5lZCk7XG59XG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlTm90aWZpY2F0aW9uKGtpbmQsIHZhbHVlLCBlcnJvcikge1xuICAgIHJldHVybiB7XG4gICAgICAgIGtpbmQ6IGtpbmQsXG4gICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgZXJyb3I6IGVycm9yLFxuICAgIH07XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Ob3RpZmljYXRpb25GYWN0b3JpZXMuanMubWFwIiwiaW1wb3J0IHsgU2FmZVN1YnNjcmliZXIsIFN1YnNjcmliZXIgfSBmcm9tICcuL1N1YnNjcmliZXInO1xuaW1wb3J0IHsgaXNTdWJzY3JpcHRpb24gfSBmcm9tICcuL1N1YnNjcmlwdGlvbic7XG5pbXBvcnQgeyBvYnNlcnZhYmxlIGFzIFN5bWJvbF9vYnNlcnZhYmxlIH0gZnJvbSAnLi9zeW1ib2wvb2JzZXJ2YWJsZSc7XG5pbXBvcnQgeyBwaXBlRnJvbUFycmF5IH0gZnJvbSAnLi91dGlsL3BpcGUnO1xuaW1wb3J0IHsgY29uZmlnIH0gZnJvbSAnLi9jb25maWcnO1xuaW1wb3J0IHsgaXNGdW5jdGlvbiB9IGZyb20gJy4vdXRpbC9pc0Z1bmN0aW9uJztcbmltcG9ydCB7IGVycm9yQ29udGV4dCB9IGZyb20gJy4vdXRpbC9lcnJvckNvbnRleHQnO1xudmFyIE9ic2VydmFibGUgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE9ic2VydmFibGUoc3Vic2NyaWJlKSB7XG4gICAgICAgIGlmIChzdWJzY3JpYmUpIHtcbiAgICAgICAgICAgIHRoaXMuX3N1YnNjcmliZSA9IHN1YnNjcmliZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBPYnNlcnZhYmxlLnByb3RvdHlwZS5saWZ0ID0gZnVuY3Rpb24gKG9wZXJhdG9yKSB7XG4gICAgICAgIHZhciBvYnNlcnZhYmxlID0gbmV3IE9ic2VydmFibGUoKTtcbiAgICAgICAgb2JzZXJ2YWJsZS5zb3VyY2UgPSB0aGlzO1xuICAgICAgICBvYnNlcnZhYmxlLm9wZXJhdG9yID0gb3BlcmF0b3I7XG4gICAgICAgIHJldHVybiBvYnNlcnZhYmxlO1xuICAgIH07XG4gICAgT2JzZXJ2YWJsZS5wcm90b3R5cGUuc3Vic2NyaWJlID0gZnVuY3Rpb24gKG9ic2VydmVyT3JOZXh0LCBlcnJvciwgY29tcGxldGUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIHN1YnNjcmliZXIgPSBpc1N1YnNjcmliZXIob2JzZXJ2ZXJPck5leHQpID8gb2JzZXJ2ZXJPck5leHQgOiBuZXcgU2FmZVN1YnNjcmliZXIob2JzZXJ2ZXJPck5leHQsIGVycm9yLCBjb21wbGV0ZSk7XG4gICAgICAgIGVycm9yQ29udGV4dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgX2EgPSBfdGhpcywgb3BlcmF0b3IgPSBfYS5vcGVyYXRvciwgc291cmNlID0gX2Euc291cmNlO1xuICAgICAgICAgICAgc3Vic2NyaWJlci5hZGQob3BlcmF0b3JcbiAgICAgICAgICAgICAgICA/XG4gICAgICAgICAgICAgICAgICAgIG9wZXJhdG9yLmNhbGwoc3Vic2NyaWJlciwgc291cmNlKVxuICAgICAgICAgICAgICAgIDogc291cmNlXG4gICAgICAgICAgICAgICAgICAgID9cbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9zdWJzY3JpYmUoc3Vic2NyaWJlcilcbiAgICAgICAgICAgICAgICAgICAgOlxuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX3RyeVN1YnNjcmliZShzdWJzY3JpYmVyKSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gc3Vic2NyaWJlcjtcbiAgICB9O1xuICAgIE9ic2VydmFibGUucHJvdG90eXBlLl90cnlTdWJzY3JpYmUgPSBmdW5jdGlvbiAoc2luaykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3N1YnNjcmliZShzaW5rKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBzaW5rLmVycm9yKGVycik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIE9ic2VydmFibGUucHJvdG90eXBlLmZvckVhY2ggPSBmdW5jdGlvbiAobmV4dCwgcHJvbWlzZUN0b3IpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcHJvbWlzZUN0b3IgPSBnZXRQcm9taXNlQ3Rvcihwcm9taXNlQ3Rvcik7XG4gICAgICAgIHJldHVybiBuZXcgcHJvbWlzZUN0b3IoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgdmFyIHN1YnNjcmliZXIgPSBuZXcgU2FmZVN1YnNjcmliZXIoe1xuICAgICAgICAgICAgICAgIG5leHQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dCh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdWJzY3JpYmVyLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGVycm9yOiByZWplY3QsXG4gICAgICAgICAgICAgICAgY29tcGxldGU6IHJlc29sdmUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIF90aGlzLnN1YnNjcmliZShzdWJzY3JpYmVyKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBPYnNlcnZhYmxlLnByb3RvdHlwZS5fc3Vic2NyaWJlID0gZnVuY3Rpb24gKHN1YnNjcmliZXIpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICByZXR1cm4gKF9hID0gdGhpcy5zb3VyY2UpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zdWJzY3JpYmUoc3Vic2NyaWJlcik7XG4gICAgfTtcbiAgICBPYnNlcnZhYmxlLnByb3RvdHlwZVtTeW1ib2xfb2JzZXJ2YWJsZV0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgT2JzZXJ2YWJsZS5wcm90b3R5cGUucGlwZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG9wZXJhdGlvbnMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIG9wZXJhdGlvbnNbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGlwZUZyb21BcnJheShvcGVyYXRpb25zKSh0aGlzKTtcbiAgICB9O1xuICAgIE9ic2VydmFibGUucHJvdG90eXBlLnRvUHJvbWlzZSA9IGZ1bmN0aW9uIChwcm9taXNlQ3Rvcikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBwcm9taXNlQ3RvciA9IGdldFByb21pc2VDdG9yKHByb21pc2VDdG9yKTtcbiAgICAgICAgcmV0dXJuIG5ldyBwcm9taXNlQ3RvcihmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICB2YXIgdmFsdWU7XG4gICAgICAgICAgICBfdGhpcy5zdWJzY3JpYmUoZnVuY3Rpb24gKHgpIHsgcmV0dXJuICh2YWx1ZSA9IHgpOyB9LCBmdW5jdGlvbiAoZXJyKSB7IHJldHVybiByZWplY3QoZXJyKTsgfSwgZnVuY3Rpb24gKCkgeyByZXR1cm4gcmVzb2x2ZSh2YWx1ZSk7IH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIE9ic2VydmFibGUuY3JlYXRlID0gZnVuY3Rpb24gKHN1YnNjcmliZSkge1xuICAgICAgICByZXR1cm4gbmV3IE9ic2VydmFibGUoc3Vic2NyaWJlKTtcbiAgICB9O1xuICAgIHJldHVybiBPYnNlcnZhYmxlO1xufSgpKTtcbmV4cG9ydCB7IE9ic2VydmFibGUgfTtcbmZ1bmN0aW9uIGdldFByb21pc2VDdG9yKHByb21pc2VDdG9yKSB7XG4gICAgdmFyIF9hO1xuICAgIHJldHVybiAoX2EgPSBwcm9taXNlQ3RvciAhPT0gbnVsbCAmJiBwcm9taXNlQ3RvciAhPT0gdm9pZCAwID8gcHJvbWlzZUN0b3IgOiBjb25maWcuUHJvbWlzZSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogUHJvbWlzZTtcbn1cbmZ1bmN0aW9uIGlzT2JzZXJ2ZXIodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgJiYgaXNGdW5jdGlvbih2YWx1ZS5uZXh0KSAmJiBpc0Z1bmN0aW9uKHZhbHVlLmVycm9yKSAmJiBpc0Z1bmN0aW9uKHZhbHVlLmNvbXBsZXRlKTtcbn1cbmZ1bmN0aW9uIGlzU3Vic2NyaWJlcih2YWx1ZSkge1xuICAgIHJldHVybiAodmFsdWUgJiYgdmFsdWUgaW5zdGFuY2VvZiBTdWJzY3JpYmVyKSB8fCAoaXNPYnNlcnZlcih2YWx1ZSkgJiYgaXNTdWJzY3JpcHRpb24odmFsdWUpKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPU9ic2VydmFibGUuanMubWFwIiwiaW1wb3J0IHsgZGF0ZVRpbWVzdGFtcFByb3ZpZGVyIH0gZnJvbSAnLi9zY2hlZHVsZXIvZGF0ZVRpbWVzdGFtcFByb3ZpZGVyJztcbnZhciBTY2hlZHVsZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFNjaGVkdWxlcihzY2hlZHVsZXJBY3Rpb25DdG9yLCBub3cpIHtcbiAgICAgICAgaWYgKG5vdyA9PT0gdm9pZCAwKSB7IG5vdyA9IFNjaGVkdWxlci5ub3c7IH1cbiAgICAgICAgdGhpcy5zY2hlZHVsZXJBY3Rpb25DdG9yID0gc2NoZWR1bGVyQWN0aW9uQ3RvcjtcbiAgICAgICAgdGhpcy5ub3cgPSBub3c7XG4gICAgfVxuICAgIFNjaGVkdWxlci5wcm90b3R5cGUuc2NoZWR1bGUgPSBmdW5jdGlvbiAod29yaywgZGVsYXksIHN0YXRlKSB7XG4gICAgICAgIGlmIChkZWxheSA9PT0gdm9pZCAwKSB7IGRlbGF5ID0gMDsgfVxuICAgICAgICByZXR1cm4gbmV3IHRoaXMuc2NoZWR1bGVyQWN0aW9uQ3Rvcih0aGlzLCB3b3JrKS5zY2hlZHVsZShzdGF0ZSwgZGVsYXkpO1xuICAgIH07XG4gICAgU2NoZWR1bGVyLm5vdyA9IGRhdGVUaW1lc3RhbXBQcm92aWRlci5ub3c7XG4gICAgcmV0dXJuIFNjaGVkdWxlcjtcbn0oKSk7XG5leHBvcnQgeyBTY2hlZHVsZXIgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVNjaGVkdWxlci5qcy5tYXAiLCJpbXBvcnQgeyBfX2V4dGVuZHMgfSBmcm9tIFwidHNsaWJcIjtcbmltcG9ydCB7IGlzRnVuY3Rpb24gfSBmcm9tICcuL3V0aWwvaXNGdW5jdGlvbic7XG5pbXBvcnQgeyBpc1N1YnNjcmlwdGlvbiwgU3Vic2NyaXB0aW9uIH0gZnJvbSAnLi9TdWJzY3JpcHRpb24nO1xuaW1wb3J0IHsgY29uZmlnIH0gZnJvbSAnLi9jb25maWcnO1xuaW1wb3J0IHsgcmVwb3J0VW5oYW5kbGVkRXJyb3IgfSBmcm9tICcuL3V0aWwvcmVwb3J0VW5oYW5kbGVkRXJyb3InO1xuaW1wb3J0IHsgbm9vcCB9IGZyb20gJy4vdXRpbC9ub29wJztcbmltcG9ydCB7IG5leHROb3RpZmljYXRpb24sIGVycm9yTm90aWZpY2F0aW9uLCBDT01QTEVURV9OT1RJRklDQVRJT04gfSBmcm9tICcuL05vdGlmaWNhdGlvbkZhY3Rvcmllcyc7XG5pbXBvcnQgeyB0aW1lb3V0UHJvdmlkZXIgfSBmcm9tICcuL3NjaGVkdWxlci90aW1lb3V0UHJvdmlkZXInO1xuaW1wb3J0IHsgY2FwdHVyZUVycm9yIH0gZnJvbSAnLi91dGlsL2Vycm9yQ29udGV4dCc7XG52YXIgU3Vic2NyaWJlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFN1YnNjcmliZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gU3Vic2NyaWJlcihkZXN0aW5hdGlvbikge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5pc1N0b3BwZWQgPSBmYWxzZTtcbiAgICAgICAgaWYgKGRlc3RpbmF0aW9uKSB7XG4gICAgICAgICAgICBfdGhpcy5kZXN0aW5hdGlvbiA9IGRlc3RpbmF0aW9uO1xuICAgICAgICAgICAgaWYgKGlzU3Vic2NyaXB0aW9uKGRlc3RpbmF0aW9uKSkge1xuICAgICAgICAgICAgICAgIGRlc3RpbmF0aW9uLmFkZChfdGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBfdGhpcy5kZXN0aW5hdGlvbiA9IEVNUFRZX09CU0VSVkVSO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgU3Vic2NyaWJlci5jcmVhdGUgPSBmdW5jdGlvbiAobmV4dCwgZXJyb3IsIGNvbXBsZXRlKSB7XG4gICAgICAgIHJldHVybiBuZXcgU2FmZVN1YnNjcmliZXIobmV4dCwgZXJyb3IsIGNvbXBsZXRlKTtcbiAgICB9O1xuICAgIFN1YnNjcmliZXIucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNTdG9wcGVkKSB7XG4gICAgICAgICAgICBoYW5kbGVTdG9wcGVkTm90aWZpY2F0aW9uKG5leHROb3RpZmljYXRpb24odmFsdWUpLCB0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX25leHQodmFsdWUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBTdWJzY3JpYmVyLnByb3RvdHlwZS5lcnJvciA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNTdG9wcGVkKSB7XG4gICAgICAgICAgICBoYW5kbGVTdG9wcGVkTm90aWZpY2F0aW9uKGVycm9yTm90aWZpY2F0aW9uKGVyciksIHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5pc1N0b3BwZWQgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5fZXJyb3IoZXJyKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgU3Vic2NyaWJlci5wcm90b3R5cGUuY29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmlzU3RvcHBlZCkge1xuICAgICAgICAgICAgaGFuZGxlU3RvcHBlZE5vdGlmaWNhdGlvbihDT01QTEVURV9OT1RJRklDQVRJT04sIHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5pc1N0b3BwZWQgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5fY29tcGxldGUoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgU3Vic2NyaWJlci5wcm90b3R5cGUudW5zdWJzY3JpYmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghdGhpcy5jbG9zZWQpIHtcbiAgICAgICAgICAgIHRoaXMuaXNTdG9wcGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIF9zdXBlci5wcm90b3R5cGUudW5zdWJzY3JpYmUuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIHRoaXMuZGVzdGluYXRpb24gPSBudWxsO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBTdWJzY3JpYmVyLnByb3RvdHlwZS5fbmV4dCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLm5leHQodmFsdWUpO1xuICAgIH07XG4gICAgU3Vic2NyaWJlci5wcm90b3R5cGUuX2Vycm9yID0gZnVuY3Rpb24gKGVycikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5lcnJvcihlcnIpO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgdGhpcy51bnN1YnNjcmliZSgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBTdWJzY3JpYmVyLnByb3RvdHlwZS5fY29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLmNvbXBsZXRlKCk7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICB0aGlzLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBTdWJzY3JpYmVyO1xufShTdWJzY3JpcHRpb24pKTtcbmV4cG9ydCB7IFN1YnNjcmliZXIgfTtcbnZhciBfYmluZCA9IEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kO1xuZnVuY3Rpb24gYmluZChmbiwgdGhpc0FyZykge1xuICAgIHJldHVybiBfYmluZC5jYWxsKGZuLCB0aGlzQXJnKTtcbn1cbnZhciBDb25zdW1lck9ic2VydmVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBDb25zdW1lck9ic2VydmVyKHBhcnRpYWxPYnNlcnZlcikge1xuICAgICAgICB0aGlzLnBhcnRpYWxPYnNlcnZlciA9IHBhcnRpYWxPYnNlcnZlcjtcbiAgICB9XG4gICAgQ29uc3VtZXJPYnNlcnZlci5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB2YXIgcGFydGlhbE9ic2VydmVyID0gdGhpcy5wYXJ0aWFsT2JzZXJ2ZXI7XG4gICAgICAgIGlmIChwYXJ0aWFsT2JzZXJ2ZXIubmV4dCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBwYXJ0aWFsT2JzZXJ2ZXIubmV4dCh2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBoYW5kbGVVbmhhbmRsZWRFcnJvcihlcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIENvbnN1bWVyT2JzZXJ2ZXIucHJvdG90eXBlLmVycm9yID0gZnVuY3Rpb24gKGVycikge1xuICAgICAgICB2YXIgcGFydGlhbE9ic2VydmVyID0gdGhpcy5wYXJ0aWFsT2JzZXJ2ZXI7XG4gICAgICAgIGlmIChwYXJ0aWFsT2JzZXJ2ZXIuZXJyb3IpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcGFydGlhbE9ic2VydmVyLmVycm9yKGVycik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBoYW5kbGVVbmhhbmRsZWRFcnJvcihlcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBoYW5kbGVVbmhhbmRsZWRFcnJvcihlcnIpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBDb25zdW1lck9ic2VydmVyLnByb3RvdHlwZS5jb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHBhcnRpYWxPYnNlcnZlciA9IHRoaXMucGFydGlhbE9ic2VydmVyO1xuICAgICAgICBpZiAocGFydGlhbE9ic2VydmVyLmNvbXBsZXRlKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHBhcnRpYWxPYnNlcnZlci5jb21wbGV0ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgaGFuZGxlVW5oYW5kbGVkRXJyb3IoZXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gQ29uc3VtZXJPYnNlcnZlcjtcbn0oKSk7XG52YXIgU2FmZVN1YnNjcmliZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhTYWZlU3Vic2NyaWJlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBTYWZlU3Vic2NyaWJlcihvYnNlcnZlck9yTmV4dCwgZXJyb3IsIGNvbXBsZXRlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgIHZhciBwYXJ0aWFsT2JzZXJ2ZXI7XG4gICAgICAgIGlmIChpc0Z1bmN0aW9uKG9ic2VydmVyT3JOZXh0KSB8fCAhb2JzZXJ2ZXJPck5leHQpIHtcbiAgICAgICAgICAgIHBhcnRpYWxPYnNlcnZlciA9IHtcbiAgICAgICAgICAgICAgICBuZXh0OiAob2JzZXJ2ZXJPck5leHQgIT09IG51bGwgJiYgb2JzZXJ2ZXJPck5leHQgIT09IHZvaWQgMCA/IG9ic2VydmVyT3JOZXh0IDogdW5kZWZpbmVkKSxcbiAgICAgICAgICAgICAgICBlcnJvcjogZXJyb3IgIT09IG51bGwgJiYgZXJyb3IgIT09IHZvaWQgMCA/IGVycm9yIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIGNvbXBsZXRlOiBjb21wbGV0ZSAhPT0gbnVsbCAmJiBjb21wbGV0ZSAhPT0gdm9pZCAwID8gY29tcGxldGUgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIGNvbnRleHRfMTtcbiAgICAgICAgICAgIGlmIChfdGhpcyAmJiBjb25maWcudXNlRGVwcmVjYXRlZE5leHRDb250ZXh0KSB7XG4gICAgICAgICAgICAgICAgY29udGV4dF8xID0gT2JqZWN0LmNyZWF0ZShvYnNlcnZlck9yTmV4dCk7XG4gICAgICAgICAgICAgICAgY29udGV4dF8xLnVuc3Vic2NyaWJlID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMudW5zdWJzY3JpYmUoKTsgfTtcbiAgICAgICAgICAgICAgICBwYXJ0aWFsT2JzZXJ2ZXIgPSB7XG4gICAgICAgICAgICAgICAgICAgIG5leHQ6IG9ic2VydmVyT3JOZXh0Lm5leHQgJiYgYmluZChvYnNlcnZlck9yTmV4dC5uZXh0LCBjb250ZXh0XzEpLFxuICAgICAgICAgICAgICAgICAgICBlcnJvcjogb2JzZXJ2ZXJPck5leHQuZXJyb3IgJiYgYmluZChvYnNlcnZlck9yTmV4dC5lcnJvciwgY29udGV4dF8xKSxcbiAgICAgICAgICAgICAgICAgICAgY29tcGxldGU6IG9ic2VydmVyT3JOZXh0LmNvbXBsZXRlICYmIGJpbmQob2JzZXJ2ZXJPck5leHQuY29tcGxldGUsIGNvbnRleHRfMSksXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHBhcnRpYWxPYnNlcnZlciA9IG9ic2VydmVyT3JOZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIF90aGlzLmRlc3RpbmF0aW9uID0gbmV3IENvbnN1bWVyT2JzZXJ2ZXIocGFydGlhbE9ic2VydmVyKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gU2FmZVN1YnNjcmliZXI7XG59KFN1YnNjcmliZXIpKTtcbmV4cG9ydCB7IFNhZmVTdWJzY3JpYmVyIH07XG5mdW5jdGlvbiBoYW5kbGVVbmhhbmRsZWRFcnJvcihlcnJvcikge1xuICAgIGlmIChjb25maWcudXNlRGVwcmVjYXRlZFN5bmNocm9ub3VzRXJyb3JIYW5kbGluZykge1xuICAgICAgICBjYXB0dXJlRXJyb3IoZXJyb3IpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmVwb3J0VW5oYW5kbGVkRXJyb3IoZXJyb3IpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGRlZmF1bHRFcnJvckhhbmRsZXIoZXJyKSB7XG4gICAgdGhyb3cgZXJyO1xufVxuZnVuY3Rpb24gaGFuZGxlU3RvcHBlZE5vdGlmaWNhdGlvbihub3RpZmljYXRpb24sIHN1YnNjcmliZXIpIHtcbiAgICB2YXIgb25TdG9wcGVkTm90aWZpY2F0aW9uID0gY29uZmlnLm9uU3RvcHBlZE5vdGlmaWNhdGlvbjtcbiAgICBvblN0b3BwZWROb3RpZmljYXRpb24gJiYgdGltZW91dFByb3ZpZGVyLnNldFRpbWVvdXQoZnVuY3Rpb24gKCkgeyByZXR1cm4gb25TdG9wcGVkTm90aWZpY2F0aW9uKG5vdGlmaWNhdGlvbiwgc3Vic2NyaWJlcik7IH0pO1xufVxuZXhwb3J0IHZhciBFTVBUWV9PQlNFUlZFUiA9IHtcbiAgICBjbG9zZWQ6IHRydWUsXG4gICAgbmV4dDogbm9vcCxcbiAgICBlcnJvcjogZGVmYXVsdEVycm9ySGFuZGxlcixcbiAgICBjb21wbGV0ZTogbm9vcCxcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1TdWJzY3JpYmVyLmpzLm1hcCIsImltcG9ydCB7IF9fcmVhZCwgX19zcHJlYWRBcnJheSwgX192YWx1ZXMgfSBmcm9tIFwidHNsaWJcIjtcbmltcG9ydCB7IGlzRnVuY3Rpb24gfSBmcm9tICcuL3V0aWwvaXNGdW5jdGlvbic7XG5pbXBvcnQgeyBVbnN1YnNjcmlwdGlvbkVycm9yIH0gZnJvbSAnLi91dGlsL1Vuc3Vic2NyaXB0aW9uRXJyb3InO1xuaW1wb3J0IHsgYXJyUmVtb3ZlIH0gZnJvbSAnLi91dGlsL2FyclJlbW92ZSc7XG52YXIgU3Vic2NyaXB0aW9uID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTdWJzY3JpcHRpb24oaW5pdGlhbFRlYXJkb3duKSB7XG4gICAgICAgIHRoaXMuaW5pdGlhbFRlYXJkb3duID0gaW5pdGlhbFRlYXJkb3duO1xuICAgICAgICB0aGlzLmNsb3NlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9wYXJlbnRhZ2UgPSBudWxsO1xuICAgICAgICB0aGlzLl9maW5hbGl6ZXJzID0gbnVsbDtcbiAgICB9XG4gICAgU3Vic2NyaXB0aW9uLnByb3RvdHlwZS51bnN1YnNjcmliZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGVfMSwgX2EsIGVfMiwgX2I7XG4gICAgICAgIHZhciBlcnJvcnM7XG4gICAgICAgIGlmICghdGhpcy5jbG9zZWQpIHtcbiAgICAgICAgICAgIHRoaXMuY2xvc2VkID0gdHJ1ZTtcbiAgICAgICAgICAgIHZhciBfcGFyZW50YWdlID0gdGhpcy5fcGFyZW50YWdlO1xuICAgICAgICAgICAgaWYgKF9wYXJlbnRhZ2UpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9wYXJlbnRhZ2UgPSBudWxsO1xuICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KF9wYXJlbnRhZ2UpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBfcGFyZW50YWdlXzEgPSBfX3ZhbHVlcyhfcGFyZW50YWdlKSwgX3BhcmVudGFnZV8xXzEgPSBfcGFyZW50YWdlXzEubmV4dCgpOyAhX3BhcmVudGFnZV8xXzEuZG9uZTsgX3BhcmVudGFnZV8xXzEgPSBfcGFyZW50YWdlXzEubmV4dCgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBhcmVudF8xID0gX3BhcmVudGFnZV8xXzEudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50XzEucmVtb3ZlKHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIChlXzFfMSkgeyBlXzEgPSB7IGVycm9yOiBlXzFfMSB9OyB9XG4gICAgICAgICAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoX3BhcmVudGFnZV8xXzEgJiYgIV9wYXJlbnRhZ2VfMV8xLmRvbmUgJiYgKF9hID0gX3BhcmVudGFnZV8xLnJldHVybikpIF9hLmNhbGwoX3BhcmVudGFnZV8xKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbmFsbHkgeyBpZiAoZV8xKSB0aHJvdyBlXzEuZXJyb3I7IH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgX3BhcmVudGFnZS5yZW1vdmUodGhpcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGluaXRpYWxGaW5hbGl6ZXIgPSB0aGlzLmluaXRpYWxUZWFyZG93bjtcbiAgICAgICAgICAgIGlmIChpc0Z1bmN0aW9uKGluaXRpYWxGaW5hbGl6ZXIpKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgaW5pdGlhbEZpbmFsaXplcigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICBlcnJvcnMgPSBlIGluc3RhbmNlb2YgVW5zdWJzY3JpcHRpb25FcnJvciA/IGUuZXJyb3JzIDogW2VdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBfZmluYWxpemVycyA9IHRoaXMuX2ZpbmFsaXplcnM7XG4gICAgICAgICAgICBpZiAoX2ZpbmFsaXplcnMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9maW5hbGl6ZXJzID0gbnVsbDtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBfZmluYWxpemVyc18xID0gX192YWx1ZXMoX2ZpbmFsaXplcnMpLCBfZmluYWxpemVyc18xXzEgPSBfZmluYWxpemVyc18xLm5leHQoKTsgIV9maW5hbGl6ZXJzXzFfMS5kb25lOyBfZmluYWxpemVyc18xXzEgPSBfZmluYWxpemVyc18xLm5leHQoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGZpbmFsaXplciA9IF9maW5hbGl6ZXJzXzFfMS52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhlY0ZpbmFsaXplcihmaW5hbGl6ZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9ycyA9IGVycm9ycyAhPT0gbnVsbCAmJiBlcnJvcnMgIT09IHZvaWQgMCA/IGVycm9ycyA6IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcnIgaW5zdGFuY2VvZiBVbnN1YnNjcmlwdGlvbkVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9ycyA9IF9fc3ByZWFkQXJyYXkoX19zcHJlYWRBcnJheShbXSwgX19yZWFkKGVycm9ycykpLCBfX3JlYWQoZXJyLmVycm9ycykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JzLnB1c2goZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVfMl8xKSB7IGVfMiA9IHsgZXJyb3I6IGVfMl8xIH07IH1cbiAgICAgICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfZmluYWxpemVyc18xXzEgJiYgIV9maW5hbGl6ZXJzXzFfMS5kb25lICYmIChfYiA9IF9maW5hbGl6ZXJzXzEucmV0dXJuKSkgX2IuY2FsbChfZmluYWxpemVyc18xKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBmaW5hbGx5IHsgaWYgKGVfMikgdGhyb3cgZV8yLmVycm9yOyB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGVycm9ycykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBVbnN1YnNjcmlwdGlvbkVycm9yKGVycm9ycyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFN1YnNjcmlwdGlvbi5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKHRlYXJkb3duKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgaWYgKHRlYXJkb3duICYmIHRlYXJkb3duICE9PSB0aGlzKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5jbG9zZWQpIHtcbiAgICAgICAgICAgICAgICBleGVjRmluYWxpemVyKHRlYXJkb3duKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICh0ZWFyZG93biBpbnN0YW5jZW9mIFN1YnNjcmlwdGlvbikge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGVhcmRvd24uY2xvc2VkIHx8IHRlYXJkb3duLl9oYXNQYXJlbnQodGhpcykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0ZWFyZG93bi5fYWRkUGFyZW50KHRoaXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAodGhpcy5fZmluYWxpemVycyA9IChfYSA9IHRoaXMuX2ZpbmFsaXplcnMpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IFtdKS5wdXNoKHRlYXJkb3duKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgU3Vic2NyaXB0aW9uLnByb3RvdHlwZS5faGFzUGFyZW50ID0gZnVuY3Rpb24gKHBhcmVudCkge1xuICAgICAgICB2YXIgX3BhcmVudGFnZSA9IHRoaXMuX3BhcmVudGFnZTtcbiAgICAgICAgcmV0dXJuIF9wYXJlbnRhZ2UgPT09IHBhcmVudCB8fCAoQXJyYXkuaXNBcnJheShfcGFyZW50YWdlKSAmJiBfcGFyZW50YWdlLmluY2x1ZGVzKHBhcmVudCkpO1xuICAgIH07XG4gICAgU3Vic2NyaXB0aW9uLnByb3RvdHlwZS5fYWRkUGFyZW50ID0gZnVuY3Rpb24gKHBhcmVudCkge1xuICAgICAgICB2YXIgX3BhcmVudGFnZSA9IHRoaXMuX3BhcmVudGFnZTtcbiAgICAgICAgdGhpcy5fcGFyZW50YWdlID0gQXJyYXkuaXNBcnJheShfcGFyZW50YWdlKSA/IChfcGFyZW50YWdlLnB1c2gocGFyZW50KSwgX3BhcmVudGFnZSkgOiBfcGFyZW50YWdlID8gW19wYXJlbnRhZ2UsIHBhcmVudF0gOiBwYXJlbnQ7XG4gICAgfTtcbiAgICBTdWJzY3JpcHRpb24ucHJvdG90eXBlLl9yZW1vdmVQYXJlbnQgPSBmdW5jdGlvbiAocGFyZW50KSB7XG4gICAgICAgIHZhciBfcGFyZW50YWdlID0gdGhpcy5fcGFyZW50YWdlO1xuICAgICAgICBpZiAoX3BhcmVudGFnZSA9PT0gcGFyZW50KSB7XG4gICAgICAgICAgICB0aGlzLl9wYXJlbnRhZ2UgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoX3BhcmVudGFnZSkpIHtcbiAgICAgICAgICAgIGFyclJlbW92ZShfcGFyZW50YWdlLCBwYXJlbnQpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBTdWJzY3JpcHRpb24ucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uICh0ZWFyZG93bikge1xuICAgICAgICB2YXIgX2ZpbmFsaXplcnMgPSB0aGlzLl9maW5hbGl6ZXJzO1xuICAgICAgICBfZmluYWxpemVycyAmJiBhcnJSZW1vdmUoX2ZpbmFsaXplcnMsIHRlYXJkb3duKTtcbiAgICAgICAgaWYgKHRlYXJkb3duIGluc3RhbmNlb2YgU3Vic2NyaXB0aW9uKSB7XG4gICAgICAgICAgICB0ZWFyZG93bi5fcmVtb3ZlUGFyZW50KHRoaXMpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBTdWJzY3JpcHRpb24uRU1QVFkgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZW1wdHkgPSBuZXcgU3Vic2NyaXB0aW9uKCk7XG4gICAgICAgIGVtcHR5LmNsb3NlZCA9IHRydWU7XG4gICAgICAgIHJldHVybiBlbXB0eTtcbiAgICB9KSgpO1xuICAgIHJldHVybiBTdWJzY3JpcHRpb247XG59KCkpO1xuZXhwb3J0IHsgU3Vic2NyaXB0aW9uIH07XG5leHBvcnQgdmFyIEVNUFRZX1NVQlNDUklQVElPTiA9IFN1YnNjcmlwdGlvbi5FTVBUWTtcbmV4cG9ydCBmdW5jdGlvbiBpc1N1YnNjcmlwdGlvbih2YWx1ZSkge1xuICAgIHJldHVybiAodmFsdWUgaW5zdGFuY2VvZiBTdWJzY3JpcHRpb24gfHxcbiAgICAgICAgKHZhbHVlICYmICdjbG9zZWQnIGluIHZhbHVlICYmIGlzRnVuY3Rpb24odmFsdWUucmVtb3ZlKSAmJiBpc0Z1bmN0aW9uKHZhbHVlLmFkZCkgJiYgaXNGdW5jdGlvbih2YWx1ZS51bnN1YnNjcmliZSkpKTtcbn1cbmZ1bmN0aW9uIGV4ZWNGaW5hbGl6ZXIoZmluYWxpemVyKSB7XG4gICAgaWYgKGlzRnVuY3Rpb24oZmluYWxpemVyKSkge1xuICAgICAgICBmaW5hbGl6ZXIoKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGZpbmFsaXplci51bnN1YnNjcmliZSgpO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVN1YnNjcmlwdGlvbi5qcy5tYXAiLCJleHBvcnQgdmFyIGNvbmZpZyA9IHtcbiAgICBvblVuaGFuZGxlZEVycm9yOiBudWxsLFxuICAgIG9uU3RvcHBlZE5vdGlmaWNhdGlvbjogbnVsbCxcbiAgICBQcm9taXNlOiB1bmRlZmluZWQsXG4gICAgdXNlRGVwcmVjYXRlZFN5bmNocm9ub3VzRXJyb3JIYW5kbGluZzogZmFsc2UsXG4gICAgdXNlRGVwcmVjYXRlZE5leHRDb250ZXh0OiBmYWxzZSxcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb25maWcuanMubWFwIiwiaW1wb3J0IHsgT2JzZXJ2YWJsZSB9IGZyb20gJy4uL09ic2VydmFibGUnO1xuZXhwb3J0IHZhciBFTVBUWSA9IG5ldyBPYnNlcnZhYmxlKGZ1bmN0aW9uIChzdWJzY3JpYmVyKSB7IHJldHVybiBzdWJzY3JpYmVyLmNvbXBsZXRlKCk7IH0pO1xuZXhwb3J0IGZ1bmN0aW9uIGVtcHR5KHNjaGVkdWxlcikge1xuICAgIHJldHVybiBzY2hlZHVsZXIgPyBlbXB0eVNjaGVkdWxlZChzY2hlZHVsZXIpIDogRU1QVFk7XG59XG5mdW5jdGlvbiBlbXB0eVNjaGVkdWxlZChzY2hlZHVsZXIpIHtcbiAgICByZXR1cm4gbmV3IE9ic2VydmFibGUoZnVuY3Rpb24gKHN1YnNjcmliZXIpIHsgcmV0dXJuIHNjaGVkdWxlci5zY2hlZHVsZShmdW5jdGlvbiAoKSB7IHJldHVybiBzdWJzY3JpYmVyLmNvbXBsZXRlKCk7IH0pOyB9KTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWVtcHR5LmpzLm1hcCIsImltcG9ydCB7IF9fZXh0ZW5kcyB9IGZyb20gXCJ0c2xpYlwiO1xuaW1wb3J0IHsgU3Vic2NyaWJlciB9IGZyb20gJy4uL1N1YnNjcmliZXInO1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZU9wZXJhdG9yU3Vic2NyaWJlcihkZXN0aW5hdGlvbiwgb25OZXh0LCBvbkNvbXBsZXRlLCBvbkVycm9yLCBvbkZpbmFsaXplKSB7XG4gICAgcmV0dXJuIG5ldyBPcGVyYXRvclN1YnNjcmliZXIoZGVzdGluYXRpb24sIG9uTmV4dCwgb25Db21wbGV0ZSwgb25FcnJvciwgb25GaW5hbGl6ZSk7XG59XG52YXIgT3BlcmF0b3JTdWJzY3JpYmVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoT3BlcmF0b3JTdWJzY3JpYmVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE9wZXJhdG9yU3Vic2NyaWJlcihkZXN0aW5hdGlvbiwgb25OZXh0LCBvbkNvbXBsZXRlLCBvbkVycm9yLCBvbkZpbmFsaXplLCBzaG91bGRVbnN1YnNjcmliZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBkZXN0aW5hdGlvbikgfHwgdGhpcztcbiAgICAgICAgX3RoaXMub25GaW5hbGl6ZSA9IG9uRmluYWxpemU7XG4gICAgICAgIF90aGlzLnNob3VsZFVuc3Vic2NyaWJlID0gc2hvdWxkVW5zdWJzY3JpYmU7XG4gICAgICAgIF90aGlzLl9uZXh0ID0gb25OZXh0XG4gICAgICAgICAgICA/IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIG9uTmV4dCh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVzdGluYXRpb24uZXJyb3IoZXJyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICA6IF9zdXBlci5wcm90b3R5cGUuX25leHQ7XG4gICAgICAgIF90aGlzLl9lcnJvciA9IG9uRXJyb3JcbiAgICAgICAgICAgID8gZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIG9uRXJyb3IoZXJyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICBkZXN0aW5hdGlvbi5lcnJvcihlcnIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy51bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIDogX3N1cGVyLnByb3RvdHlwZS5fZXJyb3I7XG4gICAgICAgIF90aGlzLl9jb21wbGV0ZSA9IG9uQ29tcGxldGVcbiAgICAgICAgICAgID8gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIG9uQ29tcGxldGUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICBkZXN0aW5hdGlvbi5lcnJvcihlcnIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy51bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIDogX3N1cGVyLnByb3RvdHlwZS5fY29tcGxldGU7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgT3BlcmF0b3JTdWJzY3JpYmVyLnByb3RvdHlwZS51bnN1YnNjcmliZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBpZiAoIXRoaXMuc2hvdWxkVW5zdWJzY3JpYmUgfHwgdGhpcy5zaG91bGRVbnN1YnNjcmliZSgpKSB7XG4gICAgICAgICAgICB2YXIgY2xvc2VkXzEgPSB0aGlzLmNsb3NlZDtcbiAgICAgICAgICAgIF9zdXBlci5wcm90b3R5cGUudW5zdWJzY3JpYmUuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgICFjbG9zZWRfMSAmJiAoKF9hID0gdGhpcy5vbkZpbmFsaXplKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbCh0aGlzKSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBPcGVyYXRvclN1YnNjcmliZXI7XG59KFN1YnNjcmliZXIpKTtcbmV4cG9ydCB7IE9wZXJhdG9yU3Vic2NyaWJlciB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9T3BlcmF0b3JTdWJzY3JpYmVyLmpzLm1hcCIsImltcG9ydCB7IGFzeW5jU2NoZWR1bGVyIH0gZnJvbSAnLi4vc2NoZWR1bGVyL2FzeW5jJztcbmltcG9ydCB7IG9wZXJhdGUgfSBmcm9tICcuLi91dGlsL2xpZnQnO1xuaW1wb3J0IHsgY3JlYXRlT3BlcmF0b3JTdWJzY3JpYmVyIH0gZnJvbSAnLi9PcGVyYXRvclN1YnNjcmliZXInO1xuZXhwb3J0IGZ1bmN0aW9uIGRlYm91bmNlVGltZShkdWVUaW1lLCBzY2hlZHVsZXIpIHtcbiAgICBpZiAoc2NoZWR1bGVyID09PSB2b2lkIDApIHsgc2NoZWR1bGVyID0gYXN5bmNTY2hlZHVsZXI7IH1cbiAgICByZXR1cm4gb3BlcmF0ZShmdW5jdGlvbiAoc291cmNlLCBzdWJzY3JpYmVyKSB7XG4gICAgICAgIHZhciBhY3RpdmVUYXNrID0gbnVsbDtcbiAgICAgICAgdmFyIGxhc3RWYWx1ZSA9IG51bGw7XG4gICAgICAgIHZhciBsYXN0VGltZSA9IG51bGw7XG4gICAgICAgIHZhciBlbWl0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKGFjdGl2ZVRhc2spIHtcbiAgICAgICAgICAgICAgICBhY3RpdmVUYXNrLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICAgICAgYWN0aXZlVGFzayA9IG51bGw7XG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gbGFzdFZhbHVlO1xuICAgICAgICAgICAgICAgIGxhc3RWYWx1ZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgc3Vic2NyaWJlci5uZXh0KHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgZnVuY3Rpb24gZW1pdFdoZW5JZGxlKCkge1xuICAgICAgICAgICAgdmFyIHRhcmdldFRpbWUgPSBsYXN0VGltZSArIGR1ZVRpbWU7XG4gICAgICAgICAgICB2YXIgbm93ID0gc2NoZWR1bGVyLm5vdygpO1xuICAgICAgICAgICAgaWYgKG5vdyA8IHRhcmdldFRpbWUpIHtcbiAgICAgICAgICAgICAgICBhY3RpdmVUYXNrID0gdGhpcy5zY2hlZHVsZSh1bmRlZmluZWQsIHRhcmdldFRpbWUgLSBub3cpO1xuICAgICAgICAgICAgICAgIHN1YnNjcmliZXIuYWRkKGFjdGl2ZVRhc2spO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVtaXQoKTtcbiAgICAgICAgfVxuICAgICAgICBzb3VyY2Uuc3Vic2NyaWJlKGNyZWF0ZU9wZXJhdG9yU3Vic2NyaWJlcihzdWJzY3JpYmVyLCBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIGxhc3RWYWx1ZSA9IHZhbHVlO1xuICAgICAgICAgICAgbGFzdFRpbWUgPSBzY2hlZHVsZXIubm93KCk7XG4gICAgICAgICAgICBpZiAoIWFjdGl2ZVRhc2spIHtcbiAgICAgICAgICAgICAgICBhY3RpdmVUYXNrID0gc2NoZWR1bGVyLnNjaGVkdWxlKGVtaXRXaGVuSWRsZSwgZHVlVGltZSk7XG4gICAgICAgICAgICAgICAgc3Vic2NyaWJlci5hZGQoYWN0aXZlVGFzayk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGVtaXQoKTtcbiAgICAgICAgICAgIHN1YnNjcmliZXIuY29tcGxldGUoKTtcbiAgICAgICAgfSwgdW5kZWZpbmVkLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBsYXN0VmFsdWUgPSBhY3RpdmVUYXNrID0gbnVsbDtcbiAgICAgICAgfSkpO1xuICAgIH0pO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGVib3VuY2VUaW1lLmpzLm1hcCIsImltcG9ydCB7IG9wZXJhdGUgfSBmcm9tICcuLi91dGlsL2xpZnQnO1xuaW1wb3J0IHsgY3JlYXRlT3BlcmF0b3JTdWJzY3JpYmVyIH0gZnJvbSAnLi9PcGVyYXRvclN1YnNjcmliZXInO1xuZXhwb3J0IGZ1bmN0aW9uIGRlZmF1bHRJZkVtcHR5KGRlZmF1bHRWYWx1ZSkge1xuICAgIHJldHVybiBvcGVyYXRlKGZ1bmN0aW9uIChzb3VyY2UsIHN1YnNjcmliZXIpIHtcbiAgICAgICAgdmFyIGhhc1ZhbHVlID0gZmFsc2U7XG4gICAgICAgIHNvdXJjZS5zdWJzY3JpYmUoY3JlYXRlT3BlcmF0b3JTdWJzY3JpYmVyKHN1YnNjcmliZXIsIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgaGFzVmFsdWUgPSB0cnVlO1xuICAgICAgICAgICAgc3Vic2NyaWJlci5uZXh0KHZhbHVlKTtcbiAgICAgICAgfSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKCFoYXNWYWx1ZSkge1xuICAgICAgICAgICAgICAgIHN1YnNjcmliZXIubmV4dChkZWZhdWx0VmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3Vic2NyaWJlci5jb21wbGV0ZSgpO1xuICAgICAgICB9KSk7XG4gICAgfSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kZWZhdWx0SWZFbXB0eS5qcy5tYXAiLCJpbXBvcnQgeyBvcGVyYXRlIH0gZnJvbSAnLi4vdXRpbC9saWZ0JztcbmltcG9ydCB7IGNyZWF0ZU9wZXJhdG9yU3Vic2NyaWJlciB9IGZyb20gJy4vT3BlcmF0b3JTdWJzY3JpYmVyJztcbmV4cG9ydCBmdW5jdGlvbiBmaWx0ZXIocHJlZGljYXRlLCB0aGlzQXJnKSB7XG4gICAgcmV0dXJuIG9wZXJhdGUoZnVuY3Rpb24gKHNvdXJjZSwgc3Vic2NyaWJlcikge1xuICAgICAgICB2YXIgaW5kZXggPSAwO1xuICAgICAgICBzb3VyY2Uuc3Vic2NyaWJlKGNyZWF0ZU9wZXJhdG9yU3Vic2NyaWJlcihzdWJzY3JpYmVyLCBmdW5jdGlvbiAodmFsdWUpIHsgcmV0dXJuIHByZWRpY2F0ZS5jYWxsKHRoaXNBcmcsIHZhbHVlLCBpbmRleCsrKSAmJiBzdWJzY3JpYmVyLm5leHQodmFsdWUpOyB9KSk7XG4gICAgfSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1maWx0ZXIuanMubWFwIiwiaW1wb3J0IHsgRW1wdHlFcnJvciB9IGZyb20gJy4uL3V0aWwvRW1wdHlFcnJvcic7XG5pbXBvcnQgeyBmaWx0ZXIgfSBmcm9tICcuL2ZpbHRlcic7XG5pbXBvcnQgeyB0YWtlIH0gZnJvbSAnLi90YWtlJztcbmltcG9ydCB7IGRlZmF1bHRJZkVtcHR5IH0gZnJvbSAnLi9kZWZhdWx0SWZFbXB0eSc7XG5pbXBvcnQgeyB0aHJvd0lmRW1wdHkgfSBmcm9tICcuL3Rocm93SWZFbXB0eSc7XG5pbXBvcnQgeyBpZGVudGl0eSB9IGZyb20gJy4uL3V0aWwvaWRlbnRpdHknO1xuZXhwb3J0IGZ1bmN0aW9uIGZpcnN0KHByZWRpY2F0ZSwgZGVmYXVsdFZhbHVlKSB7XG4gICAgdmFyIGhhc0RlZmF1bHRWYWx1ZSA9IGFyZ3VtZW50cy5sZW5ndGggPj0gMjtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHNvdXJjZSkge1xuICAgICAgICByZXR1cm4gc291cmNlLnBpcGUocHJlZGljYXRlID8gZmlsdGVyKGZ1bmN0aW9uICh2LCBpKSB7IHJldHVybiBwcmVkaWNhdGUodiwgaSwgc291cmNlKTsgfSkgOiBpZGVudGl0eSwgdGFrZSgxKSwgaGFzRGVmYXVsdFZhbHVlID8gZGVmYXVsdElmRW1wdHkoZGVmYXVsdFZhbHVlKSA6IHRocm93SWZFbXB0eShmdW5jdGlvbiAoKSB7IHJldHVybiBuZXcgRW1wdHlFcnJvcigpOyB9KSk7XG4gICAgfTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZpcnN0LmpzLm1hcCIsImltcG9ydCB7IG9wZXJhdGUgfSBmcm9tICcuLi91dGlsL2xpZnQnO1xuaW1wb3J0IHsgY3JlYXRlT3BlcmF0b3JTdWJzY3JpYmVyIH0gZnJvbSAnLi9PcGVyYXRvclN1YnNjcmliZXInO1xuZXhwb3J0IGZ1bmN0aW9uIG1hcChwcm9qZWN0LCB0aGlzQXJnKSB7XG4gICAgcmV0dXJuIG9wZXJhdGUoZnVuY3Rpb24gKHNvdXJjZSwgc3Vic2NyaWJlcikge1xuICAgICAgICB2YXIgaW5kZXggPSAwO1xuICAgICAgICBzb3VyY2Uuc3Vic2NyaWJlKGNyZWF0ZU9wZXJhdG9yU3Vic2NyaWJlcihzdWJzY3JpYmVyLCBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHN1YnNjcmliZXIubmV4dChwcm9qZWN0LmNhbGwodGhpc0FyZywgdmFsdWUsIGluZGV4KyspKTtcbiAgICAgICAgfSkpO1xuICAgIH0pO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWFwLmpzLm1hcCIsImltcG9ydCB7IEVNUFRZIH0gZnJvbSAnLi4vb2JzZXJ2YWJsZS9lbXB0eSc7XG5pbXBvcnQgeyBvcGVyYXRlIH0gZnJvbSAnLi4vdXRpbC9saWZ0JztcbmltcG9ydCB7IGNyZWF0ZU9wZXJhdG9yU3Vic2NyaWJlciB9IGZyb20gJy4vT3BlcmF0b3JTdWJzY3JpYmVyJztcbmV4cG9ydCBmdW5jdGlvbiB0YWtlKGNvdW50KSB7XG4gICAgcmV0dXJuIGNvdW50IDw9IDBcbiAgICAgICAgP1xuICAgICAgICAgICAgZnVuY3Rpb24gKCkgeyByZXR1cm4gRU1QVFk7IH1cbiAgICAgICAgOiBvcGVyYXRlKGZ1bmN0aW9uIChzb3VyY2UsIHN1YnNjcmliZXIpIHtcbiAgICAgICAgICAgIHZhciBzZWVuID0gMDtcbiAgICAgICAgICAgIHNvdXJjZS5zdWJzY3JpYmUoY3JlYXRlT3BlcmF0b3JTdWJzY3JpYmVyKHN1YnNjcmliZXIsIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGlmICgrK3NlZW4gPD0gY291bnQpIHtcbiAgICAgICAgICAgICAgICAgICAgc3Vic2NyaWJlci5uZXh0KHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvdW50IDw9IHNlZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1YnNjcmliZXIuY29tcGxldGUoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD10YWtlLmpzLm1hcCIsImltcG9ydCB7IEVtcHR5RXJyb3IgfSBmcm9tICcuLi91dGlsL0VtcHR5RXJyb3InO1xuaW1wb3J0IHsgb3BlcmF0ZSB9IGZyb20gJy4uL3V0aWwvbGlmdCc7XG5pbXBvcnQgeyBjcmVhdGVPcGVyYXRvclN1YnNjcmliZXIgfSBmcm9tICcuL09wZXJhdG9yU3Vic2NyaWJlcic7XG5leHBvcnQgZnVuY3Rpb24gdGhyb3dJZkVtcHR5KGVycm9yRmFjdG9yeSkge1xuICAgIGlmIChlcnJvckZhY3RvcnkgPT09IHZvaWQgMCkgeyBlcnJvckZhY3RvcnkgPSBkZWZhdWx0RXJyb3JGYWN0b3J5OyB9XG4gICAgcmV0dXJuIG9wZXJhdGUoZnVuY3Rpb24gKHNvdXJjZSwgc3Vic2NyaWJlcikge1xuICAgICAgICB2YXIgaGFzVmFsdWUgPSBmYWxzZTtcbiAgICAgICAgc291cmNlLnN1YnNjcmliZShjcmVhdGVPcGVyYXRvclN1YnNjcmliZXIoc3Vic2NyaWJlciwgZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICBoYXNWYWx1ZSA9IHRydWU7XG4gICAgICAgICAgICBzdWJzY3JpYmVyLm5leHQodmFsdWUpO1xuICAgICAgICB9LCBmdW5jdGlvbiAoKSB7IHJldHVybiAoaGFzVmFsdWUgPyBzdWJzY3JpYmVyLmNvbXBsZXRlKCkgOiBzdWJzY3JpYmVyLmVycm9yKGVycm9yRmFjdG9yeSgpKSk7IH0pKTtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGRlZmF1bHRFcnJvckZhY3RvcnkoKSB7XG4gICAgcmV0dXJuIG5ldyBFbXB0eUVycm9yKCk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD10aHJvd0lmRW1wdHkuanMubWFwIiwiaW1wb3J0IHsgX19leHRlbmRzIH0gZnJvbSBcInRzbGliXCI7XG5pbXBvcnQgeyBTdWJzY3JpcHRpb24gfSBmcm9tICcuLi9TdWJzY3JpcHRpb24nO1xudmFyIEFjdGlvbiA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEFjdGlvbiwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBBY3Rpb24oc2NoZWR1bGVyLCB3b3JrKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgIH1cbiAgICBBY3Rpb24ucHJvdG90eXBlLnNjaGVkdWxlID0gZnVuY3Rpb24gKHN0YXRlLCBkZWxheSkge1xuICAgICAgICBpZiAoZGVsYXkgPT09IHZvaWQgMCkgeyBkZWxheSA9IDA7IH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICByZXR1cm4gQWN0aW9uO1xufShTdWJzY3JpcHRpb24pKTtcbmV4cG9ydCB7IEFjdGlvbiB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QWN0aW9uLmpzLm1hcCIsImltcG9ydCB7IF9fZXh0ZW5kcyB9IGZyb20gXCJ0c2xpYlwiO1xuaW1wb3J0IHsgQWN0aW9uIH0gZnJvbSAnLi9BY3Rpb24nO1xuaW1wb3J0IHsgaW50ZXJ2YWxQcm92aWRlciB9IGZyb20gJy4vaW50ZXJ2YWxQcm92aWRlcic7XG5pbXBvcnQgeyBhcnJSZW1vdmUgfSBmcm9tICcuLi91dGlsL2FyclJlbW92ZSc7XG52YXIgQXN5bmNBY3Rpb24gPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhBc3luY0FjdGlvbiwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBBc3luY0FjdGlvbihzY2hlZHVsZXIsIHdvcmspIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgc2NoZWR1bGVyLCB3b3JrKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5zY2hlZHVsZXIgPSBzY2hlZHVsZXI7XG4gICAgICAgIF90aGlzLndvcmsgPSB3b3JrO1xuICAgICAgICBfdGhpcy5wZW5kaW5nID0gZmFsc2U7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgQXN5bmNBY3Rpb24ucHJvdG90eXBlLnNjaGVkdWxlID0gZnVuY3Rpb24gKHN0YXRlLCBkZWxheSkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGlmIChkZWxheSA9PT0gdm9pZCAwKSB7IGRlbGF5ID0gMDsgfVxuICAgICAgICBpZiAodGhpcy5jbG9zZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3RhdGUgPSBzdGF0ZTtcbiAgICAgICAgdmFyIGlkID0gdGhpcy5pZDtcbiAgICAgICAgdmFyIHNjaGVkdWxlciA9IHRoaXMuc2NoZWR1bGVyO1xuICAgICAgICBpZiAoaWQgIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5pZCA9IHRoaXMucmVjeWNsZUFzeW5jSWQoc2NoZWR1bGVyLCBpZCwgZGVsYXkpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucGVuZGluZyA9IHRydWU7XG4gICAgICAgIHRoaXMuZGVsYXkgPSBkZWxheTtcbiAgICAgICAgdGhpcy5pZCA9IChfYSA9IHRoaXMuaWQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHRoaXMucmVxdWVzdEFzeW5jSWQoc2NoZWR1bGVyLCB0aGlzLmlkLCBkZWxheSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgQXN5bmNBY3Rpb24ucHJvdG90eXBlLnJlcXVlc3RBc3luY0lkID0gZnVuY3Rpb24gKHNjaGVkdWxlciwgX2lkLCBkZWxheSkge1xuICAgICAgICBpZiAoZGVsYXkgPT09IHZvaWQgMCkgeyBkZWxheSA9IDA7IH1cbiAgICAgICAgcmV0dXJuIGludGVydmFsUHJvdmlkZXIuc2V0SW50ZXJ2YWwoc2NoZWR1bGVyLmZsdXNoLmJpbmQoc2NoZWR1bGVyLCB0aGlzKSwgZGVsYXkpO1xuICAgIH07XG4gICAgQXN5bmNBY3Rpb24ucHJvdG90eXBlLnJlY3ljbGVBc3luY0lkID0gZnVuY3Rpb24gKF9zY2hlZHVsZXIsIGlkLCBkZWxheSkge1xuICAgICAgICBpZiAoZGVsYXkgPT09IHZvaWQgMCkgeyBkZWxheSA9IDA7IH1cbiAgICAgICAgaWYgKGRlbGF5ICE9IG51bGwgJiYgdGhpcy5kZWxheSA9PT0gZGVsYXkgJiYgdGhpcy5wZW5kaW5nID09PSBmYWxzZSkge1xuICAgICAgICAgICAgcmV0dXJuIGlkO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpZCAhPSBudWxsKSB7XG4gICAgICAgICAgICBpbnRlcnZhbFByb3ZpZGVyLmNsZWFySW50ZXJ2YWwoaWQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfTtcbiAgICBBc3luY0FjdGlvbi5wcm90b3R5cGUuZXhlY3V0ZSA9IGZ1bmN0aW9uIChzdGF0ZSwgZGVsYXkpIHtcbiAgICAgICAgaWYgKHRoaXMuY2xvc2VkKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEVycm9yKCdleGVjdXRpbmcgYSBjYW5jZWxsZWQgYWN0aW9uJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wZW5kaW5nID0gZmFsc2U7XG4gICAgICAgIHZhciBlcnJvciA9IHRoaXMuX2V4ZWN1dGUoc3RhdGUsIGRlbGF5KTtcbiAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5wZW5kaW5nID09PSBmYWxzZSAmJiB0aGlzLmlkICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuaWQgPSB0aGlzLnJlY3ljbGVBc3luY0lkKHRoaXMuc2NoZWR1bGVyLCB0aGlzLmlkLCBudWxsKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQXN5bmNBY3Rpb24ucHJvdG90eXBlLl9leGVjdXRlID0gZnVuY3Rpb24gKHN0YXRlLCBfZGVsYXkpIHtcbiAgICAgICAgdmFyIGVycm9yZWQgPSBmYWxzZTtcbiAgICAgICAgdmFyIGVycm9yVmFsdWU7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLndvcmsoc3RhdGUpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBlcnJvcmVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGVycm9yVmFsdWUgPSBlID8gZSA6IG5ldyBFcnJvcignU2NoZWR1bGVkIGFjdGlvbiB0aHJldyBmYWxzeSBlcnJvcicpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlcnJvcmVkKSB7XG4gICAgICAgICAgICB0aGlzLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICByZXR1cm4gZXJyb3JWYWx1ZTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQXN5bmNBY3Rpb24ucHJvdG90eXBlLnVuc3Vic2NyaWJlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXRoaXMuY2xvc2VkKSB7XG4gICAgICAgICAgICB2YXIgX2EgPSB0aGlzLCBpZCA9IF9hLmlkLCBzY2hlZHVsZXIgPSBfYS5zY2hlZHVsZXI7XG4gICAgICAgICAgICB2YXIgYWN0aW9ucyA9IHNjaGVkdWxlci5hY3Rpb25zO1xuICAgICAgICAgICAgdGhpcy53b3JrID0gdGhpcy5zdGF0ZSA9IHRoaXMuc2NoZWR1bGVyID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMucGVuZGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgYXJyUmVtb3ZlKGFjdGlvbnMsIHRoaXMpO1xuICAgICAgICAgICAgaWYgKGlkICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmlkID0gdGhpcy5yZWN5Y2xlQXN5bmNJZChzY2hlZHVsZXIsIGlkLCBudWxsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZGVsYXkgPSBudWxsO1xuICAgICAgICAgICAgX3N1cGVyLnByb3RvdHlwZS51bnN1YnNjcmliZS5jYWxsKHRoaXMpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gQXN5bmNBY3Rpb247XG59KEFjdGlvbikpO1xuZXhwb3J0IHsgQXN5bmNBY3Rpb24gfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUFzeW5jQWN0aW9uLmpzLm1hcCIsImltcG9ydCB7IF9fZXh0ZW5kcyB9IGZyb20gXCJ0c2xpYlwiO1xuaW1wb3J0IHsgU2NoZWR1bGVyIH0gZnJvbSAnLi4vU2NoZWR1bGVyJztcbnZhciBBc3luY1NjaGVkdWxlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEFzeW5jU2NoZWR1bGVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEFzeW5jU2NoZWR1bGVyKFNjaGVkdWxlckFjdGlvbiwgbm93KSB7XG4gICAgICAgIGlmIChub3cgPT09IHZvaWQgMCkgeyBub3cgPSBTY2hlZHVsZXIubm93OyB9XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIFNjaGVkdWxlckFjdGlvbiwgbm93KSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5hY3Rpb25zID0gW107XG4gICAgICAgIF90aGlzLl9hY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBBc3luY1NjaGVkdWxlci5wcm90b3R5cGUuZmx1c2ggPSBmdW5jdGlvbiAoYWN0aW9uKSB7XG4gICAgICAgIHZhciBhY3Rpb25zID0gdGhpcy5hY3Rpb25zO1xuICAgICAgICBpZiAodGhpcy5fYWN0aXZlKSB7XG4gICAgICAgICAgICBhY3Rpb25zLnB1c2goYWN0aW9uKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZXJyb3I7XG4gICAgICAgIHRoaXMuX2FjdGl2ZSA9IHRydWU7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICAgIGlmICgoZXJyb3IgPSBhY3Rpb24uZXhlY3V0ZShhY3Rpb24uc3RhdGUsIGFjdGlvbi5kZWxheSkpKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gd2hpbGUgKChhY3Rpb24gPSBhY3Rpb25zLnNoaWZ0KCkpKTtcbiAgICAgICAgdGhpcy5fYWN0aXZlID0gZmFsc2U7XG4gICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgd2hpbGUgKChhY3Rpb24gPSBhY3Rpb25zLnNoaWZ0KCkpKSB7XG4gICAgICAgICAgICAgICAgYWN0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIEFzeW5jU2NoZWR1bGVyO1xufShTY2hlZHVsZXIpKTtcbmV4cG9ydCB7IEFzeW5jU2NoZWR1bGVyIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Bc3luY1NjaGVkdWxlci5qcy5tYXAiLCJpbXBvcnQgeyBBc3luY0FjdGlvbiB9IGZyb20gJy4vQXN5bmNBY3Rpb24nO1xuaW1wb3J0IHsgQXN5bmNTY2hlZHVsZXIgfSBmcm9tICcuL0FzeW5jU2NoZWR1bGVyJztcbmV4cG9ydCB2YXIgYXN5bmNTY2hlZHVsZXIgPSBuZXcgQXN5bmNTY2hlZHVsZXIoQXN5bmNBY3Rpb24pO1xuZXhwb3J0IHZhciBhc3luYyA9IGFzeW5jU2NoZWR1bGVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXN5bmMuanMubWFwIiwiZXhwb3J0IHZhciBkYXRlVGltZXN0YW1wUHJvdmlkZXIgPSB7XG4gICAgbm93OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAoZGF0ZVRpbWVzdGFtcFByb3ZpZGVyLmRlbGVnYXRlIHx8IERhdGUpLm5vdygpO1xuICAgIH0sXG4gICAgZGVsZWdhdGU6IHVuZGVmaW5lZCxcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRlVGltZXN0YW1wUHJvdmlkZXIuanMubWFwIiwiaW1wb3J0IHsgX19yZWFkLCBfX3NwcmVhZEFycmF5IH0gZnJvbSBcInRzbGliXCI7XG5leHBvcnQgdmFyIGludGVydmFsUHJvdmlkZXIgPSB7XG4gICAgc2V0SW50ZXJ2YWw6IGZ1bmN0aW9uIChoYW5kbGVyLCB0aW1lb3V0KSB7XG4gICAgICAgIHZhciBhcmdzID0gW107XG4gICAgICAgIGZvciAodmFyIF9pID0gMjsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICBhcmdzW19pIC0gMl0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICB9XG4gICAgICAgIHZhciBkZWxlZ2F0ZSA9IGludGVydmFsUHJvdmlkZXIuZGVsZWdhdGU7XG4gICAgICAgIGlmIChkZWxlZ2F0ZSA9PT0gbnVsbCB8fCBkZWxlZ2F0ZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogZGVsZWdhdGUuc2V0SW50ZXJ2YWwpIHtcbiAgICAgICAgICAgIHJldHVybiBkZWxlZ2F0ZS5zZXRJbnRlcnZhbC5hcHBseShkZWxlZ2F0ZSwgX19zcHJlYWRBcnJheShbaGFuZGxlciwgdGltZW91dF0sIF9fcmVhZChhcmdzKSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzZXRJbnRlcnZhbC5hcHBseSh2b2lkIDAsIF9fc3ByZWFkQXJyYXkoW2hhbmRsZXIsIHRpbWVvdXRdLCBfX3JlYWQoYXJncykpKTtcbiAgICB9LFxuICAgIGNsZWFySW50ZXJ2YWw6IGZ1bmN0aW9uIChoYW5kbGUpIHtcbiAgICAgICAgdmFyIGRlbGVnYXRlID0gaW50ZXJ2YWxQcm92aWRlci5kZWxlZ2F0ZTtcbiAgICAgICAgcmV0dXJuICgoZGVsZWdhdGUgPT09IG51bGwgfHwgZGVsZWdhdGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGRlbGVnYXRlLmNsZWFySW50ZXJ2YWwpIHx8IGNsZWFySW50ZXJ2YWwpKGhhbmRsZSk7XG4gICAgfSxcbiAgICBkZWxlZ2F0ZTogdW5kZWZpbmVkLFxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWludGVydmFsUHJvdmlkZXIuanMubWFwIiwiaW1wb3J0IHsgX19yZWFkLCBfX3NwcmVhZEFycmF5IH0gZnJvbSBcInRzbGliXCI7XG5leHBvcnQgdmFyIHRpbWVvdXRQcm92aWRlciA9IHtcbiAgICBzZXRUaW1lb3V0OiBmdW5jdGlvbiAoaGFuZGxlciwgdGltZW91dCkge1xuICAgICAgICB2YXIgYXJncyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDI7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgYXJnc1tfaSAtIDJdID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZGVsZWdhdGUgPSB0aW1lb3V0UHJvdmlkZXIuZGVsZWdhdGU7XG4gICAgICAgIGlmIChkZWxlZ2F0ZSA9PT0gbnVsbCB8fCBkZWxlZ2F0ZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogZGVsZWdhdGUuc2V0VGltZW91dCkge1xuICAgICAgICAgICAgcmV0dXJuIGRlbGVnYXRlLnNldFRpbWVvdXQuYXBwbHkoZGVsZWdhdGUsIF9fc3ByZWFkQXJyYXkoW2hhbmRsZXIsIHRpbWVvdXRdLCBfX3JlYWQoYXJncykpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2V0VGltZW91dC5hcHBseSh2b2lkIDAsIF9fc3ByZWFkQXJyYXkoW2hhbmRsZXIsIHRpbWVvdXRdLCBfX3JlYWQoYXJncykpKTtcbiAgICB9LFxuICAgIGNsZWFyVGltZW91dDogZnVuY3Rpb24gKGhhbmRsZSkge1xuICAgICAgICB2YXIgZGVsZWdhdGUgPSB0aW1lb3V0UHJvdmlkZXIuZGVsZWdhdGU7XG4gICAgICAgIHJldHVybiAoKGRlbGVnYXRlID09PSBudWxsIHx8IGRlbGVnYXRlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBkZWxlZ2F0ZS5jbGVhclRpbWVvdXQpIHx8IGNsZWFyVGltZW91dCkoaGFuZGxlKTtcbiAgICB9LFxuICAgIGRlbGVnYXRlOiB1bmRlZmluZWQsXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dGltZW91dFByb3ZpZGVyLmpzLm1hcCIsImV4cG9ydCB2YXIgb2JzZXJ2YWJsZSA9IChmdW5jdGlvbiAoKSB7IHJldHVybiAodHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2wub2JzZXJ2YWJsZSkgfHwgJ0BAb2JzZXJ2YWJsZSc7IH0pKCk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1vYnNlcnZhYmxlLmpzLm1hcCIsImltcG9ydCB7IGNyZWF0ZUVycm9yQ2xhc3MgfSBmcm9tICcuL2NyZWF0ZUVycm9yQ2xhc3MnO1xuZXhwb3J0IHZhciBFbXB0eUVycm9yID0gY3JlYXRlRXJyb3JDbGFzcyhmdW5jdGlvbiAoX3N1cGVyKSB7IHJldHVybiBmdW5jdGlvbiBFbXB0eUVycm9ySW1wbCgpIHtcbiAgICBfc3VwZXIodGhpcyk7XG4gICAgdGhpcy5uYW1lID0gJ0VtcHR5RXJyb3InO1xuICAgIHRoaXMubWVzc2FnZSA9ICdubyBlbGVtZW50cyBpbiBzZXF1ZW5jZSc7XG59OyB9KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUVtcHR5RXJyb3IuanMubWFwIiwiaW1wb3J0IHsgY3JlYXRlRXJyb3JDbGFzcyB9IGZyb20gJy4vY3JlYXRlRXJyb3JDbGFzcyc7XG5leHBvcnQgdmFyIFVuc3Vic2NyaXB0aW9uRXJyb3IgPSBjcmVhdGVFcnJvckNsYXNzKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gVW5zdWJzY3JpcHRpb25FcnJvckltcGwoZXJyb3JzKSB7XG4gICAgICAgIF9zdXBlcih0aGlzKTtcbiAgICAgICAgdGhpcy5tZXNzYWdlID0gZXJyb3JzXG4gICAgICAgICAgICA/IGVycm9ycy5sZW5ndGggKyBcIiBlcnJvcnMgb2NjdXJyZWQgZHVyaW5nIHVuc3Vic2NyaXB0aW9uOlxcblwiICsgZXJyb3JzLm1hcChmdW5jdGlvbiAoZXJyLCBpKSB7IHJldHVybiBpICsgMSArIFwiKSBcIiArIGVyci50b1N0cmluZygpOyB9KS5qb2luKCdcXG4gICcpXG4gICAgICAgICAgICA6ICcnO1xuICAgICAgICB0aGlzLm5hbWUgPSAnVW5zdWJzY3JpcHRpb25FcnJvcic7XG4gICAgICAgIHRoaXMuZXJyb3JzID0gZXJyb3JzO1xuICAgIH07XG59KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVVuc3Vic2NyaXB0aW9uRXJyb3IuanMubWFwIiwiZXhwb3J0IGZ1bmN0aW9uIGFyclJlbW92ZShhcnIsIGl0ZW0pIHtcbiAgICBpZiAoYXJyKSB7XG4gICAgICAgIHZhciBpbmRleCA9IGFyci5pbmRleE9mKGl0ZW0pO1xuICAgICAgICAwIDw9IGluZGV4ICYmIGFyci5zcGxpY2UoaW5kZXgsIDEpO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFyclJlbW92ZS5qcy5tYXAiLCJleHBvcnQgZnVuY3Rpb24gY3JlYXRlRXJyb3JDbGFzcyhjcmVhdGVJbXBsKSB7XG4gICAgdmFyIF9zdXBlciA9IGZ1bmN0aW9uIChpbnN0YW5jZSkge1xuICAgICAgICBFcnJvci5jYWxsKGluc3RhbmNlKTtcbiAgICAgICAgaW5zdGFuY2Uuc3RhY2sgPSBuZXcgRXJyb3IoKS5zdGFjaztcbiAgICB9O1xuICAgIHZhciBjdG9yRnVuYyA9IGNyZWF0ZUltcGwoX3N1cGVyKTtcbiAgICBjdG9yRnVuYy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEVycm9yLnByb3RvdHlwZSk7XG4gICAgY3RvckZ1bmMucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gY3RvckZ1bmM7XG4gICAgcmV0dXJuIGN0b3JGdW5jO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y3JlYXRlRXJyb3JDbGFzcy5qcy5tYXAiLCJpbXBvcnQgeyBjb25maWcgfSBmcm9tICcuLi9jb25maWcnO1xudmFyIGNvbnRleHQgPSBudWxsO1xuZXhwb3J0IGZ1bmN0aW9uIGVycm9yQ29udGV4dChjYikge1xuICAgIGlmIChjb25maWcudXNlRGVwcmVjYXRlZFN5bmNocm9ub3VzRXJyb3JIYW5kbGluZykge1xuICAgICAgICB2YXIgaXNSb290ID0gIWNvbnRleHQ7XG4gICAgICAgIGlmIChpc1Jvb3QpIHtcbiAgICAgICAgICAgIGNvbnRleHQgPSB7IGVycm9yVGhyb3duOiBmYWxzZSwgZXJyb3I6IG51bGwgfTtcbiAgICAgICAgfVxuICAgICAgICBjYigpO1xuICAgICAgICBpZiAoaXNSb290KSB7XG4gICAgICAgICAgICB2YXIgX2EgPSBjb250ZXh0LCBlcnJvclRocm93biA9IF9hLmVycm9yVGhyb3duLCBlcnJvciA9IF9hLmVycm9yO1xuICAgICAgICAgICAgY29udGV4dCA9IG51bGw7XG4gICAgICAgICAgICBpZiAoZXJyb3JUaHJvd24pIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY2IoKTtcbiAgICB9XG59XG5leHBvcnQgZnVuY3Rpb24gY2FwdHVyZUVycm9yKGVycikge1xuICAgIGlmIChjb25maWcudXNlRGVwcmVjYXRlZFN5bmNocm9ub3VzRXJyb3JIYW5kbGluZyAmJiBjb250ZXh0KSB7XG4gICAgICAgIGNvbnRleHQuZXJyb3JUaHJvd24gPSB0cnVlO1xuICAgICAgICBjb250ZXh0LmVycm9yID0gZXJyO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWVycm9yQ29udGV4dC5qcy5tYXAiLCJleHBvcnQgZnVuY3Rpb24gaWRlbnRpdHkoeCkge1xuICAgIHJldHVybiB4O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aWRlbnRpdHkuanMubWFwIiwiZXhwb3J0IGZ1bmN0aW9uIGlzRnVuY3Rpb24odmFsdWUpIHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aXNGdW5jdGlvbi5qcy5tYXAiLCJpbXBvcnQgeyBpc0Z1bmN0aW9uIH0gZnJvbSAnLi9pc0Z1bmN0aW9uJztcbmV4cG9ydCBmdW5jdGlvbiBoYXNMaWZ0KHNvdXJjZSkge1xuICAgIHJldHVybiBpc0Z1bmN0aW9uKHNvdXJjZSA9PT0gbnVsbCB8fCBzb3VyY2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNvdXJjZS5saWZ0KTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBvcGVyYXRlKGluaXQpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHNvdXJjZSkge1xuICAgICAgICBpZiAoaGFzTGlmdChzb3VyY2UpKSB7XG4gICAgICAgICAgICByZXR1cm4gc291cmNlLmxpZnQoZnVuY3Rpb24gKGxpZnRlZFNvdXJjZSkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpbml0KGxpZnRlZFNvdXJjZSwgdGhpcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lcnJvcihlcnIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1VuYWJsZSB0byBsaWZ0IHVua25vd24gT2JzZXJ2YWJsZSB0eXBlJyk7XG4gICAgfTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxpZnQuanMubWFwIiwiZXhwb3J0IGZ1bmN0aW9uIG5vb3AoKSB7IH1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW5vb3AuanMubWFwIiwiaW1wb3J0IHsgaWRlbnRpdHkgfSBmcm9tICcuL2lkZW50aXR5JztcbmV4cG9ydCBmdW5jdGlvbiBwaXBlKCkge1xuICAgIHZhciBmbnMgPSBbXTtcbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICBmbnNbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICB9XG4gICAgcmV0dXJuIHBpcGVGcm9tQXJyYXkoZm5zKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBwaXBlRnJvbUFycmF5KGZucykge1xuICAgIGlmIChmbnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiBpZGVudGl0eTtcbiAgICB9XG4gICAgaWYgKGZucy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIGZuc1swXTtcbiAgICB9XG4gICAgcmV0dXJuIGZ1bmN0aW9uIHBpcGVkKGlucHV0KSB7XG4gICAgICAgIHJldHVybiBmbnMucmVkdWNlKGZ1bmN0aW9uIChwcmV2LCBmbikgeyByZXR1cm4gZm4ocHJldik7IH0sIGlucHV0KTtcbiAgICB9O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cGlwZS5qcy5tYXAiLCJpbXBvcnQgeyBjb25maWcgfSBmcm9tICcuLi9jb25maWcnO1xuaW1wb3J0IHsgdGltZW91dFByb3ZpZGVyIH0gZnJvbSAnLi4vc2NoZWR1bGVyL3RpbWVvdXRQcm92aWRlcic7XG5leHBvcnQgZnVuY3Rpb24gcmVwb3J0VW5oYW5kbGVkRXJyb3IoZXJyKSB7XG4gICAgdGltZW91dFByb3ZpZGVyLnNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgb25VbmhhbmRsZWRFcnJvciA9IGNvbmZpZy5vblVuaGFuZGxlZEVycm9yO1xuICAgICAgICBpZiAob25VbmhhbmRsZWRFcnJvcikge1xuICAgICAgICAgICAgb25VbmhhbmRsZWRFcnJvcihlcnIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICB9XG4gICAgfSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZXBvcnRVbmhhbmRsZWRFcnJvci5qcy5tYXAiLCIvKlxuICogQ29weXJpZ2h0IDIwMTUtMjAyNC4gUml0ZW5zZSBCViwgdGhlIE5ldGhlcmxhbmRzLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIEVVUEwsIFZlcnNpb24gMS4yICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cHM6Ly9qb2ludXAuZWMuZXVyb3BhLmV1L2NvbGxlY3Rpb24vZXVwbC9ldXBsLXRleHQtZXVwbC0xMlxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBiYXNpcyxcbiAqXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyXG4gKiBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKi9cblxuZXhwb3J0ICogZnJvbSAnLi9zcG90bGVyLXBsdWdpbi1sb2dvJztcbiIsIi8qXG4gKiBDb3B5cmlnaHQgMjAxNS0yMDI0LiBSaXRlbnNlIEJWLCB0aGUgTmV0aGVybGFuZHMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgRVVQTCwgVmVyc2lvbiAxLjIgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwczovL2pvaW51cC5lYy5ldXJvcGEuZXUvY29sbGVjdGlvbi9ldXBsL2V1cGwtdGV4dC1ldXBsLTEyXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIGJhc2lzLFxuICpcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXJcbiAqIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqL1xuXG5jb25zdCBTUE9UTEVSX1BMVUdJTl9MT0dPX0JBU0U2NCA9XG4nZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFtOEFBQUp2Q0FZQUFBQXROamFJQUFBQUJHZEJUVUVBQUxHUEMveGhCUUFBQUNCalNGSk5BQUI2SmdBQWdJUUFBUG9BQUFDQTZBQUFkVEFBQU9wZ0FBQTZtQUFBRjNDY3VsRThBQUFBQm1KTFIwUUEvd0QvQVArZ3ZhZVRBQUFBQ1hCSVdYTUFBQTdEQUFBT3d3SEhiNmhrQUFBQUIzUkpUVVVINUFjSkN6SUQ5Z1dLaEFBQWdBQkpSRUZVZU5ydDNYZDhITlhaTnVEN3pNcVNYR1RjdXdIYjJPcW1ONXNVaWpFbHBCRjZUZDVBZ0JDU0FPRk5lRk9BSktRQUlRa0VETWtYaW1tbXBORmNnSkFBQm1NTTJPcVNDN2ozWGxSMjUvbittSE5tenF4azFWMUpJOTlYZnNHMnl1NXNuWHVmYzg1emxJaUFpSWlJaUtMQjZlb0RJQ0lpSXFMV1kzZ2pJaUlpaWhDR055SWlJcUlJWVhnaklpSWlpaENHTnlJaUlxSUlZWGdqSWlJaWloQ0dOeUlpSXFJSVlYZ2pJaUlpaWhDR055SWlJcUlJWVhnaklpSWlpaENHTnlJaUlxSUlZWGdqSWlJaWloQ0dOeUlpSXFJSVlYZ2pJaUlpaWhDR055SWlJcUlJWVhnaklpSWlpaENHTnlJaUlxSUlZWGdqSWlJaWloQ0dOeUlpSXFJSVlYZ2pJaUlpaWhDR055SWlJcUlJWVhnaklpSWlpaENHTnlJaUlxSUlZWGdqSWlJaWloQ0dOeUlpSXFJSVlYZ2pJaUlpaWhDR055SWlJcUlJWVhnaklpSWlpaENHTnlJaUlxSUlZWGdqSWlJaWloQ0dOeUlpSXFJSVlYZ2pJaUlpaWhDR055SWlJcUlJWVhnaklpSWlpaENHTnlJaUlxSUlZWGdqSWlJaWloQ0dOeUlpSXFJSVlYZ2pJaUlpaWhDR055SWlJcUlJWVhnaklpSWlpaENHTnlJaUlxSUlZWGdqSWlJaWloQ0dOeUlpSXFJSVlYZ2pJaUlpaWhDR055SWlJcUlJWVhnaklpSWlpaENHTnlJaUlxSUlZWGdqSWlJaWloQ0dOeUlpSXFJSVlYZ2pJaUlpaWhDR055SWlJcUlJWVhnaklpSWlpaENHTnlJaUlxSUlZWGdqSWlJaWloQ0dOeUlpSXFJSVlYZ2pJaUlpaWhDR055SWlJcUlJWVhnaklpSWlpaENHTnlJaUlxSUlZWGdqSWlJaWloQ0dOeUlpSXFJSVlYZ2pJaUlpaWhDR055SWlJcUlJWVhnaklpSWlpaENHTnlJaUlxSUlZWGdqSWlJaWloQ0dOeUlpSXFJSVlYZ2pJaUlpaWhDR055SWlJcUlJWVhnaklpSWlpaENHTnlJaUlxSUlZWGdqSWlJaWloQ0dOeUlpSXFJSVlYZ2pJaUlpaWhDR055SWlJcUlJWVhnaklpSWlpaENHTnlJaUlxSUlZWGdqSWlJaWloQ0dOeUlpSXFJSVlYZ2pJaUlpaWhDR055SWlJcUlJWVhnaklpSWlpaENHTnlJaUlxSUlZWGdqSWlJaWloQ0dOeUlpSXFJSVlYZ2pJaUlpaWhDR055SWlJcUlJWVhnaklpSWlpaENHTnlJaUlxSUlZWGdqSWlJaWloQ0dOeUlpSXFJSVlYZ2pJaUlpaWhDR055SWlJcUlJWVhnaklpSWlpaENHTnlJaUlxSUlZWGdqSWlJaWloQ0dOeUlpSXFJSVlYZ2pJaUlpaWhDR055SWlJcUlJWVhnaklpSWlpaENHTnlJaUlxSUlZWGdqSWlJaWloQ0dOeUlpSXFJSVlYZ2pJaUlpaWhDR055SWlJcUlJWVhnaklpSWlpaENHTnlJaUlxSUlZWGdqSWlJaWloQ0dOeUlpSXFJSVlYZ2pJaUlpaWhDR055SWlJcUlJWVhnaklpSWlpaENHTnlJaUlxSUlZWGdqSWlJaWloQ0dOeUlpSXFJSVlYZ2pJaUlpaWhDR055SWlJcUlJWVhnaklpSWlpaENHTnlJaUlxSUlZWGdqSWlJaWloQ0dOeUlpSXFJSVlYZ2pJaUlpaWhDR055SWlJcUlJWVhnaklpSWlpaENHTnlJaUlxSUlZWGdqSWlJaWloQ0dOeUlpSXFJSVlYZ2pJaUlpaWhDR055SWlJcUlJWVhnaklpSWlpaENHTnlJaUlxSUlZWGdqSWlJaWloQ0dOeUlpSXFJSVlYZ2pJaUlpaWhDR055SWlJcUlJWVhnaklpSWlpaENHTnlJaUlxSUlZWGdqSWlJaWloQ0dOeUlpSXFJSVlYZ2pJaUlpaWhDR055SWlJcUlJWVhnaklpSWlpaENHTnlJaUlxSUlZWGdqSWlJaWloQ0dOeUlpSXFJSVlYZ2pJaUlpaWhDR055SWlJcUlJWVhnaklpSWlpaENHTnlJaUlxSUlZWGdqSWlJaWloQ0dOeUlpSXFJSVlYZ2pJaUlpaWhDR055SWlJcUlJWVhnaklpSWlpaENHTnlJaUlxSUlZWGdqSWlJaWloQ0dOeUlpSXFJSVlYZ2pJaUlpaWhDR055SWlJcUlJWVhnaklpSWlpaENHTnlJaUlxSUlZWGdqSWlJaWloQ0dOeUlpSXFJSVlYZ2pJaUlpaWhDR055SWlJcUlJWVhnaklpSWlpaENHTnlJaUlxSUlZWGdqSWlJaWloQ0dOeUlpSXFJSVlYZ2pJaUlpaWhDR055SWlJcUlJWVhnaklpSWlpaENHTnlJaUlxSUlZWGdqSWlJaWloQ0dOeUlpSXFJSVlYZ2pJaUlpaWhDR055SWlJcUlJWVhnaklpSWlpaENHTnlJaUlxSUlZWGdqSWlJaWloQ0dOeUlpSXFJSVlYZ2pJaUlpaWhDR055SWlJcUlJWVhnaklpSWlpaENHTnlJaUlxSUlZWGdqSWlJaWloQ0dOeUlpSXFJSVlYZ2pJaUlpaWhDR055SWlJcUlJWVhnaklpSWlpaENHTnlJaUlxSUlZWGdqSWlJaWloQ0dOeUlpSXFJSVlYZ2pJaUlpaWhDR055SWlJcUlJWVhnaklpSWlpaENHTnlJaUlxSUlZWGdqSWlJaWloQ0dOeUlpSXFJSVlYZ2pJaUlpaWhDR055SWlJcUlJWVhnaklpSWlpaENHTnlJaUlxSUlZWGdqSWlJaWloQ0dOeUlpSXFJSXllanFBeUFpb3RUYnVXK0wxTHNKS0FEL3F2d3YxdXpkQ2dVSENna0FnQXNGd01Ia3dXUHh1VU9QZ1ZJT2FoTU5HTlp2bU9ycVl5ZWk1aWtSNmVwaklDS2lkdHF4ZDVPSUpQRGdSeStpWXZ0YVZPL2RpZy8zcmtXRE5BQWk4QVpZWEVBNWdMakJMeXJ2eTdDam10TUx4MlFOeDBsRHh1T1NnczlqMHNBSjZOOW5BTU1jVVRmRDhFWkVGQ0hiOTIyVnR6NzVBQzhzZnc4TGRxeEdaZDFXQUhIQUZjQlJBQVFRSGRnQWVPbE12OCtMem1GS0p6Zmw2SUJuL3ExL1JSejlkNFZ6Qmt6RTdjZGZoQWtEUjZGL2IxYmxpTG9EaGpjaW9tNXErNzZ0NGtvQ2IzMzZFZjY1L0QyOHNtMHBOdFR2QUtCRGx6THYzeWFzbVQ4RlFBeFFibEtRYy9UWFlQMGVkTDR6SVM2aC96VC85MzUzVE5aQS9PbW9pM0h5dU9PUWs4MXFIRkZYWW5nakl1b210dS9iS2dtM0RzK1YveHV2ckM3RjNKMHJVSmZZQ3krc0pRQVZnMThoRXdlQS9wcDVIMWNxcU1CSkFrQk1YN0pyRmVEc1VPWUUzMGRTeURNVTlIQnJESUJnWkdZT0hqejZRcHh5NkJUazlHYUlJK29LREc5RVJGMWt4OTV0b3BTTCt6OTRIaSt1cThDU2ZSdXgxOTNqaFN5bGRDZ1RBQms2Uk9tcW1GS0F4T0dGT3FXSE9NWDd1NlAvRHVqaFR4ZHdGZURvNzBOZnJnUHJkOTN3ZFlvS3FucEs2WXN6Ly9iK2VucDhBdTZjZGdXT0huYzRBeHhSSjJONEl5THFKSnQzcnhOSHhmRGdoeTlpenZvU3ZMVm5OWkNJZTk5VXloclNORld3bUJlaXpFSUR2M3BtaGo5ajhLcHZlakdDaXVtZjFUK29WRkN4azZSRkN5Ym8rWXNhRUlRNjgzZGw1VEkvMUNtL0duZlFsaGdLbC9mRm5WKzlIaU5IRHNDa29sd0dPYUpPd1BCR1JKUW0yL2R0bGNyTk5YaWgrajI4dXJFVVpiV2JyZmxtYmtjdXV1dnBvZHVKOHh2US83OTFHRForQXI3enZVdHc1aG1mWVlBalNqT0dOeUtpRk5peVo1dGtPQW5NVy80ZVh2NWtNZDdhc1JMTDZyY0FicjJ1Y3VtcWw1Z2h6SzQrNG83eXFvUDkxcmdZdFFYSWVXVWZvQndVbkhBY2J2bit4U2c2b29BaGppaE5HTjZJaU5waDI5NU5rcUZpK1BjbkgrQWZ5eGZnNVczTHNiRmh1eDZXVEY3aGlXQyttajJmTE9wMDlhM1BtamlHYlJJTW5sMExRRUVnT1B2Q0wrT1M4NmNobDBPcFJDbkg4RVpFMUFvNzkyNlN2UWtYTDFXOWdaZFhsV0R1cmhYWTI3QlBCekZILzJsV2U0cGVKR0JOOWpkejBxQUF4QkdzQkkyeUlLZ09XdzBNWE82aTc3djdvSFRET0NlV2pZdi81MXhNUDNNcThnc21Nc1FScFFqREd4RlJFN2J0M1N5dU5HREdoeS9obGZXVmVHL3ZhcmlKQnZqYkV2Z05iVjJyUllmK1d2TE9CV1lWcDkvaVE1SitJSUxFYWxPaW0vNE9YQzBZV1pKQTc4WDF3VzFVZ3F5Y3dmalpuZC9CbU5FalVWQTRJZUkzbktqck1id1JFY0hiWnNvRjhPQUh6K09sRGRWNGQ4OHF3RTBnTlB3cHVxb0dXS3RDNGEzOEJIUXdNMXpyZDVTMTJ0UDhjdFRmZTAwSTFiZEh0eDBadHJ3Qlk1NnI5N3VYQUFKUkNrb0VnOGNmaGovY2ZUUHlpZzVqZ0NQcUFJWTNJa3FicXRLbDh0NUhaZmozRzR1d2J0MEdOT3plaDkxYnRnQktZY0RCbzZFVU1IejRNSXcvWkFST21ub2tobzBjZ2w1S0liOG8vVU5zMi9adWtXVmJsdUtweXY5Z3p1WlBVRjY3WHJmTnNFT1dxYkxweWxxb241cTE2RUJCZnorMFVhaiswN284c3l1QzM4TXR3a1NDcHNIK0Zxb0svZGNrTUh5RG9QOXJ0VUVmT2J1SnNBaW1UajhGMy9yV0JTZ29ZaFdPcUQwWTNvZ29wU3BMbDhxaWp6N0d6Q2ZuWWZPSzVkYTJTNENkZGhURWkwWjZEMDBSZ1FNRnhETFJiOGhRako5NE1FNyszQWs0NnFoeEtDak83OUJKZnZ1K1hhS3dGNjh0WDRoWFZueUV0M2F1UmszZEp0MjdUS3grWjBCb0wxRC9uL2J4NjBhMy9vOVpBVThRL3JvOVhBb0VlNFpLeE51RUFBZ3R5akMzei9YdWg5NnJFeGkvMkVWMlNhMitTN3hGREFwQlR6bVZrWWtiZm5RMWpqNGlId1hGa3hqaWlOcUE0WTJJVXFLeWJJV3NXN3NhUC92Um43QjM1eFowZEZqUUcyb0RSQW42NWd6R2tWT093SFhmK2hyRWJVQmVjZk50S0RidFdpOFpzUmplK3ZRRC9HMzVRc3pldGh3YjZyZDVGVENJemx0SkFRM05ISEpMMzIrUzA4TDNlMEtBMjc5RHF3V0QvN1lYZ0lJb2dRcFY0YnlFSzBwaDZDSGo4WU5idm9IUnd3Y2hyNWlMR29oYWcrSHRBRlZadGxSZW5mTTJYdno3bTlpOVpUT2NXQzg4K3ZSZG5JdEM3VkpWV2lVUFBQUTgzcG56YnpTcVhMV0RWNTlSVnNGTC9LLzE3ajhRWDduMGJKeDU2bFRrRlh2UDExMjFXOFIxZ2VjcTNzQXJxejdDaXp0V0lKNm9SV2pQVG45M0FidU5oOGJ3bG5MOVY4VXg5bU9nZDFtOTl6amE1eHAvMkZoWDVCUXcrY1RqOGI4LytDWnlDOGZ4UFlpb0JReHZCNURLMG1XeTRJTnlQUGJYRjdCei9XcDlpZzArRGMvODIwUEk1eHdVYXFPcTBxVnk1ejEvUmRrNzcwTXBaVzJEbVlyM0ZoWDZJenkwcVhEbzVDSmtUOGpFM0dITHNHbGd2ZjRaL2NObWtRRDBCdTVtZ3IzWjd6UHREdXp3QmdVY1dpNFkvTSs5K3Q5V2p6dS8rQ2I2UjNXSWkyWGkwbXN1eHZSVGprVmVNZnZERWUxUFJsY2ZBS1ZmWlVtTlBQam41ekIvM2p0QW9nN214T2Y2MDNZRXNZeHNRT3E3K2xBcGdwNTRkamJLM2xub25ZRDF5VGdWalRCRW45SVZGRnh6a2xkV1ZVOWNmRkpTQWl3UkRDcklRczY0R0xZT0Vtd2ZIZk8vNy9kZk00czdsUjNjV2dwWDZkYks2N2NuKzl0ZlU5MC8yNnp2RjBmZm9reGtselhBUEFoS0FGY1BpZnMzUncraEl0R0FtUTg4aGxkZmZRdi9lOU1WY3ZLMEtkMy9SaEoxQVZiZWVxaUtKVld5ZXYwbXpIenFGWlRQWDZpL0t1R05xUUdZK0ZZMDlVUTgrc2pQK1VaSmJWSlJWaTJYZnZYYlVIcFlVNlZneURSZ0pya2pOTXptRWEvS0orYnYzcmZyOGpPeFowd01HNGM3MkRQR3RMS3dudk9PV0QzWXVqcTh0VkprdzV1M0ZWaitSeTc2ek5YVk4xaVZOMnZlbTdkd043VGFBd0F3ZGZvcHVPYXE4NUEvbVhQaGlHeXN2UFV3bFNXVnNtck5Gdnp1RDQ5aDA3TGwraVJsM2hDOVlTUXpSQkc4VHlyYyt2MHJ1L3JRS1lKZW5mTytQdkdhWjVXM1lsUlNGT0NVU1dXNk93ZEU5TmZnVmZuc1lWcWxrRlZSajZ4S2hiNlRlcUZoQTdCdWVBWjJqdFVmV2x3ZEdweVliakRydG4rT1c2c3lhb3FHVGYzWWtyekFvcnQvOFBhcW5KdUhLQnlzSDhjZ2crczdVTHorYjk2cVk1VTBqQXE4TStjTnZQdjZPL2pPTFZmTDhjY1dZRkloUXh3UndQRFdvMVNXMU1pUGJuc0lxMHBMRVlRMTZBbkIzaHVqK0gvcWRsTVFGRXc1QVpNbWM2NGJ0ZDMyN1R0MFpCTW81Y0NCbUt6VjRTcWNLQWx2VWlEbWhHLzZwSGtCenE3TWVkVTRRVloxQTdLcWdERjVRTzM2R05hUEZPd2Q3Y0N2d3ZXQURRNjZQeGRRd0I3SHhaNGplNkh2aHczQkpoUCsxRVh2Y1RSRlJQOURnUFhCMG8zWDRmZDMzb2ZpS2Nmamh6ZGZLbmxGSFdzYlE5UVRSR1RjZ0pwVFZWWWpOOXp3YTduMDNHdXhxclJNVHkwSlRwemVoM1Q5ZDMzU2NrVDVuMjR2dS9DTXJyNEpGRkVYWFhBV2xJb0ZIdzUwT3dqdjdOcVc0TmI0Zkt6ODV6SDBwYm4rbnBsZStQSk85UXJCL0NreEE2MzYzNzJyR2pEd3RYMDRaRkVjaDVRbjBIZHR3bS9UUm1tbUd4UHZIWk9CMm9NejlPT241N3RaallyTkIwbUk3Z1BuVitDOC8zdFBLWVd5K1F0dzVjVzNZczY4LzNiM2tpTlIybkhPVzRSVmxpeVZoUitYNDQ5M3pvQWt6SVJnaEx1M3Q5REpQYnYvRVB6bHI3OUVIaXR2MUE2dXUxZGVmMjBKN3ZqUnZkaTNlMHZvUTBQVHp6MHo1OGthbHd6Tlp4UDdKLzIycmtxNStuZXMxYWROWGJhNVRPc1M3R1BaYzB3MmRrMVEyQmxUMkhXd3Rmb3g5UHQ2QTNsL3dZUHJONThObXRKYTdVYlM5aGJxQkExK2xkbm9Yb0w3MkJ5RG1BM3VFK0ZmRit1WS9UMVZ1MmFGYTc4MUxnNWQ2Q0tyc3Q0OG9tMGFXaGQvZ1lOM3U2Kzg1bktjY3ZxSjNDZVZEbGdNYnhGVlZyWlVicno1dDlpeWJJWC9WaGcwdy9UZTdBeGxWZ0RxL1FYTkdJVUF1T1NhUzNIajk2L2dHeUIxU1BXU1pmTEoyZzE0OGRYL29McnFFelRzcWNQdUxac2hpUWFJSkJDYWR3bDRmdzlsTmFWemxJUisxTitjWUQ4QnIzV1NCM0FGMjZka1k4czRoZTFqTTZ5OVI4M1dXREZyNXdSWUlVaC9UU25BZGIzZlFUc09wL1dIYmUyVmFrS3Z0VitxQ2NHT0hrcEdScU1tdU1IbThLNFYzakwwbjUwUTVFeGpYampJZTJVZitwYkUyN1l0bUFxcXFONUZCZE5CcHB4eEtyNzlyWE9SeTNsd2RBQmllSXVZc3BLbE1tL2VPM2pxb2FmaElnRTlxUTMyR2MvdlptNVZJUHdUbzg4N0lUM3h3b1BJWTI4M1NwUHE4bVhpeGhONDdmVjNVYlZpTmNvWDEyRG54bzFBb2dGQlU1R0FtYk1HSUZpRjZEK1Y3VkRTY29oVCtyVUFzVDY0V0w5Zmw1dUpQV01kN0JvbTJIeXdxVjZaVmlMS3lqN21MeG1BZWMzNWxiazBDMVVHWTk1MVN5TFlVOVFFUEgrTEw2czY2TjhXdXpreDBIblZOeE1XdlQ5elAweWczOXhhZlpOYUU4Sk5BMStUNHUzdHg3d2g4OElweCtMV1cvNEhrd3I0SGtZSEZvYTNDS2tzV1NaMzMvTUlQcHEvd0xRYmJWUjFNeXYvUE5ad1VLTmhKb1djNGFQdzc3Y2U0NXNlZGFyeXNoV2kzRnJNZXZZTnZMdHdDYlo5c2dvSmFRaUd4WUpKYy83T0NtYi9VNWdmYVcyNXk2L2NKQS9QQnBleFozSVdkaFk0MkpQaFlNY1lXSTFrelhHWTY5SWh5THo0MGoxbDJEOVV0NGt2T2tsZnMvNE1EWmZxVmJiS3ZpOU1yNVEwdi9RVkFEZmhYMi8vTlM0T2U3TFdYeWdscmFtaTJvK2Z0WitzdDkyc0Y4eUxwNXlBSC83Z0c4Z3RITS8zTWpwZ01MeEZ4R3R6NTh2UGZ2UjcxTy9hNWsvS05oKzB2ZUtBaEQvUitnVUdGVHJaaVZMKytXanE5SlB4aC90dTVSc2VkYW5LMHFVaVVQanp3N1B3OFllVjJMRnBMWlI0SDBaaW91QkNMMVl3SGZyMTgxKzFvbklUWHZlcVYxdnJSckVxR0lTRFFMQm5TbTlzR0NmWU5xWVg0RmlCU1hSYVUyWjRNdFpKZmRiTTBWbkhvaHhyTW4veUhEWVZuaHNIQkFGVVRMc1UxNXF2MXducjFheGgzUDZyNHpqNGd6aXlLaHNhdlM4MS9hdW1wWkY1cEswUkJUdUlLMkR5aVNmZzVoOWNnWUpDYnU5SEJ3YUd0d2lZTzN1KzNQcmQyL1Z3Q1NCaTF0eUZZaHlDS2Q1TlR3YTJneHNnK00xOXQrUFU2VlA1WmtmZFNsVlpqYnc2NTcvNDF6LytpNTBiMWphZTY5YkNJaHlmSG9MMVI5MjhMNkx4c0d0UWlkdWJsNGw0WGlZMjlFMWc1MWdkYnZTcVNXOXhnTjZ4d1c4MHU3L3JSb3RGcFZiY0FEMi9UZ0VxRVh3WUE2enIxOGRvNXNDRmhrYk5nZ1o3a1lnRXUweDAybHUvQ1dvS0JhL0gwZnVET3JSMjZOYVAzYVkxakQrS0xEcXJCZ0d2ZU1yeCtOK2IvZ2Q1UmR3YmxYbytocmR1ckx5a1doWitXSWI3NzV3QmtVU28xaEQwYWJNN2t3UEpKN2hRT3l2N2E4ckI0OC9maHdMdUgwamRXRlhaY25sNTduL3g4Z3R2WU1mR2RRalgzVm9lY2hOZFpRUDBJaDR4N1VhU2x6REFiLzRMQUx1UHljTDZ2QmgyaklrRlFjZk1mL1BHN0xEZjlOTlNnOTgyQ1lMVzROVXVYQ2dNM3dERTl5VVEyK3RkV1F5Q2hPTWdwZ1I3Qnl2c0dPeENFTVAyc2NtM1UvODd0SGdoamN4dUx2NnVMb0tKaXdUOTU5VzIvczdScTB4ZHVGQ202bWhDdWY4alpwNmt3cFRwbjhjMVYxK0FnbUpXNEtoblkzanJ4djd3dThkbDVvekg5YitVcnJxWjNsWVM3UExqQzFhYmh1WU5BZGFFWCsvUG1KT0pCUlV2OHcyT0lxT3FyRVplbXZNTy92N2tLOWkzZTF2U0FwejlhU0prV1ExZ1Bib0hvZ2tCT2pEc201U0JmZU42WWR0d3diWlJUaERhL0k2eWJ0TlhoOURGdHR2QXRTNTY3MVhvdThsRnhnNFhxaGJvWGRtQVJxRlRYM0h3MmdmMkZXUmlTNUZDUEphQkxZZVlZOU1WUkxHSFR0UE5CRWh2Y2NYQWxRbU1mN0kydkE1alAreWg4ZEFndWIyOWxoNUtFQ2c5ZFVUaGtxc3Z3NDAzWGM3M051clJHTjY2cWRmbXZpcy8rczdQOUNmS1lGMmVhbkxZcDNuQnZHc1RBRjBNSFQ4UnMyZlA0QnNjUlU1MWVaWEVKUU4zM2ZVb3loZVZJbEczSzloaHdXelM1VysvSkVGalh6MXR3SHdBOGo3OGhQZGtEYytrODRMYzNpTjZZVjJoZysyak02eUZEUFpMSjNsT212bWFIbUoxZGZzUlNQanJFdnpPUWF0Y3hBRU0zcE5BbjAxQWJMc0xhVkRvWFZWbmZzaDZ5YmYrOWI5bmNpYldGc2V3YzJ3bWdMak9VVW92dW1qbmUzOWJBNnBmZ1FQNnJRWU9YZENBckpyNkpuNjNxZHZVM08xTTZ2bm43N0xoNEs3N2I4Zm5wNTNJOXpmcXNUb2x2RldXclJBZ0FRZEEzSTNEVVZrUXhKRmZ4UDQ4VGFrcXJaSkx6NzBCb29jYUdnOTl0S1ZQRWhwWEdaVEM0SEVUTUlmaGpTS3VzcnhHM2wxUWltZG16Y1dXNVV2aFQyWUhrbFlwZXFITHIvalljOENNMENUNG9McWpJS2lkbEluZEUyTFlNVVJoMjVpWVhzRnBwaWc0U2FIS3BuL09oZFhrMTBHL05ZRGpKdEIvQjVDenhZWGFBZlN1cUlmZCtzZHZrd0g0eDZVZzNnNEZyYXc2aWhMVVRjckVoaU5qMkh3bzRLVzJEbGJkbXJpSnpmNmd2Y3BWQklYL1NpQzdvcTZKbiszQXVVZ0hSSzg5akVKMnY0SDR5Nk0vUjE3eEpMN0hVWStVMXZCV1VicGNubm51WmZ6NzViZXdkOWMyNjVPeFYrak96T3FQU1VmbjQrdVhmZ0dEaHc1QzhlR2NmMVZac2x5dSsvYnQyTFYrclRXbnh5eXNiOHNibkZuUzRBMlIrT2NaZVBmOWtBa1RNZnZWQncvNCs3dTdxUzZwRkJjT0VnS0lTbURObXExNDc3MUZpQ2RpeUhBeW9DUUJGd0lSZ1RoS3I4Wk13SWxsSXBGSXdJazVjQkwxT1BlQ014QnpGY1R4K3BNNTBvRGNvcDc5K3Fvb3JaRVpEejJIQmY5NUgvSGEzY0g4L2xDZk44T2FOV2ROSnhCN1JhT2RVblR2eEoxSDlzTEdvaGkybTMxU1RkaHk5SjkrT2pUenM3eXEyNEJWTHFBRUF6Y0lzcmNDemw0WDJlVjExb3BLdXhobjlXejAvK3N4VzBWNVA5dTZSUnNRUVYxK0p0WWNrK0VOLzVyczF0SzRaWXVYYlE2cXVSOXc0UFhHaXdHSUExRElteHRIMzQvcVVyWmd3dThIbUxSbzY4UXpUOGEzdnZrMUZETEFVUStVdHZBMmIrNWJjdXYzZmczRTYvMDNHVk94Vi9wZFZjU0Yzc29hV1RtRGNmdWROMkRzcUtISVBZQmZiRC81eWYzeTZxeC9wT3p5Z3JrbDRUa3hROFpQd096WkR4Mnc5M05YcUN5cGxIb0FIMzlZalU4L1hZTmxuNnpEK25YclVMKzdBYnUyYk5JTjlPTmVXd3ovUkM3K2JobkJ1ZGIrV3RJcVk2WGJhc0FKSm5wRHdWRXh3SWxCbEVKVzd6N29OM1FRRklEampwOE0xeFdjOHRrak1IejRTRGdaTHZJS29sMFJyeXhkSmdzK0tzT1RUNzJDcmN1VytuUFovRDBIN0lhOW9TRTNQWHNxYVJVai9MNWtucjE1bVdpWUVNUG1RUXJieDVqV0hZQy9xbElCQTFZbU1MQkJJWE9IUUcxMkVkc3J5S3FzZ3dQSEg2NE5ENFY2anl1c3gxWHN4OVc2ZUwvTlhJdnYzU3IwMTEwblpHSExCSVV0WXpNYS8yaDdUZ090V3BqaEpyVlZVWmowWGh3NWI5YTI0c0tiRzIxSW1qN2lyMFlOdDRHNTgvYy93ZWxuZlRiU3oyZWlwcVFsdlAxNzNueTU1Zm83SUlqN3k3c2gzc3NwK0x3Yjd0ZGozbENIakp1QTM5MXpNd29Pd0NIVnlySVZjdWxYcnRwUEs0UzJEaXVveHIvcG42aUFZUWRQd0N2ekdON1NvYUswUmdBSHMyYk54cWVyMTJIdCtzM1krc2txd0UxQXhJWFpvTnVmYXE0WG9zRC9tbFgxc2NNRkFIOGpiOEIrVVAzcjlwdklKTFd5Q0wveWt0WW9tLytJQUNvRzVXUmcwS0VIbzIvZmJCeFpPQkVuVENuRXFOR2prSkZ3a1J1aDZuaGxTYVVvSjRaZjNmVW95dDc5SURRTklialA3UVJpdCtBSmh3Tjd4TUIwL044OXRUZFdqUk00amtLZEN3eXJCdzVhSzRqdkZtVHVGV1JYMSsvM0ZXc3FhSDZvREFWMC9YNW9xbnFOUWxJcjN3dVM1Z0VDQ3FzdTc0dU5JNkg3d0ZsOTN0SVMzdlJPRUJJOGQ2RmM1QzUwMGUrTjJoYkNaeHZlNy96Z0hhd2tOanZLSERSaURCNTQ0R2ZJWmZzUTZtRlNIdDdLUzVmSjkyNzZEYlorc2lMVVJERjBJdEV2ckdESlBmd2ZVRkNBaXVIaWF5N0JHYWVmaFB6Q0ErZEZkK1dWL3llbDc3NmY5SVpydEgyaFFvamZKc1RyQzZkaW1Yaml1ZDhqOXdBTXlhbFVXVm9scmdpZWUvNTFMQ210d1pxYVQ1R28yd2NncnM5TnlxK0VlUVZuMFI5azdHVW9kZysrOE1uY2Z5N29FQmRzMEkya3A0UWtQVFdVRmZMc1h2Ymh1WTkydGNJK0JsaFg0VlhKQVpXUmlad2hRekZtL0NoTUdEY0dGNXg3T2hMaVJtSllxckprcVR6enR6bVkvZnpyaU5mdFJLanFGdHhRL3o1UGZyMzU5N3QvOTFsVEduU1NWbUxkRGZxSHhiUW1zZllURHQzSFRYeFFzNGQ0eldnRm9PQlliVEphL1RaZ2hVS0JZTytVVEZSOHRsZnI3clNXcnFNMXc2YW1zYkVvd1BIR2EvdXZkSEhZVS9zNlBHcUwwTE02WENtMVZ4QmY5Nk5yOGZVcnY5cnRuNk5FYlpINjhGWlNLWmQvN1R1aEYxQndiZDZibWJkTVhjL2hrdkN3Z1A5N1NxSDR4T1B3bzF1K2NVRHNXMWRSdWt3dS9lcTNnb3FNZldMUm1wb08zYnpHVlFXeEx2ZlJ2ejJJSW9hM05xa3FxNUcxYTNiZ0h5L093WktQcXJCNzAwYTRFb2VqbERXTlNKKzRyWFlJcHRJVGhDODdnUmxOaFhYN1o0TGhVbnZvTE5TSjNwcUtFQTRlNGVxY0pBYy8renFWUXJod2wxVCs4WWNTQVNnSHZmc2RoSWxINUtFZ2Z6ek9ubjRDUk1XNjdXS2s4c1Zsc3Joc09mNTB6MHpVN3Q3cUJlbFE1VE80SDB6N2F6UFZ3N1RuY2Z6cVp2SjlGNzQvUlFWejB4cmRHU3JJMjlhakVwNkQxK2g5UUZjQnJmMWZtK092dkRWSHB4VHE4bnBoNWRFeDdCenR0UHhtMGxJNGF6RzhXWHVybWdiSFNLRGZXa0hlNDdYNytYRGFSazF0ZjVZVWlHT3hMRHp5L0IrNCt3TDFLQ2tQYjMrNFo2Yk1mT2h4NzlNODBHaG94eTdoaHlwd0NGNTR3UnVld3FHSEYrSDJuMTNYNDRkUjcvM2RYK1hKR1UvNUo5cldiZi9UdlAxdkFPMTk3WE5ubm9KNy9zRHRzWnBUWGJaVVBsMjlEaSs5OGc1S1BxckVyZzNydkZPNFBVL0pacDYvZnFYTU85bTdkZ1VtZElLeFpxb0g2ZHBjV09nNm1qOXBlOTMvWE9YNmo3bmROa1A1UTYvNmlwSS9YSmxtcVBvMW1WejVEWjZQUVhBeHczcWh1YXhRVUxGZUdIVEl3ZmpzQ1lVNGZzcUpHRHY2SU9RV2RxL1hiK1dTR2xtellUUHV1dWRSYkY2eHZQRmpnbkFvYmlvVWhBZWdZYjFpcGNuSFdaUTA4WHEwSHBQUUxnajYzcllxZFA2aXBhWStHRGZ4ZkdoNkpTMnc1dnhzckIvZkN5MnVPTjNmNTRyazc3ZjRObVdDb21rMnJEQnNZUjM2VkRWMDhGRzBibVBTNXZYQlZCR0JDSERadFZmaWU5Ky90RnM5QjRrNkl1WGg3ZmJiN3BjWG4vb0g3RGUyY01YSWUxTnk5SXVxTmJMN0Q4SmZIcjBUZVVVOTk1UFRWNy8yUFZtNXBGU2ZMSnhXdGdMb21NeWNRZmpybzdjaHI3aWd4OTZ2N1ZGV3RsUmVtL01PM3A2L0dKK1VWMEhpOWZxelJWRDFVTzBzRk94ZmN4ZVk4aXRMMGZFMWYxeEIwOXNZK2c4Ymp1S2o4dkNGczA3R3dhT0hkS3ZoK3NWTHF1WGUzODlFeVR2dk5WcVJHbFJSN2ViWFFWTllmVU90Vmg2dFhBWGFDczFYMmh0WCtwSWZEek92RGtsVjE1MVRzMUg5bVU3WTE5UWNVcERzWVlKYzRkL3FrVjFWbC9TRExTeEs2SUNzL29QdzE4ZCsyZTArUkJDMVY4ckRXMFZadFZ6MjFldk1PNGRmUmZPclFHYmlTSnU2b3lzY1hGeUVPMi83TnZKNjZMWW5KMDcraWpUVTd0Yi9TcTU4dFBmTnE0V1RLeFJ1K3NsM2NlRmxYK2lSOTJscmxaZFVpWElWSHZ6ckMvajQ3WSt3SjlTOXY0a1ZnU2s4cVVUZi91OERFMmVVMGxQSlRjREo2SVhCQngrTUU0NHJ3dm5uVFFlZ3VzVjJSdVVsUytXM3Yzc0U1UXMraGlUcWd3K2VwcUlZaW1YaEJWZkpGZGYwUHplc29LZ1FoTWxRZGREMGhiT3lFeFQyRldTaS9Jc1o3YnZhdGgrbVBlN3NEWjJLb09CZjlicXZYZnF2WCtuK2ZqZjgzN2R4K2VWZjd2TG5HVkVxcEdIQlFvMWNlZjczNFNicUdnMHhlUFFuV2YrL0xSNmkveVkxNWN4VGNlMVY1eU8vcU9mTmdUdXU0QXVTU05TRldqK2tuUUtjV0RZZW4vVWI1QlVYOXJqN3REa1ZaZFd5ZHMxbXpIenFKU3dyWFlaOU83ZUdXcW40Yi9xbU9ZT2VlSzMwNUgzUGdSN2NXc2V2U1psaWtkaHJYUVVaV1RuSVA3WVlwMzcyS0J4L2JBRW1GbmJ0QW9pSzBtWHkzS3c1ZU9tRlYrREdhOUh5dkVSZGpaTmd0V3FudklidDlpYWhJVVJBaVdOOWFBNFdwVUFwN0puWUN5dVBkN0IzZEN6OWQ2WUpiQURzUFZVTFgyNUFWa2w5Rytmd3R1dksvWDhOSFQ4QnI3STlFdlVRYVdrVmN2dFAveVF2UHZOMytCTlZyUTJpbGIvcXNiVkg2UDJ1MmMzbGhoOWVqOHUvMGZNK1BSMVg4QVZ4NDdYV1hCZWdZMi8rclRoNTZCODVhTVJvUFBEQVQ1SGJBME94cmFwc3VheFl2UVpQejVxSHFvVkxFSy9iN2EvRzgxbERvMTZCV09raDB2QVFXZU9tcjVUTXpCeHJhdkZONHlFKzcvNVVLb2JCNHc3Qm1XZWNoTk5QbTlxbEg5UXFTNWZLazgvT3dlem5YdkUralBvYjJ3Y0xyaG90dE5LM3paL1AyeWwzdEQwL3Jvblh2VCtwMzl6WHdLZVg5TWFXTVdrT2I5WThOejM1MC91aXVDaVlFMGZ2aitvNmRQRXRhYlJRUnlrODl2eDlLQ2pPNjlIdmMzUmdTRXQ0cXlpdGtlOWM5MHRzMjdBRzBLSE4rOUJuTDhWdjhkQ3NTYWZ3QTQyVGtZWEhudjBqOG92Rzk2Z1g0SEg1WjRtYnFOZVR6b09WdU8zWHlrLytlcmluOE1UajhjT2JyMEJlY2MrYUUxSmVVaU1iTjJ6QTQwL09RZWtISlhEcjlzQWU3dkwydUxRcUY2RkZBNlpVNU1MZno3TEppZXRSMDhuRHZmWUxXYy9wOURaMXR4WnJBRWxEandBZzZEOWlESW9tVDhLM3I3MFFDU1VvNklLVjU5VWxsVEw3dFEvdzNKTXZvbmJuRnIwOWxYM1RKS2grZGZaSXV0V0FPUG52UVBpKzFYMWhBQWkyZkswM1Bqa3N6VU9uQ3ZweGhnNXY1djBmeUp0WGo3NkwwaHZlekRIWU8xZGNmczBWdU9GR0xseWc2RXZiRGdzVnBjdmtXMWY4eU5zV3krcGw1WWlwbzdWbWJ6M2RPQ08wTU0vRkljWEYrTVZ0MXlDdkIzMkNPdld6VjhxTzlhc2JoNGwwOHFmdGVOWE5nMGFNeHYxLytpSHlpL0lqZmI5V1ZYd2k2MWV2d1dOUHZvS3lEOG9RYjlnTHBUZkdEbGFpQmY5RjBxck1Sck9iOUZCcE1BRzhBL3RDSGxDQzU3RGRXTmhic09SVk5ZT2ZhbXArcHpka2JWcHRaT2NNd2pFbkhZMXZmdXRjT0lrRUNvbzd0MkZ3WlVtbHZQZGhOZjd5eDVtbzNiVmRMMXd3ejRua3lTQ2RrZUJhbW04WVBIZWRyTDRZTytsUW5EVDFHSXc2L2lCYzllYkQyRFV5M1lzV1RISXlJekQ2K2x4QjdtdjE2TGNvdlhQZS9KWTQvcDBpeUJrK0d2OSs2N0ZJdjc4UkFXa01id0JRWHJaTXJyNzhWdFR0M2dKWGxOOTlTbDgxV25xRHMwK2l5WTB6N3J6L3B6ajk5TS8wbUJmaE43N3hFMW44enJ2QmlyWk9lUE1QaHJXQ1JTUk9SamF1KytILzRJUWpDeU8xcVhORjZYSlp2V1lUbnA3MVQ5UXNYb3A5dTdlRldnZUVHNWVaL2xOQjJ3WFQwZDUwdmZmdm9mMnU1a3ZIb29VZXRnQWlxZlZHZUpjSTVXOEhhbnFYdVJBNFlnZnA1TXN6clVrVXN2b1B3ckZUajhMWC8rZUx5SFJpeUN2cXZPZHFaVW1sTFBxb0JqTitQeFA3ZG05dHRMZ282Ty9YU1FGT2x5dTlqOFhlbnhuWi9URjYwbmljTktVSVowNmJDaWZtK1AweXQrM2RJSU9ldnFyeGxJR1VjMEx6M0lKRGRwQTd1dzc5UG1vdXZLWG10V0FlRzI5RUE0Z2hocGwvdTQrclRpbnkwaHJlQUc4bDM0eUgvNDc1YzE1ci9HYmVBbnZ4ZldqemFCSDA2VDhZZjMza05rd3NqbmFWeUpnNzUyMjU5VHUzTmFyNnBGVlNieVE3cUF3ZWZ4aHUvY0hsR0RGOGNMZmQwTHl5cEVwV3JkMkNwMmE5Z29vUHloQ3YzUVV6ejlJZjlMUWJ5c0tyQVBsRFMwZ3FCK21XRUE3TW9nVDdnNFBWSnkxcFY1Q3VzNy9qNkQ0aE1JaTR5cHI2Skg3VkxUVFozdG9ZUGhpOXRvT2UzZjB3K0h0MnprQjg3ZEt6Y05icEoyRlNKelppclZpeVZONzlxQVIvdmU4cHJ4S1g5QnBxNmw0STRtcHpiVUNhdnlkRDFVeTlDQ0Vqc3g5R1RUb0VKMy9tYUV3NzlWaEFZc2liM0hSQTJibHZzeHowekZXZFVFRnVMcnpWbzErYTU3dzEzb3JSKytPR0gzOEhsMS8rcFc3NW5rYlVXbWtQYjhhU2ttcjUvYjB6VWJPNENyVzd0bm56dXZ3cUUwSVRmTTJuSlBQcDFSOUtESVUvNElZZlg5OWpYb1NWcFV2bHlvdCtnSGo5YnYvTlA3U0JkbE50Q1RwaE5WdnZuRUU0OTVLemNmcHBKNkNnRzFUaXlrdXI1TU5GVmZqSFA5L0FtdW9WcUsvZjZ3MFBRUWN6ZE9KRThWWm8rU1J0QlRDOXd0VlYxdTgwMFR3MmZBSlhTVzFOOUd0STdFcTF2ZGpDdXRwR3o2M2dpTTBRb0dzYXk1cWZ0MW92S0Iyc1JMeStqVjQ3RURTNlBIKytxeVEzdnJWK0Zrbkgwd3JCWlFYSE5HRFlTRnh4MVFVNDlxamNUdXNMV1ZWYUl3cytxc0xEZjNnY3RidTIrYldlOExaa0FKTHZnK1MrY0tIN0JBZzFiRTVxNnV6RXNqRW0vekI4L2pOSFlOcXBKOEpGRElWdGFMZWlIdm1hUURyYUpMZWxZVmR6dkFCY1BkY1JDVUNBZ25seDlQNHdWZUZ0ZjgrWjVGWEMzcjlQblA1NTNIZmYvM1g1ZXhsUlIzUmFlRE9xeTJ1a0lRNTg4SEU1L3ZQbUlpeGRVb1U5TzdmNmV6NEdJVzQvdzFJcWVNUHIwMjh3SG5yOGR1UVg5b3k1YjdmLzdFRjU4ZWtYRUF6WHdidWwvbHdyTTZmR2hWSk81MHlhOXdOakRFUEhIWUl6cG44R3A1OTJFcURpbmJJRlVuWEZVbG0xWmlQKzlhLy9vT1NqU3V6Y3VNNjdZNndxYkRBMEVtaDdaU1B0ZHlTYU9zR1k0VUZsdG83emZ4Wit5TEczM0RKRGpOS29lei84ZThHZVROOG9DRnJEU042b3NiVVRpZ2tYZGp1VVJpdHRRMGZmeE8yenFoeEpBY2EvcmY1dk52Nzl0dGNNVmVpUG9Gb2FRK0dVWTNIbEpXZGorSkJCeUQ4aS9kWGppdEpsc3ZDamN2emw5NDk3YzMyVEZzVTQrbkZLL29CaHdxMklYbFVmVG54Nlc5Qk1ERHAwREk0N1pqSXV2R0E2TXBTRDNNTDJMOXBTajM1TjRLWTd2Q1VBeEx3S1g5S01nOXc1OGJSWDNyeGhaRDFuVW9kaEFUQmd4R2k4OXQ5SHU5ZmJBMUViZFhwNGEwcDVTWlc4L3UrRmVQV1Z0N0Z4K1ZKemFQNkp4ZjdrSGt3cTk3NytuWjljanlzdTZ4bXRROHFXVk1zMTMvZ3A5dTNjQXNEdXpZU2s0a25uckhZTXp6TU00cEFBaU1VeU1mamdNY2pOUFFTSGpqc1kwNmROZ1JLM1EwMlVxOG9xSmU1bTRyWFgzc0dTa21wOHNuUTFkbXhZWXczdmVGVUhyK3FZZE5KTzNndXlpMWVFdGpVOEJuVVlKSzNBTkZVMEs3ejVpMXFDazM3NGtodzlDbXh0eDJST1h2NUljZklISkh2bHBGbkVFa3kvRDQ2aGNRdUdvQUYzMG4yZnRFZXFtRGxyVmxYSm5pWVFiT01GM1RPdDVjY3ZPQ2tuM1I1cjJXcDIvOEU0N2F5cHVQRDhNenBsYmx4VldZMHMrcWdNdi8vbFgrQzZkVEJEN2EwYU5BMlc1a05FMEx2L0lQemxrWjlEcVl5VXRmTFp0WGVMOUovMXpSUU1tN1ppd1lOU2dKc0licTRDNEFKRi82aEhWb2UzeDJvdDA2eFlmM2pJeU1MalBiQmpBUjFZdWtWNHM1V1hWTXZjMXhmZytabi9RdTJ1YlFDQ04zWHZQYzF1TXdEMHpobUloLy82QytSUDd2b2h2VlQ0ejl4MzVLYnJiNE1laExLR2xLd3FDZEFwNGNUZVdCMSt4U0NvL2tEUWFGak55Y2lDQUJoODhCaEFCTEZZREltNGkxR2pobUxzb2FPUVNNVGhxQXlzWGIwQnE5ZXNCNVJDdzk1YTdOeThDVWpFSVpKQWVDNlhtZjhVekVzejMvT0gxNEVnMk91L3ArYithVzQ0cG4yWDNlUnBPL2lFWW9XZHhwdllOOXJ2TnJsMWlkOXFRNElIRUlEajlOSVZhN05SdVNCbjhGQms5ZTN0TFJRUTF4dUtjMlBZdEhxVkZ3cjF2cXdpOEU2K2t0ai9NTDBWb0VMUFQvdXg4Rzk4VWd5MWUrWWxUWXZZLzMyY1hKWDNkbkZRb3BDdzhxKzkzTW44TVd6OFJGeDg0WFFjYzNRUjh0TGNRNjZpdEVhZWVuWXU1anovcW03MmF4NldwS0Z1V0IvVTdBOGwvckN6d3RrWG5ZTkx6ajBEdVNsNG45dStiNGNNZlBweXRDcDhkWWpWSmtUcDFLWmJoaFQ4dlE2OUs1dGFzTkRjYTZ0dHJ6dnY3bFRCL1dwYS9rRGhxYi9kaDBuZGRDNHZVV3QwdS9CbWxKVlV5NGFOVy9EQUE3UHdhVWtaQU1CdTV5RDZqZDRCOE5zLzNZR1RwMDNwRVMvRXF0SVZNblBXUzVnOTY1K3dUMkxTeFBCWjgxUWJmbmIvbDJGUEt4ZGRCdlFtbklkL3hweVM3UjNRek5YYUovWHdRb0pnN3BPNWJIL3pjd2xXR1loQXI2SUxMaUhVQkRXNWYyQTM3OE5teDVOUUhGT0FpS3R2YTNpY3lRejkyRlU0RmNzRUFBdzUrR0NJQTV4d2JCRVVGQTZiTkJwSEg1NEhwUnlJeEtDY1JJZFcxNVV0WGlhT3FnVml2ZUNLZzJkbnZReWxlbUhidHUxWXVuUVZYRmV3WmVWcVFBRnV2QzQwOWNGKzdCdk45UW90SHJHZk1xWnkxb2FEdEI5elpWOWE4RHdURVRqNitSYkx5c0h4SngrTHE2NCtGMFZwcnNaVmxDNlRwNStkZzluUHYyS0ZPT1dQUW91NGNKUit6TVVPY3ZhOFBnVW5sb1ZMdm5rUnBrODdya1A5R0xmdTNTU0RuN2tLd2JNd1RheXdaQ3JDUUFJRFZnbEdmeEJIZGxXNnQ4Y0t2L2Y1N3k1SzhOamZIK3FTbm9GRXFkSnR3NXV0c21TcC9PcDNqNkI4L3Z2Nmc3bDVVd1lBd1NIRnhYamhoWHQ3ekF1eHZHeVovT3J1djZMaW5RWDZLNDBYTEFTVHkxdlNrZkNHNEtSbjFUSENjNTlNNWNNN3RFWmI5U1FOellYclJ4TDZUdkxKUGp3eEg5WVFZUGd5MDdkSW9ZUDNYU3N1WCtsS2xEOVVobUMxcFJrYWRXSlo2RGRrQ0FZTkc0RDhnb240N0dlT3hOaVJneUd1UXY3aDNhZDZVRjVTS1ZBS3E5ZXN4M3Z2bHVPVFQ5ZGczZHBOMkx4cUZaQklXSFA2d2tQQTVpdm1Rd29BZjNWcGErL0hwaGMrNkV2V1NURzBPTUI2WGc0YlB3RTNmZmRLakQ1NENQTFN1RnExcXF4R25uNTJIbDU1N3BWUUpTNm90dWxoWmZ1RFNoUHRWckp6QnVLcTcxNk1ZNDhvUkVFN1F0dy95MStWTHk5NHVCT0dUZTJwREs3L0hCKzRKb0Z4VCt4cjNBb21IYXpGTFBiOHd5OWQvQ1g4OUxidmRKdlhEbEZiUlNLOEdaVWxTK1hXMis3RHlwSnloQ2FCQWZqcjgzL0M1RzZ3R2pKVktrcHI1RmQzUDRMeWR4ZjZGUVcvK21aUElrOGpjMVhCTmtCQkpTTWNwcXpUY0ZNOTBaS0gwRXdsQk5hY0xQKzM3RDBaN2QrM2gwM043OE1mYmpNVkhIcytXSGNVcXJvcEJWY2Z2d2tyVGtZV0JvOGRpd201aCtLa1l5ZGg4dEZISWlieHlQZWxLaXVwbGhnVVpqMDNCNnRXYmNEeVphdXdlL01tdUluNlJ2TVZnd1VUelQvSGxmSUc1cFEwdFdvemFjNmRQd2ZPdTF4N0V3MnpZS05Qem1DYytvWFA0cnl2blpyV0xaVEt5NnZscnQ4K2hwTDU3OE1PbmQ3VUVIMUwvTVVPL3EyMUR0aTdVVVBHVDhCTjMvOEdSbzA0Q0lXSHQvNTRiLy9QbitTMlpYTlRjRXRhRTk2Z0Z5dzQvcGNHckVsZ3doUDcwblgzQnF4cXJFcjY4UG5GODcrRW4vNzgra2kvcHVqQUZxbndCbmdOTXQvL3VCTDMzL2xudUc2OS8ybnF6QXUvakR2dStIYVBlakZXbEM2VFg5LzkvMUEyLzMzL2E4RUg4ZllNRGJhMWt0UlV4Yyt1ZUFWVnQ5REtXSC9FTTNraWVYQ1o0ZDVwd2UvRGZEZDVJVUxTei9xVDY1dllxZ2hvUEttKzZ6Ui9uL2ZwUHhnVGlpYmk2TU1uNHBScFV4Q0QwK1AzbURXcWxsUkxRZ2tXTDZuQm5OZm00OU9sYTdGbnl5YTQ4WHByMkxTbDU2eGRZYk9IVHBYLzNoQ3U3OXFyazAzdnVmQXdwVklPOGs0OEZqLzh3ZGVSb2VLWVZKQ2U2bVpWYVpYODhxNlpLSC92ZlQrMHV1TDZyeWZ6U3ZFclY4cXg1cjRHeTB1R2pEOE1mN3puNWxZSC9CT2Z1MUhlMjdVc0JiZWdOWFBtM0VhL00ybGhIRG12dHllOHRhTVNib1ZnTS9WRENYRFNtYWZoOTMvNDRRSHhPcU9lS1hMaHphZ3BxWkFmM3Y0d1BsMVNBZ1VnWi9ob3ZORUR0ejJwTEttUjMveitDU3g1K3gwZGlwS2IrQ2E5b2JXeEVYTDNrZjRoeXNhWGI0WjdyYmxsMWdJSWI3VE5Ec25LS29Ba3o4a0tWM1g4WG1nbTRPckNUMWEvZ1pnMGVTSk9PK1ZZSEhkRWJvOXBNcDBxVldVckpLRVMrTnV6czdHNGRBVldWaTFEd3V4SGE2OG1CcHFvMEFWVks3dHFxK3lGTmNrZkhDUWMrcE1YU3d3ZU53RVhYM0lXVGppeUNMbkY2UW5WUzBxV3lpMC91QXViVnl5M3JycUp1VnJXc0hMakQyNE9Kazg5RHJmYy9BM2t0ZEJDSlB1eFM2VXVzUWV0MjZLd0NTMnRKd245bkFPNHB2TG1YVi9CVzNIMGZxYys2UUphKy9wWExmNWVFTlh0RDUvaEJWaER4bzNEN0RrUDg3VkhrUlhaOEFZQWxhWFZNbWZ1dTNqaW9TZUJXQzhzTEgrNVI3NFl5eGRYeUx3M0YrTHhCMlltcmNwREV4VTRQWThxZ2c5ck13MFUwcXZSQ2JHSlFLd1AwSzdTK0JIWlhpMXB6aEw2OXpPeSsyUE14SVB4bVpPT3hQVFRwbmFvbGNxQnFxSzBSaFo4V0lhMy9yMElOVXVxc0hmM05pdmdxRkFseWxGZWQ3RkdRYzE2Wm9seW9lQllxemtCMHovU2ZNMXVGSzRBWlBjYmlQTXUveUttblhJVThpY1hwUHd4ckNtdGxrL1hiTWJ2N25rRUd6OVpFWHpEcjNxYlkyczZnTnFWNmJQUC96SXVPdi8wSmhjMTdOcTNWZm8vL2ZXT0hXeHJ3NXYvODFhSEFBSHk1c2JSOTZPNnBQbXQ2V0FXK3VpcEhoRHZjWWRneUlSeG1QM3FuL2xhcE1pS2RIZzcwTXliODY3ODlPYmZvcUYrbHovNXQ2VU8vSzBYdFVwZEt0aHJhZlcvL1luTnNGWjhtcXFCZHpaWG9iWVk0ZDFBb0J6MHpobUlJNlljanV1dlBnOXdYZVJPN2o2TENucUNpdEpsOHVHSFpaanp4dnRZWGxxTjJwMWJFWHFNL0xsTnNJcHlTY0hhLzJld2lqdDVTVVB3ZUFmUGhWZ3NHeWVjZmhLdS9aL3prRGM1OVpXNHNwSnFXYjloRTM1eHg4UFl0WDV0YUtKOXFPWnVWUTFkdlJMWlg2Q3RGRlFzQzJlZU94MlhubjhHSmxraDdyNzNac29ORlMrMFljRlRSNWhoVmRPc1Y5QnZyZURnRHhyUXA2TEJ1dlkwSFVmb2c2M1pOczhMY0VNbkhJWlhYMzJRcjB1S0xJYTNpS2tzcjVFL1BmZ3MzcDN6SnZ5Vm5sYjFJSDByTDl1cU5XR3dxVldwblhoTVNZc2VJSFlqQzhPMEpyRVhWeWpyeENCUUtvWWhoeDZDTTg2WWdtblRQb09DQTJUT1duZFJXVklwSDVRc3hULys5anBXVjMyQ2VOMHVOQm95UTlCbDN4OTZEYzJIUW1qK1pDQjVkYmU1WEFkRlU0L0ZMVGRlQ1loQ1FZb3JxbFVseStTOWowcnhsejg4amRyZG03MlYzS1lTNkRkbVR2NndaZzhXNnNwdlZnNXV1T1YvY09SUmVjZ3ZQRXdWUDMyTmxPNWJqK0JEU1JyWis1b3Fiem5SMEpVdURuNXFUMmp4U0JvUHdMK09VTzFWS1F3NWREeG16M21JcjFPS0xJYTNDS3F1V0M2ZmZMb09QLzNCM2ZwRUZXN0E0ZWtwbGJUMDNnNTdYcHMzNnFUMHpCeFh6MXNMTjhwVk1Kdlh4ekIyY2hHK2RNN25jY3pSRTFIUVE3Wm9pN3JLa21wcEVJVTNYcHVQVithK2k2MHJWdWdXSlUxVnBNTUJyOG1LWGVobllTLzJoQWtGUThlUHh3OXYranFHalJqU3J0WWR6U2t0S1pmWDU3NlBKLzd5SENUaGJTZGxtbEhiaCtpSTJUWXYyRHJOZkRBUkNQcjBINHFydjNzaHJsLzlLSFlPNzRUZ0J1aUFMRUZnaHNMNDBqZ0d2clN2RFF1dTJqK0s0QStUK3ZNa2c0ZG15UGp4bUQyYjRZMmlpK0V0d3NwTHErV3BXWE14KzlsL0JpdnJsSUpJSXFsNkZBMmRQK2N0UE1IZGExUGllazNnOVpDYTE0TEVxN1FvT0Rpa0tCOWYrdktwT1A3d1BFeWFITzMySFFlQ3lwSWFXYjF1RTU1KytsWFVMSzdDM3QxYkFkaHpGYjJmczFkT202cVdDVVBXV0NYc0VPLy9udjd5a0FtSDRjcEx6c0xrdy9OVEh1S3FTcXZrcVZuejhPb0xzME9OZnB1ZXJKL1Vwc2VxMGkyN3BBKzJqNDNwVU5YQ2UzK0hQemM1M3ZXNDhGNVFya0wrV3duMG1iK3ZpWVZYSGJHL0E3V3JlK0VXTEVQSEg0clpzLy9DMXk5RkZzTmJEMUJXVWkwL3VmMUJyRnhTRWd6L1dTdXIycStuVk8vMmQvUDBDZGdQdmtIUHIyQm9MWVp4eGNVNDU0c240ZGlqaXBIUElkSElLaTliSm80a01QZTE5L0RxblBuWXRId0Z6S2JwNWprUUhsYjNKcmNyN0c5SEVmTWxGZnExUHYwSDRwdlhYNHFqank1QVlhcUhVOHVXeTYvdStuOG9lL2Q5M2VNdTNPZXcwUlpqMXVyYzJvSk1yRG5Ld2ZZeHNkWmRXU3BHTnEwWFZmWnFGK00vU0tCM1pVTVRxN1hUUlRYNStFNDk0elQ4NFk5c0ZVTFJ4ZkRXUTFTVzFNaXFkVnR3OSs4ZXdlYmx5NU9HVUE5a0xRZlFvSitXV1l3QURCNC9EbGRjZWpZT24xeUFRbGJZdXJXcXNtb1IxL0ZHQWtWQktSZHVBb0RVUXptWkVBWGtGelYrREt0S3EyVEJSeFY0N2ZYM1ViV29Bb242M2NIRXNxUUE1QzlSYVdMdjFYRGZ1S0RLazUwekNOKzQ0VUtjZUV3UjhndFQyMEM4c25TWjNIcmIvVmk1cE1RYktrV3drQ1lVNE14ZXNxS3c2U3ZaV0ptYmdVWUxPL1luZWVwbld5a0FyZ0ljQmJqQXdOVU5HUDlrYlp0NlZMYS9HcTgvbUNrMFhxR3YrNEwrdklmMUJhVURDOE5iRDFOWlVpNHJOMnpGdmZmTXhLWmxwaEZuK0kwNjNHYkFXNjhXcmlpb1VFdU05a3ZGZ29UOS81NS9udlViQmR2OTJQVHB0RkdIOWFRSjYvNEtSQ0FyWnlBdXVPekxtSGJhc1UyZTdDbTlLa3VxUlpSQ0ExeTg4TnpyRUZld1k4ZE9WTmQ4QWhFRjVRTGIxbTlBb3FFZWp0NmR3cHNHTDRnbkdwcjR3T0k5MWpFZDRNUk05b2NnRnN2RWdGSER2TzlEY01KeFI2RUJDWlNXVjJQamlnMm8zYlc1NHpkSUI0YXMvb1B4amVzdnhHZU9LMGhwdzkveWtpclpzSDRIZm52UC84UEc1Y3U4VjdDMU90VmJoT0Y5YWZkUnZiQW1ONGJkaHpoNkdMUDFBYXI5ekdJRkFPSWdiMkVDZlYvZm0rYnJ0UGdWVWRjN0ZtdUs0emtYZlJrL3ZZM2hqYUtMNFUxYlhMWlVzc3lxTkVHSE5uN3VEaXFYMU1pNjladHgxejJQWXVPS1pVbTl6SkxEV1JOaHpXNDkwRVZhODZrN0hBOU4yNDdHUTFyQkRCdTdUNWEzR3UrRWs0L0d0Zjl6SGdRdTh0cXd6UkMxVFZWcGpRQXU0cTZENTU2Ymc1MDdkNktzYWlYMmJONkcrajI3NExvSlFCTGhYMnJVT3k5NUhsTm9SbE1USzRWaHJTb05uZ1ZCYno1NHdSQkJwY3B2cXR6NlJtYlkvd2NUYTU1Y1JoYk9PZmRNbkhmQm1Ta2RmaThycVphU3hWVzQvOTZacU4yMU5iaE92YnAyWDE0dnJEODJocTJqSFBnZlhqcHIyRkx2Q2pGNFhUMkdmUVQwS2JHMlErdTAwUUdydFk5K0g3enNta3Z4M2U5ZndkYzZSUmJERzREZi8rNHhlZktoSjcxVmFRcFFzVXdNUGZnUW5IQjhJYVorOW1pTUhqNFVlVVhSYks1YVhyWk0wTkNBdTM3L0ZKYTgrMjVvNWFRbjZIenV0WTVUWGZEbTJsNHFtTnRuSnFzbE56SzFxbXplVFJjNEtnT0hGT2ZqK20rZGh4RWpoeU9QODloU3JtSkp0VGl4RER3N2F6WktLcGRoMi9xdDJMNXBJeVJSRjVwVWI4Y3hwVlF3ajh1RURJZzFYOGxxL1dETjZReTFkMmxpWldHajFtOVdsZGF2VURYcWxZWU9QLzNOM3JYSzMrWEJ1OHhZTEJPbm4zY0dMam4vckpTR3VQTFNLdm40b3hyOC9zNEh2RDFqOVMxY2ZuNDJ0azNJOEs3Y2hSZW9sS0RqRzlPM3hJRjVkQWF1aldQYzQvdmdKQTB0cDA0VGwrYy8yQWgvVHlrOCtjS01BMlliT3VxWkdONEFIRmZ3QlpGNHJkOTIxZTdZN3ExQWM1Q1ZjeEJHSFRvR2VRWGo4Ylh6VGtlbUc3MHFUV1ZKbFR6MTNHdVkrNC9YRWEvZGxUUjhpUDN2TU5CdEJTSE5OQ3ROL3A3OTk1eGhvL0hscjU2Q2FhY2VpNExEVTk4bC8wQlZVVklseW9uaDZhZGZ4WUtGSmRpNmRpUGMrcjFCM3p3emxLZFBwcUozQUZIMlBLU2s2cGovR3ZTSDlnWEpRLzlBRTlVeGUvSysvc25raXAzWllzckxoa21WT0lRNko3YWdwZGRKTUh6dldPMUZ2T3NEWWs0V3pqcnZiRngwL3FuSUxVcmRjT3FTa21YeXM5a1BvUHJ0U3V3OUxBTTdCc1N4YlhRR1FsTUdBS1MvWFlnZU1vV0RDZTgzWU1BYmRicHRpNk5qWFZ2NlFMWlh1QmVlQ2V1UHZmQmd5aGVURUhVbWhqY0F4K1dmTFFtM0xta1kwVnJKQmQwdnlWN0JxV0xvblRNQVF3OFppY09MY3pIMWhNa1lmZkFJSUJGSGZuSDM3cWhmVmxvakgzMVlpcWVlbkkwTks1YkRzWnI4dHI3cTFqMENubjNTdGR1VW1tMXhsSk9KNGhPUHd2ZHV2QUs5M1BxMGJHMTBvS2tzclpKRkgxVmc3dXNmWUZscERlcDM3WUFyY2UrYnB2MkdHZTFzTkpncFZwTlp3SzdCaFVLVENvWXVneTJPd252UEpnZjBvUDl1VU8yeUE0SnBEZUsvdG8za0ZacEFDOE9LYlhqdSsxdEQyZi9XUVZRL2Q3TnlCdUdxR3k3R2NVZDNmRFh6eGwxclpNR2FFbnh4L3A4QkZkY3ZpcGczSEMwQUhBZHdFNERLYVAxdGFDOFJ3QkZrclV6Z3NNVXVza3JyUTIyRTA4NVUzdnk1c1RxY3gzcmhpZWYvaE53VzlvQWw2czRZM2dBY1YzQ091UEY5K2w5QkY4NmcvNWV5SnNjblRYb0hZQTg5cW93c0REeDRMQWJrWktNb2J3S21mUFpvakJ3MUFCbXVJTGU0c0Z1OVdaU1ZMcFVZZ0Z0dit4TldsWlNpZXp3WDJ2YkdMa3BYTmV6SFIzZFF2L0t5TTNIazVBTGtUazd0U3I4RFRYbEpqWHk0cEJ4dnpIc2YxU1UxcU4yOUxkdyt3eDluVkVsQnhkN3h3NHB2Q3ZvRGc1L3dyTXZSbFM4enZHODEwQTJHeUZXb1lvWW1ya05mVTlLL3cxV1kwUHc1dS9xc043eFhUVjZHZlRuTkMxZndsSFYxVGV4TnFvQ3NuRUc0NXZxTGNjeFJ1Y2lmM0xhcS9yYTltK1Q1OGpmd2s4cFhzYUZ1Ry95TjRNMktUMlVXSnBsRFQwa3ZvUmJ2QVNoZzNGSVhnNTdiQ3hPd25UYk5KMnpGZGV4dlFST0Nqd2JCanlwazl4dUF0ejk4anU4SkZHa01id0RPTys5R1diR2t4UC9VN2djQ0FLR2FnTktkekszM2Z2L2twSUszZXY5M3JVQ2hZbGxRR1prWU5IbzQrdmJOUW1IaEpBd2IwQThuVHpzUm9vQmVFa051Y2VybllKU1gxb2lJZ3VQRThkeXovMEdEeFBIQmdpV28zMXVMblZzMnc0M1hKUTB4bVZ0aDY2b3FXK3NxZ09ZMEhNdnVoeE0vZnl5dXZ2bzhGSEMxYUx0VmxkWEk2dlZyOGZnVDg3QjBTUlhxZG0zM28xWXdqeEN3VTVmZCsweEJ6MTJ6aHprYkxXN1VRNG9DZjlnN09jd0FnSWlydngrK0J2MWROTDJpT1pqL0ppSndsSFVrK3JpRC9VaUNOaEwraHpXOUlqVWxJM2JXSEMrejI0SFNrL2pOQVFVVmZXL1ZkSGJPSUh6ek94ZmgyS1B5VWRCTUZYL3o3dlh5enVvbCtHdkZmL0N2N1dYZUYvMkd1T1krTmovdGVOVTN2VTJWdDNWVnFwODVqUTFZSXhoZTVpTG53M3E0Y0lQSDBhcVlwMDk0WHFXNW40ZE9HSTlYWDMyWTd3OFVhUXh2QU9iTmZVdHUvYzd0ZXVURTY3THZoeTUvMGkzczJjN2hTZEJKZXcyYTdXdkNaeXRyRGgyc0U1VlpTYWNjT0U0TVVBNEdqaDNsRHhNQkxrYU5ISUV4WTRjakZnTWs0Y0tKWmNCTnVOaTZZeGVxcTFmNGk4ZVVFME9EbThEZXJkdFJ2MmVQZC8xdUFxNGtZSi9nek1yU29FbElFMVVDQUYwVDJOcEdBQXdaUHdHWFhYd1dqam15SVBLcmhMdEtWZWt5ZVhYdXU1Z3oreTFzV3ZrcDRNWkRRNWZKenc5LytMTFJXazlkVDdNbWlvY3FJSDVWUzRKaHpDWldpUWFWVkx0NkVuNWVodWU5QlVQbDNoZWJHdjYzcGtPRVFvVDlveWJTSlc4M2h5WXVyMlgrcFlRV1VnU3YvV0RUZXdSaFU5K1c3UDZEOGZNN3Y0dFJvd1lodHloUGJkKzdXUklTeDN1cnkvRlErV3Q0Y1h1NU5XZlFISm9ESU9FTmxVSUExMW95N3QrTmp2NTZtbC9mQ2hqd3FXREMwM3VEa0s2OHVhbHBML3FocWZjMDcrL25YUGhWL095TzYvZytRWkdXMGRVSDBCMk1IVFVLZzhlTngrYmx5NjJWYmJCT0JPWW43YUVQYTVXbUg5TDBTYVhKUUJ6OFRQQ2gyL285U2NCTmVHMFN0cXhZSHZyTnpTdVdZMGtLYjI5NGxWNmpvMHJkOWVpZ3FNOUtDRlZHOUVsVS9KTW92STNmclpPY2Z3TFhmOXFmb3pPeSttSEt5Y2ZnbTFkZGlJSTBWQ3g3dXNxU2NuRVJ3OE4vZmdHTDVpOUc3YTV0ZWpLNVptM29EaVEvUDVKUHZpWk1oYWJrQnhkbC85dGFUQkFzRUFqL3ZQZTlKbjQzNldjYUhaTysvTkJQbU9kVlV5RU8xclNJMEpHSGcxdDRRRFlZK210MERQdGIzUWhkUWJRcWJnSll3YzJlcldrK0h5clU3dHlDSDF6L1UyUi9mZ1RPdnZ3MGVYelZPNmlzM2FnYjN5WlZCdjIvbTQ5amJ2S0JXM2VqRy81NmUvbERzdUs5SHlwei9kN3hEMXlUd05CUHZCOE0xVXFUaHI3YmZxV3RXVmhsVjRqdGR3NkZLVk9LVTNEamlib1dLMjlhWmVsU3VmVGNiL3REQzZITnA1VVo4b0EzQk5QbSs2eXBONW45dmZGMGg0VUFxYXU4aFU5TCtpdldUVXl1eWtBa1ZNbE1YdmMzZU1KNFhIekIyVGorcUFMa2NlZUROcWtxclpDRTlNTC8rOHNMZVArZEQ3RjM1MVpyT0VtYU9LRkdwd0xiRlAvRGd6MXVaai9Qa2tLYjkwdEtqem8yRlJCMGxGUTZxTnA5YXNManN2cm56TjZwd1hCd01FUXFUVHk3RVY3TW9ZQzZnaXpVRFZHb09WSDNhUFBuMXdZZkhwdTQ0Y21Ia2taNkFZWmo3cGhnT0xiUG1nVHlaOWJxbTY2ZlcvYmowQ0V0WDBaU0pJWjVwNW41d2dPczBGUGtNYnhaSG4zc0JmblRMMmQ0Wlgxcm5wdGRlVXVlZGRNenBlYmRQM203b0ViZnRZZFFyTGxPM21wQko2alN4REl4ZWNyUnVQR0dpNUhoOUVyTDNNQ2VxcktrWEpTVGlRY2VlaDZMM3ZrUSszWnZCU1FZY0d3OHJJY09WRVc2bytDNUY1N0xaazEvME9ITG1wMldGS3FVLytObWdEYTRiSC9BRmdLeEoxbFl2OWZVM0Q5clhGaC9RMEd3Tno4TGJnNFFINTZCOVFjcHhPTDEySEZJbGc0K1NVRjBmMk9Qblo2NTliRzRadmhYTUhDdGl4R1ZMdnErWDU5VXo1U2toU3pwUEt6dzgxakJXeFR5OXFKbitmNUJrY2RoVTh0eFJ4Vmp4eldYWSthTXgvVW5kbXU0VDc5eCtndnJVdkxwc2J0S3plMXFkQ21oTjFQUjAzSE1XVEZwd3JpNHlENW9NSzc5enNVNDVzaDg1QlZ6eFdoYlZKUlZ5NnhaOHpEdjVmK2didmMyditvUm5PK0QrV2ZKSWFMSEJMZWtGaUF1elBDN0ExZnBMZUhNbkR1bFordjVROFhtOVIzTWdRWE04eldvd0RraTNzZ2hZTzB0NnJVSGNlQk5MZk1QQjhFd3FibmJhL016a2VnUDdCc2F3N1lCM3I2c08wYkhFTHpuWkZtM1Fla0tsNnNmeUhUM2FXdnhEdGJIWXFwcXdYdmlRWHVCUHUvWGg1dGsyL2RGWnp6SFFzT3pDcTRTVEpxYzI4WDNHVkZxTUx4WkNvb25LY2ZKRUNnWGo4K1lpZEJxdHREOGt0WUZ0K1FwSndjT000L04yeXpiUDJuNVEzTUlwZy9xMEFZeEZUZ0hCU2NjaTI5YzlnVU1Iem9JK1lkMzc1NTUzVWxsYVpXOHY2Z0tqLzNsZVd6ZnVNNmZVNmlTaC9iOHFaeWlLejVObFdvNm8zelRtUitBeEQrWmk0aTNhaHhCQVd0ZmJpYmNMQUFaZ0dRNWNIc0R2UklLaVYxeHFBYkFxUVg2VkRmQWhjQlJqamVIVGM5WkN3S2d2am42ZWU2R0ZoTjQxN2N2dHhla3IwTERJQWViUnlqVUE5ZzdPcWFIRy9YUXFELzNVODlkTXhsTnBKdDlYa3dFZ1UzQkQzSURWd0s5bDVtNWIrRTVyMmI3d2ZSVE9yZUpQdzFHaWNKcHB4N1QxWGNhVVVvd3ZDWEpLeHl2RkJLaUVNUGpNeDROd2dYZ3ozdFRvVS9tKzlkMXFhT3JxNEptNFliNWwxbUFZQ2FJbzlHbjhONDVnM0h5bVovQkJlZFBRK0ZrQnJiV3FpaXJrZlZyTnVHeHAxOUIrWUtQa1lqWFdyVWhQU2hxVmRmODVUaCtGVm5DSDBaQ2M5K1NseWttLzczNzg3YmNFbjlGTmlTWUNySDd5Q3pVRFhLd2U0UWc0U2hzRzZXM2pWSXg2eVo2eWVtZ05YRmtITmtIQTFZM29QY1doYXpLK3REZG9meUZFZGJkcVpRWEN2c0o2b1k1MkRYQXdaNllpMzJqSEs4NloxNEl5VlVvUndCWGYxL3A2cFpmZkxPYi9xWjdlNnNXNzkzUWM4dmNWd08zSk5EM296bzlPbTArS2VoRlNuQ1MzaGZTUllMaGFVQ0g3Z3djZFRncmI5UXpNTHcxSWJkd29rcTREZUpDOE9TTUp3R0orNHZJSERod2xhU283Sit1aWJ1ZGVYTGQvMjN3K24yWmJZNTBleElGM1ViQ0c2b2FkT2c0M1BLRHIyUDBzRUhJWTJocnRmS1NHcG43K250NC9vbVhVTGRycXg2Q0ZqKzBRVStxTnkwYXpLNEQzbHo1cEJLY2VmeE1hR3ZVOEZiMjgvZU9TdlB6VklLMWwrYjI3Y3ZyaGZqQnZiQmxSQUlxTHRnOE5pTUlVVW9BMGJzUitQUFZ2SVVCM2xBbXNHVjhMd3hZN1dMNDZHekUxaVRRdTZwZVg1VjNMYlg1dlpBNHlFSGlJSVZ0dzRFNkpkZzFNbE1mandDcUY3eWpjcTBwR1RvRW1kQ0doRmVKTTQxMi9jNjJ1c1dIQTNnTEJibzR2Q2tCRU5QSDYvV1JHN2hha0wwaW9SZWhXaHZDK3crM1BjY3l2WWRuQnBiTjllVU1INGE4NG1odGFVaTBQd3h2KzFGUVhLQUtpZ3RRVUhDbzNQYURlOUZRdXd1aWh3SWRnZldXMUpGM29GUzhlM1ZXVUd2ZnU2Mi9mNlcxdWpTV2xZTVRUemtPMzdycXZKUnV6TjNUVlpZc0UrVzR1UFB1UjFFK2Z4RmNpZXVlWU1GOEtyUE5PdnpucVBnVkR0Ty8xVXl1OXg0YXE0V0ZWWFZyemFQZDlMU0E3bFNaRTMvMGNlOVJ2YkZuTkxDbHY4TGVNUXBBcitCV2hJYjJkQ0JSU2RVdHE4M0g5bEVLMjBjckRCd05EQitValFTQTJtRUsrL29BaVpqQ3RsRm1Ub0JaRVdvQ0dIUXdsTkRsQWVhQjBWVS9tTytaMzB1YWh5aXdqcTlMNzE0QUNmL3ZBOWNtTUtKVUlidXFBZjVndk4wWFU5L0hmaC9NRmk2Nm8yOE1wbCtlcVRTZjg1VXp1dm9lSTBvWnJqWnRoWXJTR3ZucDdROWl4ZUlTSk04TE1pY0g4OEU1V0VqV3pLQ0F0ZVdQZlZsTm5mUzZ4N3k1OXAyUVF3TnZLZ09IRkJmZytxdk93N0JSUTFEQXBmcXRWbDVTSlI4c3JzUmpENzZBSFp2WEpRMXR0bFpiSHNQMEJyQzJQS2VEL245bWVGZGZncGxIcHVkVjJyczEyTWUrNStnc2JKc1F3OTdld0s2UlFLaTFSV3NPdER0clRRSksvdGsyUFdXc1pyNTJPN3JRTUxzWExyTlhOV0Q0Tm9VaHI5VHFSc1BCaDRlTzNjRHc3N2Y5L2RDRXh4aWUvTnY5eUMzayt3NzFEQXh2clZSVnVremUrN0FVOS85cUJpVFJFRXpVTmNOU2tIRGx3M1E0QnhxZmJFTmQ0UGVuTzFVd1duTmMrL202Y25EUjFSZmhDMmVjeERmT05xb3NXUzdQUFA4cVhudjV2NmpkdWNYL3V2Slg3a1hwK2RIZWkydXE5NXhWYTlRTEVFVFo4L3NVNm5JenNTc1AyTlJQWWUvWVh2bzFxTGVJUWd4ZVJhdzczbjlwMHA3d0pnQWNNNHljZkdINlBVM3Y0REI2dVlzUnorNURVKzFST243Zzdic3MremNQblZ5TTU1Ky9sKzgvMUdOdzJMU1Zjb3NtcU55aUNUais2R0w1eVUvdng0cVNFaitFdWZyTlN1bDlBNVdZUnB2VzUwUTd3TFhxalMxZFZaV09hdU54aWNDQmcwUkRvZzIvMXprcXlxcEZKUUEzRnNPc1dhOEF5b0VTRjFBWnVQRGN6d05PTCtRVkhkYnBiL2lscGRWeXo5MlBvdlQ5ajcwUENxWmhzVjQ5Wi9wbWRVK3BQQzRWek5uelB4cTUvbEF4QUg5U3VxbDAxK1Ztb25hc2c5VWpGZXBHOXdKVVFzOE5jL1NXWCtZWTlkeXlBMFY3SGhZRmY1czBRQytnY1BWY1BKWHdnOXZBVllLQkpYcWVvSjVuYVlZc3U4ZE5Wcmp1Nm5PNzlGaUlVbzJWdDNZb1cxSWw2OWR0eE8yMzNvZTl1N2I1bnpUTjZpcXptRUdzK1VQUTMvTytjV0RjNThHMlZnckZVNC9IelRkL0hRV0ZYVGZIcldKSnRjQlJlT2pQejZPcThoTnNYcmtLa3FnSHJMa3hvVzI2NE9DUW9qejg3UGJyTUxrb3ZZc3BLc3BYeVByVmF6RHpxZGtvZVhlQmJpWnJWNWxnQlJpeEFrd1BmaTc1QlI1cjcyQy9xbVA5WGIvTzloNmRoVTBGTVd3ZXBmUmtmL045V0Q4YkE5eUVOZGsrd2xwNkgxRWRmY3FhSG00eEFIRjRjd0VUOElLdzk3MEJhMXlNV055QXZrdmkzaUZaejlHV3J6MzlIenFWY3BDZE14Qi9mdVIyTGxhZ0hvWGhyUU9xeTVmSlUwKy9nbGVlbjYxREFLemVVVmFZTTk4QS9LYVZCOHE3U0JBOUZQb05HNEdmL2V3YURCOHhyTlBtdkZVdXFaS0ZINWZpSHkrK2d6V1ZLNUNvM3cxWGI0MWtqOGlabm1mK25wVldiN1FoNHlkZzl1d1phVG5leXBJYVdibHVEZTY5OTJsc1dyWXNhT1hoMzNzMmE0NVhwNGUyOWx4bkNvNHp1VzFKVW1DRFVxak43WVZkazNwaFYwNEMyOGFhMVp4Nk5hWUR2V0kwQVgvL1RiTVhaOVNsTzd5WmhSRitleEt6QU1ON1hITld4VEYyaFVMditiVm9QQzZiNnVkb1U1Zlh3blhvNThqM2Z2d2RYSHI1bHc2VXQxdzZRREM4cFVCWlNiWE1ldTQxdkRycm45Ym0zdUdLQ1lBREpyQ0YyVlBJdmY4ZVB2VUVYSHp4MlJnemNoaHkwN0RhdEt5MFJoWi9YSTYvL2VOTnJDd3BoNHVraHFHUXBOMkZyQXFYdndXUjk4WS81WXhUY2UwM3Y0VDh5UVVwUGM3S2ttV3lhdDE2M0h2UDQ5aTRZbm1vU3VudDdtSEN2LzY2cmo3WjIxbkpBZlFoQVBvMkIzZUtkNzhrVGgrTVZTUDJZUE9vWHZDcVF5WmdaT2dmdHZyY05iY2ZhRS9VWExacGRiYlNjOTRjeDZ0WU9nNGdDZ1BXSkRCcXVZdmU4K3RDcldmTTg5SFZIMkM3OXVZck9CbFplUHpaUDZUbGZZYW9Lekc4cFZCMTJYTDUxVjJQb0dUK2UzN25BWDkyem40blhrZFZLNCsvbVFubi9VZU14cGUrZkFwT24zNFNFSThqLy9EMmJZRlZXYkpVVnEzYmlQbnZmSXczMzNnWHV6ZHVoRWpDdjZxZ21wVTg5QWEvT3BIY3EzYklvZU54MDgyWFl0cnBuMG5wbTM1NWFabXNXYk1aOTl3N0M1dVgxNFE3ODl2aE1YUVhXL0ZYdDF6bzZoTmpad2dDZGpCQjN1OVZDNFh2L3Q5MWVDcnhObDZWR3YxVkY5NVFxTURmdGduUVE2Vm03bGJRd3JqSEI3a09oemN6TDlBTUwzdGhlTUNuQ1F6ZDdPQ2dlZnY4QnR4TlZVUzdmbnFJd2hjdS9DSnV1K003REc3VWFoV2x5MlRoaDZVWU0zd29SbzRlaXZ5aTdyblFqdUV0RFNwTGxzb3p6NzZLVjUrZmpYaWkzZ3R3S21pVUdyeHBwbllaL2Y1MFZic1Jzd0l3MlBNeEdBSlRNTnRpZVVlWWtaMkRnMFlOUmU3RThSZzBPQWNYZk8wTUFLN3VGNlVBeEpHQWd6WHJ0dUs5ZDk3SDVxMjdVVlg5Q1hadjJvYTYzZHQxeFRONUpTSWc0dmlCeVA2dUM3TmdPTmhURlFBeXN2cmoyaDljaVJPUHljV2tndFROYzZzc1hTcWZydHFBZS8vd09EYXZXTzV2cVdRZmxiMmRUK2grOGsrT3liZXdPNzUyVTFMdThYL2ExUk1SVFFOaUFkQi94RmpNbUhFckpoVk1WSGUrL1JmNXYrcVhFT3J5SDdvYTE3cHFVM2t6YzdkYTBCM3YzdVE3cUwyM29WV04vSFNQT2JqK2pnOERWOFV4WkxWQy8vL3MxWmVqNS9YYWkrbVRSaHphZHFVcHZIdGltWmc1Nno3a1RXYlZqVnFuc21TcHZEeHZQcDZlOFRnQVlPajQ4Zmp0UGJlZ3VMRHpGNjYxaE9FdGpTcEtsOG1zNStiZ2paZmV4TDVkVy8zQlUyOEF4NTdTbS94SjFYNlRNOVVEcnpUa3JiWnpldjVrOVZheFdoYm9FR2dIc1VaRHR2cm4vTmExNW1lVmduSjY0Y3p6ejhMRjU1MlIwaFdtbFNXVnNucjladHg5ejB4c1hyN2NudzhaL2NwclU5cDJtMFR2T2VuUFVRdTY3L2dmZU93cWppaUZLZE0raCs5Y2R3RW1GWGlmaG4veDFrUHlrNld2V01FTUNHOGgxUTAwMWFhak96ejgvbkhGRUd4MkQzaVBoWmszcVB1OFFXSHdhaGZEbHJubzQ4OXhhODBOU1BNTjlhY1RCUDgyejVuTHI3c1lOM3ozNjkzdXBFdmRVM2xwamN5ZE94OVB6SGhTN3cwRWVGWGxHQzc3MWlXWWZ2cUpYZEo5WUgvWUtpU044b3NtcU51S3JzUDU1MCtYaFIrVzRhbW5Yc2JXNWN2aGRVNTN3bS9xalU3b1pzV2pybHlacldhVWc5UUc3dlkwZ09vZVJDY3hFOEQ4cVUyQS95YnUybUZPcnp3VXY5K3JkNStmZE1hcHVQcWJYMEZCY1dwWGxGYVYxY2ovM2ZZd1BpMHQ4YTVlNlhXdCtzOEkzdVV0YU5zTjhvTXo5SE5hWUlWdkZYcE5LQlhEeFZkZmpDK2NlUkltRmJDU2tocU9maUc0d2IrVi9UM0FMTnJKV1ZlUFFVc2Q5SG12VG4rL3RZOTFtcC9rSXFINW9LWUEyN3YvWUp4K3lrbWRlbTlTZEZXVTE4aTh1ZlB4eEVOUCtMdlZlQVNRT0dZKzlCaVVJMUJRMGwzbVR6SzhkWUtDd2dtcW9IQUNycmpzaTZnc1dTNS9ldmdaTEh4eklScnFkL3R6ZWt5YjMvQjhITy9OMVV6K1ZTcW9Mb1FyVEIwUjNRUmg4cGVaeEs5MDljMDBzUlhySlJZS0JmcS94Vk9PeDQ5KzhQV1VoNEhTMG1xNSsrNUhVZnJ1UXNCcSthR3M2ejZ3N0wreHM0Uldrb1lEbTZtcTlPNDNHTC84OWZmd3VXa25IbmgzWFRxWkRlOGRXQk0rZFNOanBmY3NGWVdSS3hzd1lJbENuN0pnVmFsNXgrcEsvakZZVHhuUnIvOGYvL0k3eU9NdUx0UUtsU1hsTXVmMVJYaGl4c3pnT2VXMzlkTFBNd0VlZjJBbUhBQzVSUk82K3BBQk1MeDF1cnppOGVxKysyNUZSV21OTFBxd0F2LzQxNy94U1VrRlJPTFdPYzY4aWVyQ3JTZzkzT2JONnpKenRjaCtBMWYrQkhkejF6ald2REpsM1YyVHA1NkltMis2QWdVcC9nUlZVYlpDWmozek1sNTVZVGJjZUhDaUMzckhLZXZ4YlZwWHpVOXNyOVlkNzM1dWI2anRpVGZVYVpxN21zZHlmSEV4N3JqOStuYnVnZHZGN1VERU9nazA5N1V1bzNTelhXVzFCTkhOZGlXQnZtc1RPR2l2d3FBU1FWWlZRMmhxaDZpdXJ4eWJ5anRFL0FWSENncUhGQlhoa0pGRHUvck9wUWlvTEttV1AvL2xSYnc1ZTU3MVBoWWVpamZUT0VRcFBQcmdUT1RsajVmVHBwL1U1Uzlpem5uckJpcExxbVR1YSsvaEgzOS9BenZYcjIyMGZhRDVpOStzdEZ1czVPb3VWT2hUdDkvWlhWbmZGNjlaNStRcHgrSUhOMStKdkJSUFBxMHNxWlpGSDFmaWdYdG5vbTdQZHVzRTUwOFhDdlg1YzZTbk5kaHQzN3dtdjdHRTNwYzBXUG5yUFpLWFhYTUpUai85cEdhRFcvTnozcnBKZUV1ZUhxRlVlKyt5RkV2QSsveXVlK0Q1OHd4ZERGZ3JHTFlCeUptN3p6cDROUEVCcEF0dmlEWGZUU2s5VnVGazR0SG43a05oTnhuYW91NnJ2R1NwL1BxZVIxQSsvMzJFeXJmSnEvNDE4eFA5aG8vQ2pBZi9EM2xwYnR6ZUVsYmV1b0c4NGx5VlY1eUxHNzUvQmFyS2xzdUxzOS9DSy85OEE3czJyQXZDR3BLelhMZDQ5KzhlL0JXalhqaXk1NzQ1c1V5Y2ZmNFhjT0g1MDVGYk9EN2xMN1o1Yy84ajkvN3VLV3hjdnR6cXZlYWRuQjBKQXB5ci8rMHRxa2dhMDQyODlqMFBnNnFvZVM3clZjRVpXYmp6OTdkaTlPZ1J5Ty9Ramh4ZHZHakI3czdkM05lNlRBYThYUlRnaFVySCsxRFlmNDJMWVJVdWNoYVp4dU82Q21FdEJFbnUzZGowalUvdjdmVDdJdXJEVUFDKzg4TnZNcmhSaThwTGF1VDZiLzhjT3plc2cxbm81dmk5TmYweXJuOXVjYXpSK1QwYjFtSFJoOVhJSzhydDB0dkE4TmJONUJhT1Y3bUY0M0h6VFZlZ1lrbVZMRnF5RkgvL3gydFlXVjROaWRmNUt5V0R6Y2tQWkFwS1YyMlVubFBtNnJEYkoyY1FydjNlSlRqeWlEemtGYmV2ZjF4enlrdHFaTWFmbjhmOE9mOEd4TlhuWkJXYWgrUGFQWDlGaFlhYUd2VXdTOE45MDMxQ3d2NE8wWng0elowQ0RCMS9HTzY5Nnhia0ZhY2dhTGQwQ2QzODdray9zOVVWdkdGVGlXRmNoWXZzcWdUNlZOWDc4MFQ5WjdXWnh1RnZWOWFjOU4rNXJsL0E5RTZyR2IzNjRiaWpKM2Z4ZlVyZDNieTUvNVZidi9kclNMd2grS0lwQUppLzZ6OEJ1eDRYdExkNjhBOHpjY3hSa3lTM0M2dHZERy9kV1A3a1hKVS9PUmVYWG5vMnFrcVd5Y3ExNi9EU3kvL0ZSKzk4akQyN3RyWnhibFE2VHViMlcyYzZOSC9NWmhtQXQyVVVBT1hnOENuSDR1S0x6c0xZVVlPUmpoZFdlVW0xTFBxNEFuLzgxY09RZUIyOG9ibGdVVWxRQVRTYnBYc0JFeUlROFpkV1dJdE4wbldTNjdxS1NPc1AwZG94QWdwZnVQaEx1UGk4OUZSSXFRbm1YbFptZnEyTDJtekI0TW9HZngwRHJEbUlwdUxmK3FrYjZYMnVtZGVRMmVjM1hyOExsNTU3TGNZWFRaYXJyenNYWTRjUFJXNDNiYkJLbmEreXBGeG16MXVFSng2YUdXb2xaQnBLS2JFM2YvTStwQUN3MmhYQkw3L1Y3ZDZHZFJ1MklMZW82MjRQNTd4RlZFMUpoY3ovdUFadnZ2NCtscFpXWTkvT2JkWjN6VVJlNjgzVDZwVmxWbVhhazNIODlhNmh2VmdiOXlNenY5OTQ2K2x3MzdSd3p6cnJ1SnJvYlJlc3RRMU81Y25YNnkvZnRoZDE2QmRVL3hFamNjNlhUOFlacDMrMm5SUGJXNmU4dEZwdXZPbDMyUHpKVXZQcVRtcngwcmp0U3VOVndjay8wOWxoS3RYWDE4ckxzM3UyQWFFVHY4ckl3aDMzL2hqalI3ZDl1N1JmdlBXdy9HVHB5MEdEWG44WU1MMzNZbzhRYWx5c0FDajBYOTJBa2NzVStyMjNMeWdQUy9BTHB1b1BvQnZNdTkzL0F5MEErdVFNeGxYZnZ4VEhINW1IM0VLR3VBTlpaY2xTK2VuUFoyRDU0c1YreTZpT3ZrZE1PZU0wL1BHUFAreXk1eFhEV3c5UnVXU3BmTEM0SE8rL1g0cUt4ZFhZdm1rVFhMY3V0TW95dkQ5bXVDVHMvVDI4L044MEJmRG1rVmtyQTVQZXZKTWI0NFl1WUQvUEwvRlA1c0VVQThmc3hKQTBZVlRaUDYvMTdqOEl4MDA5RHQvNG4zTVFpOFZTdmdqQlZsMnlWSjU4OWxXOCt1eEwzajZwNHZkWHNOdnhCVXZNclFuZFp2NWJjT2dIenV1dFVaaHZZcXUwb2VQRzQ1NjdiMFpCTzlzNk5BNXYwRStZYnRTa3Q5dlN6MkVBOXZPeTkyckJ1SVZ4OUs1cWdOY1dISERnd0ZWNk5YQTNXVFRWcW9xL1VuQmlXVGpoMUttNDlwcHprVitZK2lrVTFIMVZsaTZWMWVzMjRzYzMzWVY0N2E2Z29wYUM1Kzd3Y2VQeDhweUhHZDRvdGFwS2xva2dnVG56M3NXSEpVdXhhdGxLN05xOENSS3ZEMVpuV25OYXhKcWM2VmZXa2lwTGZwaExyc2cxVlY1T3FpeUZLMzVvc2dMai83eFovdThQTWdKUU1lUU1INDdQZnY1NFhIRCtkQ2hwUUY1eFh0cGZPSysvOXJiODRvNkhzV3Y5V3V0WWxOKytUZmtCMWp0MnY1ZWNFbi80RkUxVjNnNllkaTk2UnhIL3FXUkN1Y0tsMTF5Qk02WWQzNkYrWEF4dkhkQ29jcXovVUE1eUY4YlI3NDE5ZWg2bjl3M1J2K01OTDBuTHdhbGJDSmRZRHAxY2pLdXZPaGRqUmc5SEFZZFVlN1RLMHFYeXdJeG5NSC9lZjBLci9mVEVGVFExc3RRV0tpTWJDOHRmNHB3M1NxM2NZbS80S2E5NGt2KzFpckpxYVlnTE5xemZoTGZlK1FnVjVTdXdaY01XN042OEJaTHcrcEtaZ09WL0hyZDNNUER6bUJWSTdNbkxvVW9MckNDSHhwVzU1T2FzNW1zNjFEZ1pXZWc3ZUNpS2o1aUVzOC81SEE0Wk9UUXRDdy8ycDdLa1JwNTRkZzVtei9xbk4yY041aE9iTlVqcUx6aXdXb0w0ZDQ5VnhmVHZEM09uZG4yUHJFN1J4TDZYRUNBN1p6Qis5cXNiTU8zMHFXbCtQTHU0VlVoMzU1b3F1djYvNkY1dmNMRmhsRUpHYmlheXF4cjhQb29LZ0NzdXpCS0c3dmtrVHY1UUdhenNWaEI4c3FRRXQ5NVFpdXgrZzNIZXBXZkw5R25ISTYrSTFiaWVwTHE4UmxaK3VoNC92dVYzU05UdjlzODEvdUsyNURla2RuSzYrT25QeWhzQkFLcEtxeVFoZ3NXTGw2R2llZ1YyYnQrRGl1b1ZjTVRCMXJWcjRTWWFvQVJJdVBYaGdBWjdHTmJxdWVhdnByUm5zb1dIWkZVc0cxQkFacCsrNkRmb0lPVGxUOENoaHd6QjlOTk9BSnpleUMvcW1vbnJOU1hMNUpwcmI4ZU9qV3NSakJSYjFUYTdTbUVSWlFXNXBuN0F2K1d0ZmMxMTdBU1p2b1VrcldjZWV6TlhhdXEweitHYWF5NUsyZHpFNWl0dkRHOHRDczFEMVBNRmxRSkU0ZENxQkFiL2ZWOW9QOTVnaVZKYmRGM1FDOW84QkZXVzBCUU41YURnaEdOdzVTVm5ZOVRJSWNoTDhSWjUxTG5LeTViSlhYYzlncEozRnlRVkNOREVDRWpIbnBNcUl4TUx5MTloNVkyNmxsbVpXVkNjdDkrZnFTcGRKZ21KdzFFeEtDakVsV0QxcWsxNDc3MkZTQ1F5RUhNY0tEY09WM25ES3Q1bmVBZktjVEZwNHFFNGZISWVzcFMzNnRKRkFpNWk3WjdybEE0VnBjdGw3cHovNG9tSG53cnZ6T0QzYjlPc2hTREJRZzhkNnFTSkVCZGFvNUJjdG05T0I5OWN1dm9PMWM4REpVQkdWZzd1dlBkL01XckU0TFF1S2duajBHbXpsUG1QdDlMVTJ4SkwvSXJjamh4Qm55T3owUHVqT3RqQkoxdzliNDJ1Q1c1S1R6WVZNLzFDTCtMeStpOEdMWWJLMzEySVc5NWJpTjQ1QTNIcVdaK1hDODZmM29uUFVVcUY2ckpsOHVRenIrTFZGMTZGbTZpRHQrT09tUlprbnFvcUdDSVJzMGluL1FhUEhkdWx0NW5oalZxdHFaV0FoWVdIWWZvWkozYjFvWFZZK2VKUytmTWpyK0N0VitZMTdxNXRsZHFUMmlYN3ZkeVVCQWt0MkhUZWFtTVMyaW9yRmF1ZHV1dXdWZEw5QmdjblRQODh2bjNOMXpoWnZMc1JXRk1WSEYxeFM4RHNBTEZ0bElQc0JoZTlQN0tHVjYycERlM1R1YzliVTNtelY2bUxOZjNCYnJ5NGI5YzJ2RFRyYjNqNW1iL2o0TW5GOHNVdmZoYkhIWm1QZkZianVxMnlra3BaK0ZFbC92S0hwN0J2OXpaN1NxMC9RdVJDNElqakxiMHhvMEhLYVVXdnd1YWVxd3I1dVFkMzZXMW5lS01EWGtWWnRkeDE3OU1vbWI4QXB1Ti9NTXhydFNkSmJvRmlOZG8xclZOVVJqYjZEeDZNZ2NNSG9TRC9NRGh3b1ZRTXJnSzJiTjJPNVRVcnNYWE5Cc1RyOTZCako3RnVIdHdBOUI4eEJqLzZ5VGN3YmRwbmVmTHJscXlsMG80T2JrNE0vb2IxQUxZN0NqbkhaNlAvZ2xwL3BaNWZ4V2pYdElCVVBHOWJGd0JkRmNwc1Fmc2tlN1dzSkEwRjY2cmNwMHVXNEk4bEpjakk3SWVDWS9MbGlrdk93WWpoZ3p0MTNpM3RYMDFKaFh5NmJqUHUrTkg5Mkx0ckM0SUpHdVlwYlI1UENZOXltT2t2b1RuWXpUMlh3djBZN0hQQ1ZWZGQwS1gzQWNNYkhkQktTNnZsN25zZVI5bTc3M3RmMEVPazlpSURFYjJqQllLNWIwSDFRU0VqcXg4S2ppbkF4UmVmalRFakJyZHEza3hOU1lXOHU2Z2FiNzc1UHNvV2xTTmV2eHNPQks1cDVHdjE1ZlBZbTdnYlRmV01DLzdXdXJsSmZ1eHM0ckthNzJGbnIxSzIzK09jakN4Y2ROVkYrTUpwUjJOaWNYNmFUM1ppOVNwejlaQzJhbnVCcC9ITmErWHZXWnU1ZTdmZU93Nmw1OXU1L29vZDczc0tnT3NHWFRwQ3ZkYWdTN05LLzl2YWI5U1ZZTDgxQUdZUDBnN2ZkLzVmM2ZDZnVsL2V2ckVLbXgyZzN3TFRiTHFKMzkzZlpmcDNiRWNDVzdCYTNReDNlbFV6MWVMeld5VlhWdXgvV3hQV0c5MGthNUZWdkg0M1N0NVppSnZmZVIrOWM0Ymc2Sk9LNU9wdlhnRGxDdklQWjVEcmJGV2xWYkxnd3lvOC9NZW5VTHR6cy9XZDVqOHcrTEhPZmc1WUMxcnNlWjNKYzdPOUFkYlFhalFVVHprZUJjWHBhMC9WR2x5d1FBZXNxdElhK2RPTUZ6Qi83bXNJMnFGWVZUZWxUeEpXV0RQelprUXBEQmszRGpmZjlBMGNQR29vSm5WZ1Y0REtraHBaczM0ekhudnlSVlF2cWtCRC9XNy94Qk0wTUxhQ296NmhoM3J2d1FvQVVLRTJKcTBSM3ZKSVdlRTBtQ3Nrc0dLY3NpS2YvM01PaXFlY2dCL2NkQm55TzZrTnd5L2Vla2grVWpNYjRVM3BBVys3cHpaY1VIdkRtMW1wR1NSOWE3S2pBSWhaQ3lqc0NvQmp6WjAwUVcxL0RZWk5JSFgxZkxRWU9tMCtuM0xRZjFVQ3c5Y0RPYS90QVpSalRRdm9MTXFhVTZxQy9Ob0o1eTYvU1pLL0g3RjNuZG45QitPWUtVZmlxcXUvZ3BnNEhXcDNReTJyS0syUjErZTlpMmVlZkJuN2RtNUowWHplNEhYcmY5ajFlNkVpNktSZ3o1MEQ0R1RsWU9ZejkzVDVUakNzdk5FQmEvWGFUWmcvOTNXL0RZcUNuaDloRHczNTVYZnZCQ29BSms4NUhqZmZkRVhLRmx2a0ZVOVVlY1VUY2VxMEUxRzFwRW8rS2xtR1J4Ly9KemF2V0c1OVpyUjdjbmtoempIVkJ3WHZ5Q1U0MGFqV2JIeHZ2Vkc1a2xSOXMzNWZyR0FiaEJScnF5OG9ERDVzQXU3KzlmZFFORG45dmZmU29sMDV3QVF1MDJaRGVWK3pHOXVaNEJiTW1MZnUyd1Q2ckJGa0NkQnZaeHg5dGdqUXk4RzZFUzUySGhyekFwNHJWblVQZ01xQXR5ZHBaOXduRG9BRWRvN0pRS2JVbzFkK05ucFg2TVVMcWpVQmJ2OVZ0OWF0aERhL0w5N3FVS3VvMmpsYmN6WHhldENWOE5xZFcvRE83TmZ3OXB6WDBidi9ZQnc1WmJKOCtRdWZ3NmlSSTVESHhRNHBVYm1rV2xSTTRkZDNQNDZ5QlIvQ2pkY0JnSDUvN25od0Y0aS90WnBmMFRXZnJSRHNPK0xQWDRiM3dlblg5OTdjNWNFTllPV05EbUJubm5HdGJGNitGSzZ5VGc3K0NkZi9lQTlBUVRtOWNPSnBVL0d0YXk1QVlScDNjekRLU3BhSjR5VHdtN3NlUSttN0N3RllBY0QwM1FzT0Q2Rm1xMjN0SUo3Y1dObWYwQzJoNEdhcUh5TEJ6d3liTUFFMzNYZ1JSbzhZMlNYemdacXZ2S1c1VlloeS9YbFQvbm5lUDkrYjY5YjFTdjNRREZnanFGZkFpSTJDWGx0YzlOb3R5S3FvaHgwMjFwM1hCMnZIQTNBY3EySm45Mkl6QjVEdVZpalcwQzBFQjFjSWh2NXpuM1c3MHMxN0JubzVPRHk4TDdCYTlxVHgrdTNYa3oyRVprOUxzSGNTeWNqcWh6R1REc0ZYdm53YWpqZ2lGNFZzQk54bUZlWEw1TFc1YitOdmYzc2RPemVzQzk1ellIMWdUVVU0dDk0bm05N0dNRWh5U2hSRU9manRIMi9ES2ROUDdCYVBLU3R2ZEVDcUxLbVNUY3VYQXJxVmhaZGRkSlZMZ3FIS0RDY2IwOCtiam92T1A2UFRoZ0lCb0ZBM1dYNzAwVitpdkdTcC9QMXZyK0dmczE2RUc2LzNUMXlPS0wzYTFWcFk0ZGZEV2hZYWt0VW5SdS9rWkU3YWVxZ09qbDZZR0F3bkRCMTNHRzY4OFZLTUdURVkrVkd0dG5XVUg5RGNZSzZhUDJ6cWhlM0I2d1JaRFFyWm0xeGs3aFRFZHJ2b1hkNFEzT3VON2ptRm5KbzRCdlhKd05ZUjBFT2tnRmR0YzRLNWRKMHhiR3JtNXlrdndPM01jZEgzOEV6MFdWemY5ZzhJN2J1RC9lMjRSTm5WWjJzT1VpZmNCZDZSZUZYNW9IZ2F6TDJ6ZDVhSjErN0NpcEpTM0x1a0ZJQkNkczRBT1hycUVUam5DNS9ENk9IRE9FOXVQNnBLYTJUMnZQbDQ2KzJQOFVscHFWL3N0TGRrOU83eXBvSmIrNE9jUHhYRmFqVHZzWWJKQllCeThKc0hic01wcDNhUDRBWXd2TkVCeW9Yanpkdnl0d2Z6M2hRYzhkNGVzbk1HNDVydlg0SmpEcy90OHNhZEJjV0hxWUxpdy9EVmM2ZkowN05leGV6blo4TjE2M1FQTld1UmdwaTVjV2pWKzVscnFvcjYzNEpnVHArRFlJbTlxeThvNW1TaWVNcFJ1T25HS3lLeXRWQUxBYWY1VGdBdG53K1VBN2ltdFlZRHVDNTZyM0VoY0hId1JnVm5pNHZZSGtGMlpiM1hNa1lQcVFZWEs3RDNIaGJsUFJiOUZqZGdjNjREZjFqV0Q0YW1MNDJwbEtZN3dEbTZ1dWpkeHUxak10QzdyZ0Y5bG9TSDFkTXA2TGNZckNSc2RyRnJTcS9iOVN1NVNnRktISWk0Q0QrQzVnT2ZxWVlycXptNW9IYlhkcnd6Kzk5NFovYWJjQndIZlllTmtISGp4K0N6cHh5REU0K2FES1VFa3pxaGt0L2RWSlF1RXlVdW5uNStIdDU2ODMzc1hMY20rR2Fva0MzaHFsaVRJL2J0ZkNKSThwS1hZR3FLbzF1TUFBb0RSb3pHSHgvOENRb0t1OWR3T0lkTjZZQlVYVklsdjd6N1VaUy90eENpUDJGbFpPY2c5OGdpWEhIWldSZzlZcERmdUxpN0tWdFNJODgvUHcrdi9IMHUzTG85d1FsT3Y5R1prZC9XdktrRkN4QzhDb2NabHZENjAzbTl2M0tHajhMWHYvRkZISGQwY2JlYm1OMmhCUXNkRFc5d01IQlZIQ29PREZrdmlHMFRPUFV1c2lzYndoZGlieE1HOC9oSXVMSVE2Z2tJN0RtbU4zWk9WRmg3aUY2Y1lBS2NHUTcyRjBHa2tUOTlJRmo5T21CTkFzT3FFK2kvb0w2VnE1azdmQUQ2cndxVHA1NklrdmMrZ0NRYU9tbk9HNnpXS0xyNlkwMGI4R1lybU9WTk9wejdyU1NTNnQ5SlEzSm0yTlhKeU1iQXNhT1FsM3NvampxNkFNY2RQUmt4UnpDcG9Ic0ZoWTZxS3EwU0VRZFBQejhYQzk1YmdpMnJWZ0h4QnVzNXBQelpCK2IxQVZqVk4yc0JWVkQrN05neCtmdFIrOVUxUFVWRXpBY3BoUzljOUJWY2NPNXAzZTU5RDJCNG93TllSZWt5UVNLT3VIS1I0V1JBZ0loVWxEeFZKY3RsL3FMRmVPTC8vUjA3TnE3elc0c29mNHBWeXljNDgzUGVISHZkQThseDBIL1lDSHpwcTZmZzlHa25kdXZtdWwwYTNnVElmU09PZmd2ckFZaS9ZdGRlc1N6MmVkeWFzeGpzekJHZWErTkFlUlZSQVpaZDJCdmJEMVZCV0ROejUrQ2tQN2dCUWFYUDIwL0t2OTcrcXdVVG45amJ4Z3RyUjVoSzZxdW9Nckl3Yzlidk1PdTUxL0R5Y3k5N25mVFR6ZDg2REVudEpHRGRIaFgrd3g3ZTA0K2x2YWJSaEdMN05lci9TeWs0c1N4azllNkxuS0VETWZHd01SZ3daQ0F1UFA4c1pMZ0p4Q0dkT24yanJhcEtxeVNPWGlqNTZFTlVMdDJBZDkvN0dIdTM3RVR0cnUwUXMraW1pZFc3b2RlRm4rQjBoVm4vYkdoTGJTUy92N1VuckNzSVhEaDZXZ2hVTU5Jd2FOeWgrTU05dDNUcis1cmhqYWdIcUZ4U0kzTmVuNCszNW4rTVZaV2ZJbEczRTBIOUxhZ2FoTjR3ZFlDSXhUSXg4T0N4eU0wOUZGODU1eFNNSGpFSWs3cmhKODJtL09LdGgrUW5TMmRiWWFhVHFsSUFvSUM4dVhIMFhWVFhxcjVqYmJYMzZDeXNLd0Myajg1RW95RlMxUWtCVGdGQVRLOTBkZno1ZkFOV0NvWnVBUHEvdmk4b3pqVTZqNlJ3WE5OYXVEdDAzR0c0Kys0YkVZUENVOCsraWxkZm1BdUoxMXJYMTlTZjJQL1hySURnL1dFLzdidjYzSmk4WUVJUHo4ZGk2TjI3UC9vTlBRaWlISXdZUGhSakR4NnVWNW5ITUdSQWI1d3liUW95blAyL2hFVUVnbGp6MXk0SmlNcUEwc1BtOVc0Qy8vcmJYRFNJQXhFdjhKU1dsV1B2M2pvazl0Ump4NmJOZ0J1SFNEeEZ0MTc1NzEzKzV2S05IaFc3Z28xZ3hNRC9NQmYrc09TUHlVcjQ5OHhsRFowd0h0LzU3dVVZUDNwNHQ2eTJoUjhmaGplaUhxZWlyRm9Tb3JEazR6SXNXN1lHaWJnTGtReTRqaUJEeFRGaHdzRTQ2cWhDeE9BMHVlMVpWRVF2dkxVbDFDaXNPYjhQMW85VFh1c1IyTGVyRXlaOW1lc3hEWWI5L09OaTVLY3VCbitjUUZaRnZSV0h3aDhNT25wOHdkNlU0UlB2R2VlZmcxLzgvQVlGQUpXbFMrV3A1K1pnem5PemtZalhocmVqUzY3ZzJKVlFJUFQxVUgvSDlqZjkyLzk5Mkk3TFNvNmJLdW5EV1BBRDRlb1ZnQlI5bUZCNlhuQjRqYTlYMVZiQmluY2d4ZGVyYjc5ZmxRNnYvSWQvZlNyMDRjRnU1Qnpza2hNY3Q2bWNXdnZoK05zYkhseGNoT3V2L1JwR2p4aU0zS0pvTE1EaWdnV2lIc2dNZFJZVlRlenFRNkdRdHJSd0VSeFVrOEMrTEdESDZGN2VTYk85VFlnN2NyeTYzeHRnRmswNFdIY0lrTFVIeUtxQW50eXRGOHo0YlRNNlBpZkpoQ3dUeU15SzhEblB2b2pQbkhTQ1RKOStuTW9yT2t6ZFVYUVlManp2ZEhsMjFteThQdnN0N04yNUZVcGNQZFRtd0pXRU54K3RVVHVJY0FYYSs2dEtDbnp0T25LRWY3bDlGMlJ2d3VFM2pJWHloK2Z0SVhmUjk3ODVmQmZTWkoycTdiZkN6S1VONXA2SjFiRERnYW5pbWJzdUhKWTd3dkV2SVlpdm9WNlgwRUZXejhzMHc5VmkzMjY5MENkNGhJUGdscFV6RUNlZk5SVVhYL1FGNUVkd2ppSERHeEgxVU9udWc1WmVDZ3I5UHFyRmtOeSsyQUVYa0JpOGs1SlZaVXdyY3ozbWhCa0RrUEEzRGQzVkgraHplRFo2TDY2RFVoS2VFOWJFVmtOdHZ3UDBpVGxwVmFBTHdjOXUvalVPR2ZWck1iMEZDNG9tcXR1S0p1TDhyMDJYajVkVVk4WWZabUx2cmkzZTZsQnJIOU5RYlVqc0NsdFFxVXRCemRCL0JFMlVhT2NkRUQ0U3MyVWVWREFOd3YrV2ZSdk5oSDlwL1dVM3diV2FmWnNWdFBDcmNHYnhSbEJ6OWUvUDBMelBqdDZOMW00eDlnaXFQM2NRQ0UwcTlSZHJoZnUwdWZxNFk1bDlVWGhNRVM2OTlHeU1HajRVZVYyOHhWVkhNTHdSRVhWSCt1U1ZVWjNBMEF4ZzB4akFHNzdzckNGVHh3cFFBSnlFM21NVmdLdXdaWXlEekhxRjNvdnJySk9tZitBcE9FWXpiQ2R3bEtPcmUxNXNpTmZ0eEcvdWVSei9lOU9sa2xjY0RITVZIRDVKRlJ3K0NVY2RrU3RyMW0zR2IrOTlIRnVXTGZYbnREa0NIWDZDUS9TM2hwTmd6NURVM0wwZG0xQWZtdTlsQnlMeEI1SDkvOXFOdS8zb0tNMWZPbHFJbFg3TEV3VXZwTmtWVUFEQjh0Q2tlWUttQXRmUmU4OU0rYk0rQ0lnL3Q4MWtOclBxRjNvMXR0SVZZRDEwS29KZVdmMlJmM1ErTHJua2JJd2ROYXpIdEdaaGVDT2lIcXFUOXY5TUUzT0s3dnRSTGJibTl0RkRwaEphK1puK2c5QkRwaXFXdEYrUUYzWjJaTVZ4MExHOTBHOWhnejdaMmkxUE90ckxBVEREaE1IMmJVRlZiOG03Qy9EYWE3bklLODVyOUt2K2xuT25uNGlLSmRYeTIzc2ZSZWw3aStFbTZ2MXBmUDdBbTk4T0pWZ3gzRkt3c1EreHVaOXNIR2piY1BQMVNsZmxWOXpzK1ZyK0lRZXgwSjhIMXNyclVvMlBQd2htUWNWUTdIQVc5UEx3cTZMaEFkYmdjVXZGNDI4dXhXNmo0Mi8vWithNmVYY1NBQVVSRjByRjBIL0VLQlFWVDhLM3J6MFg0cXB1di9pZ1BSamVpSWk2TVNYQXdFOWROR1FBMjBmck9XOGlyYzBYSFdUUHM5TWh4OVZoRGk3MmpzckFLaEhrTGF6WFd3aUpOU204b3pjY2Z1dVYwTDY2T3RRNEFqdzI0d21jZHRxSjB0endWLzdrU2VxUlIrNUVaVW1sdlBiR0Izam04UmRSdTJzTFhIak5xRVBGcXphdXQxQnQrZUUyL3F3RGI4OWgrelo3c2RrTVpYci9FZ1RoTTFpUW9WcCtma2pqSVYzVjZGL1dzVXJ5Nms5cnVCbkJKdTVlc0U5RjVjMjFxbm9tcWJwZXMyUWQ1bHlsNE1CQnYySERjZVNSQlRqbkM1L0Y4SkdEVUZBY2pVVUhIY0h3UmtTVWNoMWZzZWhQQ0lkQ3pydDEyRFNoTjd6eVY4eXFnS1dUMmVFaHFMUkJDZlJtbzM3L3Q5N0t4ZmJQWjJQQW0zVTZBWm1kQ0RySWhBcy9GT2kyRDliMmRaQUV2bjN0SGZqVGpKOUpTeHZDNXhYbnFiemlQRXc3Yllxc1c3Y2U5ODE0QVorV2xNQ0JJQ0VTQ29naXJyKzZzM1dQVkt0dlZDc0dMTTNOdHlwdDFsQzVXY0RnL2QzZUlzOGVLbTFxd1VqYnFtRitFMXNKUXFGQzBNdlFtL29vZnFYTmZNLzhxNk9yVHBXdWlKb2hVSy9RcHVCazljUEFVY053L0hHSDQyc1huSTRNRlVkK1ljOFBhOGtZM29pbzUvQlA5SjF4WGUzK3B0YkN5ZFJxQXlGUUdMb2lnWXhFREpzT051T1hlc0dDMlhYQnI0b2tnQlo2ZUhsYUNsakp2ZVhNOGsvOUh3WEFWZGc4eHNGZUNMTHplaUc3c3I1UmV3N3ZkNE4rYWw2RkRtMnJ6bGcvRzh5bzgvWTAyTDVwSFo1NWRnNHV3SFRKYjBYYm05ekM4U3EzY0R3K2Y5b1VWSmN0bDZlZW5ZM1hYLzR2YW5kdThadGNoK0tWdjBPR0NnV3E1QWZMQzl0bVFjSCtWOXUyN2RscHFtTkpDMERzblIway9QTk5YWnU1dnh1dlFMVUNxeDQyOWg4eXE2V0t2NnJWREkzYjM3ZXFmbDdHVDVvekdGckJhOTEvb1o5cjRuNVZEbnJuREVTL29RZmgrR09MY05KbmpzUFlrVU1qM2Rvb2xSamVpS2puNkt6Z2xoSXRoQmZSKzh2cWlsTy9kK3F4Y1Z5MmR4dGRIZUQ4Q2VNS2ZwVk1PZDdDZ3M2NEx4eHZpR3p2YUFkN3Q4U1FYWWx3ZnpXL1dtYmFPZ0F0Wkp0VzMyOUtpVC9VK2RJemY4UG5Qbk1NOG9zbXRPbVNKaFdPVjdmZGZoMHVPUDhVV2IxNkU1NTRaamJLNWkrRVFQVGlCajNOMEE4Y0NPYkUyVTNZL0ZDaTUzOUo2cHMydC8wZXM2cFdFdlE2OCtlb21ZWEIzbmYwUWczeDI1S1lFVkEva0FHaEtweCtFTHdqRTFnclU4WGZYc29zdGdnT1Nma0xUOHg4dFZnc0cxbDkrNkR2a0lHWWROaWhtSFRZYUp4eTJvbkljSndldDAxWUtqRzhFUkYxUXdwSmM4ZkV4YWdWM29ibjIwYWJ5cHVacUpXd1NsSm1QbHlhejN2K0tsUnY4Y1Rtb1M3NkZHUWl1NkxCUHc1ei9CSXFHa21MUmNmV1hyL1p1VXNVY01zTnQrSHhaKzZWL01QYnZpZHhmbUdleWkvTXc3VHBuMEZOV1kyOE9tOEIvdkhDYTlpeGNZME9jV2JZMks4ekJmTUFrMjZIMysrc1V6Ui9SeVoxMGJBV2tsaE5hNU8ySWZOWERwczVqQWpDbXBnV0pmcDJlNHVScmNzd2ZkV3NDcmhTTWNESlFQK2h3eERybllIOFNSTXc0S0NEY01HRnB3TGlvSmVUd01UQzdybVBkSGZHOEVaRVBWVG45WGxMenlidFFiWEh6UC9KZnJzV0RlTjZJOWp2RkhySUZQb2tyUmNZZUFlVjN2dkhYSjgrOGU4YW1Za2RoWUxzOG5ydjZwdkxGYTI2dTVxN0FOTzZJZ2doa3FqSGozL3hFTzY4N1ZySkxXei82c0tKaFJQVnhNS0ptSGJxc1JLTFplRCtCNTdHUis4dXdiN2RXL1hoQk8xanpUWkxqdC9SUDlpNFBoV1Q5cHUvZTh5QWFxaHBTSlAzY1RCL1QxZG14VTBhSGpibFVHKy9UK1h2VkNMQjg4bC9SSUpLbmhQTEJBRGtEQjBLcDI4MkR1cVRqY0xDWEFnU3VQRGNNNkI2Q1pRYjdWMWN1aXVHTnlLaTdzZ2YxekxUODcxVDhKamxnczBxZ2Myak1oRE1jN04yWEJBRmIwZUVUbWppNjVpV0pURkFDWFpueGRIdjZDejBYVlR2dHpMeG02d3FwWWNndlhqUThucFVhZjU3VmpvMDJ4eDl1bmdKWHBuOUxuSUxPNzZ6U0g2eFZ3MzY0LzAvUnVXU0dsbS9jUU1lZjJvT0toYVdvYUYrWitNaFlMdm5XV2NWM3RCY3hMVUNwdFZhMTRVYlJMYU1MQjM0bGQvemJ0RFkwVURNZ1NPQ0JGd2NmY3lSeUlnQmp0dUFFNmNlZ1RHalI2T1hFaVRnSUw5d1BFTlpGMkY0STZJZXF2UDZ2S1ZqWS9wd0tEQi9WK2o3VGgwMmo4L1dKMTE0eVVVZmhaZlhUQis0ZE44L2VqV3FxZEFJc0gxTURQVVE1Qzh5eXdtQ2xaRDI3Z1Z0YXlUU2ZBbFA0UGpEZ2FJVW5ucjRLUnd4ZWJ5Y1BPMmtsQVdMdk1rVFZSNG00dk9ubllTeTBocFp0MjRUSHByeEhENHByWUNMaEY2QWE3ZlI2SVJNWTFYMkdyZjRBQ1pQT1FFWFhuSVdSZzBiakF6SGdRT0ZoQ1RncUF3a0ZPQklBZ294NUJhektoWkYzSmllaUNLclN6ZW1CNUEzcjYwYjA3ZUZIVnJzN1g0VWRrek54TTV4R2RnNHlvRy9VYmkzMGFUMXN5MVYzanA0SCtuaE56ODV1RjQvc2lGckV4aTBNb0YrLzZuM04yZ3d3MngrY2FwTjIyZnQvK2ZDOTVBM1Iwc0E5TzQzQ0g5NTVKZkltNXplNXF6VjVjdmsvWTlLOGNJTC84YWFzZ29kanJ5RkppcnRwOWFXNzcvZS9RZmpjMmRPeFdVWG5vbU9EQ1ZUOThQd1JrU1IxYVBEVzZpMUF1QnQ4YVIwRTF3SFN5L054UGF4c2FCTmlILzl1aUtXN3ZCbUx6czA0VkZQZUIrd0pvRXhDK1BJckdvSUpzazMydlM5Zy9mWC91YVY2YTkvOW95VDhjMnJMa0JCSisxZldWNVNKUjh2cWNJTC8zZ1RLNWVVUVNUUkdWZmJETzk1b0pTM3VLVnd5ckc0OHBJek1YckVVRXdzbXNRZ0YzRWNOaVdpSHNBRUZpRHR3NlVwTysyMVVEbngyNm9GL2RXQ2FmRXVScXhRMkQ0NnVXV0ZmWHdkcmF5Rmo2TVIwMHNEc01aNHZTOXNINjB3ZEpPRHJDcnZhMzREVjkxSExUemcxODRRdDcvQ2cvNzZmK2Y4RzhjZlB4a0Z4WWQxN0g1b3BZTGlYRlZRbkl1TEwva2lha29xNUlNbE5YaitiMjlpWlhrbEpORVFyRksxd3Fzb0U4Wk4rRGM3Q1NUMVJJT3BMQ0twYXFtYUtOQmE4eUFCWFFVVWxMN3pIbTUrWndINjVBekVFVk9Qa211LzlWWGtGekxFUlJVcmIwUVVXVUhsRGZDclRjcnRjRkduV2RicExtOWVISDAvU0ZYbHpUKzl0eW9mN3N2TFJQbVhzL1MvM0dBWVU2QlhDS1k1dkxYdy9ZRnJnWkVmTkNDN29pSG9ENFlVVmQxYWVRTlVMQk5QUFB2SExwM1hWVmxhSld2WGJzWVRUNytDOGtWbGlOZnVSaEM2OWhmWWpHRExLV1dhNHlwdlA5YmcyUUkwRllLOW4xWFdaZ3ZpOTZ2elpnbzY2RHRpSkU3KzdMRTQvNkl6NENRU3lKMTg0TzFVRUZVTWIwUVVXVjBTM2d5VjZ2RFdOclVGMlNqN1lreFhXdlNPQ3E3b2pldFQwVWl0NWRzUE5IODFvNVltTVByNU9oMGpyWGx2Nkl4ajlBTFNrRU1uNEhlL3V4a0ZoWjB6Zk5xY3lvcmxzbkxsU3N4K2VRSGVuLzhoYW5kdXNVSmJ1Q0pwOTdDREpPMWJxdTlQMDVVazZIK2NQQXZRVlB2MDc0bS94QVBpVDBqMExqOHJaeENPbmpJWjU1eHpNZzRlTllMdFBibzVoamNpaXF6bXcxdWFXMlVvSUc5dVBmb3VxdXVTMjE1WGtJMmNTeWJpM1YzTDlWY2NzeDJBcnVpay8vWURhS1l5NTZML1NzSElTaGY5RnRVaHFQK1lqZVk3WjE2aVFQREZDNytLbjkzeDdXNFZSaXBMbG91b0JHYlBmUnN2L3YxTjdOeTRYZzkxV3RVMGY4c3BhLzlTOHhONnlEVVlWRFZmOTM4aCtGMFQzRlI0SVlVL0ZHdXRBVllDT0JsWkdEUm1GRTQ4NFhDY2YvNFpjQkJIYmhFYjZYWW5ERzlFRkZuZEpieTF2L0xXL3VwVExKYU5CMS83T1k2ZWM0Y09hMjVRZ1d2VmdvV08zMzZndWNQM2ptSEF5bm9jOW5TRDNwVkFXdk9MSGIxaS8rZE1SemtvaFYvZC8yTk1tL2E1Ymh0QXlrdVd5ZUtQeXZEcTYrK2o1c015Tk5UdENtNXZhQXN1aFBhOVRiNC9RdHRYSmExU3RuL0hid0N0ZjBtc1lkWFFyeW9GeDhuRTRFUEhJSGZpSWZqUzJhZGgxT2lER09hNkdNTWJFVVZXV29kTlc4cFZDc2libTg1V0lTMGNYaXdUTDc3L0NNNmQvVnZNMzczVXUrMnVudnVXN2hXMzltbTdoWnZkZTIwQ1l6NTFrZk9mT2lqbE5KNXdINTdoMWNSOHYvWUZYSDlyTGgzZ25Pd2NQUDdrYjVCWDNQMG42VmN1V1NiaXVIam11Ymw0KzkvdlkrZUdEWHIxcWhmZ1RGUGk0SzVwUFBmTnkyckpRVGZZcUY3cDZYU3UzaUxMWHpnTU4zZ1V6QUlUT3l5YWJhK2NYaGh5OEZqazVoNktROGVOd0ptbm53UTM3cUk5MjVPbFFzWGlwYUl5SENURWhaSUdaQ0FEb2x5SU9IQ1ZJTU9KOWFpOVVobmVpQ2l5MGg3ZWdHWXZLM2RlWEE4SmRyNVlMQXNMS2w1V0g2eGVKTWZPL1RsQzdmNkRqU3hUTC9uMDErSkdDVEVNWGh2SDhJVUo5SzZxYTJIZnJOVHlRb3JYU2tXVTRQQ3BKK0xtRzY5RVFjVG1jNVdYMU1qN2kwcngxbjhYb1dweERXcDNiVUZvNDNtbHQrVktXdndRYVB5Z0thWGdpaHNLMU40UXE3MXZxejNHYWk4Mk1aVzZZSHN1UHpSbVpLSGZvRUhJek9tTmcwZU93TWhSSTVBUkE4WlBHSTBqanlwR2hrckFGYWZGUnMyaUJPSUNDYVh3d3JOejRNS0JrZ1JXclY2SE5lczJlOStycThQT1RSdmhpQVBYalVQMEhyK05GM01Bc2V4KytQbmROK1AwMDZkRzZySGZIN1lLSVNKcXp2NnlobXFxU3RUV0Mybi9nWmlORmNZUEhJUGhtUU93b1g1YlVOVksxK21wTFplcjlDNFBUZ0pieHNSdzBEcUYzcFYxVGR5VS9UUWpUc0dCZW0wNHZOV1ZTaFJLM25rWDg0b21vYUJvUXBydW9MQTVzOStTbi8vNGZ0VHYzZVBmckZoR0pnYU1HWW96cGszQjZhZFBnUU8zeFNISWd1S0pxcUI0SXE2ODhpdW9LcXNSY1FVdnZmWSszbjluRVZhVVYwUGk5VjRmUUQyMG1ueC9CblBkZ3UrSjdoY0lheTVkS0t5SjNaN0UrbDVvQ05mdUw2am4xc1hyc1d2VGVtQ2pZTXZ5RmZqSXYzd3pWTnZhRmNmSlRaMFJDcFIrWlRWNWR3dWwyOUpZdDE5QklWRzNHdzgvL0R4T1AzMXFwenoyNmNid1JrUTlnTlhwWDFwb2s5SGFLVk1keVJDTktoK05MNnp0bXlpRkw4TnNOajZvNzNBMTQ2Z0w1Q3Z2L1JsQVFwK3ZXdEVxcEQxVHo5cDBuK2c5VCtFQXJtRFRLRUYyUVMvMExvK0g5Z1cxYXlUK2dZWG1kRFYzQS9hL2JaWS9SQWpkUTFoUDduL2lvU2R4eHZRVE9yUjVmV3U5TzMrSnQ2SVVRWGh4M1Rwc1dyWVRNNWN0dzh3Wk05RXJ1ejlHVGh3clIwek94WG5ubmdFbEx2S2FhU3hzamp1dmVCTHcvVXRSVVZZcHJwdUI1NStmZy9rTFNyQjE1V3BJM0ZTRDlSclUwSHk1cHJmdzhsY0FXME94VFdZc2FmU1hwTXV3dm1VOWhzSDNXdnNrYXVMNm0zeE5KZDFWVm5CVHVyRzE2UEE1YXVTUUZEMnlYWS9oallnT0xPa1lzZHRmdC8vbWZxV2pOOE82dmxQR0hZT1JIejZOZGZVN2RIQkx0SHdONlI2NWRBR29oSGM4am1EWEtBZDdKbVdnZDBYY0g5b1ZzOExSdWsvTU51cEpheXZiY1FOMGNQRlhiSm9Hd1FsY2UrMHY4YWNIZmlyNVJlbmRXUDJ6bnowS0w4MzZGNVM0ZnRWSnhMVHFBQ0NDaHRxZFdGbFNqcFVsWmZqWGszK0RrNUdOZm9NSHljRGhnM0Y0NFNTY09MVVlJMGNNUnhZRUV5YzNucStYWCtqMVppdlV6WWdyU212RVVjQXpzK1ppL3Z0THNHM2xHcmp4MnFRS21xbkltUXBsVysvYmRHcGQ5ZFVMNWNGY3ZXQXZZT1ZQRy9CdnFwNjQ5NjFyenV2QzI1WGllNGx6M29nb3FrTGJZeWtnMkpDOUU5cFFLQWQ1OCtyUjk0UDZ4cFdpVUhValBlK3hLcGFGaFJVdit5ZnpmMVc4S2w5Njk2RlFkLzB1NVZjQTlTcFRCV1N2RXh4YW1rQy9SZlYrNHhCdmZNN1JKOTlVRHA4cVB3ZzI3bzJtY1BiNVg4UmxGNXlKdzRyUzIvOXQzbXZ6NVZkM3pNRE85V3NiNzV4Z3JlaE1IaG9NOVcxVGdPTmtvbmZmL3VnenBEOG1UaHFQUVFmbDRET2ZPeHFqUnc0RDNEZ0FGM25Galp2c2xwZlVpS01Vbm5sMk5oWXNLTVBtbFNzQnQ4NTZ1alpWNmV5OGVZbnQ1UWMzbmRXOERqbkJzMG9sZlhnNSs0S3Y0UGFmWDljajVyc0JyTHdSVVUrbHJGWVpuWFllU2o3cHRlMktneXBVMjArZW56M2tXQXhiOUN3MjFtMExnbXg3RHI5OWg5NzBqZkhER1FCUnFCMEY3TnlqMEhlUjFWZk1ieDVySDBCSGhreURBd2hhWDBnd2Z3b0FSUER5cy8vQ1p6NTNPQTRyU3UvMldkTk9tNkpHRFI4a3p6MzNiN3p5L010SUpHcXRZVVV2U0lyZmJkYzdOcTk0WkFVNkFkeEVQZmJzM0lJOU96ZGowNG9WZ0FoZW12VjNmK1dvazVFTkVaSGVmZnFoNzdDQitsY0ZKeHgzT0Z5NHlIQXljT3l4QmNpWWNqaHljdnBnNjQ0OXFDcXB4S3FhbFdpbzN3TXpOOHhyM3B1Syt6KzlsRDA4cXNPdUtLVUxiUklzNGxBSy9ZZU94Q1VYVGV2UzQwM0Q3ZS9lNlpxSWFIK2FyYnlsTzd3cE5GRjVDNGFqVkpyZlc1Mk1MTHhmL25Lb2t2QlMxV3R5emp2M1dWV3Z0dCttMU4xblpzNmI2VG5udGFEb3N5YUJNY3RkNUx4VHE2OUcvRjVzMEcwclVuTmVVdFlmcGhvWnRDZ1JKWEJpV1pqNTdCK1IxMG1yVDB1V1ZNaHp6NytCVjU5L0JZaDd6eHNYNFNCaS9odmNMMEZGeVZTVFhOTy96dit0SnJiVWF0U1Vkeis3TDhCdTVKdUtQbnpOUFI2cGYwMkVGa0xBTE1SQThIeUtaWHFQY1hIWDc3Q1JTbW51NGtoRTFFWEVEZjZQZFB6ZnVxcWt2NlgvTEtHYVBBK2VNS1lJSXpNSFdnc1cydmovVk41bmZ1ZCtnVDhIVDF6c0hlTmcwd1FIZS9NeTlTMXhRc0VoVlFVRnIxK1p3R3c5WlM5Z0FPRHRGUnF2eDQ5L2RoL0tTMm82cFlwUlBEbGYzWEhIdDlYTVdmZmlyQXUrQkJYTDlJS2JVc0UrVnhDL1F1Z3E4ZnF3ZWZVaytQdVNLaWVvMU9tZkMrNXYrTGRaaWVucjFyaFZTR2lOcURVWFR0TFZZaWJWd1UzZlo4RUsxdUN4VnZyZmpzckFiLzd3ZnowdXVBRU1iMFRqQUlVREFBQWVnVWxFUVZSRVRWTXQvQittbjV4MFFsaExKcUdUdHpHazd3ajE0REVYbzdPMm5tcWVxYnBCajFmcVFPY0MyMFlwSk1ZNCt1VHJObG8zcUZUSDcxSGxuOTRVUkZ3L2xEaCtpUE9DMG9xU1VzeDdiWDZuM2pONXhaUFU3VCsvWGozNjdCL3gzWjllait4K0EvM3ZpZDlLUTFudE9pUllEUW85aFRDWWplLzl6MjhGNG5HdEVPYjliTGlOakNncjFLbmc2MllGY05kcDVXTXZFcW9VMnZQY1hIZ1Z0OS8rOGFjNHBZZjBkVXZHT1c5RWRPQkk2YkJnU3hlUjNubEIrOXZSNGRSRGo4YndEd1o2ZmQ4NjhiNW9mSUJtQXI3cEpTWUFZdjR3NXFiaENXUVVacUozYWIxL1Z3VXJNbE56RC9tM1U4eUNRelBEWFhTaHl6dmR6NXp4QklvbVQ1SlRUejJ4VTAvMEJVVVRWRUhSQkJ4elJMRzgvMkVKbm5scU5qWXRYd1pScm02K2F5cEsxc09sSzNSaWxvOHFPNHpDSDdKdkZNS0N3cDYzYzRJM3JxcnYrS1NoMGk2ZDBtYkgxSllPSnBnbjZPamhkbEVLZmZzTndveEhmNEdDNHZTM2cra3FyTHdSVVdTNUFqM2ZUYzkxYTJtVnBWai9ieTNaLy8vM2UyWm9aZnJvVUN1NS9WeDd2K3pCNnZFVC9nZmhPVi9tcmQ2eC91MVk5MFVzNlh1TnJzdzZ3VHQ2a3BUakJ6SC82LzdQVzVmbG1vQmhINitMYldOajJIT1lFOXhmL3Mra3FwSVpuTmo5cjlqTlp2MWVabDRGNTJlMzNJdktUaG8rVFpaZk5FRmRjZm1YMWIxMzNZQkgvdjRnanBveUZVNHN5NzhkZnJReWN5djlEVXlWUDFvcSt2NVRPc0I0QWMzdTdXWmRvWWgvKzYwN3cvcCtPKy9yTmpOejlWVG92MEhyR0hNTDdHWXlDRlVQL1RtTU9zZ2VNZVZFL1BteE8zdDBjQU1ZM29pSW10YldrTmZrQlRTdkkyY1hhU2FvSGoweUZ5TXpCNW14TWZqRGw4cE0ybmZEUVZkY05ONVdUTUVQYXE0QWpqbGRXUFBqOUxReUwzaTUrdnFnL3pUWGFWKy9PUWJ2aXJiMUJSSzk5TGY4YzNSeis4UzI1UjVyellwSnI3b2xTcUYyMXpiODZlSG5VYkdrcXN0cVRubkZCYXE0OEREMTUwZnVVSTgvZXhlKzgzL2ZSditSWStEUGVqTUxPb0lOUjNVT0N5cHQvaENxMld6ZWFrL1MvQ2VPam1qSFhhYThlWWxLQlpVMXNZN1JlOVpZeldOTVVGUEJjTEt5RmdrcHhIREpOVmZneHU5ZmhOeUliWC9XSGh3MkpTSnFyMDQ3UlNRUEhTbHZUOHI5R054M21KcHh6SG55cGZrUFc3OXY1cCtaTDVtTjdKTnVoM0tEeW82cHNFRUJrZ0RNZGtxT0UvUTFVVzdRejAwSHRZRnJHbENyZ094RUF2MXJnZGdlaFl3NEFMZ1FCU1JFSVNiQTVwRUM1NUJld0xJR2I2R0NEaHpLN25zV2tycGM1ZDFFOFNmMUE0SjM1NzZCWTQ3TlEvN2szRTU0VEp1WFYxeWc4b29MY054UnhZSjRIUGY4OFVtVUxDeEJvbjYzUG1hQlVnNUVYSC9scUlNZ0J2bEQwVHBjbTZLalN1NHIxeXBORFYzYW9hc2RMd1h4bHFyNEMxVHNIbmdTWEtiL3A3K0hxNzA4eUt2TUhWcGNqRi9lY1IwNlk5ZU03b0xoalloNnFEUU1MQ1RQRSt1MEdvMDAvbmNMMS8zNVE0N0RrSVhQWUhOOGU5THg2dnZGamVzUVpwcTBXbWQ3ZndqVGJ2TVJOTlNGZU50dzlWa3J5SFFWaG0xSUlITmJBbTY5Z2xNdmtJU0w3T3I0Zm01SDBCUzJQK3dKK1lCanJ4eHMramRUUnBrZEJreGcwUGZCL2IvNk00NC9xbGp5MHR5OHQ3WHlkUlhwTDMrOUErV0xxMlROaHMzNDA0eFpXRk5XQlpHRXRhV25za1pVVlZBUmxlQzVvcEtIVHp2RWJqdlN6c3FiR2NGdXNyVk9NQ3lzSU41ZXZ0WnRFZ0Q5UjR6R3JULzVCc2FPSElYY3d1N3hlSFVXaGpjaW92Wkt3ZW1pL2FHaytSTm0vOTZEMVYrUHVVUysrTzZmOUxHYTNRN2dsVitzOWdxaDIyUGFqSWhDYU1Vb0ZJYXNUU0MyMTBXL0xTNHl0N2h3Nm9Hc3FvYWczVVhTaHVEK2thcGdibGJ5TGZiM0VqRDl6S1RwQUpmeU03TVpRUXoxVVhPQlJBTytkL052OGZ1N2ZpQjUzV3plVk1IaHVhb0F1WmgyK2xSVUxsa2hDeFl2eHIvKytSK3NMQ2tIOUJaY3dUVEU1TDV0MXYzZjVxd2w3ZnhlODcvbHozanpIM005Q3pHWTBnY0k0Q296bDgvNzJkNzlCK09xNzF5QzQ0NHVRSGNKMloyTjRZMkllcWcwdE11UUZ2N2REbTAvODVoR3dDMy81TlJEanNTWUR3ZGlkZjBPZlNKUEJPSE5QM1pyRTN2WENsMEtnQnRIN3pVS1EzWUsrcTVOd05rbDZGM1ZZQjhGbFBKK1RWbkRYNkZ0cVFTTm10QjZsUk9CQThkZk1BQW9PRXJCRlVsNWxhMjUrOUZNOW5mTWFsY0FtMWFzd05NdnpNWHR4UlBUZmhUdGxUZDVuTXFiUEE1WFhQWmxsSmRVeVVjZlZXUE9Hd3RRL1dFWkd1cDJ3eEYvL1NsTS96WjdLVUNLbHZTMld6QjhDNzhTNjFWZmRROCt3RDlHcy9MMmtLSUNYUDJ0ODNISXlHSG9ic0c2c3pHOEVSRkZpb1QrYU02Z1BrUFZnMGRmS09lOE8wUFBWWXQ1SjB3WGdHUEcyOHdpQnBnbVh4aXcya1h2dUlPY2xRbjAyaUxJcnE2M0ZpWll6VnhGaFRyYWUrZmc1RGxyb1dXTytvVHRuWXhkaUE1Mlh2ZTFoR241MENuajBjRnVEbVo2bjFoaDgrV24vb0dUcGh3aDB5TFFKNnlnT0ZjVkZPZmlrc3ZQUVhuSlVuRVU4TUNNWjFHMnBBbzdONnozNXNXSnZ4ZEJOOWpjeXM5cmVyR0ZqdnFoTmpGZTJNd1pNUVpmUGZkVW5IYktGT1FWaisvMmowVm5ZWGdqSW1wS0d2dWdwYUt5MU5wR3RwODUrR2hrdmQ4UGRkZ0RmNHNvUjhKRGFJNFhXZ2F0VGFELzFoajZybkNSWGJiUEdyNE01cW1GNTFFRi96WjdhZnJiV3ltN3ltUGRjcXVhQXBqNVRycDZCOGRiZ1NoTng0dlVWdVRNWkhrOStWK1NON0lYL09TbXV6SHl5UkZTTkRrNnF4Y0w5RzRDZjd6L1ZnQkFlVW1sck51d0N5LzlheTZXTEs3QnJvMmI0Q2JxR3QwWDZZeHp6VDV1ZnJzNkhhUXpzakhrNERHWVB2MUVuREZ0NmdFN0xOb1NoamNpaWl3bmFBMFdTTlY1cURXZEp2eWZiZHNWcHVKczFOcHRwQTdxTTFUZE52NXo4cVBxbDVzK1h1Vmd3R29YZzljTHNsY2xrRlZaYXcxNVd0VXphZUozclgrYitVditjYlZ3ZkthNjVyZTRhSzd2V0F2M1c5dENuZDJ0TnJpdUlMZ0YvNHJYN2NJOTkvNFYvM3ZqMXlXcVd5d1ZGT2VwZ21MZzFOT09CUUJVbFZWS0FyMHdkODU4TEY1U2hVK1dyY0tlTFpzaGlRYTlFd1hnaVBKN3l2a3ZwemF0VUxXR2FlM3R5ZndMOCs1L3BXTEl5T3lEL3FPRzRvVGpEOGNGRjB4SEZvREREckRGQiszQjhFWkUxQjZkTXpFckpiNTUrRG00YmRrYnFIUDM2cWE1R1FCYzVLeHpNV3hEQTNwL2trQjJaVHlwdDMxWEQ2eTFYdXU2OFJ1dHVWM0tIeUV1bWI4QUMwNCtGbm5GaDNYMXpVeUozTUk4QlFBRmhSTkNYNjhwV1NZTnlzVWI4K1pqODdaZFdQN3BlcXpmdUFuS0ZleFl1d21KZUIyVTR6VmRkaE1Oc0hhOGIvS2xrS0d5SVk0WGduTUdEVVptdjJ6MHorbU4vTHlKR0Rob0FLYWZkZ3d5MEFzVE9SVGFMZ3h2UkVUdDBSMG1EclhTa0p3UjZ0WnhKOHZQYWw0Q2xJT2hhK0xJYUJBTVdwSkFkcmwzSWc1M2x1aUsvVnBUSVJVUFNMQ1F3VlFmNy92bEE1aHlWSkZNN01GRGVCT0x2YUhoZ3FLV0YyblVsQzZWZUF2M2RYN1JnYjJnSU4wWTNvaW9oK3JLRFdUYW11elNud1N2UC9yTHVIMzVIR1IrV28vQjFTNzZMcXhITUVjTmVrOVJyNHVyYW5JMVlxcU9zYnVuM21DMXJiY1l3MnRNL0sxcmY0NEhIdmhKWklkUFU2a25oOWlvNFBaWVJFVHR0Zi9OVGJ2NnlCb1oxSGVZZXZXa20xRHc1RDcwWFZqdkQ1R0tOWmZObTQ3VTNNeXlWT2lxKzZhTmVVTzgvVUhOZGw0N042N0ZVOC9PUVZWcDEyMmZSV1F3dkJGUkQrV20vLzhwNzFhZlhxY2ZOa1VkUHZXRTRBc0sxanczRmF4ZzdkYnhwTDFGbnpiZUtMTjlGdUN2bkgxNTF0K3hjczNHcnI0RGlCamVpSWlpSVRValZULzQvdVc0L0xvcmRGODJlOVdwZUtzTm05ejNxL05HeVZxT1dKMlRMSlZ1M2l2bTd0RDk2MzV5OCs5UVZsTGRyZU10OVh3TWIwUkU3ZFZsTTMvYWY4WDVreWVwNmFjZGk4dXV2UlFDeDV2ZlpucHQrVDM0a3krL3M3S0s2allMSmJ5ZEgwd0RZMTJkRkVHOGJoZCtldnZEcUNtcFlJQ2pMc1B3UmtTMFAvNHdvdEo3ZzBMLzZYaDdnRXI0NTB6SE0reTNnVzVIb2tueVRnWHR2NlRjb2x6MXZlOWRvWDUxMzIxUUdabEplMkJhOGMzL2tyS3VyelZYbk82aFRkWGhTMmpkdGRpTEs0SkwvblRKeDNoeDd2c3B2Q2FpdG1GNEl5TGFIL0cyY3ZKMklEQWRnVjA5aWQwTnNwdHVLK0ZIdVAwMk0rMWV4WnBwcDA5Umo4MzZIWHJuRElJZFVvTElvbSt6TlpMYW1qMVYwMzg3OTMvNW5WVzVlK3JocC9ERzYyOTNyd2VVRGhnTWIwUkUrK1Y2eWN6Vm03ckRiSUxwQU1yeENteDZqMDVBYi9Wa0FrOUVGQlRucW9jZit5WEdGaGY1WC9QM0Z2VzN3UExTbXloclEvRnVJNVhIMG9iTEVoZS91UDB2cUNsZHlnQkhuWTdoalloNktLZUQvMGN3Uktxc1lWTUl2SldtTGlRdWVpSzcyV0RiMjZPenUxWFlXcEpmTkZIZGVkdTFNQ3RSUlFWRHY5NG04NEJTamplSjM5NHFhNys2VTdocmk3WThib0tkRzliZ29ZZWZRM1Y1VGJRZWNJbzhoamNpb3FiNFcyQW1yQ3dpQ09hN09YRE0vRGFCOTNjSWxLNVFwZmZBVWkrL09GZmRlTk1WdVBUYVMzU2hUVmZiOUh3NHM3K2xMamEyb0trc2s2NDdwUXY3eGdudzV1dzM4TjZDc2k0NkJqcFFjWWNGSXVxaDNJNzl1dWpMMFBzNTZySVRkQmtLZ0t2WExMakJHazNkV3NKZXZwQjY2UXNyaGQ2V1JqSm95QUQ4OFJjUCtsVkZWd1JLZERnMU96RjBvK1AyZFBiT0RXWkxNWVg3ZnZzd2pqa21Ud3FLODZKYWNxU0lZZVdOaUtncHl0RWJmWnFKWGdBUTA1VTJGeEFGNVNvNGNMeHBjQkF2dUVWdzJOUldXRFJSWFg3WlY5U3Y3L3NwVkVZdnZXVVcvTUtaMk0xOHU1WE9hMmRpL3F1Z00zMmlBVGZkOGp0VXN2OGJkUktHTnlLaXBnZ0FKMmF0SEkzNVd5VU5XT3RpMUxJRW5GclhLOG9CZWw1Y01NellscXZwams0Ny9TUTFjOVlmMEx2L1lEaGk5anBWRUxqdHJMejFGSHB4aXU2UFo1b2FiMTYyQXJOZlc5RFZCMGNIQ0lZM0lvb3NSOFgwMzl4Z1FZSFprOUtPUmFMZ0wwUXdFOUxzdm0xMkZsSDZaeFIwazFZSnJrTVUrcTFNWU5nYXdjam45eUc3c3Q2YkRXYm1pUG1YRTdyQVptOUQ2OXZocXRiK1lNcmtGVTlVRHo5Nkp3cW42QzIxbElSWG15cTlyUmJzZjZldTFhNVlOeklJeUZZWjBLOEFLbS9CU1BKS1g3OU5uOVhEemo1MnBZTEZHZnJ2OW1LTmNPKzdwTi8xTHRodmlDY0tlT0xCeHpGM3pvSURPZGxTSjJGNEk2TG9FZ0VrQmtEcGRoNkEzODRER1FCaVZtTXl2UitwR1FJVjEvdSs2d0orQ05RL3A1UVY4cnlWcGdOV3gzRklwZUNRRHhQSWVhTzJMUWZaelBkVUs3N1Ntc3RKbi95aUNlcC9iN2tTVTg4NEJTYkVtTVVMb3R1SUJDSExWT2RTYzZ5T0R0aWlsRmtLRXZRblZyQ3FuQUlIamw3cHExZklRbTl0cFZRUU9CV0Noc1NpVndyclA4M2YvWCtiTVZGenU1VDNkZEVMVkV6ek96T3liaXEwUDczNVZ5Z3JxV1NBbzdSaWVDT2l5SEoxeXc3dnhPekNxNndKZ0xoM3NyWC83N1BiZmlUMDk4MzM5RXBTdVBveUZJYXNqR05jVlFLalAzUXg1Sjk3a0ZYVmtNSk5uS0p4anM4dm1LQ3V2ZnA4WEhUVnBmNkc3UkN2MHVXSEY1anFwbGlWcnJZSS80N1lDeVAwbjQ0b0hlRzhCUlFLam43OEZJTEJhb0dybzE1eS9ySjNrbEQ3K1ovNW50K2NHTW9QYkFvS1NnU2lnZ1NaM05Xdm9YNFA3djNkMDZoay96ZEtJNjQySmFMSUVzU0M0VTF4QU1mc1Jaa1JyQmFGL3BJL1pHcjJyTlREcFk0QWJsd0h1bUNGNnVEVkNnTTNKSkMxWHBCZHNqY294QUVwcXl4RlNWN1JZU29tamh4eHhFVDg3N2R2MDJGSXI3U1ZvQUpuQWs3TGtsZUhobjlINmVxWHdBUXczWUpGekNPZ3QzMFFFOWtraUY3aVBaS09NdnRFeEtBY2I5aGNaZlRDd0pGRG9GVFR0UXR6RzBSY2JGdTNCUkt2ODhKYXdvVklRaCtiVjhYVCsyMVlROG5lc1BMSDc4ekgreWNmaWJ5aXc3cjZZYU1lU2gzWUUwK0pLTXB1Lys4TXVXM3BxOEU4TjFPRk15ZDFlNmpNMzhzS1Z0c1BtNE5CYXhvd1lHY0dNdGMzd05rbTZGTlRENGhYMVJFejMwdlBiMnBkUUdsT3gxcGJxRmdXRmxhODNDWExQdDk4N1czNTBZMzNJRjY3eTU5cEZnNjBIVy9iSWNxRVFQdXlrdTU3cFhRRjBBRXlNakY0N0dqMHllbU53d3NtNGFBQnZYSG05TThBa2tCY0JJVWRiT05SWGxvdE1RaVVrNEZYWnY4WG03ZnR4cHJWRzdGMjNVYnNXTE1SaWZwOWNDVWVUTGRVRGo2b210c2RsK1ZTRDhES0d4RkZsZ01IUWRkWTAwQlh2TjVzZ0RlVWFzNy95WHVNSzJESU9oZUplZ2Y5dGlYUWQzTWNhb2VnVC9WdW1MS0tTRGc0bUQ4Nkh0ek1RZXhQWi9jc2E1dlBuM2FTZXVUSllYTGRkWGRpNTRZMS9odzRwTEFZb0t5L2lLN21lVjFZQkJuWi9UQm85QWdjYyt4a1REbXBHT05HRFVOdVVXNWFnMUpCMFNULzhpY1ZUR2owL1lvbFZlTEVITHd5NXgxOHNtSWRxcXMvd1QrZWYwMisvTFhUR09BbzVWaDVJNkxJK3RlaXVmTGpwLytNK0NkNzRHWTZTQXhRaVBjVGJPM25JT1lBNGlyVUNhQWNRWVlJY3VvVXNuWUpNdllKbk4yQ2pEMkNyTW9HZjhKNWFKR3FIMGJzeXBKcFZOdnhuTksyaGlLTmRXWGx6YWdxcTVGZjNmTUlTdDkrUDdpZmxMVWdvQ09zT3prelp4RHlpaWZoYzZjY2pST09Ma0p1NFVRR0lqcWdNYndSVWFSdDNycGR6anp4UW9qWk9ONnZXaVVGQ0N1TW1aV0MvdVIxcFlKRmlQQ213WW5aU1NGcGlLNmpvYXYxbXErK2RZZndCZ0RsaXl2azJSZitqWmVlK1R0Q205ZTM4ZmFFZjFTaC8vQ1IrTUtYcCtHTTAwOEFSRkJRUEtuTGJ5dFJkOEZoVXlLS3RDR0RCcWc3Ny91SjNQNmpQNkIyMXphSXNzSVhBRDgwNks4cHY5VkRrQVhFYWg4UmloaDIrQk5CK0xlYWs0cGh6eFordjV0RW1ZTEQ4OVdGVGt6NkQraVBweDU2ekY5Y0VCeWo2WW1tbTl1YTFoMzZFWExNcWxLbGNORHdVZmo2MWVmaG1NTW5JcTg0dmNPZ1JGSEd5aHNSOVFnVnBjdmwrdXZ1d0k3MXE0TXZoc1kzN1Q1ZjBhY3lzckN3dk9zcmI3WTVjOTZVSDkvd0s0aHVibXlDbW1taGF4WWJtSVlmQUpDVk14RFR2M1F5enYvcTZjZ3JPcXhiM1I2aTdvcmhqWWg2ak1yU3BmTGJ1eC9GNHZrTDdMcWFEZ3NJTjJudHhnc0NtaFkrNXU0WTNnQmczdHgzNVBaYi80RGFuZHNBbUZXNit0aE5tRllLUThlUHcvZHYvRG9PR1RrVXVReHRSRzNDOEVaRVBVcGxTWTA4OS94Yy9PdnBmL2p6MWtUODlyRUl4aHRUMGVyRDZQejMwZTRhM2dDZ3FuU1pYSFB0SGRpMWNVMHdncW9iNmVhZmNDeCtmTXZYdWVpQXFBTVkzb2lveDZrc1hTRno1cjJObVRObXdwdnNwcXR2ZGd1NGxQUnBNeGpla2xVdXFaSGYzUHNFU3ViUEJ3QVVUVGtCdDl4NEtRbzRsNDJvd3hqZWlLakhtamZuYmZuUkRYZm9WYUttblN3UXZTSFRaQW9xSTdOYmh6Y0FLRmxTSVVzK0xNR1lVV014ZlBSUTVCVnllSlFvRlJqZWlLaEhxeXlwa3F1di9CbjI3dG9DczYyUzhqZWVqKzc3WDNldnZCRlIrbkJqZWlMcTBmS0tjOVg5ajk2QndlUEdBWUMzcDJWa2d4dXpHaEV4dkJIUkFXQnk4U1IxLzkzL2k0SXB4K3ZNNXJXeENMYldzcWoyQnFSVUJDdnJNaG9kaDk2QVhmZE9Vd3h5UkFjc2hqY2lPaUJNTEo2Zy91L215M0RGdFpmcS9VbmhKU0d6QlpZS041TnRleGhMOFg2bityaEVINWVPYm43YkRZbGs1WkNJVW9FN0xCRFJBU08zS0U4SmVrbS9JUWZoZ1Y4OENFZ0NvanY4UzZpVzFVMkdWWFhJOURLbTY5ZmJ6QlplUkhSZ1luZ2pvZ05LWHRFRWxWYzBBWWVPR2k3L2UvMHZJWWs2cXdjY3JFM291d0d4OWdwVmppNEtlcjNyWEk2YUVoMndPR3hLUkFla2swODlVVDMrN0wzSXpoa0lWeWtvVVdqTDdxWE5TMDJ5VWpEN2dDcTlyWlRBejIvZEpGOFNVZWRqZUNPaUExWmU4VVQxbDhmdnhDRkZoUkFJSENpNG9WMFkyaXNGeVVvcENOeWtTL1NHVFIzQW53dEhSQWNlaGpjaU9xRGxGUjZtN3Z6NXQxRTQ5WGk0U3ZRaXorNVExdElMS1dEdEM2cVB5NFhnNE1KSlhYMkFSTlJGMktTWGlBaEFSZWx5ZVhYdU8zaDZ4dU5laU92eXQwWnJOd2k5b2J1amdJUUFoVk9PeDYwM2Z4MTUzTkNkNklERThFWkVwRldXMU1nbmE5ZmpKemY4RWlKeHdLOTdKYTlHYmFxZGlQYzFVVXJ2bStyOXB0S3JXYUV2VFNEQllsYWwvTDV6c0N0c2VxR0NZK2JoS2RFL0VzTkYxMXlDczA4N0hubmNJNVRvZ01Yd1JrU1VaTTZjLzhoUGYvQjd4T3QyUVltOUFqVm8xV0VITHkrUU9icGFKMEdEWFFtSE1oSFJPenlZdVd3NjRFRlptejVJT0FEcXJ3OGVQd0gzM3ZWOWJ1eE9SQXh2UkVSTnFTcGRKbGRkY1N2MjdON3ExZGRFck1xWmJ1N2JSRWl6dzUzQTlHbHJhaGpXbnN1RzRQTHM5MlFGS0NjVE4vemZ0M0hzNFpPUVZ6eVJ3WTJJR042SWlQYW5xbXlGL09hdS80Y2w4OThMQnl1bHZLd0Z1em9XdkpmNnZkbDBSVTBsNzlwZ2hrSDlMcnhJQ29LQWs1R0ZzODgvQytkKzdUUVVGYkhhUmtRQmhqY2lvbVpVbHRUSVF3OC9qN2ZtdkE0RnJ6bXVFak9XYWkwcUFHRENHdUR0Z0NEMlBEaUlOMndLSjlnMndhL2ltYjhEMlRrRGNkcFpuOE9GNTAxSFhqRVhKQkJSWXd4dlJFUXRxQ2hkTHJOZmV3dFBQakJUZjhWZmNZQWdnQ0gwZDRFTEJjZGI2bUR2dHVYL0xJTExjQndjV2xTSWE2NCtINk5IRFVaK0VZZEhpV2ovR042SWlGcWhzblNackZ1M0RqKzg2UjRrYW5kN1gvU0hTOE5EcHdyS0h4VTFlNUo2My9DQ202TWM5TW9aZ0VsRjQzREZwVi9DOEJGREdOaUlxTlVZM29pSTJxQnlTWTFBdWZoZ2NSV1dWYTlDV2NWUzdOaTFCMG9VOW16ZGp0bzllNkRFR3pBZGVNZ29PSWhCS1dEOFlZZGcySUFjbkhmaG1ZRHJvb0NMRDRpb25SamVpSWlJaUNLRTIyTVJFUkVSUlFqREd4RVJFVkdFTUx3UkVSRVJSUWpER3hFUkVWR0VNTHdSRVJFUlJRakRHeEVSRVZHRU1Md1JFUkVSUlFqREd4RVJFVkdFTUx3UkVSRVJSUWpER3hFUkVWR0VNTHdSRVJFUlJRakRHeEVSRVZHRU1Md1JFUkVSUlFqREd4RVJFVkdFTUx3UkVSRVJSUWpER3hFUkVWR0VNTHdSRVJFUlJRakRHeEVSRVZHRU1Md1JFUkVSUlFqREd4RVJFVkdFTUx3UkVSRVJSUWpER3hFUkVWR0VNTHdSRVJFUlJRakRHeEVSRVZHRU1Md1JFUkVSUlFqREd4RVJFVkdFTUx3UkVSRVJSUWpER3hFUkVWR0VNTHdSRVJFUlJRakRHeEVSRVZHRU1Md1JFUkVSUlFqREd4RVJFVkdFTUx3UkVSRVJSUWpER3hFUkVWR0VNTHdSRVJFUlJRakRHeEVSRVZHRU1Md1JFUkVSUlFqREd4RVJFVkdFTUx3UkVSRVJSUWpER3hFUkVWR0VNTHdSRVJFUlJRakRHeEVSRVZHRU1Md1JFUkVSUlFqREd4RVJFVkdFTUx3UkVSRVJSUWpER3hFUkVWR0VNTHdSRVJFUlJRakRHeEVSRVZHRU1Md1JFUkVSUlFqREd4RVJFVkdFTUx3UkVSRVJSUWpER3hFUkVWR0VNTHdSRVJFUlJRakRHeEVSRVZHRU1Md1JFUkVSUlFqREd4RVJFVkdFTUx3UkVSRVJSUWpER3hFUkVWR0VNTHdSRVJFUlJRakRHeEVSRVZHRU1Md1JFUkVSUlFqREd4RVJFVkdFTUx3UkVSRVJSUWpER3hFUkVWR0VNTHdSRVJFUlJRakRHeEVSRVZHRU1Md1JFUkVSUlFqREd4RVJFVkdFTUx3UkVSRVJSUWpER3hFUkVWR0VNTHdSRVJFUlJRakRHeEVSRVZHRU1Md1JFUkVSUlFqREd4RVJFVkdFTUx3UkVSRVJSUWpER3hFUkVWR0VNTHdSRVJFUlJRakRHeEVSRVZHRU1Md1JFUkVSUlFqREd4RVJFVkdFTUx3UkVSRVJSUWpER3hFUkVWR0VNTHdSRVJFUlJRakRHeEVSRVZHRU1Md1JFUkVSUlFqREd4RVJFVkdFTUx3UkVSRVJSUWpER3hFUkVWR0VNTHdSRVJFUlJRakRHeEVSRVZHRU1Md1JFUkVSUlFqREd4RVJFVkdFTUx3UkVSRVJSUWpER3hFUkVWR0VNTHdSRVJFUlJRakRHeEVSRVZHRU1Md1JFUkVSUlFqREd4RVJFVkdFTUx3UkVSRVJSUWpER3hFUkVWR0VNTHdSRVJFUlJRakRHeEVSRVZHRU1Md1JFUkVSUlFqREd4RVJFVkdFTUx3UkVSRVJSUWpER3hFUkVWR0VNTHdSRVJFUlJRakRHeEVSRVZHRU1Md1JFUkVSUlFqREd4RVJFVkdFTUx3UkVSRVJSUWpER3hFUkVWR0VNTHdSRVJFUlJRakRHeEVSRVZHRU1Md1JFUkVSUlFqREd4RVJFVkdFTUx3UkVSRVJSUWpER3hFUkVWR0VNTHdSRVJFUlJRakRHeEVSRVZHRU1Md1JFUkVSUlFqREd4RVJFVkdFTUx3UkVSRVJSUWpER3hFUkVWR0VNTHdSRVJFUlJRakRHeEVSRVZHRU1Md1JFUkVSUlFqREd4RVJFVkdFTUx3UkVSRVJSUWpER3hFUkVWR0VNTHdSRVJFUlJRakRHeEVSRVZHRU1Md1JFUkVSUlFqREd4RVJFVkdFTUx3UkVSRVJSUWpER3hFUkVWR0VNTHdSRVJFUlJRakRHeEVSRVZHRU1Md1JFUkVSUlFqREd4RVJFVkdFTUx3UkVSRVJSUWpER3hFUkVWR0VNTHdSRVJFUlJRakRHeEVSRVZHRU1Md1JFUkVSUlFqREd4RVJFVkdFTUx3UkVSRVJSUWpER3hFUkVWR0VNTHdSRVJFUlJRakRHeEVSRVZHRU1Md1JFUkVSUlFqREd4RVJFVkdFTUx3UkVSRVJSUWpER3hFUkVWR0VNTHdSRVJFUlJRakRHeEVSRVZHRU1Md1JFUkVSUlFqREd4RVJFVkdFTUx3UkVSRVJSUWpER3hFUkVWR0VNTHdSRVJFUlJRakRHeEVSRVZHRU1Md1JFUkVSUlFqREd4RVJFVkdFTUx3UkVSRVJSUWpER3hFUkVWR0VNTHdSRVJFUlJRakRHeEVSRVZHRU1Md1JFUkVSUlFqREd4RVJFVkdFTUx3UkVSRVJSUWpER3hFUkVWR0VNTHdSRVJFUlJRakRHeEVSRVZHRU1Md1JFUkVSUlFqREd4RVJFVkdFTUx3UkVSRVJSUWpER3hFUkVWR0VNTHdSRVJFUlJRakRHeEVSRVZHRU1Md1JFUkVSUlFqREd4RVJFVkdFTUx3UkVSRVJSUWpER3hFUkVWR0VNTHdSRVJFUlJRakRHeEVSRVZHRU1Md1JFUkVSUlFqREd4RVJFVkdFTUx3UkVSRVJSUWpER3hFUkVWR0VNTHdSRVJFUlJRakRHeEVSRVZHRU1Md1JFUkVSUlFqREd4RVJFVkdFTUx3UkVSRVJSUWpER3hFUkVWR0VNTHdSRVJFUlJRakRHeEVSRVZHRU1Md1JFUkVSUlFqREd4RVJFVkdFTUx3UkVSRVJSUWpER3hFUkVWR0VNTHdSRVJFUlJRakRHeEVSRVZHRU1Md1JFUkVSUlFqREd4RVJFVkdFTUx3UkVSRVJSUWpER3hFUkVWR0VNTHdSRVJFUlJRakRHeEVSRVZHRU1Md1JFUkVSUlFqREd4RVJFVkdFTUx3UkVSRVJSUWpER3hFUkVWR0VNTHdSRVJFUlJRakRHeEVSRVZHRU1Md1JFUkVSUmNqL0IvVHUzblIrV0xMUUFBQUFKWFJGV0hSa1lYUmxPbU55WldGMFpRQXlNREl3TFRBM0xUQTVWREV4T2pRNU9qVXlLekF3T2pBd1NQT2NrUUFBQUNWMFJWaDBaR0YwWlRwdGIyUnBabmtBTWpBeU1DMHdOeTB3T1ZReE1UbzBPVG8xTWlzd01Eb3dNRG11SkMwQUFBQUFTVVZPUks1Q1lJST0nO1xuXG5leHBvcnQge1NQT1RMRVJfUExVR0lOX0xPR09fQkFTRTY0fTtcbiIsIi8qXG4gKiBDb3B5cmlnaHQgMjAxNS0yMDI0LiBSaXRlbnNlIEJWLCB0aGUgTmV0aGVybGFuZHMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgRVVQTCwgVmVyc2lvbiAxLjIgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwczovL2pvaW51cC5lYy5ldXJvcGEuZXUvY29sbGVjdGlvbi9ldXBsL2V1cGwtdGV4dC1ldXBsLTEyXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIGJhc2lzLFxuICpcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXJcbiAqIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqL1xuXG5pbXBvcnQge0NvbXBvbmVudCwgRXZlbnRFbWl0dGVyLCBJbnB1dCwgT25EZXN0cm95LCBPbkluaXQsIE91dHB1dH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge1BsdWdpbkNvbmZpZ3VyYXRpb25Db21wb25lbnR9IGZyb20gJ0B2YWx0aW1vL3BsdWdpbic7XG5pbXBvcnQge0JlaGF2aW9yU3ViamVjdCwgY29tYmluZUxhdGVzdCwgT2JzZXJ2YWJsZSwgU3Vic2NyaXB0aW9uLCB0YWtlfSBmcm9tICdyeGpzJztcbmltcG9ydCB7U3BvdGxlclBsdWdpbkNvbmZpZ30gZnJvbSBcIi4uLy4uL21vZGVsc1wiO1xuXG5AQ29tcG9uZW50KHtcbiAgc2VsZWN0b3I6ICdzcG90bGVyLXBsdWdpbi1jb25maWd1cmF0aW9uJyxcbiAgdGVtcGxhdGU6IHJlcXVpcmUoJy4vc3BvdGxlci1wbHVnaW4tY29uZmlndXJhdGlvbi5jb21wb25lbnQuaHRtbCcpLFxuICBzdHlsZXM6IFtyZXF1aXJlKCcuL3Nwb3RsZXItcGx1Z2luLWNvbmZpZ3VyYXRpb24uY29tcG9uZW50LnNjc3MnKV0sXG59KVxuZXhwb3J0IGNsYXNzIFNwb3RsZXJQbHVnaW5Db25maWd1cmF0aW9uQ29tcG9uZW50XG4gIGltcGxlbWVudHMgU3BvdGxlclBsdWdpbkNvbmZpZ3VyYXRpb25Db21wb25lbnQsIE9uSW5pdCwgT25EZXN0cm95XG57XG4gIEBJbnB1dCgpIHNhdmUkOiBPYnNlcnZhYmxlPHZvaWQ+O1xuICBASW5wdXQoKSBkaXNhYmxlZCQ6IE9ic2VydmFibGU8Ym9vbGVhbj47XG4gIEBJbnB1dCgpIHBsdWdpbklkOiBzdHJpbmc7XG4gIEBJbnB1dCgpIHByZWZpbGxDb25maWd1cmF0aW9uJDogT2JzZXJ2YWJsZTxTcG90bGVyUGx1Z2luQ29uZmlnPjtcbiAgQE91dHB1dCgpIHZhbGlkOiBFdmVudEVtaXR0ZXI8Ym9vbGVhbj4gPSBuZXcgRXZlbnRFbWl0dGVyPGJvb2xlYW4+KCk7XG4gIEBPdXRwdXQoKSBjb25maWd1cmF0aW9uOiBFdmVudEVtaXR0ZXI8U3BvdGxlclBsdWdpbkNvbmZpZz4gPVxuICAgICAgbmV3IEV2ZW50RW1pdHRlcjxTcG90bGVyUGx1Z2luQ29uZmlnPigpO1xuXG4gIHByaXZhdGUgc2F2ZVN1YnNjcmlwdGlvbiE6IFN1YnNjcmlwdGlvbjtcblxuICBwcml2YXRlIHJlYWRvbmx5IGZvcm1WYWx1ZSQgPSBuZXcgQmVoYXZpb3JTdWJqZWN0PFNwb3RsZXJQbHVnaW5Db25maWcgfCBudWxsPihudWxsKTtcbiAgcHJpdmF0ZSByZWFkb25seSB2YWxpZCQgPSBuZXcgQmVoYXZpb3JTdWJqZWN0PGJvb2xlYW4+KGZhbHNlKTtcblxuICBuZ09uSW5pdCgpOiB2b2lkIHtcbiAgICB0aGlzLm9wZW5TYXZlU3Vic2NyaXB0aW9uKCk7XG4gIH1cblxuICBuZ09uRGVzdHJveSgpIHtcbiAgICB0aGlzLnNhdmVTdWJzY3JpcHRpb24/LnVuc3Vic2NyaWJlKCk7XG4gIH1cblxuICBmb3JtVmFsdWVDaGFuZ2UoZm9ybVZhbHVlOiBTcG90bGVyUGx1Z2luQ29uZmlnKTogdm9pZCB7XG4gICAgdGhpcy5mb3JtVmFsdWUkLm5leHQoZm9ybVZhbHVlKTtcbiAgICB0aGlzLmhhbmRsZVZhbGlkKGZvcm1WYWx1ZSk7XG4gIH1cblxuICBwcml2YXRlIGhhbmRsZVZhbGlkKGZvcm1WYWx1ZTogU3BvdGxlclBsdWdpbkNvbmZpZyk6IHZvaWQge1xuICAgIGNvbnN0IHZhbGlkID0gISEoZm9ybVZhbHVlLmNvbmZpZ3VyYXRpb25UaXRsZVxuICAgICAgICAmJiBmb3JtVmFsdWUuY2xpZW50SWRcbiAgICAgICAgJiYgZm9ybVZhbHVlLmNsaWVudFNlY3JldFxuICAgICAgICAmJiBmb3JtVmFsdWUuYWNjb3VudElkKTtcblxuICAgIHRoaXMudmFsaWQkLm5leHQodmFsaWQpO1xuICAgIHRoaXMudmFsaWQuZW1pdCh2YWxpZCk7XG4gIH1cblxuICBwcml2YXRlIG9wZW5TYXZlU3Vic2NyaXB0aW9uKCk6IHZvaWQge1xuICAgIHRoaXMuc2F2ZVN1YnNjcmlwdGlvbiA9IHRoaXMuc2F2ZSQ/LnN1YnNjcmliZShzYXZlID0+IHtcbiAgICAgIGNvbWJpbmVMYXRlc3QoW3RoaXMuZm9ybVZhbHVlJCwgdGhpcy52YWxpZCRdKVxuICAgICAgICAgIC5waXBlKHRha2UoMSkpXG4gICAgICAgICAgLnN1YnNjcmliZSgoW2Zvcm1WYWx1ZSwgdmFsaWRdKSA9PiB7XG4gICAgICAgICAgICBpZiAodmFsaWQpIHtcbiAgICAgICAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uLmVtaXQoZm9ybVZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICB9KTtcbiAgfVxufVxuIiwiaW1wb3J0IHtDb21wb25lbnQsIEV2ZW50RW1pdHRlciwgSW5wdXQsIE9uRGVzdHJveSwgT25Jbml0LCBPdXRwdXR9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtGdW5jdGlvbkNvbmZpZ3VyYXRpb25Db21wb25lbnR9IGZyb20gJ0B2YWx0aW1vL3BsdWdpbic7XG5pbXBvcnQge0JlaGF2aW9yU3ViamVjdCwgY29tYmluZUxhdGVzdCwgT2JzZXJ2YWJsZSwgU3Vic2NyaXB0aW9uLCB0YWtlLCB0YXB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHtSZWNpcGllbnQsIFNlbmRNYWlsQWN0aW9uQ29uZmlnfSBmcm9tICcuLi8uLi9tb2RlbHMnO1xuaW1wb3J0IHtcbiAgICBBY3Rpb25JdGVtLFxuICAgIENvbHVtbkNvbmZpZywgTGlzdEl0ZW1XaXRoSWQsXG4gICAgTW9kYWxDb21wb25lbnQsXG4gICAgTW92ZVJvd0RpcmVjdGlvbixcbiAgICBNb3ZlUm93RXZlbnQsXG4gICAgTXVsdGlJbnB1dE91dHB1dCxcbiAgICBNdWx0aUlucHV0VmFsdWVzLFxuICAgIFNlbGVjdEl0ZW0sXG4gICAgVGFibGVDb2x1bW4sXG4gICAgVmlld1R5cGUsXG59IGZyb20gJ0B2YWx0aW1vL2NvbXBvbmVudHMnO1xuXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ3Nwb3RsZXItc2VuZC1tYWlsLWFjdGlvbi1jb25maWd1cmF0aW9uJyxcbiAgICB0ZW1wbGF0ZTogcmVxdWlyZSgnLi9zZW5kLW1haWwtYWN0aW9uLWNvbmZpZ3VyYXRpb24uY29tcG9uZW50Lmh0bWwnKSxcbiAgICBzdHlsZXM6IFtyZXF1aXJlKCcuL3NlbmQtbWFpbC1hY3Rpb24tY29uZmlndXJhdGlvbi5jb21wb25lbnQuc2NzcycpXSxcbn0pXG5leHBvcnQgY2xhc3MgU2VuZE1haWxBY3Rpb25Db25maWd1cmF0aW9uQ29tcG9uZW50XG4gICAgLy8gVGhlIGNvbXBvbmVudCBleHBsaWNpdGx5IGltcGxlbWVudHMgdGhlIEZ1bmN0aW9uQ29uZmlndXJhdGlvbkNvbXBvbmVudCBpbnRlcmZhY2VcbiAgICBpbXBsZW1lbnRzIEZ1bmN0aW9uQ29uZmlndXJhdGlvbkNvbXBvbmVudCwgT25Jbml0LCBPbkRlc3Ryb3kge1xuICAgIEBJbnB1dCgpIHNhdmUkOiBPYnNlcnZhYmxlPHZvaWQ+O1xuICAgIEBJbnB1dCgpIGRpc2FibGVkJDogT2JzZXJ2YWJsZTxib29sZWFuPjtcbiAgICBASW5wdXQoKSBwbHVnaW5JZDogc3RyaW5nO1xuICAgIEBJbnB1dCgpIHByZWZpbGxDb25maWd1cmF0aW9uJDogT2JzZXJ2YWJsZTxTZW5kTWFpbEFjdGlvbkNvbmZpZz47XG4gICAgQE91dHB1dCgpIHZhbGlkOiBFdmVudEVtaXR0ZXI8Ym9vbGVhbj4gPSBuZXcgRXZlbnRFbWl0dGVyPGJvb2xlYW4+KCk7XG4gICAgQE91dHB1dCgpIGNvbmZpZ3VyYXRpb246IEV2ZW50RW1pdHRlcjxTZW5kTWFpbEFjdGlvbkNvbmZpZz4gPVxuICAgICAgICBuZXcgRXZlbnRFbWl0dGVyPFNlbmRNYWlsQWN0aW9uQ29uZmlnPigpO1xuXG4gICAgcHJpdmF0ZSBzYXZlU3Vic2NyaXB0aW9uITogU3Vic2NyaXB0aW9uO1xuXG4gICAgcHJpdmF0ZSByZWFkb25seSBmb3JtVmFsdWUkID0gbmV3IEJlaGF2aW9yU3ViamVjdDxTZW5kTWFpbEFjdGlvbkNvbmZpZyB8IG51bGw+KG51bGwpO1xuICAgIHByaXZhdGUgcmVhZG9ubHkgdmFsaWQkID0gbmV3IEJlaGF2aW9yU3ViamVjdDxib29sZWFuPihmYWxzZSk7XG5cbiAgICBwdWJsaWMgcmVhZG9ubHkgcmVjaXBpZW50VHlwZXM6IFNlbGVjdEl0ZW1bXSA9IFtcbiAgICAgICAge1xuICAgICAgICAgICAgaWQ6IFwiVE9cIixcbiAgICAgICAgICAgIHRleHQ6IFwiVE9cIixcbiAgICAgICAgICAgIHRyYW5zbGF0aW9uS2V5OiBcInRvXCJcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgaWQ6IFwiQkNDXCIsXG4gICAgICAgICAgICB0ZXh0OiBcIkJDQ1wiLFxuICAgICAgICAgICAgdHJhbnNsYXRpb25LZXk6IFwiYmNjXCJcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgaWQ6IFwiQ0NcIixcbiAgICAgICAgICAgIHRleHQ6IFwiQ0NcIixcbiAgICAgICAgICAgIHRyYW5zbGF0aW9uS2V5OiBcImNjXCJcbiAgICAgICAgfVxuICAgIF1cblxuICAgIG5nT25Jbml0KCk6IHZvaWQge1xuICAgICAgICB0aGlzLm9wZW5TYXZlU3Vic2NyaXB0aW9uKCk7XG4gICAgfVxuXG4gICAgbmdPbkRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuc2F2ZVN1YnNjcmlwdGlvbj8udW5zdWJzY3JpYmUoKTtcbiAgICB9XG5cbiAgICBmb3JtVmFsdWVDaGFuZ2UoZm9ybVZhbHVlOiBTZW5kTWFpbEFjdGlvbkNvbmZpZyk6IHZvaWQge1xuICAgICAgICB0aGlzLmZvcm1WYWx1ZSQubmV4dChmb3JtVmFsdWUpO1xuICAgICAgICB0aGlzLmhhbmRsZVZhbGlkKGZvcm1WYWx1ZSk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBoYW5kbGVWYWxpZChmb3JtVmFsdWU6IFNlbmRNYWlsQWN0aW9uQ29uZmlnKTogdm9pZCB7XG4gICAgICAgIGNvbnN0IHZhbGlkID0gISEoZm9ybVZhbHVlLnN1YmplY3RcbiAgICAgICAgICAgICYmIGZvcm1WYWx1ZS5zZW5kZXJFbWFpbFxuICAgICAgICAgICAgJiYgdGhpcy52YWxpZGF0ZUVtYWlsKGZvcm1WYWx1ZS5zZW5kZXJFbWFpbClcbiAgICAgICAgICAgICYmIGZvcm1WYWx1ZS5zZW5kZXJOYW1lXG4gICAgICAgICAgICAmJiBmb3JtVmFsdWUucmVjaXBpZW50c1xuICAgICAgICAgICAgJiYgZm9ybVZhbHVlLnJlY2lwaWVudHMuZXZlcnkocmVjaXBpZW50ID0+ICEhKHJlY2lwaWVudC5lbWFpbFxuICAgICAgICAgICAgICAgICAgICAmJiB0aGlzLnZhbGlkYXRlRW1haWwocmVjaXBpZW50LmVtYWlsKVxuICAgICAgICAgICAgICAgICAgICAmJiByZWNpcGllbnQubmFtZVxuICAgICAgICAgICAgICAgICAgICAmJiByZWNpcGllbnQudHlwZVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgIClcbiAgICAgICAgICAgICYmIGZvcm1WYWx1ZS5tYWlsVGVtcGxhdGVJZGVudGlmaWVyKTtcblxuICAgICAgICB0aGlzLnZhbGlkJC5uZXh0KHZhbGlkKTtcbiAgICAgICAgdGhpcy52YWxpZC5lbWl0KHZhbGlkKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIG9wZW5TYXZlU3Vic2NyaXB0aW9uKCk6IHZvaWQge1xuICAgICAgICB0aGlzLnNhdmVTdWJzY3JpcHRpb24gPSB0aGlzLnNhdmUkPy5zdWJzY3JpYmUoc2F2ZSA9PiB7XG4gICAgICAgICAgICBjb21iaW5lTGF0ZXN0KFt0aGlzLmZvcm1WYWx1ZSQsIHRoaXMudmFsaWQkXSlcbiAgICAgICAgICAgICAgICAucGlwZSh0YWtlKDEpKVxuICAgICAgICAgICAgICAgIC5zdWJzY3JpYmUoKFtmb3JtVmFsdWUsIHZhbGlkXSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAodmFsaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY29uZmlndXJhdGlvbi5lbWl0KGZvcm1WYWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSB2YWxpZGF0ZUVtYWlsKGVtYWlsOiBzdHJpbmcpIHtcbiAgICAgICAgY29uc3QgcmUgPSAvXFxTK0BcXFMrXFwuXFxTKy87XG4gICAgICAgIHJldHVybiBlbWFpbC5zdGFydHNXaXRoKFwicHY6XCIpIHx8IHJlLnRlc3QoZW1haWwpO1xuICAgIH1cbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgMjAxNS0yMDI0LiBSaXRlbnNlIEJWLCB0aGUgTmV0aGVybGFuZHMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgRVVQTCwgVmVyc2lvbiAxLjIgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwczovL2pvaW51cC5lYy5ldXJvcGEuZXUvY29sbGVjdGlvbi9ldXBsL2V1cGwtdGV4dC1ldXBsLTEyXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIGJhc2lzLFxuICpcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXJcbiAqIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqL1xuXG5pbXBvcnQge1BsdWdpbkNvbmZpZ3VyYXRpb25EYXRhfSBmcm9tICdAdmFsdGltby9wbHVnaW4nO1xuXG5pbnRlcmZhY2UgU3BvdGxlclBsdWdpbkNvbmZpZyBleHRlbmRzIFBsdWdpbkNvbmZpZ3VyYXRpb25EYXRhIHtcbiAgICBjbGllbnRJZDogc3RyaW5nO1xuICAgIGFjY291bnRJZDogc3RyaW5nO1xuICAgIGNsaWVudFNlY3JldDogc3RyaW5nO1xufVxuXG5pbnRlcmZhY2UgU2VuZE1haWxBY3Rpb25Db25maWcge1xuICAgIHN1YmplY3Q6IHN0cmluZztcbiAgICBzZW5kZXJFbWFpbDogc3RyaW5nO1xuICAgIHNlbmRlck5hbWU6IHN0cmluZztcbiAgICByZWNpcGllbnRzOiBBcnJheTxSZWNpcGllbnQ+XG4gICAgbWFpbFRlbXBsYXRlSWRlbnRpZmllcjogc3RyaW5nO1xuICAgIHBsYWNlaG9sZGVyczogQXJyYXk8UGxhY2Vob2xkZXI+O1xufVxuXG5pbnRlcmZhY2UgUmVjaXBpZW50IHtcbiAgICBlbWFpbDogc3RyaW5nO1xuICAgIG5hbWU6IHN0cmluZztcbiAgICB0eXBlOiBSZWNpcGllbnRUeXBlO1xufVxuXG5lbnVtIFJlY2lwaWVudFR5cGUge1xuICAgIFRPLCBDQywgQkNDXG59XG5cbmludGVyZmFjZSBQbGFjZWhvbGRlciB7XG4gICAga2V5OiBTdHJpbmcsXG4gICAgdmFsdWU6IFN0cmluZ1xufVxuXG5leHBvcnQge1Nwb3RsZXJQbHVnaW5Db25maWcsIFNlbmRNYWlsQWN0aW9uQ29uZmlnLCBSZWNpcGllbnR9O1xuIiwiLypcbiAqIENvcHlyaWdodCAyMDE1LTIwMjQuIFJpdGVuc2UgQlYsIHRoZSBOZXRoZXJsYW5kcy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciBFVVBMLCBWZXJzaW9uIDEuMiAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHBzOi8vam9pbnVwLmVjLmV1cm9wYS5ldS9jb2xsZWN0aW9uL2V1cGwvZXVwbC10ZXh0LWV1cGwtMTJcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgYmFzaXMsXG4gKlxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlclxuICogZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICovXG5cbmV4cG9ydCAqIGZyb20gJy4vY29uZmlnJztcbiIsIi8qXG4gKiBDb3B5cmlnaHQgMjAxNS0yMDI0LiBSaXRlbnNlIEJWLCB0aGUgTmV0aGVybGFuZHMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgRVVQTCwgVmVyc2lvbiAxLjIgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwczovL2pvaW51cC5lYy5ldXJvcGEuZXUvY29sbGVjdGlvbi9ldXBsL2V1cGwtdGV4dC1ldXBsLTEyXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIGJhc2lzLFxuICpcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXJcbiAqIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqL1xuXG5pbXBvcnQge05nTW9kdWxlfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7Q29tbW9uTW9kdWxlfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHtQTFVHSU5TX1RPS0VOLCBQbHVnaW5UcmFuc2xhdGVQaXBlTW9kdWxlfSBmcm9tICdAdmFsdGltby9wbHVnaW4nO1xuXG5pbXBvcnQge0Zvcm1zTW9kdWxlfSBmcm9tIFwiQGFuZ3VsYXIvZm9ybXNcIjtcbmltcG9ydCB7XG4gICAgQ2FyYm9uTGlzdE1vZHVsZSxcbiAgICBDYXJib25NdWx0aUlucHV0TW9kdWxlLFxuICAgIEZvcm1Nb2R1bGUsXG4gICAgSW5wdXRNb2R1bGUsXG4gICAgTXVsdGlJbnB1dEZvcm1Nb2R1bGUsIFNlbGVjdE1vZHVsZSxcbiAgICBUYWJsZU1vZHVsZVxufSBmcm9tIFwiQHZhbHRpbW8vY29tcG9uZW50c1wiO1xuaW1wb3J0IHtcbiAgU3BvdGxlclBsdWdpbkNvbmZpZ3VyYXRpb25Db21wb25lbnRcbn0gZnJvbSBcIi4vY29tcG9uZW50cy9wbHVnaW4tY29uZmlndXJhdGlvbi9zcG90bGVyLXBsdWdpbi1jb25maWd1cmF0aW9uLmNvbXBvbmVudFwiO1xuaW1wb3J0IHtcbiAgU2VuZE1haWxBY3Rpb25Db25maWd1cmF0aW9uQ29tcG9uZW50XG59IGZyb20gXCIuL2NvbXBvbmVudHMvc2VuZC1tYWlsLWNvbmZpZ3VyYXRpb24vc2VuZC1tYWlsLWFjdGlvbi1jb25maWd1cmF0aW9uLmNvbXBvbmVudFwiO1xuaW1wb3J0IHtDaGVja2JveE1vZHVsZSwgRHJvcGRvd25Nb2R1bGV9IGZyb20gXCJjYXJib24tY29tcG9uZW50cy1hbmd1bGFyXCI7XG5pbXBvcnQge3Nwb3RsZXJQbHVnaW5TcGVjaWZpY2F0aW9ufSBmcm9tICcuL3Nwb3RsZXItcGx1Z2luLnNwZWNpZmljYXRpb24nO1xuXG5ATmdNb2R1bGUoe1xuICBkZWNsYXJhdGlvbnM6IFtcbiAgICAgIFNwb3RsZXJQbHVnaW5Db25maWd1cmF0aW9uQ29tcG9uZW50LFxuICAgICAgU2VuZE1haWxBY3Rpb25Db25maWd1cmF0aW9uQ29tcG9uZW50XG4gIF0sXG4gICAgaW1wb3J0czogW0NvbW1vbk1vZHVsZSwgUGx1Z2luVHJhbnNsYXRlUGlwZU1vZHVsZSwgRm9ybU1vZHVsZSwgSW5wdXRNb2R1bGUsIEZvcm1zTW9kdWxlLCBQbHVnaW5UcmFuc2xhdGVQaXBlTW9kdWxlLCBGb3JtTW9kdWxlLCBGb3JtTW9kdWxlLCBGb3JtTW9kdWxlLCBGb3JtTW9kdWxlLCBDYXJib25NdWx0aUlucHV0TW9kdWxlLCBUYWJsZU1vZHVsZSwgQ2FyYm9uTGlzdE1vZHVsZSwgTXVsdGlJbnB1dEZvcm1Nb2R1bGUsIERyb3Bkb3duTW9kdWxlLCBTZWxlY3RNb2R1bGUsIENoZWNrYm94TW9kdWxlXSxcbiAgZXhwb3J0czogW1xuICAgICAgU3BvdGxlclBsdWdpbkNvbmZpZ3VyYXRpb25Db21wb25lbnQsXG4gICAgICBTZW5kTWFpbEFjdGlvbkNvbmZpZ3VyYXRpb25Db21wb25lbnRcbiAgXSxcbiAgICBwcm92aWRlcnM6IFtcbiAgICAgICAge1xuICAgICAgICAgICAgcHJvdmlkZTogUExVR0lOU19UT0tFTixcbiAgICAgICAgICAgIHVzZVZhbHVlOiBbXG4gICAgICAgICAgICAgICAgc3BvdGxlclBsdWdpblNwZWNpZmljYXRpb24sXG4gICAgICAgICAgICBdXG4gICAgICAgIH1cbiAgICBdXG59KVxuZXhwb3J0IGNsYXNzIFNwb3RsZXJQbHVnaW5Nb2R1bGUge31cbiIsIi8qXG4gKiBDb3B5cmlnaHQgMjAxNS0yMDI0LiBSaXRlbnNlIEJWLCB0aGUgTmV0aGVybGFuZHMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgRVVQTCwgVmVyc2lvbiAxLjIgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwczovL2pvaW51cC5lYy5ldXJvcGEuZXUvY29sbGVjdGlvbi9ldXBsL2V1cGwtdGV4dC1ldXBsLTEyXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIGJhc2lzLFxuICpcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXJcbiAqIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqL1xuXG5pbXBvcnQge1BsdWdpblNwZWNpZmljYXRpb259IGZyb20gJ0B2YWx0aW1vL3BsdWdpbic7XG5pbXBvcnQge1NQT1RMRVJfUExVR0lOX0xPR09fQkFTRTY0fSBmcm9tICcuL2Fzc2V0cyc7XG5pbXBvcnQge1xuICBTcG90bGVyUGx1Z2luQ29uZmlndXJhdGlvbkNvbXBvbmVudFxufSBmcm9tIFwiLi9jb21wb25lbnRzL3BsdWdpbi1jb25maWd1cmF0aW9uL3Nwb3RsZXItcGx1Z2luLWNvbmZpZ3VyYXRpb24uY29tcG9uZW50XCI7XG5pbXBvcnQge1xuICBTZW5kTWFpbEFjdGlvbkNvbmZpZ3VyYXRpb25Db21wb25lbnRcbn0gZnJvbSBcIi4vY29tcG9uZW50cy9zZW5kLW1haWwtY29uZmlndXJhdGlvbi9zZW5kLW1haWwtYWN0aW9uLWNvbmZpZ3VyYXRpb24uY29tcG9uZW50XCI7XG5cbmNvbnN0IHNwb3RsZXJQbHVnaW5TcGVjaWZpY2F0aW9uOiBQbHVnaW5TcGVjaWZpY2F0aW9uID0ge1xuICBwbHVnaW5JZDogJ3Nwb3RsZXInLFxuICBwbHVnaW5Db25maWd1cmF0aW9uQ29tcG9uZW50OiBTcG90bGVyUGx1Z2luQ29uZmlndXJhdGlvbkNvbXBvbmVudCxcbiAgcGx1Z2luTG9nb0Jhc2U2NDogU1BPVExFUl9QTFVHSU5fTE9HT19CQVNFNjQsXG4gIGZ1bmN0aW9uQ29uZmlndXJhdGlvbkNvbXBvbmVudHM6IHtcbiAgICBzZW5kTWFpbDogU2VuZE1haWxBY3Rpb25Db25maWd1cmF0aW9uQ29tcG9uZW50XG4gIH0sXG4gIHBsdWdpblRyYW5zbGF0aW9uczoge1xuICAgIG5sOiB7XG4gICAgICB0aXRsZTogJ1Nwb3RsZXInLFxuICAgICAgZGVzY3JpcHRpb246XG4gICAgICAgICAgJ01ldCBkZSBTcG90bGVyIHBsdWdpbiBrdW4gamUgaW4gZWVuIHByb2Nlc3MgZW1haWxzIHZlcnN0dXJlbicsXG4gICAgICBjb25maWd1cmF0aW9uVGl0bGU6ICdDb25maWd1cmF0aWVuYWFtJyxcbiAgICAgIGNvbmZpZ3VyYXRpb25UaXRsZVRvb2x0aXA6XG4gICAgICAgICAgJ09uZGVyIGRlemUgbmFhbSB6YWwgZGUgcGx1Z2luIHRlIGhlcmtlbm5lbiB6aWpuIGluIGRlIHJlc3QgdmFuIGRlIGFwcGxpY2F0aWUnLFxuICAgICAgY2xpZW50SWQ6ICdDbGllbnQgSUQnLFxuICAgICAgY2xpZW50SWRUb29sdGlwOlxuICAgICAgICAgICdWdWwgaGllciBoZXQgdXcgU3BvdGxlciBjbGllbnRJZCBpbicsXG4gICAgICBhY2NvdW50SWQ6ICdBY2NvdW50IElEJyxcbiAgICAgIGFjY291bnRJZFRvb2x0aXA6ICdIZXQgSUQgdmFuIHV3IFNwb3RsZXIgYWNjb3VudCcsXG4gICAgICBjbGllbnRTZWNyZXQ6ICdTZWNyZXQnLFxuICAgICAgY2xpZW50U2VjcmV0VG9vbHRpcDogJ1Z1bCBkZSBzZWNyZXQgaW4gZGllIGhvb3J0IGJpaiBkZSBjbGllbnRJZCBoaWVyYm92ZW4nLFxuICAgICAgdG9BZGRyZXNzOiBcIkVtYWlsIHZlcnplbmQgYWRyZXNcIixcbiAgICAgIHRvTmFtZTogXCJOYWFtIHZhbiBvbnR2YW5nZXJcIixcbiAgICAgIHNlbmRlckVtYWlsOiBcIkVtYWlsIHZhbiBhZnplbmRlclwiLFxuICAgICAgc2VuZGVyTmFtZTogXCJOYWFtIHZhbiBhZnplbmRlclwiLFxuICAgICAgZW1haWxTdWJqZWN0OiBcIk9uZGVyd2VycFwiLFxuICAgICAgbWFpbFRlbXBsYXRlSWRlbnRpZmllcjogXCJTcG90bGVyIEVtYWlsIHRlbXBsYXRlIElEXCIsXG4gICAgICBtYWlsVGVtcGxhdGVJZGVudGlmaWVyVG9vbHRpcDogXCJWdWwgaGllciBkZSB0ZW1wbGF0ZSBpZGVudGlmaWVyIHZhbiB1dyBTcG90bGVyIGVtYWlsIHRlbXBsYXRlIGluXCIsXG4gICAgICByZWNpcGllbnRzOiBcIk9udHZhbmdlcnNcIixcbiAgICAgIGFkZFJlY2lwaWVudDogXCJWb2VnIG5pZXV3ZSBvbnR2YW5nZXIgdG9lXCIsXG4gICAgICBlbWFpbFR5cGU6IFwiT250dmFuZ2VyIHR5cGVcIixcbiAgICAgIHNlbmRNYWlsOiBcIkVtYWlsIHZlcnplbmRlblwiLFxuICAgICAgcGxhY2Vob2xkZXJzOiBcIlBsYWNlaG9sZGVyc1wiLFxuICAgICAgYWRkUGxhY2Vob2xkZXI6IFwiVm9lZyBlZW4gbmlldXdlIHZhcmlhYmVsZSB0b2VcIixcbiAgICAgIHBsYWNlaG9sZGVyS2V5OiBcIlZhcmlhYmVsZVwiLFxuICAgICAgcGxhY2Vob2xkZXJLZXlUb29sdGlwOiBcIlZ1bCBlZW4gdmFyaWFiZWxlIGluIGRpZSBpbiBkZSBTcG90bGVyIGVtYWlsIHRlbXBsYXRlIHN0YWF0IGdlY29uZmlndXJlZXJkLlwiLFxuICAgICAgcGxhY2Vob2xkZXJWYWx1ZTogXCJXYWFyZGVcIixcbiAgICAgIHBsYWNlaG9sZGVyVmFsdWVUb29sdGlwOiBcIkRlIHdhYXJkZSBkaWUgaW4gZGUgZW1haWwgaW5nZXZ1bGQgd29yZC4gU3RhcnQgbWV0IHB2OiBvbSBlZW4gcHJvY2VzcyB3YWFyZGUgdGUgZ2VicnVpa2VuXCJcbiAgICB9LFxuICAgIGVuOiB7XG4gICAgICB0aXRsZTogJ1Nwb3RsZXInLFxuICAgICAgZGVzY3JpcHRpb246XG4gICAgICAgICAgJ1Nwb3RsZXIgYWxsb3dzIHlvdSB0byBzZW5kIGVtYWlscyBmcm9tIHdpdGhpbiBhIHByb2Nlc3MnLFxuICAgICAgY29uZmlndXJhdGlvblRpdGxlOiAnQ29uZmlndXJhdGlvbiBuYW1lJyxcbiAgICAgIGNvbmZpZ3VyYXRpb25UaXRsZVRvb2x0aXA6XG4gICAgICAgICAgJ1VuZGVyIHRoaXMgbmFtZSwgdGhlIHBsdWdpbiB3aWxsIGJlIHJlY29nbml6YWJsZSBpbiB0aGUgcmVzdCBvZiB0aGUgYXBwbGljYXRpb24nLFxuICAgICAgY2xpZW50SWQ6ICdDbGllbnQgSUQnLFxuICAgICAgY2xpZW50SWRUb29sdGlwOlxuICAgICAgICAgICdFbnRlciB5b3VyIFNwb3RsZXIgY2xpZW50SWQgaGVyZScsXG4gICAgICBhY2NvdW50SWQ6ICdBY2NvdW50IElEJyxcbiAgICAgIGFjY291bnRJZFRvb2x0aXA6ICdGaWxsIGluIHRoZSBJRCBvZiB5b3VyIFNwb3RsZXIgYWNjb3VudCcsXG4gICAgICBjbGllbnRTZWNyZXQ6ICdTZWNyZXQnLFxuICAgICAgY2xpZW50U2VjcmV0VG9vbHRpcDogJ0VudGVyIHRoZSBzZWNyZXQgYXNzb2NpYXRlZCB3aXRoIHRoZSBjbGllbnRJZCBhYm92ZScsXG4gICAgICB0b0FkZHJlc3M6IFwiRW1haWwgVG8gYWRkcmVzc1wiLFxuICAgICAgdG9OYW1lOiBcIk5hbWUgb2YgcmVjaXBpZW50XCIsXG4gICAgICBzZW5kZXJFbWFpbDogXCJTZW5kZXIncyBlbWFpbCBhZGRyZXNzXCIsXG4gICAgICBzZW5kZXJOYW1lOiBcIlNlbmRlcidzIG5hbWVcIixcbiAgICAgIGVtYWlsU3ViamVjdDogXCJTdWJqZWN0XCIsXG4gICAgICBtYWlsVGVtcGxhdGVJZGVudGlmaWVyOiBcIlNwb3RsZXIgRW1haWwgdGVtcGxhdGUgSURcIixcbiAgICAgIG1haWxUZW1wbGF0ZUlkZW50aWZpZXJUb29sdGlwOiBcIkVudGVyIHRoZSB0ZW1wbGF0ZSBpZGVudGlmaWVyIG9mIHlvdXIgU3BvdGxlciBlbWFpbCB0ZW1wbGF0ZVwiLFxuICAgICAgcmVjaXBpZW50czogXCJSZWNpcGllbnRzXCIsXG4gICAgICBhZGRSZWNpcGllbnQ6IFwiQWRkIG5ldyByZWNpcGllbnRcIixcbiAgICAgIGVtYWlsVHlwZTogXCJSZWNpcGllbnQgdHlwZVwiLFxuICAgICAgc2VuZE1haWw6IFwiU2VuZCBhbiBFbWFpbFwiLFxuICAgICAgcGxhY2Vob2xkZXJzOiBcIlBsYWNlaG9sZGVyc1wiLFxuICAgICAgYWRkUGxhY2Vob2xkZXI6IFwiQWRkIGEgbmV3IHBsYWNlaG9sZGVyXCIsXG4gICAgICBwbGFjZWhvbGRlcktleTogXCJLZXlcIixcbiAgICAgIHBsYWNlaG9sZGVyS2V5VG9vbHRpcDogXCJGaWxsIGluIGEgcGxhY2Vob2xkZXIgbmFtZSB0aGF0IHdhcyByZWZlcmVuY2VkIGluIHRoZSBTcG90bGVyIGVtYWlsIHRlbXBsYXRlXCIsXG4gICAgICBwbGFjZWhvbGRlclZhbHVlOiBcIlZhbHVlXCIsXG4gICAgICBwbGFjZWhvbGRlclZhbHVlVG9vbHRpcDogXCJUaGUgdmFsdWUgdGhhdCB3aWxsIHJlcGxhY2UgdGhlIHBsYWNlaG9sZGVyLiBTdGFydCB3aXRoIHB2OiB0byByZXRyaWV2ZSBhIHByb2Nlc3MgdmFyaWFibGVcIlxuICAgIH0sXG4gICAgZGU6IHtcbiAgICAgIHRpdGxlOiAnU3BvdGxlcicsXG4gICAgICBkZXNjcmlwdGlvbjpcbiAgICAgICAgICAnU3BvdGxlciBlcm3DtmdsaWNodCBkYXMgdmVyc2VuZGVuIHZvbiBFLU1haWxzIGF1cyBlaW5lbSBwcm96ZXNzIGhlcmF1cycsXG4gICAgICBjb25maWd1cmF0aW9uVGl0bGU6ICdLb25maWd1cmF0aW9uc25hbWUnLFxuICAgICAgY29uZmlndXJhdGlvblRpdGxlVG9vbHRpcDpcbiAgICAgICAgICAnVW50ZXIgZGllc2VtIE5hbWVuIHdpcmQgZGFzIFBsdWdpbiBpbSBSZXN0IGRlciBBbndlbmR1bmcgZXJrZW5uYmFyIHNlaW4nLFxuICAgICAgY2xpZW50SWQ6ICdDbGllbnQgSUQnLFxuICAgICAgY2xpZW50SWRUb29sdGlwOlxuICAgICAgICAgICdHZWJlbiBTaWUgaGllciBJaHJlIFNwb3RsZXItQ2xpZW50LUlEIGVpbicsXG4gICAgICBhY2NvdW50SWQ6ICdLb250by1JRCcsXG4gICAgICBhY2NvdW50SWRUb29sdGlwOiAnR2ViZW4gU2llIGRpZSBJRCBJaHJlcyBTcG90bGVyLUtvbnRvcyBlaW4nLFxuICAgICAgY2xpZW50U2VjcmV0OiAnU2VjcmV0JyxcbiAgICAgIGNsaWVudFNlY3JldFRvb2x0aXA6ICdHZWJlbiBTaWUgZGFzIG1pdCBkZXIgb2JpZ2VuIGNsaWVudElkIHZlcmtuw7xwZnRlIEdlaGVpbW5pcyBlaW4nLFxuICAgICAgdG9BZGRyZXNzOiBcIkUtTWFpbC1BZHJlc3NlXCIsXG4gICAgICB0b05hbWU6IFwiTmFtZSBkZXMgRW1wZsOkbmdlcnNcIixcbiAgICAgIHNlbmRlckVtYWlsOiBcIkUtTWFpbC1BZHJlc3NlIGRlcyBBYnNlbmRlclwiLFxuICAgICAgc2VuZGVyTmFtZTogXCJOYW1lIGRlcyBBYnNlbmRlclwiLFxuICAgICAgZW1haWxTdWJqZWN0OiBcIkUtTWFpbCBCZXRyZWZmXCIsXG4gICAgICBtYWlsVGVtcGxhdGVJZGVudGlmaWVyOiBcIlNwb3RsZXIgRS1NYWlsLVZvcmxhZ2VuLUlEXCIsXG4gICAgICBtYWlsVGVtcGxhdGVJZGVudGlmaWVyVG9vbHRpcDogXCJHZWJlbiBTaWUgZGllIFZvcmxhZ2Vua2VubnVuZyBJaHJlciBTcG90bGVyLUUtTWFpbC1Wb3JsYWdlIGVpblwiLFxuICAgICAgcmVjaXBpZW50czogXCJFbXBmw6RuZ2VyXCIsXG4gICAgICBhZGRSZWNpcGllbnQ6IFwiTmV1ZW4gRW1wZsOkbmdlciBoaW56dWbDvGdlblwiLFxuICAgICAgZW1haWxUeXBlOiBcIkVtcGbDpG5nZXJ0eXBcIixcbiAgICAgIHNlbmRNYWlsOiBcIkUtTWFpbCBzZW5kZW5cIixcbiAgICAgIHBsYWNlaG9sZGVyczogXCJQbGF0emhhbHRlclwiLFxuICAgICAgYWRkUGxhY2Vob2xkZXI6IFwiRsO8Z2VuIFNpZSBlaW5lbiBuZXVlbiBQbGF0emhhbHRlciBoaW56dVwiLFxuICAgICAgcGxhY2Vob2xkZXJLZXk6IFwiU2NobMO8c3NlbFwiLFxuICAgICAgcGxhY2Vob2xkZXJLZXlUb29sdGlwOiBcIkdlYmVuIFNpZSBlaW5lbiBQbGF0emhhbHRlcm5hbWVuIGVpbiwgYXVmIGRlbiBpbiBkZXIgU3BvdGxlci1FLU1haWwtVm9ybGFnZSB2ZXJ3aWVzZW4gd3VyZGVcIixcbiAgICAgIHBsYWNlaG9sZGVyVmFsdWU6IFwiV2VydFwiLFxuICAgICAgcGxhY2Vob2xkZXJWYWx1ZVRvb2x0aXA6IFwiRGVyIFdlcnQsIGRlciBkZW4gUGxhdHpoYWx0ZXIgZXJzZXR6dC4gQmVnaW5uZW4gU2llIG1pdCBwdjosIHVtIGVpbmUgUHJvemVzc3ZhcmlhYmxlIGFienVydWZlbi5cIlxuICAgIH0sXG4gIH0sXG59O1xuXG5leHBvcnQge3Nwb3RsZXJQbHVnaW5TcGVjaWZpY2F0aW9ufTtcbiIsIm1vZHVsZS5leHBvcnRzID0gd2luZG93W1wiQGFuZ3VsYXIvY29tbW9uXCJdOyIsIm1vZHVsZS5leHBvcnRzID0gd2luZG93W1wiQGFuZ3VsYXIvY29yZVwiXTsiLCJtb2R1bGUuZXhwb3J0cyA9IHdpbmRvd1tcIkB2YWx0aW1vL2NvbXBvbmVudHNcIl07IiwibW9kdWxlLmV4cG9ydHMgPSB3aW5kb3dbXCJAdmFsdGltby9wbHVnaW5cIl07IiwibW9kdWxlLmV4cG9ydHMgPSB3aW5kb3dbXCJyeGpzXCJdOyIsIm1vZHVsZS5leHBvcnRzID0gd2luZG93W1widHNsaWJcIl07IiwiLyoqXG4gKiBAbGljZW5zZSBBbmd1bGFyIHYxNy4zLjEyXG4gKiAoYykgMjAxMC0yMDI0IEdvb2dsZSBMTEMuIGh0dHBzOi8vYW5ndWxhci5pby9cbiAqIExpY2Vuc2U6IE1JVFxuICovXG5cbmltcG9ydCAqIGFzIGkwIGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgRGlyZWN0aXZlLCBJbmplY3Rpb25Ub2tlbiwgZm9yd2FyZFJlZiwgT3B0aW9uYWwsIEluamVjdCwgybVpc1Byb21pc2UsIMm1aXNTdWJzY3JpYmFibGUsIMm1UnVudGltZUVycm9yLCBTZWxmLCBFdmVudEVtaXR0ZXIsIElucHV0LCBIb3N0LCBTa2lwU2VsZiwgYm9vbGVhbkF0dHJpYnV0ZSwgQ2hhbmdlRGV0ZWN0b3JSZWYsIE91dHB1dCwgSW5qZWN0YWJsZSwgaW5qZWN0LCBOZ01vZHVsZSwgVmVyc2lvbiB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgybVnZXRET00gfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHsgZnJvbSwgZm9ya0pvaW4gfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IG1hcCB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcblxuLyoqXG4gKiBCYXNlIGNsYXNzIGZvciBhbGwgQ29udHJvbFZhbHVlQWNjZXNzb3IgY2xhc3NlcyBkZWZpbmVkIGluIEZvcm1zIHBhY2thZ2UuXG4gKiBDb250YWlucyBjb21tb24gbG9naWMgYW5kIHV0aWxpdHkgZnVuY3Rpb25zLlxuICpcbiAqIE5vdGU6IHRoaXMgaXMgYW4gKmludGVybmFsLW9ubHkqIGNsYXNzIGFuZCBzaG91bGQgbm90IGJlIGV4dGVuZGVkIG9yIHVzZWQgZGlyZWN0bHkgaW5cbiAqIGFwcGxpY2F0aW9ucyBjb2RlLlxuICovXG5jbGFzcyBCYXNlQ29udHJvbFZhbHVlQWNjZXNzb3Ige1xuICAgIGNvbnN0cnVjdG9yKF9yZW5kZXJlciwgX2VsZW1lbnRSZWYpIHtcbiAgICAgICAgdGhpcy5fcmVuZGVyZXIgPSBfcmVuZGVyZXI7XG4gICAgICAgIHRoaXMuX2VsZW1lbnRSZWYgPSBfZWxlbWVudFJlZjtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSByZWdpc3RlcmVkIGNhbGxiYWNrIGZ1bmN0aW9uIGNhbGxlZCB3aGVuIGEgY2hhbmdlIG9yIGlucHV0IGV2ZW50IG9jY3VycyBvbiB0aGUgaW5wdXRcbiAgICAgICAgICogZWxlbWVudC5cbiAgICAgICAgICogQG5vZG9jXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm9uQ2hhbmdlID0gKF8pID0+IHsgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSByZWdpc3RlcmVkIGNhbGxiYWNrIGZ1bmN0aW9uIGNhbGxlZCB3aGVuIGEgYmx1ciBldmVudCBvY2N1cnMgb24gdGhlIGlucHV0IGVsZW1lbnQuXG4gICAgICAgICAqIEBub2RvY1xuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5vblRvdWNoZWQgPSAoKSA9PiB7IH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEhlbHBlciBtZXRob2QgdGhhdCBzZXRzIGEgcHJvcGVydHkgb24gYSB0YXJnZXQgZWxlbWVudCB1c2luZyB0aGUgY3VycmVudCBSZW5kZXJlclxuICAgICAqIGltcGxlbWVudGF0aW9uLlxuICAgICAqIEBub2RvY1xuICAgICAqL1xuICAgIHNldFByb3BlcnR5KGtleSwgdmFsdWUpIHtcbiAgICAgICAgdGhpcy5fcmVuZGVyZXIuc2V0UHJvcGVydHkodGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LCBrZXksIHZhbHVlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVnaXN0ZXJzIGEgZnVuY3Rpb24gY2FsbGVkIHdoZW4gdGhlIGNvbnRyb2wgaXMgdG91Y2hlZC5cbiAgICAgKiBAbm9kb2NcbiAgICAgKi9cbiAgICByZWdpc3Rlck9uVG91Y2hlZChmbikge1xuICAgICAgICB0aGlzLm9uVG91Y2hlZCA9IGZuO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWdpc3RlcnMgYSBmdW5jdGlvbiBjYWxsZWQgd2hlbiB0aGUgY29udHJvbCB2YWx1ZSBjaGFuZ2VzLlxuICAgICAqIEBub2RvY1xuICAgICAqL1xuICAgIHJlZ2lzdGVyT25DaGFuZ2UoZm4pIHtcbiAgICAgICAgdGhpcy5vbkNoYW5nZSA9IGZuO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBcImRpc2FibGVkXCIgcHJvcGVydHkgb24gdGhlIHJhbmdlIGlucHV0IGVsZW1lbnQuXG4gICAgICogQG5vZG9jXG4gICAgICovXG4gICAgc2V0RGlzYWJsZWRTdGF0ZShpc0Rpc2FibGVkKSB7XG4gICAgICAgIHRoaXMuc2V0UHJvcGVydHkoJ2Rpc2FibGVkJywgaXNEaXNhYmxlZCk7XG4gICAgfVxuICAgIHN0YXRpYyB7IHRoaXMuybVmYWMgPSBpMC7Jtcm1bmdEZWNsYXJlRmFjdG9yeSh7IG1pblZlcnNpb246IFwiMTIuMC4wXCIsIHZlcnNpb246IFwiMTcuMy4xMlwiLCBuZ0ltcG9ydDogaTAsIHR5cGU6IEJhc2VDb250cm9sVmFsdWVBY2Nlc3NvciwgZGVwczogW3sgdG9rZW46IGkwLlJlbmRlcmVyMiB9LCB7IHRva2VuOiBpMC5FbGVtZW50UmVmIH1dLCB0YXJnZXQ6IGkwLsm1ybVGYWN0b3J5VGFyZ2V0LkRpcmVjdGl2ZSB9KTsgfVxuICAgIHN0YXRpYyB7IHRoaXMuybVkaXIgPSBpMC7Jtcm1bmdEZWNsYXJlRGlyZWN0aXZlKHsgbWluVmVyc2lvbjogXCIxNC4wLjBcIiwgdmVyc2lvbjogXCIxNy4zLjEyXCIsIHR5cGU6IEJhc2VDb250cm9sVmFsdWVBY2Nlc3NvciwgbmdJbXBvcnQ6IGkwIH0pOyB9XG59XG5pMC7Jtcm1bmdEZWNsYXJlQ2xhc3NNZXRhZGF0YSh7IG1pblZlcnNpb246IFwiMTIuMC4wXCIsIHZlcnNpb246IFwiMTcuMy4xMlwiLCBuZ0ltcG9ydDogaTAsIHR5cGU6IEJhc2VDb250cm9sVmFsdWVBY2Nlc3NvciwgZGVjb3JhdG9yczogW3tcbiAgICAgICAgICAgIHR5cGU6IERpcmVjdGl2ZVxuICAgICAgICB9XSwgY3RvclBhcmFtZXRlcnM6ICgpID0+IFt7IHR5cGU6IGkwLlJlbmRlcmVyMiB9LCB7IHR5cGU6IGkwLkVsZW1lbnRSZWYgfV0gfSk7XG4vKipcbiAqIEJhc2UgY2xhc3MgZm9yIGFsbCBidWlsdC1pbiBDb250cm9sVmFsdWVBY2Nlc3NvciBjbGFzc2VzIChleGNlcHQgRGVmYXVsdFZhbHVlQWNjZXNzb3IsIHdoaWNoIGlzXG4gKiB1c2VkIGluIGNhc2Ugbm8gb3RoZXIgQ1ZBcyBjYW4gYmUgZm91bmQpLiBXZSB1c2UgdGhpcyBjbGFzcyB0byBkaXN0aW5ndWlzaCBiZXR3ZWVuIGRlZmF1bHQgQ1ZBLFxuICogYnVpbHQtaW4gQ1ZBcyBhbmQgY3VzdG9tIENWQXMsIHNvIHRoYXQgRm9ybXMgbG9naWMgY2FuIHJlY29nbml6ZSBidWlsdC1pbiBDVkFzIGFuZCB0cmVhdCBjdXN0b21cbiAqIG9uZXMgd2l0aCBoaWdoZXIgcHJpb3JpdHkgKHdoZW4gYm90aCBidWlsdC1pbiBhbmQgY3VzdG9tIENWQXMgYXJlIHByZXNlbnQpLlxuICpcbiAqIE5vdGU6IHRoaXMgaXMgYW4gKmludGVybmFsLW9ubHkqIGNsYXNzIGFuZCBzaG91bGQgbm90IGJlIGV4dGVuZGVkIG9yIHVzZWQgZGlyZWN0bHkgaW5cbiAqIGFwcGxpY2F0aW9ucyBjb2RlLlxuICovXG5jbGFzcyBCdWlsdEluQ29udHJvbFZhbHVlQWNjZXNzb3IgZXh0ZW5kcyBCYXNlQ29udHJvbFZhbHVlQWNjZXNzb3Ige1xuICAgIHN0YXRpYyB7IHRoaXMuybVmYWMgPSBpMC7Jtcm1bmdEZWNsYXJlRmFjdG9yeSh7IG1pblZlcnNpb246IFwiMTIuMC4wXCIsIHZlcnNpb246IFwiMTcuMy4xMlwiLCBuZ0ltcG9ydDogaTAsIHR5cGU6IEJ1aWx0SW5Db250cm9sVmFsdWVBY2Nlc3NvciwgZGVwczogbnVsbCwgdGFyZ2V0OiBpMC7Jtcm1RmFjdG9yeVRhcmdldC5EaXJlY3RpdmUgfSk7IH1cbiAgICBzdGF0aWMgeyB0aGlzLsm1ZGlyID0gaTAuybXJtW5nRGVjbGFyZURpcmVjdGl2ZSh7IG1pblZlcnNpb246IFwiMTQuMC4wXCIsIHZlcnNpb246IFwiMTcuMy4xMlwiLCB0eXBlOiBCdWlsdEluQ29udHJvbFZhbHVlQWNjZXNzb3IsIHVzZXNJbmhlcml0YW5jZTogdHJ1ZSwgbmdJbXBvcnQ6IGkwIH0pOyB9XG59XG5pMC7Jtcm1bmdEZWNsYXJlQ2xhc3NNZXRhZGF0YSh7IG1pblZlcnNpb246IFwiMTIuMC4wXCIsIHZlcnNpb246IFwiMTcuMy4xMlwiLCBuZ0ltcG9ydDogaTAsIHR5cGU6IEJ1aWx0SW5Db250cm9sVmFsdWVBY2Nlc3NvciwgZGVjb3JhdG9yczogW3tcbiAgICAgICAgICAgIHR5cGU6IERpcmVjdGl2ZVxuICAgICAgICB9XSB9KTtcbi8qKlxuICogVXNlZCB0byBwcm92aWRlIGEgYENvbnRyb2xWYWx1ZUFjY2Vzc29yYCBmb3IgZm9ybSBjb250cm9scy5cbiAqXG4gKiBTZWUgYERlZmF1bHRWYWx1ZUFjY2Vzc29yYCBmb3IgaG93IHRvIGltcGxlbWVudCBvbmUuXG4gKlxuICogQHB1YmxpY0FwaVxuICovXG5jb25zdCBOR19WQUxVRV9BQ0NFU1NPUiA9IG5ldyBJbmplY3Rpb25Ub2tlbihuZ0Rldk1vZGUgPyAnTmdWYWx1ZUFjY2Vzc29yJyA6ICcnKTtcblxuY29uc3QgQ0hFQ0tCT1hfVkFMVUVfQUNDRVNTT1IgPSB7XG4gICAgcHJvdmlkZTogTkdfVkFMVUVfQUNDRVNTT1IsXG4gICAgdXNlRXhpc3Rpbmc6IGZvcndhcmRSZWYoKCkgPT4gQ2hlY2tib3hDb250cm9sVmFsdWVBY2Nlc3NvciksXG4gICAgbXVsdGk6IHRydWUsXG59O1xuLyoqXG4gKiBAZGVzY3JpcHRpb25cbiAqIEEgYENvbnRyb2xWYWx1ZUFjY2Vzc29yYCBmb3Igd3JpdGluZyBhIHZhbHVlIGFuZCBsaXN0ZW5pbmcgdG8gY2hhbmdlcyBvbiBhIGNoZWNrYm94IGlucHV0XG4gKiBlbGVtZW50LlxuICpcbiAqIEB1c2FnZU5vdGVzXG4gKlxuICogIyMjIFVzaW5nIGEgY2hlY2tib3ggd2l0aCBhIHJlYWN0aXZlIGZvcm0uXG4gKlxuICogVGhlIGZvbGxvd2luZyBleGFtcGxlIHNob3dzIGhvdyB0byB1c2UgYSBjaGVja2JveCB3aXRoIGEgcmVhY3RpdmUgZm9ybS5cbiAqXG4gKiBgYGB0c1xuICogY29uc3QgcmVtZW1iZXJMb2dpbkNvbnRyb2wgPSBuZXcgRm9ybUNvbnRyb2woKTtcbiAqIGBgYFxuICpcbiAqIGBgYFxuICogPGlucHV0IHR5cGU9XCJjaGVja2JveFwiIFtmb3JtQ29udHJvbF09XCJyZW1lbWJlckxvZ2luQ29udHJvbFwiPlxuICogYGBgXG4gKlxuICogQG5nTW9kdWxlIFJlYWN0aXZlRm9ybXNNb2R1bGVcbiAqIEBuZ01vZHVsZSBGb3Jtc01vZHVsZVxuICogQHB1YmxpY0FwaVxuICovXG5jbGFzcyBDaGVja2JveENvbnRyb2xWYWx1ZUFjY2Vzc29yIGV4dGVuZHMgQnVpbHRJbkNvbnRyb2xWYWx1ZUFjY2Vzc29yIHtcbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBcImNoZWNrZWRcIiBwcm9wZXJ0eSBvbiB0aGUgaW5wdXQgZWxlbWVudC5cbiAgICAgKiBAbm9kb2NcbiAgICAgKi9cbiAgICB3cml0ZVZhbHVlKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuc2V0UHJvcGVydHkoJ2NoZWNrZWQnLCB2YWx1ZSk7XG4gICAgfVxuICAgIHN0YXRpYyB7IHRoaXMuybVmYWMgPSBpMC7Jtcm1bmdEZWNsYXJlRmFjdG9yeSh7IG1pblZlcnNpb246IFwiMTIuMC4wXCIsIHZlcnNpb246IFwiMTcuMy4xMlwiLCBuZ0ltcG9ydDogaTAsIHR5cGU6IENoZWNrYm94Q29udHJvbFZhbHVlQWNjZXNzb3IsIGRlcHM6IG51bGwsIHRhcmdldDogaTAuybXJtUZhY3RvcnlUYXJnZXQuRGlyZWN0aXZlIH0pOyB9XG4gICAgc3RhdGljIHsgdGhpcy7JtWRpciA9IGkwLsm1ybVuZ0RlY2xhcmVEaXJlY3RpdmUoeyBtaW5WZXJzaW9uOiBcIjE0LjAuMFwiLCB2ZXJzaW9uOiBcIjE3LjMuMTJcIiwgdHlwZTogQ2hlY2tib3hDb250cm9sVmFsdWVBY2Nlc3Nvciwgc2VsZWN0b3I6IFwiaW5wdXRbdHlwZT1jaGVja2JveF1bZm9ybUNvbnRyb2xOYW1lXSxpbnB1dFt0eXBlPWNoZWNrYm94XVtmb3JtQ29udHJvbF0saW5wdXRbdHlwZT1jaGVja2JveF1bbmdNb2RlbF1cIiwgaG9zdDogeyBsaXN0ZW5lcnM6IHsgXCJjaGFuZ2VcIjogXCJvbkNoYW5nZSgkZXZlbnQudGFyZ2V0LmNoZWNrZWQpXCIsIFwiYmx1clwiOiBcIm9uVG91Y2hlZCgpXCIgfSB9LCBwcm92aWRlcnM6IFtDSEVDS0JPWF9WQUxVRV9BQ0NFU1NPUl0sIHVzZXNJbmhlcml0YW5jZTogdHJ1ZSwgbmdJbXBvcnQ6IGkwIH0pOyB9XG59XG5pMC7Jtcm1bmdEZWNsYXJlQ2xhc3NNZXRhZGF0YSh7IG1pblZlcnNpb246IFwiMTIuMC4wXCIsIHZlcnNpb246IFwiMTcuMy4xMlwiLCBuZ0ltcG9ydDogaTAsIHR5cGU6IENoZWNrYm94Q29udHJvbFZhbHVlQWNjZXNzb3IsIGRlY29yYXRvcnM6IFt7XG4gICAgICAgICAgICB0eXBlOiBEaXJlY3RpdmUsXG4gICAgICAgICAgICBhcmdzOiBbe1xuICAgICAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ2lucHV0W3R5cGU9Y2hlY2tib3hdW2Zvcm1Db250cm9sTmFtZV0saW5wdXRbdHlwZT1jaGVja2JveF1bZm9ybUNvbnRyb2xdLGlucHV0W3R5cGU9Y2hlY2tib3hdW25nTW9kZWxdJyxcbiAgICAgICAgICAgICAgICAgICAgaG9zdDogeyAnKGNoYW5nZSknOiAnb25DaGFuZ2UoJGV2ZW50LnRhcmdldC5jaGVja2VkKScsICcoYmx1ciknOiAnb25Ub3VjaGVkKCknIH0sXG4gICAgICAgICAgICAgICAgICAgIHByb3ZpZGVyczogW0NIRUNLQk9YX1ZBTFVFX0FDQ0VTU09SXVxuICAgICAgICAgICAgICAgIH1dXG4gICAgICAgIH1dIH0pO1xuXG5jb25zdCBERUZBVUxUX1ZBTFVFX0FDQ0VTU09SID0ge1xuICAgIHByb3ZpZGU6IE5HX1ZBTFVFX0FDQ0VTU09SLFxuICAgIHVzZUV4aXN0aW5nOiBmb3J3YXJkUmVmKCgpID0+IERlZmF1bHRWYWx1ZUFjY2Vzc29yKSxcbiAgICBtdWx0aTogdHJ1ZVxufTtcbi8qKlxuICogV2UgbXVzdCBjaGVjayB3aGV0aGVyIHRoZSBhZ2VudCBpcyBBbmRyb2lkIGJlY2F1c2UgY29tcG9zaXRpb24gZXZlbnRzXG4gKiBiZWhhdmUgZGlmZmVyZW50bHkgYmV0d2VlbiBpT1MgYW5kIEFuZHJvaWQuXG4gKi9cbmZ1bmN0aW9uIF9pc0FuZHJvaWQoKSB7XG4gICAgY29uc3QgdXNlckFnZW50ID0gybVnZXRET00oKSA/IMm1Z2V0RE9NKCkuZ2V0VXNlckFnZW50KCkgOiAnJztcbiAgICByZXR1cm4gL2FuZHJvaWQgKFxcZCspLy50ZXN0KHVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpKTtcbn1cbi8qKlxuICogQGRlc2NyaXB0aW9uXG4gKiBQcm92aWRlIHRoaXMgdG9rZW4gdG8gY29udHJvbCBpZiBmb3JtIGRpcmVjdGl2ZXMgYnVmZmVyIElNRSBpbnB1dCB1bnRpbFxuICogdGhlIFwiY29tcG9zaXRpb25lbmRcIiBldmVudCBvY2N1cnMuXG4gKiBAcHVibGljQXBpXG4gKi9cbmNvbnN0IENPTVBPU0lUSU9OX0JVRkZFUl9NT0RFID0gbmV3IEluamVjdGlvblRva2VuKG5nRGV2TW9kZSA/ICdDb21wb3NpdGlvbkV2ZW50TW9kZScgOiAnJyk7XG4vKipcbiAqIFRoZSBkZWZhdWx0IGBDb250cm9sVmFsdWVBY2Nlc3NvcmAgZm9yIHdyaXRpbmcgYSB2YWx1ZSBhbmQgbGlzdGVuaW5nIHRvIGNoYW5nZXMgb24gaW5wdXRcbiAqIGVsZW1lbnRzLiBUaGUgYWNjZXNzb3IgaXMgdXNlZCBieSB0aGUgYEZvcm1Db250cm9sRGlyZWN0aXZlYCwgYEZvcm1Db250cm9sTmFtZWAsIGFuZFxuICogYE5nTW9kZWxgIGRpcmVjdGl2ZXMuXG4gKlxuICoge0BzZWFyY2hLZXl3b3JkcyBuZ0RlZmF1bHRDb250cm9sfVxuICpcbiAqIEB1c2FnZU5vdGVzXG4gKlxuICogIyMjIFVzaW5nIHRoZSBkZWZhdWx0IHZhbHVlIGFjY2Vzc29yXG4gKlxuICogVGhlIGZvbGxvd2luZyBleGFtcGxlIHNob3dzIGhvdyB0byB1c2UgYW4gaW5wdXQgZWxlbWVudCB0aGF0IGFjdGl2YXRlcyB0aGUgZGVmYXVsdCB2YWx1ZSBhY2Nlc3NvclxuICogKGluIHRoaXMgY2FzZSwgYSB0ZXh0IGZpZWxkKS5cbiAqXG4gKiBgYGB0c1xuICogY29uc3QgZmlyc3ROYW1lQ29udHJvbCA9IG5ldyBGb3JtQ29udHJvbCgpO1xuICogYGBgXG4gKlxuICogYGBgXG4gKiA8aW5wdXQgdHlwZT1cInRleHRcIiBbZm9ybUNvbnRyb2xdPVwiZmlyc3ROYW1lQ29udHJvbFwiPlxuICogYGBgXG4gKlxuICogVGhpcyB2YWx1ZSBhY2Nlc3NvciBpcyB1c2VkIGJ5IGRlZmF1bHQgZm9yIGA8aW5wdXQgdHlwZT1cInRleHRcIj5gIGFuZCBgPHRleHRhcmVhPmAgZWxlbWVudHMsIGJ1dFxuICogeW91IGNvdWxkIGFsc28gdXNlIGl0IGZvciBjdXN0b20gY29tcG9uZW50cyB0aGF0IGhhdmUgc2ltaWxhciBiZWhhdmlvciBhbmQgZG8gbm90IHJlcXVpcmUgc3BlY2lhbFxuICogcHJvY2Vzc2luZy4gSW4gb3JkZXIgdG8gYXR0YWNoIHRoZSBkZWZhdWx0IHZhbHVlIGFjY2Vzc29yIHRvIGEgY3VzdG9tIGVsZW1lbnQsIGFkZCB0aGVcbiAqIGBuZ0RlZmF1bHRDb250cm9sYCBhdHRyaWJ1dGUgYXMgc2hvd24gYmVsb3cuXG4gKlxuICogYGBgXG4gKiA8Y3VzdG9tLWlucHV0LWNvbXBvbmVudCBuZ0RlZmF1bHRDb250cm9sIFsobmdNb2RlbCldPVwidmFsdWVcIj48L2N1c3RvbS1pbnB1dC1jb21wb25lbnQ+XG4gKiBgYGBcbiAqXG4gKiBAbmdNb2R1bGUgUmVhY3RpdmVGb3Jtc01vZHVsZVxuICogQG5nTW9kdWxlIEZvcm1zTW9kdWxlXG4gKiBAcHVibGljQXBpXG4gKi9cbmNsYXNzIERlZmF1bHRWYWx1ZUFjY2Vzc29yIGV4dGVuZHMgQmFzZUNvbnRyb2xWYWx1ZUFjY2Vzc29yIHtcbiAgICBjb25zdHJ1Y3RvcihyZW5kZXJlciwgZWxlbWVudFJlZiwgX2NvbXBvc2l0aW9uTW9kZSkge1xuICAgICAgICBzdXBlcihyZW5kZXJlciwgZWxlbWVudFJlZik7XG4gICAgICAgIHRoaXMuX2NvbXBvc2l0aW9uTW9kZSA9IF9jb21wb3NpdGlvbk1vZGU7XG4gICAgICAgIC8qKiBXaGV0aGVyIHRoZSB1c2VyIGlzIGNyZWF0aW5nIGEgY29tcG9zaXRpb24gc3RyaW5nIChJTUUgZXZlbnRzKS4gKi9cbiAgICAgICAgdGhpcy5fY29tcG9zaW5nID0gZmFsc2U7XG4gICAgICAgIGlmICh0aGlzLl9jb21wb3NpdGlvbk1vZGUgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5fY29tcG9zaXRpb25Nb2RlID0gIV9pc0FuZHJvaWQoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBcInZhbHVlXCIgcHJvcGVydHkgb24gdGhlIGlucHV0IGVsZW1lbnQuXG4gICAgICogQG5vZG9jXG4gICAgICovXG4gICAgd3JpdGVWYWx1ZSh2YWx1ZSkge1xuICAgICAgICBjb25zdCBub3JtYWxpemVkVmFsdWUgPSB2YWx1ZSA9PSBudWxsID8gJycgOiB2YWx1ZTtcbiAgICAgICAgdGhpcy5zZXRQcm9wZXJ0eSgndmFsdWUnLCBub3JtYWxpemVkVmFsdWUpO1xuICAgIH1cbiAgICAvKiogQGludGVybmFsICovXG4gICAgX2hhbmRsZUlucHV0KHZhbHVlKSB7XG4gICAgICAgIGlmICghdGhpcy5fY29tcG9zaXRpb25Nb2RlIHx8ICh0aGlzLl9jb21wb3NpdGlvbk1vZGUgJiYgIXRoaXMuX2NvbXBvc2luZykpIHtcbiAgICAgICAgICAgIHRoaXMub25DaGFuZ2UodmFsdWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBfY29tcG9zaXRpb25TdGFydCgpIHtcbiAgICAgICAgdGhpcy5fY29tcG9zaW5nID0gdHJ1ZTtcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIF9jb21wb3NpdGlvbkVuZCh2YWx1ZSkge1xuICAgICAgICB0aGlzLl9jb21wb3NpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fY29tcG9zaXRpb25Nb2RlICYmIHRoaXMub25DaGFuZ2UodmFsdWUpO1xuICAgIH1cbiAgICBzdGF0aWMgeyB0aGlzLsm1ZmFjID0gaTAuybXJtW5nRGVjbGFyZUZhY3RvcnkoeyBtaW5WZXJzaW9uOiBcIjEyLjAuMFwiLCB2ZXJzaW9uOiBcIjE3LjMuMTJcIiwgbmdJbXBvcnQ6IGkwLCB0eXBlOiBEZWZhdWx0VmFsdWVBY2Nlc3NvciwgZGVwczogW3sgdG9rZW46IGkwLlJlbmRlcmVyMiB9LCB7IHRva2VuOiBpMC5FbGVtZW50UmVmIH0sIHsgdG9rZW46IENPTVBPU0lUSU9OX0JVRkZFUl9NT0RFLCBvcHRpb25hbDogdHJ1ZSB9XSwgdGFyZ2V0OiBpMC7Jtcm1RmFjdG9yeVRhcmdldC5EaXJlY3RpdmUgfSk7IH1cbiAgICBzdGF0aWMgeyB0aGlzLsm1ZGlyID0gaTAuybXJtW5nRGVjbGFyZURpcmVjdGl2ZSh7IG1pblZlcnNpb246IFwiMTQuMC4wXCIsIHZlcnNpb246IFwiMTcuMy4xMlwiLCB0eXBlOiBEZWZhdWx0VmFsdWVBY2Nlc3Nvciwgc2VsZWN0b3I6IFwiaW5wdXQ6bm90KFt0eXBlPWNoZWNrYm94XSlbZm9ybUNvbnRyb2xOYW1lXSx0ZXh0YXJlYVtmb3JtQ29udHJvbE5hbWVdLGlucHV0Om5vdChbdHlwZT1jaGVja2JveF0pW2Zvcm1Db250cm9sXSx0ZXh0YXJlYVtmb3JtQ29udHJvbF0saW5wdXQ6bm90KFt0eXBlPWNoZWNrYm94XSlbbmdNb2RlbF0sdGV4dGFyZWFbbmdNb2RlbF0sW25nRGVmYXVsdENvbnRyb2xdXCIsIGhvc3Q6IHsgbGlzdGVuZXJzOiB7IFwiaW5wdXRcIjogXCIkYW55KHRoaXMpLl9oYW5kbGVJbnB1dCgkZXZlbnQudGFyZ2V0LnZhbHVlKVwiLCBcImJsdXJcIjogXCJvblRvdWNoZWQoKVwiLCBcImNvbXBvc2l0aW9uc3RhcnRcIjogXCIkYW55KHRoaXMpLl9jb21wb3NpdGlvblN0YXJ0KClcIiwgXCJjb21wb3NpdGlvbmVuZFwiOiBcIiRhbnkodGhpcykuX2NvbXBvc2l0aW9uRW5kKCRldmVudC50YXJnZXQudmFsdWUpXCIgfSB9LCBwcm92aWRlcnM6IFtERUZBVUxUX1ZBTFVFX0FDQ0VTU09SXSwgdXNlc0luaGVyaXRhbmNlOiB0cnVlLCBuZ0ltcG9ydDogaTAgfSk7IH1cbn1cbmkwLsm1ybVuZ0RlY2xhcmVDbGFzc01ldGFkYXRhKHsgbWluVmVyc2lvbjogXCIxMi4wLjBcIiwgdmVyc2lvbjogXCIxNy4zLjEyXCIsIG5nSW1wb3J0OiBpMCwgdHlwZTogRGVmYXVsdFZhbHVlQWNjZXNzb3IsIGRlY29yYXRvcnM6IFt7XG4gICAgICAgICAgICB0eXBlOiBEaXJlY3RpdmUsXG4gICAgICAgICAgICBhcmdzOiBbe1xuICAgICAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ2lucHV0Om5vdChbdHlwZT1jaGVja2JveF0pW2Zvcm1Db250cm9sTmFtZV0sdGV4dGFyZWFbZm9ybUNvbnRyb2xOYW1lXSxpbnB1dDpub3QoW3R5cGU9Y2hlY2tib3hdKVtmb3JtQ29udHJvbF0sdGV4dGFyZWFbZm9ybUNvbnRyb2xdLGlucHV0Om5vdChbdHlwZT1jaGVja2JveF0pW25nTW9kZWxdLHRleHRhcmVhW25nTW9kZWxdLFtuZ0RlZmF1bHRDb250cm9sXScsXG4gICAgICAgICAgICAgICAgICAgIC8vIFRPRE86IHZzYXZraW4gcmVwbGFjZSB0aGUgYWJvdmUgc2VsZWN0b3Igd2l0aCB0aGUgb25lIGJlbG93IGl0IG9uY2VcbiAgICAgICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2FuZ3VsYXIvYW5ndWxhci9pc3N1ZXMvMzAxMSBpcyBpbXBsZW1lbnRlZFxuICAgICAgICAgICAgICAgICAgICAvLyBzZWxlY3RvcjogJ1tuZ01vZGVsXSxbZm9ybUNvbnRyb2xdLFtmb3JtQ29udHJvbE5hbWVdJyxcbiAgICAgICAgICAgICAgICAgICAgaG9zdDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgJyhpbnB1dCknOiAnJGFueSh0aGlzKS5faGFuZGxlSW5wdXQoJGV2ZW50LnRhcmdldC52YWx1ZSknLFxuICAgICAgICAgICAgICAgICAgICAgICAgJyhibHVyKSc6ICdvblRvdWNoZWQoKScsXG4gICAgICAgICAgICAgICAgICAgICAgICAnKGNvbXBvc2l0aW9uc3RhcnQpJzogJyRhbnkodGhpcykuX2NvbXBvc2l0aW9uU3RhcnQoKScsXG4gICAgICAgICAgICAgICAgICAgICAgICAnKGNvbXBvc2l0aW9uZW5kKSc6ICckYW55KHRoaXMpLl9jb21wb3NpdGlvbkVuZCgkZXZlbnQudGFyZ2V0LnZhbHVlKSdcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgcHJvdmlkZXJzOiBbREVGQVVMVF9WQUxVRV9BQ0NFU1NPUl1cbiAgICAgICAgICAgICAgICB9XVxuICAgICAgICB9XSwgY3RvclBhcmFtZXRlcnM6ICgpID0+IFt7IHR5cGU6IGkwLlJlbmRlcmVyMiB9LCB7IHR5cGU6IGkwLkVsZW1lbnRSZWYgfSwgeyB0eXBlOiB1bmRlZmluZWQsIGRlY29yYXRvcnM6IFt7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IE9wdGlvbmFsXG4gICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBJbmplY3QsXG4gICAgICAgICAgICAgICAgICAgIGFyZ3M6IFtDT01QT1NJVElPTl9CVUZGRVJfTU9ERV1cbiAgICAgICAgICAgICAgICB9XSB9XSB9KTtcblxuZnVuY3Rpb24gaXNFbXB0eUlucHV0VmFsdWUodmFsdWUpIHtcbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiB0aGUgb2JqZWN0IGlzIGEgc3RyaW5nIG9yIGFycmF5IGJlZm9yZSBldmFsdWF0aW5nIHRoZSBsZW5ndGggYXR0cmlidXRlLlxuICAgICAqIFRoaXMgYXZvaWRzIGZhbHNlbHkgcmVqZWN0aW5nIG9iamVjdHMgdGhhdCBjb250YWluIGEgY3VzdG9tIGxlbmd0aCBhdHRyaWJ1dGUuXG4gICAgICogRm9yIGV4YW1wbGUsIHRoZSBvYmplY3Qge2lkOiAxLCBsZW5ndGg6IDAsIHdpZHRoOiAwfSBzaG91bGQgbm90IGJlIHJldHVybmVkIGFzIGVtcHR5LlxuICAgICAqL1xuICAgIHJldHVybiB2YWx1ZSA9PSBudWxsIHx8XG4gICAgICAgICgodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyB8fCBBcnJheS5pc0FycmF5KHZhbHVlKSkgJiYgdmFsdWUubGVuZ3RoID09PSAwKTtcbn1cbmZ1bmN0aW9uIGhhc1ZhbGlkTGVuZ3RoKHZhbHVlKSB7XG4gICAgLy8gbm9uLXN0cmljdCBjb21wYXJpc29uIGlzIGludGVudGlvbmFsLCB0byBjaGVjayBmb3IgYm90aCBgbnVsbGAgYW5kIGB1bmRlZmluZWRgIHZhbHVlc1xuICAgIHJldHVybiB2YWx1ZSAhPSBudWxsICYmIHR5cGVvZiB2YWx1ZS5sZW5ndGggPT09ICdudW1iZXInO1xufVxuLyoqXG4gKiBAZGVzY3JpcHRpb25cbiAqIEFuIGBJbmplY3Rpb25Ub2tlbmAgZm9yIHJlZ2lzdGVyaW5nIGFkZGl0aW9uYWwgc3luY2hyb25vdXMgdmFsaWRhdG9ycyB1c2VkIHdpdGhcbiAqIGBBYnN0cmFjdENvbnRyb2xgcy5cbiAqXG4gKiBAc2VlIHtAbGluayBOR19BU1lOQ19WQUxJREFUT1JTfVxuICpcbiAqIEB1c2FnZU5vdGVzXG4gKlxuICogIyMjIFByb3ZpZGluZyBhIGN1c3RvbSB2YWxpZGF0b3JcbiAqXG4gKiBUaGUgZm9sbG93aW5nIGV4YW1wbGUgcmVnaXN0ZXJzIGEgY3VzdG9tIHZhbGlkYXRvciBkaXJlY3RpdmUuIEFkZGluZyB0aGUgdmFsaWRhdG9yIHRvIHRoZVxuICogZXhpc3RpbmcgY29sbGVjdGlvbiBvZiB2YWxpZGF0b3JzIHJlcXVpcmVzIHRoZSBgbXVsdGk6IHRydWVgIG9wdGlvbi5cbiAqXG4gKiBgYGB0eXBlc2NyaXB0XG4gKiBARGlyZWN0aXZlKHtcbiAqICAgc2VsZWN0b3I6ICdbY3VzdG9tVmFsaWRhdG9yXScsXG4gKiAgIHByb3ZpZGVyczogW3twcm92aWRlOiBOR19WQUxJREFUT1JTLCB1c2VFeGlzdGluZzogQ3VzdG9tVmFsaWRhdG9yRGlyZWN0aXZlLCBtdWx0aTogdHJ1ZX1dXG4gKiB9KVxuICogY2xhc3MgQ3VzdG9tVmFsaWRhdG9yRGlyZWN0aXZlIGltcGxlbWVudHMgVmFsaWRhdG9yIHtcbiAqICAgdmFsaWRhdGUoY29udHJvbDogQWJzdHJhY3RDb250cm9sKTogVmFsaWRhdGlvbkVycm9ycyB8IG51bGwge1xuICogICAgIHJldHVybiB7ICdjdXN0b20nOiB0cnVlIH07XG4gKiAgIH1cbiAqIH1cbiAqIGBgYFxuICpcbiAqIEBwdWJsaWNBcGlcbiAqL1xuY29uc3QgTkdfVkFMSURBVE9SUyA9IG5ldyBJbmplY3Rpb25Ub2tlbihuZ0Rldk1vZGUgPyAnTmdWYWxpZGF0b3JzJyA6ICcnKTtcbi8qKlxuICogQGRlc2NyaXB0aW9uXG4gKiBBbiBgSW5qZWN0aW9uVG9rZW5gIGZvciByZWdpc3RlcmluZyBhZGRpdGlvbmFsIGFzeW5jaHJvbm91cyB2YWxpZGF0b3JzIHVzZWQgd2l0aFxuICogYEFic3RyYWN0Q29udHJvbGBzLlxuICpcbiAqIEBzZWUge0BsaW5rIE5HX1ZBTElEQVRPUlN9XG4gKlxuICogQHVzYWdlTm90ZXNcbiAqXG4gKiAjIyMgUHJvdmlkZSBhIGN1c3RvbSBhc3luYyB2YWxpZGF0b3IgZGlyZWN0aXZlXG4gKlxuICogVGhlIGZvbGxvd2luZyBleGFtcGxlIGltcGxlbWVudHMgdGhlIGBBc3luY1ZhbGlkYXRvcmAgaW50ZXJmYWNlIHRvIGNyZWF0ZSBhblxuICogYXN5bmMgdmFsaWRhdG9yIGRpcmVjdGl2ZSB3aXRoIGEgY3VzdG9tIGVycm9yIGtleS5cbiAqXG4gKiBgYGB0eXBlc2NyaXB0XG4gKiBARGlyZWN0aXZlKHtcbiAqICAgc2VsZWN0b3I6ICdbY3VzdG9tQXN5bmNWYWxpZGF0b3JdJyxcbiAqICAgcHJvdmlkZXJzOiBbe3Byb3ZpZGU6IE5HX0FTWU5DX1ZBTElEQVRPUlMsIHVzZUV4aXN0aW5nOiBDdXN0b21Bc3luY1ZhbGlkYXRvckRpcmVjdGl2ZSwgbXVsdGk6XG4gKiB0cnVlfV1cbiAqIH0pXG4gKiBjbGFzcyBDdXN0b21Bc3luY1ZhbGlkYXRvckRpcmVjdGl2ZSBpbXBsZW1lbnRzIEFzeW5jVmFsaWRhdG9yIHtcbiAqICAgdmFsaWRhdGUoY29udHJvbDogQWJzdHJhY3RDb250cm9sKTogUHJvbWlzZTxWYWxpZGF0aW9uRXJyb3JzfG51bGw+IHtcbiAqICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHsnY3VzdG9tJzogdHJ1ZX0pO1xuICogICB9XG4gKiB9XG4gKiBgYGBcbiAqXG4gKiBAcHVibGljQXBpXG4gKi9cbmNvbnN0IE5HX0FTWU5DX1ZBTElEQVRPUlMgPSBuZXcgSW5qZWN0aW9uVG9rZW4obmdEZXZNb2RlID8gJ05nQXN5bmNWYWxpZGF0b3JzJyA6ICcnKTtcbi8qKlxuICogQSByZWd1bGFyIGV4cHJlc3Npb24gdGhhdCBtYXRjaGVzIHZhbGlkIGUtbWFpbCBhZGRyZXNzZXMuXG4gKlxuICogQXQgYSBoaWdoIGxldmVsLCB0aGlzIHJlZ2V4cCBtYXRjaGVzIGUtbWFpbCBhZGRyZXNzZXMgb2YgdGhlIGZvcm1hdCBgbG9jYWwtcGFydEB0bGRgLCB3aGVyZTpcbiAqIC0gYGxvY2FsLXBhcnRgIGNvbnNpc3RzIG9mIG9uZSBvciBtb3JlIG9mIHRoZSBhbGxvd2VkIGNoYXJhY3RlcnMgKGFscGhhbnVtZXJpYyBhbmQgc29tZVxuICogICBwdW5jdHVhdGlvbiBzeW1ib2xzKS5cbiAqIC0gYGxvY2FsLXBhcnRgIGNhbm5vdCBiZWdpbiBvciBlbmQgd2l0aCBhIHBlcmlvZCAoYC5gKS5cbiAqIC0gYGxvY2FsLXBhcnRgIGNhbm5vdCBiZSBsb25nZXIgdGhhbiA2NCBjaGFyYWN0ZXJzLlxuICogLSBgdGxkYCBjb25zaXN0cyBvZiBvbmUgb3IgbW9yZSBgbGFiZWxzYCBzZXBhcmF0ZWQgYnkgcGVyaW9kcyAoYC5gKS4gRm9yIGV4YW1wbGUgYGxvY2FsaG9zdGAgb3JcbiAqICAgYGZvby5jb21gLlxuICogLSBBIGBsYWJlbGAgY29uc2lzdHMgb2Ygb25lIG9yIG1vcmUgb2YgdGhlIGFsbG93ZWQgY2hhcmFjdGVycyAoYWxwaGFudW1lcmljLCBkYXNoZXMgKGAtYCkgYW5kXG4gKiAgIHBlcmlvZHMgKGAuYCkpLlxuICogLSBBIGBsYWJlbGAgY2Fubm90IGJlZ2luIG9yIGVuZCB3aXRoIGEgZGFzaCAoYC1gKSBvciBhIHBlcmlvZCAoYC5gKS5cbiAqIC0gQSBgbGFiZWxgIGNhbm5vdCBiZSBsb25nZXIgdGhhbiA2MyBjaGFyYWN0ZXJzLlxuICogLSBUaGUgd2hvbGUgYWRkcmVzcyBjYW5ub3QgYmUgbG9uZ2VyIHRoYW4gMjU0IGNoYXJhY3RlcnMuXG4gKlxuICogIyMgSW1wbGVtZW50YXRpb24gYmFja2dyb3VuZFxuICpcbiAqIFRoaXMgcmVnZXhwIHdhcyBwb3J0ZWQgb3ZlciBmcm9tIEFuZ3VsYXJKUyAoc2VlIHRoZXJlIGZvciBnaXQgaGlzdG9yeSk6XG4gKiBodHRwczovL2dpdGh1Yi5jb20vYW5ndWxhci9hbmd1bGFyLmpzL2Jsb2IvYzEzM2VmODM2L3NyYy9uZy9kaXJlY3RpdmUvaW5wdXQuanMjTDI3XG4gKiBJdCBpcyBiYXNlZCBvbiB0aGVcbiAqIFtXSEFUV0cgdmVyc2lvbl0oaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvaW5wdXQuaHRtbCN2YWxpZC1lLW1haWwtYWRkcmVzcykgd2l0aFxuICogc29tZSBlbmhhbmNlbWVudHMgdG8gaW5jb3Jwb3JhdGUgbW9yZSBSRkMgcnVsZXMgKHN1Y2ggYXMgcnVsZXMgcmVsYXRlZCB0byBkb21haW4gbmFtZXMgYW5kIHRoZVxuICogbGVuZ3RocyBvZiBkaWZmZXJlbnQgcGFydHMgb2YgdGhlIGFkZHJlc3MpLiBUaGUgbWFpbiBkaWZmZXJlbmNlcyBmcm9tIHRoZSBXSEFUV0cgdmVyc2lvbiBhcmU6XG4gKiAgIC0gRGlzYWxsb3cgYGxvY2FsLXBhcnRgIHRvIGJlZ2luIG9yIGVuZCB3aXRoIGEgcGVyaW9kIChgLmApLlxuICogICAtIERpc2FsbG93IGBsb2NhbC1wYXJ0YCBsZW5ndGggdG8gZXhjZWVkIDY0IGNoYXJhY3RlcnMuXG4gKiAgIC0gRGlzYWxsb3cgdG90YWwgYWRkcmVzcyBsZW5ndGggdG8gZXhjZWVkIDI1NCBjaGFyYWN0ZXJzLlxuICpcbiAqIFNlZSBbdGhpcyBjb21taXRdKGh0dHBzOi8vZ2l0aHViLmNvbS9hbmd1bGFyL2FuZ3VsYXIuanMvY29tbWl0L2YzZjVjZjcyZSkgZm9yIG1vcmUgZGV0YWlscy5cbiAqL1xuY29uc3QgRU1BSUxfUkVHRVhQID0gL14oPz0uezEsMjU0fSQpKD89LnsxLDY0fUApW2EtekEtWjAtOSEjJCUmJyorLz0/Xl9ge3x9fi1dKyg/OlxcLlthLXpBLVowLTkhIyQlJicqKy89P15fYHt8fX4tXSspKkBbYS16QS1aMC05XSg/OlthLXpBLVowLTktXXswLDYxfVthLXpBLVowLTldKT8oPzpcXC5bYS16QS1aMC05XSg/OlthLXpBLVowLTktXXswLDYxfVthLXpBLVowLTldKT8pKiQvO1xuLyoqXG4gKiBAZGVzY3JpcHRpb25cbiAqIFByb3ZpZGVzIGEgc2V0IG9mIGJ1aWx0LWluIHZhbGlkYXRvcnMgdGhhdCBjYW4gYmUgdXNlZCBieSBmb3JtIGNvbnRyb2xzLlxuICpcbiAqIEEgdmFsaWRhdG9yIGlzIGEgZnVuY3Rpb24gdGhhdCBwcm9jZXNzZXMgYSBgRm9ybUNvbnRyb2xgIG9yIGNvbGxlY3Rpb24gb2ZcbiAqIGNvbnRyb2xzIGFuZCByZXR1cm5zIGFuIGVycm9yIG1hcCBvciBudWxsLiBBIG51bGwgbWFwIG1lYW5zIHRoYXQgdmFsaWRhdGlvbiBoYXMgcGFzc2VkLlxuICpcbiAqIEBzZWUgW0Zvcm0gVmFsaWRhdGlvbl0oL2d1aWRlL2Zvcm0tdmFsaWRhdGlvbilcbiAqXG4gKiBAcHVibGljQXBpXG4gKi9cbmNsYXNzIFZhbGlkYXRvcnMge1xuICAgIC8qKlxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqIFZhbGlkYXRvciB0aGF0IHJlcXVpcmVzIHRoZSBjb250cm9sJ3MgdmFsdWUgdG8gYmUgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIHRoZSBwcm92aWRlZCBudW1iZXIuXG4gICAgICpcbiAgICAgKiBAdXNhZ2VOb3Rlc1xuICAgICAqXG4gICAgICogIyMjIFZhbGlkYXRlIGFnYWluc3QgYSBtaW5pbXVtIG9mIDNcbiAgICAgKlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBjb25zdCBjb250cm9sID0gbmV3IEZvcm1Db250cm9sKDIsIFZhbGlkYXRvcnMubWluKDMpKTtcbiAgICAgKlxuICAgICAqIGNvbnNvbGUubG9nKGNvbnRyb2wuZXJyb3JzKTsgLy8ge21pbjoge21pbjogMywgYWN0dWFsOiAyfX1cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIEEgdmFsaWRhdG9yIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhbiBlcnJvciBtYXAgd2l0aCB0aGVcbiAgICAgKiBgbWluYCBwcm9wZXJ0eSBpZiB0aGUgdmFsaWRhdGlvbiBjaGVjayBmYWlscywgb3RoZXJ3aXNlIGBudWxsYC5cbiAgICAgKlxuICAgICAqIEBzZWUge0BsaW5rIHVwZGF0ZVZhbHVlQW5kVmFsaWRpdHkoKX1cbiAgICAgKlxuICAgICAqL1xuICAgIHN0YXRpYyBtaW4obWluKSB7XG4gICAgICAgIHJldHVybiBtaW5WYWxpZGF0b3IobWluKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICogVmFsaWRhdG9yIHRoYXQgcmVxdWlyZXMgdGhlIGNvbnRyb2wncyB2YWx1ZSB0byBiZSBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gdGhlIHByb3ZpZGVkIG51bWJlci5cbiAgICAgKlxuICAgICAqIEB1c2FnZU5vdGVzXG4gICAgICpcbiAgICAgKiAjIyMgVmFsaWRhdGUgYWdhaW5zdCBhIG1heGltdW0gb2YgMTVcbiAgICAgKlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBjb25zdCBjb250cm9sID0gbmV3IEZvcm1Db250cm9sKDE2LCBWYWxpZGF0b3JzLm1heCgxNSkpO1xuICAgICAqXG4gICAgICogY29uc29sZS5sb2coY29udHJvbC5lcnJvcnMpOyAvLyB7bWF4OiB7bWF4OiAxNSwgYWN0dWFsOiAxNn19XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBBIHZhbGlkYXRvciBmdW5jdGlvbiB0aGF0IHJldHVybnMgYW4gZXJyb3IgbWFwIHdpdGggdGhlXG4gICAgICogYG1heGAgcHJvcGVydHkgaWYgdGhlIHZhbGlkYXRpb24gY2hlY2sgZmFpbHMsIG90aGVyd2lzZSBgbnVsbGAuXG4gICAgICpcbiAgICAgKiBAc2VlIHtAbGluayB1cGRhdGVWYWx1ZUFuZFZhbGlkaXR5KCl9XG4gICAgICpcbiAgICAgKi9cbiAgICBzdGF0aWMgbWF4KG1heCkge1xuICAgICAgICByZXR1cm4gbWF4VmFsaWRhdG9yKG1heCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqIFZhbGlkYXRvciB0aGF0IHJlcXVpcmVzIHRoZSBjb250cm9sIGhhdmUgYSBub24tZW1wdHkgdmFsdWUuXG4gICAgICpcbiAgICAgKiBAdXNhZ2VOb3Rlc1xuICAgICAqXG4gICAgICogIyMjIFZhbGlkYXRlIHRoYXQgdGhlIGZpZWxkIGlzIG5vbi1lbXB0eVxuICAgICAqXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGNvbnN0IGNvbnRyb2wgPSBuZXcgRm9ybUNvbnRyb2woJycsIFZhbGlkYXRvcnMucmVxdWlyZWQpO1xuICAgICAqXG4gICAgICogY29uc29sZS5sb2coY29udHJvbC5lcnJvcnMpOyAvLyB7cmVxdWlyZWQ6IHRydWV9XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBBbiBlcnJvciBtYXAgd2l0aCB0aGUgYHJlcXVpcmVkYCBwcm9wZXJ0eVxuICAgICAqIGlmIHRoZSB2YWxpZGF0aW9uIGNoZWNrIGZhaWxzLCBvdGhlcndpc2UgYG51bGxgLlxuICAgICAqXG4gICAgICogQHNlZSB7QGxpbmsgdXBkYXRlVmFsdWVBbmRWYWxpZGl0eSgpfVxuICAgICAqXG4gICAgICovXG4gICAgc3RhdGljIHJlcXVpcmVkKGNvbnRyb2wpIHtcbiAgICAgICAgcmV0dXJuIHJlcXVpcmVkVmFsaWRhdG9yKGNvbnRyb2wpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKiBWYWxpZGF0b3IgdGhhdCByZXF1aXJlcyB0aGUgY29udHJvbCdzIHZhbHVlIGJlIHRydWUuIFRoaXMgdmFsaWRhdG9yIGlzIGNvbW1vbmx5XG4gICAgICogdXNlZCBmb3IgcmVxdWlyZWQgY2hlY2tib3hlcy5cbiAgICAgKlxuICAgICAqIEB1c2FnZU5vdGVzXG4gICAgICpcbiAgICAgKiAjIyMgVmFsaWRhdGUgdGhhdCB0aGUgZmllbGQgdmFsdWUgaXMgdHJ1ZVxuICAgICAqXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGNvbnN0IGNvbnRyb2wgPSBuZXcgRm9ybUNvbnRyb2woJ3NvbWUgdmFsdWUnLCBWYWxpZGF0b3JzLnJlcXVpcmVkVHJ1ZSk7XG4gICAgICpcbiAgICAgKiBjb25zb2xlLmxvZyhjb250cm9sLmVycm9ycyk7IC8vIHtyZXF1aXJlZDogdHJ1ZX1cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIEFuIGVycm9yIG1hcCB0aGF0IGNvbnRhaW5zIHRoZSBgcmVxdWlyZWRgIHByb3BlcnR5XG4gICAgICogc2V0IHRvIGB0cnVlYCBpZiB0aGUgdmFsaWRhdGlvbiBjaGVjayBmYWlscywgb3RoZXJ3aXNlIGBudWxsYC5cbiAgICAgKlxuICAgICAqIEBzZWUge0BsaW5rIHVwZGF0ZVZhbHVlQW5kVmFsaWRpdHkoKX1cbiAgICAgKlxuICAgICAqL1xuICAgIHN0YXRpYyByZXF1aXJlZFRydWUoY29udHJvbCkge1xuICAgICAgICByZXR1cm4gcmVxdWlyZWRUcnVlVmFsaWRhdG9yKGNvbnRyb2wpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKiBWYWxpZGF0b3IgdGhhdCByZXF1aXJlcyB0aGUgY29udHJvbCdzIHZhbHVlIHBhc3MgYW4gZW1haWwgdmFsaWRhdGlvbiB0ZXN0LlxuICAgICAqXG4gICAgICogVGVzdHMgdGhlIHZhbHVlIHVzaW5nIGEgW3JlZ3VsYXJcbiAgICAgKiBleHByZXNzaW9uXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L0d1aWRlL1JlZ3VsYXJfRXhwcmVzc2lvbnMpXG4gICAgICogcGF0dGVybiBzdWl0YWJsZSBmb3IgY29tbW9uIHVzZSBjYXNlcy4gVGhlIHBhdHRlcm4gaXMgYmFzZWQgb24gdGhlIGRlZmluaXRpb24gb2YgYSB2YWxpZCBlbWFpbFxuICAgICAqIGFkZHJlc3MgaW4gdGhlIFtXSEFUV0cgSFRNTFxuICAgICAqIHNwZWNpZmljYXRpb25dKGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2lucHV0Lmh0bWwjdmFsaWQtZS1tYWlsLWFkZHJlc3MpIHdpdGhcbiAgICAgKiBzb21lIGVuaGFuY2VtZW50cyB0byBpbmNvcnBvcmF0ZSBtb3JlIFJGQyBydWxlcyAoc3VjaCBhcyBydWxlcyByZWxhdGVkIHRvIGRvbWFpbiBuYW1lcyBhbmQgdGhlXG4gICAgICogbGVuZ3RocyBvZiBkaWZmZXJlbnQgcGFydHMgb2YgdGhlIGFkZHJlc3MpLlxuICAgICAqXG4gICAgICogVGhlIGRpZmZlcmVuY2VzIGZyb20gdGhlIFdIQVRXRyB2ZXJzaW9uIGluY2x1ZGU6XG4gICAgICogLSBEaXNhbGxvdyBgbG9jYWwtcGFydGAgKHRoZSBwYXJ0IGJlZm9yZSB0aGUgYEBgIHN5bWJvbCkgdG8gYmVnaW4gb3IgZW5kIHdpdGggYSBwZXJpb2QgKGAuYCkuXG4gICAgICogLSBEaXNhbGxvdyBgbG9jYWwtcGFydGAgdG8gYmUgbG9uZ2VyIHRoYW4gNjQgY2hhcmFjdGVycy5cbiAgICAgKiAtIERpc2FsbG93IHRoZSB3aG9sZSBhZGRyZXNzIHRvIGJlIGxvbmdlciB0aGFuIDI1NCBjaGFyYWN0ZXJzLlxuICAgICAqXG4gICAgICogSWYgdGhpcyBwYXR0ZXJuIGRvZXMgbm90IHNhdGlzZnkgeW91ciBidXNpbmVzcyBuZWVkcywgeW91IGNhbiB1c2UgYFZhbGlkYXRvcnMucGF0dGVybigpYCB0b1xuICAgICAqIHZhbGlkYXRlIHRoZSB2YWx1ZSBhZ2FpbnN0IGEgZGlmZmVyZW50IHBhdHRlcm4uXG4gICAgICpcbiAgICAgKiBAdXNhZ2VOb3Rlc1xuICAgICAqXG4gICAgICogIyMjIFZhbGlkYXRlIHRoYXQgdGhlIGZpZWxkIG1hdGNoZXMgYSB2YWxpZCBlbWFpbCBwYXR0ZXJuXG4gICAgICpcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogY29uc3QgY29udHJvbCA9IG5ldyBGb3JtQ29udHJvbCgnYmFkQCcsIFZhbGlkYXRvcnMuZW1haWwpO1xuICAgICAqXG4gICAgICogY29uc29sZS5sb2coY29udHJvbC5lcnJvcnMpOyAvLyB7ZW1haWw6IHRydWV9XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBBbiBlcnJvciBtYXAgd2l0aCB0aGUgYGVtYWlsYCBwcm9wZXJ0eVxuICAgICAqIGlmIHRoZSB2YWxpZGF0aW9uIGNoZWNrIGZhaWxzLCBvdGhlcndpc2UgYG51bGxgLlxuICAgICAqXG4gICAgICogQHNlZSB7QGxpbmsgdXBkYXRlVmFsdWVBbmRWYWxpZGl0eSgpfVxuICAgICAqXG4gICAgICovXG4gICAgc3RhdGljIGVtYWlsKGNvbnRyb2wpIHtcbiAgICAgICAgcmV0dXJuIGVtYWlsVmFsaWRhdG9yKGNvbnRyb2wpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKiBWYWxpZGF0b3IgdGhhdCByZXF1aXJlcyB0aGUgbGVuZ3RoIG9mIHRoZSBjb250cm9sJ3MgdmFsdWUgdG8gYmUgZ3JlYXRlciB0aGFuIG9yIGVxdWFsXG4gICAgICogdG8gdGhlIHByb3ZpZGVkIG1pbmltdW0gbGVuZ3RoLiBUaGlzIHZhbGlkYXRvciBpcyBhbHNvIHByb3ZpZGVkIGJ5IGRlZmF1bHQgaWYgeW91IHVzZSB0aGVcbiAgICAgKiB0aGUgSFRNTDUgYG1pbmxlbmd0aGAgYXR0cmlidXRlLiBOb3RlIHRoYXQgdGhlIGBtaW5MZW5ndGhgIHZhbGlkYXRvciBpcyBpbnRlbmRlZCB0byBiZSB1c2VkXG4gICAgICogb25seSBmb3IgdHlwZXMgdGhhdCBoYXZlIGEgbnVtZXJpYyBgbGVuZ3RoYCBwcm9wZXJ0eSwgc3VjaCBhcyBzdHJpbmdzIG9yIGFycmF5cy4gVGhlXG4gICAgICogYG1pbkxlbmd0aGAgdmFsaWRhdG9yIGxvZ2ljIGlzIGFsc28gbm90IGludm9rZWQgZm9yIHZhbHVlcyB3aGVuIHRoZWlyIGBsZW5ndGhgIHByb3BlcnR5IGlzIDBcbiAgICAgKiAoZm9yIGV4YW1wbGUgaW4gY2FzZSBvZiBhbiBlbXB0eSBzdHJpbmcgb3IgYW4gZW1wdHkgYXJyYXkpLCB0byBzdXBwb3J0IG9wdGlvbmFsIGNvbnRyb2xzLiBZb3VcbiAgICAgKiBjYW4gdXNlIHRoZSBzdGFuZGFyZCBgcmVxdWlyZWRgIHZhbGlkYXRvciBpZiBlbXB0eSB2YWx1ZXMgc2hvdWxkIG5vdCBiZSBjb25zaWRlcmVkIHZhbGlkLlxuICAgICAqXG4gICAgICogQHVzYWdlTm90ZXNcbiAgICAgKlxuICAgICAqICMjIyBWYWxpZGF0ZSB0aGF0IHRoZSBmaWVsZCBoYXMgYSBtaW5pbXVtIG9mIDMgY2hhcmFjdGVyc1xuICAgICAqXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGNvbnN0IGNvbnRyb2wgPSBuZXcgRm9ybUNvbnRyb2woJ25nJywgVmFsaWRhdG9ycy5taW5MZW5ndGgoMykpO1xuICAgICAqXG4gICAgICogY29uc29sZS5sb2coY29udHJvbC5lcnJvcnMpOyAvLyB7bWlubGVuZ3RoOiB7cmVxdWlyZWRMZW5ndGg6IDMsIGFjdHVhbExlbmd0aDogMn19XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBgYGBodG1sXG4gICAgICogPGlucHV0IG1pbmxlbmd0aD1cIjVcIj5cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIEEgdmFsaWRhdG9yIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhbiBlcnJvciBtYXAgd2l0aCB0aGVcbiAgICAgKiBgbWlubGVuZ3RoYCBwcm9wZXJ0eSBpZiB0aGUgdmFsaWRhdGlvbiBjaGVjayBmYWlscywgb3RoZXJ3aXNlIGBudWxsYC5cbiAgICAgKlxuICAgICAqIEBzZWUge0BsaW5rIHVwZGF0ZVZhbHVlQW5kVmFsaWRpdHkoKX1cbiAgICAgKlxuICAgICAqL1xuICAgIHN0YXRpYyBtaW5MZW5ndGgobWluTGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBtaW5MZW5ndGhWYWxpZGF0b3IobWluTGVuZ3RoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICogVmFsaWRhdG9yIHRoYXQgcmVxdWlyZXMgdGhlIGxlbmd0aCBvZiB0aGUgY29udHJvbCdzIHZhbHVlIHRvIGJlIGxlc3MgdGhhbiBvciBlcXVhbFxuICAgICAqIHRvIHRoZSBwcm92aWRlZCBtYXhpbXVtIGxlbmd0aC4gVGhpcyB2YWxpZGF0b3IgaXMgYWxzbyBwcm92aWRlZCBieSBkZWZhdWx0IGlmIHlvdSB1c2UgdGhlXG4gICAgICogdGhlIEhUTUw1IGBtYXhsZW5ndGhgIGF0dHJpYnV0ZS4gTm90ZSB0aGF0IHRoZSBgbWF4TGVuZ3RoYCB2YWxpZGF0b3IgaXMgaW50ZW5kZWQgdG8gYmUgdXNlZFxuICAgICAqIG9ubHkgZm9yIHR5cGVzIHRoYXQgaGF2ZSBhIG51bWVyaWMgYGxlbmd0aGAgcHJvcGVydHksIHN1Y2ggYXMgc3RyaW5ncyBvciBhcnJheXMuXG4gICAgICpcbiAgICAgKiBAdXNhZ2VOb3Rlc1xuICAgICAqXG4gICAgICogIyMjIFZhbGlkYXRlIHRoYXQgdGhlIGZpZWxkIGhhcyBtYXhpbXVtIG9mIDUgY2hhcmFjdGVyc1xuICAgICAqXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGNvbnN0IGNvbnRyb2wgPSBuZXcgRm9ybUNvbnRyb2woJ0FuZ3VsYXInLCBWYWxpZGF0b3JzLm1heExlbmd0aCg1KSk7XG4gICAgICpcbiAgICAgKiBjb25zb2xlLmxvZyhjb250cm9sLmVycm9ycyk7IC8vIHttYXhsZW5ndGg6IHtyZXF1aXJlZExlbmd0aDogNSwgYWN0dWFsTGVuZ3RoOiA3fX1cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8aW5wdXQgbWF4bGVuZ3RoPVwiNVwiPlxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQHJldHVybnMgQSB2YWxpZGF0b3IgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGFuIGVycm9yIG1hcCB3aXRoIHRoZVxuICAgICAqIGBtYXhsZW5ndGhgIHByb3BlcnR5IGlmIHRoZSB2YWxpZGF0aW9uIGNoZWNrIGZhaWxzLCBvdGhlcndpc2UgYG51bGxgLlxuICAgICAqXG4gICAgICogQHNlZSB7QGxpbmsgdXBkYXRlVmFsdWVBbmRWYWxpZGl0eSgpfVxuICAgICAqXG4gICAgICovXG4gICAgc3RhdGljIG1heExlbmd0aChtYXhMZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIG1heExlbmd0aFZhbGlkYXRvcihtYXhMZW5ndGgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKiBWYWxpZGF0b3IgdGhhdCByZXF1aXJlcyB0aGUgY29udHJvbCdzIHZhbHVlIHRvIG1hdGNoIGEgcmVnZXggcGF0dGVybi4gVGhpcyB2YWxpZGF0b3IgaXMgYWxzb1xuICAgICAqIHByb3ZpZGVkIGJ5IGRlZmF1bHQgaWYgeW91IHVzZSB0aGUgSFRNTDUgYHBhdHRlcm5gIGF0dHJpYnV0ZS5cbiAgICAgKlxuICAgICAqIEB1c2FnZU5vdGVzXG4gICAgICpcbiAgICAgKiAjIyMgVmFsaWRhdGUgdGhhdCB0aGUgZmllbGQgb25seSBjb250YWlucyBsZXR0ZXJzIG9yIHNwYWNlc1xuICAgICAqXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGNvbnN0IGNvbnRyb2wgPSBuZXcgRm9ybUNvbnRyb2woJzEnLCBWYWxpZGF0b3JzLnBhdHRlcm4oJ1thLXpBLVogXSonKSk7XG4gICAgICpcbiAgICAgKiBjb25zb2xlLmxvZyhjb250cm9sLmVycm9ycyk7IC8vIHtwYXR0ZXJuOiB7cmVxdWlyZWRQYXR0ZXJuOiAnXlthLXpBLVogXSokJywgYWN0dWFsVmFsdWU6ICcxJ319XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBgYGBodG1sXG4gICAgICogPGlucHV0IHBhdHRlcm49XCJbYS16QS1aIF0qXCI+XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiAjIyMgUGF0dGVybiBtYXRjaGluZyB3aXRoIHRoZSBnbG9iYWwgb3Igc3RpY2t5IGZsYWdcbiAgICAgKlxuICAgICAqIGBSZWdFeHBgIG9iamVjdHMgY3JlYXRlZCB3aXRoIHRoZSBgZ2Agb3IgYHlgIGZsYWdzIHRoYXQgYXJlIHBhc3NlZCBpbnRvIGBWYWxpZGF0b3JzLnBhdHRlcm5gXG4gICAgICogY2FuIHByb2R1Y2UgZGlmZmVyZW50IHJlc3VsdHMgb24gdGhlIHNhbWUgaW5wdXQgd2hlbiB2YWxpZGF0aW9ucyBhcmUgcnVuIGNvbnNlY3V0aXZlbHkuIFRoaXMgaXNcbiAgICAgKiBkdWUgdG8gaG93IHRoZSBiZWhhdmlvciBvZiBgUmVnRXhwLnByb3RvdHlwZS50ZXN0YCBpc1xuICAgICAqIHNwZWNpZmllZCBpbiBbRUNNQS0yNjJdKGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtcmVnZXhwYnVpbHRpbmV4ZWMpXG4gICAgICogKGBSZWdFeHBgIHByZXNlcnZlcyB0aGUgaW5kZXggb2YgdGhlIGxhc3QgbWF0Y2ggd2hlbiB0aGUgZ2xvYmFsIG9yIHN0aWNreSBmbGFnIGlzIHVzZWQpLlxuICAgICAqIER1ZSB0byB0aGlzIGJlaGF2aW9yLCBpdCBpcyByZWNvbW1lbmRlZCB0aGF0IHdoZW4gdXNpbmdcbiAgICAgKiBgVmFsaWRhdG9ycy5wYXR0ZXJuYCB5b3UgKipkbyBub3QqKiBwYXNzIGluIGEgYFJlZ0V4cGAgb2JqZWN0IHdpdGggZWl0aGVyIHRoZSBnbG9iYWwgb3Igc3RpY2t5XG4gICAgICogZmxhZyBlbmFibGVkLlxuICAgICAqXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIC8vIE5vdCByZWNvbW1lbmRlZCAoc2luY2UgdGhlIGBnYCBmbGFnIGlzIHVzZWQpXG4gICAgICogY29uc3QgY29udHJvbE9uZSA9IG5ldyBGb3JtQ29udHJvbCgnMScsIFZhbGlkYXRvcnMucGF0dGVybigvZm9vL2cpKTtcbiAgICAgKlxuICAgICAqIC8vIEdvb2RcbiAgICAgKiBjb25zdCBjb250cm9sVHdvID0gbmV3IEZvcm1Db250cm9sKCcxJywgVmFsaWRhdG9ycy5wYXR0ZXJuKC9mb28vKSk7XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcGF0dGVybiBBIHJlZ3VsYXIgZXhwcmVzc2lvbiB0byBiZSB1c2VkIGFzIGlzIHRvIHRlc3QgdGhlIHZhbHVlcywgb3IgYSBzdHJpbmcuXG4gICAgICogSWYgYSBzdHJpbmcgaXMgcGFzc2VkLCB0aGUgYF5gIGNoYXJhY3RlciBpcyBwcmVwZW5kZWQgYW5kIHRoZSBgJGAgY2hhcmFjdGVyIGlzXG4gICAgICogYXBwZW5kZWQgdG8gdGhlIHByb3ZpZGVkIHN0cmluZyAoaWYgbm90IGFscmVhZHkgcHJlc2VudCksIGFuZCB0aGUgcmVzdWx0aW5nIHJlZ3VsYXJcbiAgICAgKiBleHByZXNzaW9uIGlzIHVzZWQgdG8gdGVzdCB0aGUgdmFsdWVzLlxuICAgICAqXG4gICAgICogQHJldHVybnMgQSB2YWxpZGF0b3IgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGFuIGVycm9yIG1hcCB3aXRoIHRoZVxuICAgICAqIGBwYXR0ZXJuYCBwcm9wZXJ0eSBpZiB0aGUgdmFsaWRhdGlvbiBjaGVjayBmYWlscywgb3RoZXJ3aXNlIGBudWxsYC5cbiAgICAgKlxuICAgICAqIEBzZWUge0BsaW5rIHVwZGF0ZVZhbHVlQW5kVmFsaWRpdHkoKX1cbiAgICAgKlxuICAgICAqL1xuICAgIHN0YXRpYyBwYXR0ZXJuKHBhdHRlcm4pIHtcbiAgICAgICAgcmV0dXJuIHBhdHRlcm5WYWxpZGF0b3IocGF0dGVybik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqIFZhbGlkYXRvciB0aGF0IHBlcmZvcm1zIG5vIG9wZXJhdGlvbi5cbiAgICAgKlxuICAgICAqIEBzZWUge0BsaW5rIHVwZGF0ZVZhbHVlQW5kVmFsaWRpdHkoKX1cbiAgICAgKlxuICAgICAqL1xuICAgIHN0YXRpYyBudWxsVmFsaWRhdG9yKGNvbnRyb2wpIHtcbiAgICAgICAgcmV0dXJuIG51bGxWYWxpZGF0b3IoY29udHJvbCk7XG4gICAgfVxuICAgIHN0YXRpYyBjb21wb3NlKHZhbGlkYXRvcnMpIHtcbiAgICAgICAgcmV0dXJuIGNvbXBvc2UodmFsaWRhdG9ycyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqIENvbXBvc2UgbXVsdGlwbGUgYXN5bmMgdmFsaWRhdG9ycyBpbnRvIGEgc2luZ2xlIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0aGUgdW5pb25cbiAgICAgKiBvZiB0aGUgaW5kaXZpZHVhbCBlcnJvciBvYmplY3RzIGZvciB0aGUgcHJvdmlkZWQgY29udHJvbC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIEEgdmFsaWRhdG9yIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhbiBlcnJvciBtYXAgd2l0aCB0aGVcbiAgICAgKiBtZXJnZWQgZXJyb3Igb2JqZWN0cyBvZiB0aGUgYXN5bmMgdmFsaWRhdG9ycyBpZiB0aGUgdmFsaWRhdGlvbiBjaGVjayBmYWlscywgb3RoZXJ3aXNlIGBudWxsYC5cbiAgICAgKlxuICAgICAqIEBzZWUge0BsaW5rIHVwZGF0ZVZhbHVlQW5kVmFsaWRpdHkoKX1cbiAgICAgKlxuICAgICAqL1xuICAgIHN0YXRpYyBjb21wb3NlQXN5bmModmFsaWRhdG9ycykge1xuICAgICAgICByZXR1cm4gY29tcG9zZUFzeW5jKHZhbGlkYXRvcnMpO1xuICAgIH1cbn1cbi8qKlxuICogVmFsaWRhdG9yIHRoYXQgcmVxdWlyZXMgdGhlIGNvbnRyb2wncyB2YWx1ZSB0byBiZSBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gdGhlIHByb3ZpZGVkIG51bWJlci5cbiAqIFNlZSBgVmFsaWRhdG9ycy5taW5gIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uLlxuICovXG5mdW5jdGlvbiBtaW5WYWxpZGF0b3IobWluKSB7XG4gICAgcmV0dXJuIChjb250cm9sKSA9PiB7XG4gICAgICAgIGlmIChpc0VtcHR5SW5wdXRWYWx1ZShjb250cm9sLnZhbHVlKSB8fCBpc0VtcHR5SW5wdXRWYWx1ZShtaW4pKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDsgLy8gZG9uJ3QgdmFsaWRhdGUgZW1wdHkgdmFsdWVzIHRvIGFsbG93IG9wdGlvbmFsIGNvbnRyb2xzXG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdmFsdWUgPSBwYXJzZUZsb2F0KGNvbnRyb2wudmFsdWUpO1xuICAgICAgICAvLyBDb250cm9scyB3aXRoIE5hTiB2YWx1ZXMgYWZ0ZXIgcGFyc2luZyBzaG91bGQgYmUgdHJlYXRlZCBhcyBub3QgaGF2aW5nIGFcbiAgICAgICAgLy8gbWluaW11bSwgcGVyIHRoZSBIVE1MIGZvcm1zIHNwZWM6IGh0dHBzOi8vd3d3LnczLm9yZy9UUi9odG1sNS9mb3Jtcy5odG1sI2F0dHItaW5wdXQtbWluXG4gICAgICAgIHJldHVybiAhaXNOYU4odmFsdWUpICYmIHZhbHVlIDwgbWluID8geyAnbWluJzogeyAnbWluJzogbWluLCAnYWN0dWFsJzogY29udHJvbC52YWx1ZSB9IH0gOiBudWxsO1xuICAgIH07XG59XG4vKipcbiAqIFZhbGlkYXRvciB0aGF0IHJlcXVpcmVzIHRoZSBjb250cm9sJ3MgdmFsdWUgdG8gYmUgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIHRoZSBwcm92aWRlZCBudW1iZXIuXG4gKiBTZWUgYFZhbGlkYXRvcnMubWF4YCBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvbi5cbiAqL1xuZnVuY3Rpb24gbWF4VmFsaWRhdG9yKG1heCkge1xuICAgIHJldHVybiAoY29udHJvbCkgPT4ge1xuICAgICAgICBpZiAoaXNFbXB0eUlucHV0VmFsdWUoY29udHJvbC52YWx1ZSkgfHwgaXNFbXB0eUlucHV0VmFsdWUobWF4KSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7IC8vIGRvbid0IHZhbGlkYXRlIGVtcHR5IHZhbHVlcyB0byBhbGxvdyBvcHRpb25hbCBjb250cm9sc1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHZhbHVlID0gcGFyc2VGbG9hdChjb250cm9sLnZhbHVlKTtcbiAgICAgICAgLy8gQ29udHJvbHMgd2l0aCBOYU4gdmFsdWVzIGFmdGVyIHBhcnNpbmcgc2hvdWxkIGJlIHRyZWF0ZWQgYXMgbm90IGhhdmluZyBhXG4gICAgICAgIC8vIG1heGltdW0sIHBlciB0aGUgSFRNTCBmb3JtcyBzcGVjOiBodHRwczovL3d3dy53My5vcmcvVFIvaHRtbDUvZm9ybXMuaHRtbCNhdHRyLWlucHV0LW1heFxuICAgICAgICByZXR1cm4gIWlzTmFOKHZhbHVlKSAmJiB2YWx1ZSA+IG1heCA/IHsgJ21heCc6IHsgJ21heCc6IG1heCwgJ2FjdHVhbCc6IGNvbnRyb2wudmFsdWUgfSB9IDogbnVsbDtcbiAgICB9O1xufVxuLyoqXG4gKiBWYWxpZGF0b3IgdGhhdCByZXF1aXJlcyB0aGUgY29udHJvbCBoYXZlIGEgbm9uLWVtcHR5IHZhbHVlLlxuICogU2VlIGBWYWxpZGF0b3JzLnJlcXVpcmVkYCBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvbi5cbiAqL1xuZnVuY3Rpb24gcmVxdWlyZWRWYWxpZGF0b3IoY29udHJvbCkge1xuICAgIHJldHVybiBpc0VtcHR5SW5wdXRWYWx1ZShjb250cm9sLnZhbHVlKSA/IHsgJ3JlcXVpcmVkJzogdHJ1ZSB9IDogbnVsbDtcbn1cbi8qKlxuICogVmFsaWRhdG9yIHRoYXQgcmVxdWlyZXMgdGhlIGNvbnRyb2wncyB2YWx1ZSBiZSB0cnVlLiBUaGlzIHZhbGlkYXRvciBpcyBjb21tb25seVxuICogdXNlZCBmb3IgcmVxdWlyZWQgY2hlY2tib3hlcy5cbiAqIFNlZSBgVmFsaWRhdG9ycy5yZXF1aXJlZFRydWVgIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uLlxuICovXG5mdW5jdGlvbiByZXF1aXJlZFRydWVWYWxpZGF0b3IoY29udHJvbCkge1xuICAgIHJldHVybiBjb250cm9sLnZhbHVlID09PSB0cnVlID8gbnVsbCA6IHsgJ3JlcXVpcmVkJzogdHJ1ZSB9O1xufVxuLyoqXG4gKiBWYWxpZGF0b3IgdGhhdCByZXF1aXJlcyB0aGUgY29udHJvbCdzIHZhbHVlIHBhc3MgYW4gZW1haWwgdmFsaWRhdGlvbiB0ZXN0LlxuICogU2VlIGBWYWxpZGF0b3JzLmVtYWlsYCBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvbi5cbiAqL1xuZnVuY3Rpb24gZW1haWxWYWxpZGF0b3IoY29udHJvbCkge1xuICAgIGlmIChpc0VtcHR5SW5wdXRWYWx1ZShjb250cm9sLnZhbHVlKSkge1xuICAgICAgICByZXR1cm4gbnVsbDsgLy8gZG9uJ3QgdmFsaWRhdGUgZW1wdHkgdmFsdWVzIHRvIGFsbG93IG9wdGlvbmFsIGNvbnRyb2xzXG4gICAgfVxuICAgIHJldHVybiBFTUFJTF9SRUdFWFAudGVzdChjb250cm9sLnZhbHVlKSA/IG51bGwgOiB7ICdlbWFpbCc6IHRydWUgfTtcbn1cbi8qKlxuICogVmFsaWRhdG9yIHRoYXQgcmVxdWlyZXMgdGhlIGxlbmd0aCBvZiB0aGUgY29udHJvbCdzIHZhbHVlIHRvIGJlIGdyZWF0ZXIgdGhhbiBvciBlcXVhbFxuICogdG8gdGhlIHByb3ZpZGVkIG1pbmltdW0gbGVuZ3RoLiBTZWUgYFZhbGlkYXRvcnMubWluTGVuZ3RoYCBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvbi5cbiAqL1xuZnVuY3Rpb24gbWluTGVuZ3RoVmFsaWRhdG9yKG1pbkxlbmd0aCkge1xuICAgIHJldHVybiAoY29udHJvbCkgPT4ge1xuICAgICAgICBpZiAoaXNFbXB0eUlucHV0VmFsdWUoY29udHJvbC52YWx1ZSkgfHwgIWhhc1ZhbGlkTGVuZ3RoKGNvbnRyb2wudmFsdWUpKSB7XG4gICAgICAgICAgICAvLyBkb24ndCB2YWxpZGF0ZSBlbXB0eSB2YWx1ZXMgdG8gYWxsb3cgb3B0aW9uYWwgY29udHJvbHNcbiAgICAgICAgICAgIC8vIGRvbid0IHZhbGlkYXRlIHZhbHVlcyB3aXRob3V0IGBsZW5ndGhgIHByb3BlcnR5XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29udHJvbC52YWx1ZS5sZW5ndGggPCBtaW5MZW5ndGggP1xuICAgICAgICAgICAgeyAnbWlubGVuZ3RoJzogeyAncmVxdWlyZWRMZW5ndGgnOiBtaW5MZW5ndGgsICdhY3R1YWxMZW5ndGgnOiBjb250cm9sLnZhbHVlLmxlbmd0aCB9IH0gOlxuICAgICAgICAgICAgbnVsbDtcbiAgICB9O1xufVxuLyoqXG4gKiBWYWxpZGF0b3IgdGhhdCByZXF1aXJlcyB0aGUgbGVuZ3RoIG9mIHRoZSBjb250cm9sJ3MgdmFsdWUgdG8gYmUgbGVzcyB0aGFuIG9yIGVxdWFsXG4gKiB0byB0aGUgcHJvdmlkZWQgbWF4aW11bSBsZW5ndGguIFNlZSBgVmFsaWRhdG9ycy5tYXhMZW5ndGhgIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uLlxuICovXG5mdW5jdGlvbiBtYXhMZW5ndGhWYWxpZGF0b3IobWF4TGVuZ3RoKSB7XG4gICAgcmV0dXJuIChjb250cm9sKSA9PiB7XG4gICAgICAgIHJldHVybiBoYXNWYWxpZExlbmd0aChjb250cm9sLnZhbHVlKSAmJiBjb250cm9sLnZhbHVlLmxlbmd0aCA+IG1heExlbmd0aCA/XG4gICAgICAgICAgICB7ICdtYXhsZW5ndGgnOiB7ICdyZXF1aXJlZExlbmd0aCc6IG1heExlbmd0aCwgJ2FjdHVhbExlbmd0aCc6IGNvbnRyb2wudmFsdWUubGVuZ3RoIH0gfSA6XG4gICAgICAgICAgICBudWxsO1xuICAgIH07XG59XG4vKipcbiAqIFZhbGlkYXRvciB0aGF0IHJlcXVpcmVzIHRoZSBjb250cm9sJ3MgdmFsdWUgdG8gbWF0Y2ggYSByZWdleCBwYXR0ZXJuLlxuICogU2VlIGBWYWxpZGF0b3JzLnBhdHRlcm5gIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uLlxuICovXG5mdW5jdGlvbiBwYXR0ZXJuVmFsaWRhdG9yKHBhdHRlcm4pIHtcbiAgICBpZiAoIXBhdHRlcm4pXG4gICAgICAgIHJldHVybiBudWxsVmFsaWRhdG9yO1xuICAgIGxldCByZWdleDtcbiAgICBsZXQgcmVnZXhTdHI7XG4gICAgaWYgKHR5cGVvZiBwYXR0ZXJuID09PSAnc3RyaW5nJykge1xuICAgICAgICByZWdleFN0ciA9ICcnO1xuICAgICAgICBpZiAocGF0dGVybi5jaGFyQXQoMCkgIT09ICdeJylcbiAgICAgICAgICAgIHJlZ2V4U3RyICs9ICdeJztcbiAgICAgICAgcmVnZXhTdHIgKz0gcGF0dGVybjtcbiAgICAgICAgaWYgKHBhdHRlcm4uY2hhckF0KHBhdHRlcm4ubGVuZ3RoIC0gMSkgIT09ICckJylcbiAgICAgICAgICAgIHJlZ2V4U3RyICs9ICckJztcbiAgICAgICAgcmVnZXggPSBuZXcgUmVnRXhwKHJlZ2V4U3RyKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJlZ2V4U3RyID0gcGF0dGVybi50b1N0cmluZygpO1xuICAgICAgICByZWdleCA9IHBhdHRlcm47XG4gICAgfVxuICAgIHJldHVybiAoY29udHJvbCkgPT4ge1xuICAgICAgICBpZiAoaXNFbXB0eUlucHV0VmFsdWUoY29udHJvbC52YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsOyAvLyBkb24ndCB2YWxpZGF0ZSBlbXB0eSB2YWx1ZXMgdG8gYWxsb3cgb3B0aW9uYWwgY29udHJvbHNcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB2YWx1ZSA9IGNvbnRyb2wudmFsdWU7XG4gICAgICAgIHJldHVybiByZWdleC50ZXN0KHZhbHVlKSA/IG51bGwgOlxuICAgICAgICAgICAgeyAncGF0dGVybic6IHsgJ3JlcXVpcmVkUGF0dGVybic6IHJlZ2V4U3RyLCAnYWN0dWFsVmFsdWUnOiB2YWx1ZSB9IH07XG4gICAgfTtcbn1cbi8qKlxuICogRnVuY3Rpb24gdGhhdCBoYXMgYFZhbGlkYXRvckZuYCBzaGFwZSwgYnV0IHBlcmZvcm1zIG5vIG9wZXJhdGlvbi5cbiAqL1xuZnVuY3Rpb24gbnVsbFZhbGlkYXRvcihjb250cm9sKSB7XG4gICAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBpc1ByZXNlbnQobykge1xuICAgIHJldHVybiBvICE9IG51bGw7XG59XG5mdW5jdGlvbiB0b09ic2VydmFibGUodmFsdWUpIHtcbiAgICBjb25zdCBvYnMgPSDJtWlzUHJvbWlzZSh2YWx1ZSkgPyBmcm9tKHZhbHVlKSA6IHZhbHVlO1xuICAgIGlmICgodHlwZW9mIG5nRGV2TW9kZSA9PT0gJ3VuZGVmaW5lZCcgfHwgbmdEZXZNb2RlKSAmJiAhKMm1aXNTdWJzY3JpYmFibGUob2JzKSkpIHtcbiAgICAgICAgbGV0IGVycm9yTWVzc2FnZSA9IGBFeHBlY3RlZCBhc3luYyB2YWxpZGF0b3IgdG8gcmV0dXJuIFByb21pc2Ugb3IgT2JzZXJ2YWJsZS5gO1xuICAgICAgICAvLyBBIHN5bmNocm9ub3VzIHZhbGlkYXRvciB3aWxsIHJldHVybiBvYmplY3Qgb3IgbnVsbC5cbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIGVycm9yTWVzc2FnZSArPVxuICAgICAgICAgICAgICAgICcgQXJlIHlvdSB1c2luZyBhIHN5bmNocm9ub3VzIHZhbGlkYXRvciB3aGVyZSBhbiBhc3luYyB2YWxpZGF0b3IgaXMgZXhwZWN0ZWQ/JztcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgybVSdW50aW1lRXJyb3IoLTExMDEgLyogUnVudGltZUVycm9yQ29kZS5XUk9OR19WQUxJREFUT1JfUkVUVVJOX1RZUEUgKi8sIGVycm9yTWVzc2FnZSk7XG4gICAgfVxuICAgIHJldHVybiBvYnM7XG59XG5mdW5jdGlvbiBtZXJnZUVycm9ycyhhcnJheU9mRXJyb3JzKSB7XG4gICAgbGV0IHJlcyA9IHt9O1xuICAgIGFycmF5T2ZFcnJvcnMuZm9yRWFjaCgoZXJyb3JzKSA9PiB7XG4gICAgICAgIHJlcyA9IGVycm9ycyAhPSBudWxsID8geyAuLi5yZXMsIC4uLmVycm9ycyB9IDogcmVzO1xuICAgIH0pO1xuICAgIHJldHVybiBPYmplY3Qua2V5cyhyZXMpLmxlbmd0aCA9PT0gMCA/IG51bGwgOiByZXM7XG59XG5mdW5jdGlvbiBleGVjdXRlVmFsaWRhdG9ycyhjb250cm9sLCB2YWxpZGF0b3JzKSB7XG4gICAgcmV0dXJuIHZhbGlkYXRvcnMubWFwKHZhbGlkYXRvciA9PiB2YWxpZGF0b3IoY29udHJvbCkpO1xufVxuZnVuY3Rpb24gaXNWYWxpZGF0b3JGbih2YWxpZGF0b3IpIHtcbiAgICByZXR1cm4gIXZhbGlkYXRvci52YWxpZGF0ZTtcbn1cbi8qKlxuICogR2l2ZW4gdGhlIGxpc3Qgb2YgdmFsaWRhdG9ycyB0aGF0IG1heSBjb250YWluIGJvdGggZnVuY3Rpb25zIGFzIHdlbGwgYXMgY2xhc3NlcywgcmV0dXJuIHRoZSBsaXN0XG4gKiBvZiB2YWxpZGF0b3IgZnVuY3Rpb25zIChjb252ZXJ0IHZhbGlkYXRvciBjbGFzc2VzIGludG8gdmFsaWRhdG9yIGZ1bmN0aW9ucykuIFRoaXMgaXMgbmVlZGVkIHRvXG4gKiBoYXZlIGNvbnNpc3RlbnQgc3RydWN0dXJlIGluIHZhbGlkYXRvcnMgbGlzdCBiZWZvcmUgY29tcG9zaW5nIHRoZW0uXG4gKlxuICogQHBhcmFtIHZhbGlkYXRvcnMgVGhlIHNldCBvZiB2YWxpZGF0b3JzIHRoYXQgbWF5IGNvbnRhaW4gdmFsaWRhdG9ycyBib3RoIGluIHBsYWluIGZ1bmN0aW9uIGZvcm1cbiAqICAgICBhcyB3ZWxsIGFzIHJlcHJlc2VudGVkIGFzIGEgdmFsaWRhdG9yIGNsYXNzLlxuICovXG5mdW5jdGlvbiBub3JtYWxpemVWYWxpZGF0b3JzKHZhbGlkYXRvcnMpIHtcbiAgICByZXR1cm4gdmFsaWRhdG9ycy5tYXAodmFsaWRhdG9yID0+IHtcbiAgICAgICAgcmV0dXJuIGlzVmFsaWRhdG9yRm4odmFsaWRhdG9yKSA/XG4gICAgICAgICAgICB2YWxpZGF0b3IgOlxuICAgICAgICAgICAgKChjKSA9PiB2YWxpZGF0b3IudmFsaWRhdGUoYykpO1xuICAgIH0pO1xufVxuLyoqXG4gKiBNZXJnZXMgc3luY2hyb25vdXMgdmFsaWRhdG9ycyBpbnRvIGEgc2luZ2xlIHZhbGlkYXRvciBmdW5jdGlvbi5cbiAqIFNlZSBgVmFsaWRhdG9ycy5jb21wb3NlYCBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvbi5cbiAqL1xuZnVuY3Rpb24gY29tcG9zZSh2YWxpZGF0b3JzKSB7XG4gICAgaWYgKCF2YWxpZGF0b3JzKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICBjb25zdCBwcmVzZW50VmFsaWRhdG9ycyA9IHZhbGlkYXRvcnMuZmlsdGVyKGlzUHJlc2VudCk7XG4gICAgaWYgKHByZXNlbnRWYWxpZGF0b3JzLmxlbmd0aCA9PSAwKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGNvbnRyb2wpIHtcbiAgICAgICAgcmV0dXJuIG1lcmdlRXJyb3JzKGV4ZWN1dGVWYWxpZGF0b3JzKGNvbnRyb2wsIHByZXNlbnRWYWxpZGF0b3JzKSk7XG4gICAgfTtcbn1cbi8qKlxuICogQWNjZXB0cyBhIGxpc3Qgb2YgdmFsaWRhdG9ycyBvZiBkaWZmZXJlbnQgcG9zc2libGUgc2hhcGVzIChgVmFsaWRhdG9yYCBhbmQgYFZhbGlkYXRvckZuYCksXG4gKiBub3JtYWxpemVzIHRoZSBsaXN0IChjb252ZXJ0cyBldmVyeXRoaW5nIHRvIGBWYWxpZGF0b3JGbmApIGFuZCBtZXJnZXMgdGhlbSBpbnRvIGEgc2luZ2xlXG4gKiB2YWxpZGF0b3IgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGNvbXBvc2VWYWxpZGF0b3JzKHZhbGlkYXRvcnMpIHtcbiAgICByZXR1cm4gdmFsaWRhdG9ycyAhPSBudWxsID8gY29tcG9zZShub3JtYWxpemVWYWxpZGF0b3JzKHZhbGlkYXRvcnMpKSA6IG51bGw7XG59XG4vKipcbiAqIE1lcmdlcyBhc3luY2hyb25vdXMgdmFsaWRhdG9ycyBpbnRvIGEgc2luZ2xlIHZhbGlkYXRvciBmdW5jdGlvbi5cbiAqIFNlZSBgVmFsaWRhdG9ycy5jb21wb3NlQXN5bmNgIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uLlxuICovXG5mdW5jdGlvbiBjb21wb3NlQXN5bmModmFsaWRhdG9ycykge1xuICAgIGlmICghdmFsaWRhdG9ycylcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgY29uc3QgcHJlc2VudFZhbGlkYXRvcnMgPSB2YWxpZGF0b3JzLmZpbHRlcihpc1ByZXNlbnQpO1xuICAgIGlmIChwcmVzZW50VmFsaWRhdG9ycy5sZW5ndGggPT0gMClcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChjb250cm9sKSB7XG4gICAgICAgIGNvbnN0IG9ic2VydmFibGVzID0gZXhlY3V0ZVZhbGlkYXRvcnMoY29udHJvbCwgcHJlc2VudFZhbGlkYXRvcnMpLm1hcCh0b09ic2VydmFibGUpO1xuICAgICAgICByZXR1cm4gZm9ya0pvaW4ob2JzZXJ2YWJsZXMpLnBpcGUobWFwKG1lcmdlRXJyb3JzKSk7XG4gICAgfTtcbn1cbi8qKlxuICogQWNjZXB0cyBhIGxpc3Qgb2YgYXN5bmMgdmFsaWRhdG9ycyBvZiBkaWZmZXJlbnQgcG9zc2libGUgc2hhcGVzIChgQXN5bmNWYWxpZGF0b3JgIGFuZFxuICogYEFzeW5jVmFsaWRhdG9yRm5gKSwgbm9ybWFsaXplcyB0aGUgbGlzdCAoY29udmVydHMgZXZlcnl0aGluZyB0byBgQXN5bmNWYWxpZGF0b3JGbmApIGFuZCBtZXJnZXNcbiAqIHRoZW0gaW50byBhIHNpbmdsZSB2YWxpZGF0b3IgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGNvbXBvc2VBc3luY1ZhbGlkYXRvcnModmFsaWRhdG9ycykge1xuICAgIHJldHVybiB2YWxpZGF0b3JzICE9IG51bGwgPyBjb21wb3NlQXN5bmMobm9ybWFsaXplVmFsaWRhdG9ycyh2YWxpZGF0b3JzKSkgOlxuICAgICAgICBudWxsO1xufVxuLyoqXG4gKiBNZXJnZXMgcmF3IGNvbnRyb2wgdmFsaWRhdG9ycyB3aXRoIGEgZ2l2ZW4gZGlyZWN0aXZlIHZhbGlkYXRvciBhbmQgcmV0dXJucyB0aGUgY29tYmluZWQgbGlzdCBvZlxuICogdmFsaWRhdG9ycyBhcyBhbiBhcnJheS5cbiAqL1xuZnVuY3Rpb24gbWVyZ2VWYWxpZGF0b3JzKGNvbnRyb2xWYWxpZGF0b3JzLCBkaXJWYWxpZGF0b3IpIHtcbiAgICBpZiAoY29udHJvbFZhbGlkYXRvcnMgPT09IG51bGwpXG4gICAgICAgIHJldHVybiBbZGlyVmFsaWRhdG9yXTtcbiAgICByZXR1cm4gQXJyYXkuaXNBcnJheShjb250cm9sVmFsaWRhdG9ycykgPyBbLi4uY29udHJvbFZhbGlkYXRvcnMsIGRpclZhbGlkYXRvcl0gOlxuICAgICAgICBbY29udHJvbFZhbGlkYXRvcnMsIGRpclZhbGlkYXRvcl07XG59XG4vKipcbiAqIFJldHJpZXZlcyB0aGUgbGlzdCBvZiByYXcgc3luY2hyb25vdXMgdmFsaWRhdG9ycyBhdHRhY2hlZCB0byBhIGdpdmVuIGNvbnRyb2wuXG4gKi9cbmZ1bmN0aW9uIGdldENvbnRyb2xWYWxpZGF0b3JzKGNvbnRyb2wpIHtcbiAgICByZXR1cm4gY29udHJvbC5fcmF3VmFsaWRhdG9ycztcbn1cbi8qKlxuICogUmV0cmlldmVzIHRoZSBsaXN0IG9mIHJhdyBhc3luY2hyb25vdXMgdmFsaWRhdG9ycyBhdHRhY2hlZCB0byBhIGdpdmVuIGNvbnRyb2wuXG4gKi9cbmZ1bmN0aW9uIGdldENvbnRyb2xBc3luY1ZhbGlkYXRvcnMoY29udHJvbCkge1xuICAgIHJldHVybiBjb250cm9sLl9yYXdBc3luY1ZhbGlkYXRvcnM7XG59XG4vKipcbiAqIEFjY2VwdHMgYSBzaW5nbGV0b24gdmFsaWRhdG9yLCBhbiBhcnJheSwgb3IgbnVsbCwgYW5kIHJldHVybnMgYW4gYXJyYXkgdHlwZSB3aXRoIHRoZSBwcm92aWRlZFxuICogdmFsaWRhdG9ycy5cbiAqXG4gKiBAcGFyYW0gdmFsaWRhdG9ycyBBIHZhbGlkYXRvciwgdmFsaWRhdG9ycywgb3IgbnVsbC5cbiAqIEByZXR1cm5zIEEgdmFsaWRhdG9ycyBhcnJheS5cbiAqL1xuZnVuY3Rpb24gbWFrZVZhbGlkYXRvcnNBcnJheSh2YWxpZGF0b3JzKSB7XG4gICAgaWYgKCF2YWxpZGF0b3JzKVxuICAgICAgICByZXR1cm4gW107XG4gICAgcmV0dXJuIEFycmF5LmlzQXJyYXkodmFsaWRhdG9ycykgPyB2YWxpZGF0b3JzIDogW3ZhbGlkYXRvcnNdO1xufVxuLyoqXG4gKiBEZXRlcm1pbmVzIHdoZXRoZXIgYSB2YWxpZGF0b3Igb3IgdmFsaWRhdG9ycyBhcnJheSBoYXMgYSBnaXZlbiB2YWxpZGF0b3IuXG4gKlxuICogQHBhcmFtIHZhbGlkYXRvcnMgVGhlIHZhbGlkYXRvciBvciB2YWxpZGF0b3JzIHRvIGNvbXBhcmUgYWdhaW5zdC5cbiAqIEBwYXJhbSB2YWxpZGF0b3IgVGhlIHZhbGlkYXRvciB0byBjaGVjay5cbiAqIEByZXR1cm5zIFdoZXRoZXIgdGhlIHZhbGlkYXRvciBpcyBwcmVzZW50LlxuICovXG5mdW5jdGlvbiBoYXNWYWxpZGF0b3IodmFsaWRhdG9ycywgdmFsaWRhdG9yKSB7XG4gICAgcmV0dXJuIEFycmF5LmlzQXJyYXkodmFsaWRhdG9ycykgPyB2YWxpZGF0b3JzLmluY2x1ZGVzKHZhbGlkYXRvcikgOiB2YWxpZGF0b3JzID09PSB2YWxpZGF0b3I7XG59XG4vKipcbiAqIENvbWJpbmVzIHR3byBhcnJheXMgb2YgdmFsaWRhdG9ycyBpbnRvIG9uZS4gSWYgZHVwbGljYXRlcyBhcmUgcHJvdmlkZWQsIG9ubHkgb25lIHdpbGwgYmUgYWRkZWQuXG4gKlxuICogQHBhcmFtIHZhbGlkYXRvcnMgVGhlIG5ldyB2YWxpZGF0b3JzLlxuICogQHBhcmFtIGN1cnJlbnRWYWxpZGF0b3JzIFRoZSBiYXNlIGFycmF5IG9mIGN1cnJlbnQgdmFsaWRhdG9ycy5cbiAqIEByZXR1cm5zIEFuIGFycmF5IG9mIHZhbGlkYXRvcnMuXG4gKi9cbmZ1bmN0aW9uIGFkZFZhbGlkYXRvcnModmFsaWRhdG9ycywgY3VycmVudFZhbGlkYXRvcnMpIHtcbiAgICBjb25zdCBjdXJyZW50ID0gbWFrZVZhbGlkYXRvcnNBcnJheShjdXJyZW50VmFsaWRhdG9ycyk7XG4gICAgY29uc3QgdmFsaWRhdG9yc1RvQWRkID0gbWFrZVZhbGlkYXRvcnNBcnJheSh2YWxpZGF0b3JzKTtcbiAgICB2YWxpZGF0b3JzVG9BZGQuZm9yRWFjaCgodikgPT4ge1xuICAgICAgICAvLyBOb3RlOiBpZiB0aGVyZSBhcmUgZHVwbGljYXRlIGVudHJpZXMgaW4gdGhlIG5ldyB2YWxpZGF0b3JzIGFycmF5LFxuICAgICAgICAvLyBvbmx5IHRoZSBmaXJzdCBvbmUgd291bGQgYmUgYWRkZWQgdG8gdGhlIGN1cnJlbnQgbGlzdCBvZiB2YWxpZGF0b3JzLlxuICAgICAgICAvLyBEdXBsaWNhdGUgb25lcyB3b3VsZCBiZSBpZ25vcmVkIHNpbmNlIGBoYXNWYWxpZGF0b3JgIHdvdWxkIGRldGVjdFxuICAgICAgICAvLyB0aGUgcHJlc2VuY2Ugb2YgYSB2YWxpZGF0b3IgZnVuY3Rpb24gYW5kIHdlIHVwZGF0ZSB0aGUgY3VycmVudCBsaXN0IGluIHBsYWNlLlxuICAgICAgICBpZiAoIWhhc1ZhbGlkYXRvcihjdXJyZW50LCB2KSkge1xuICAgICAgICAgICAgY3VycmVudC5wdXNoKHYpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGN1cnJlbnQ7XG59XG5mdW5jdGlvbiByZW1vdmVWYWxpZGF0b3JzKHZhbGlkYXRvcnMsIGN1cnJlbnRWYWxpZGF0b3JzKSB7XG4gICAgcmV0dXJuIG1ha2VWYWxpZGF0b3JzQXJyYXkoY3VycmVudFZhbGlkYXRvcnMpLmZpbHRlcih2ID0+ICFoYXNWYWxpZGF0b3IodmFsaWRhdG9ycywgdikpO1xufVxuXG4vKipcbiAqIEBkZXNjcmlwdGlvblxuICogQmFzZSBjbGFzcyBmb3IgY29udHJvbCBkaXJlY3RpdmVzLlxuICpcbiAqIFRoaXMgY2xhc3MgaXMgb25seSB1c2VkIGludGVybmFsbHkgaW4gdGhlIGBSZWFjdGl2ZUZvcm1zTW9kdWxlYCBhbmQgdGhlIGBGb3Jtc01vZHVsZWAuXG4gKlxuICogQHB1YmxpY0FwaVxuICovXG5jbGFzcyBBYnN0cmFjdENvbnRyb2xEaXJlY3RpdmUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICAvKipcbiAgICAgICAgICogU2V0IG9mIHN5bmNocm9ub3VzIHZhbGlkYXRvcnMgYXMgdGhleSB3ZXJlIHByb3ZpZGVkIHdoaWxlIGNhbGxpbmcgYHNldFZhbGlkYXRvcnNgIGZ1bmN0aW9uLlxuICAgICAgICAgKiBAaW50ZXJuYWxcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX3Jhd1ZhbGlkYXRvcnMgPSBbXTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldCBvZiBhc3luY2hyb25vdXMgdmFsaWRhdG9ycyBhcyB0aGV5IHdlcmUgcHJvdmlkZWQgd2hpbGUgY2FsbGluZyBgc2V0QXN5bmNWYWxpZGF0b3JzYFxuICAgICAgICAgKiBmdW5jdGlvbi5cbiAgICAgICAgICogQGludGVybmFsXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9yYXdBc3luY1ZhbGlkYXRvcnMgPSBbXTtcbiAgICAgICAgLypcbiAgICAgICAgICogVGhlIHNldCBvZiBjYWxsYmFja3MgdG8gYmUgaW52b2tlZCB3aGVuIGRpcmVjdGl2ZSBpbnN0YW5jZSBpcyBiZWluZyBkZXN0cm95ZWQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9vbkRlc3Ryb3lDYWxsYmFja3MgPSBbXTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICogUmVwb3J0cyB0aGUgdmFsdWUgb2YgdGhlIGNvbnRyb2wgaWYgaXQgaXMgcHJlc2VudCwgb3RoZXJ3aXNlIG51bGwuXG4gICAgICovXG4gICAgZ2V0IHZhbHVlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb250cm9sID8gdGhpcy5jb250cm9sLnZhbHVlIDogbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICogUmVwb3J0cyB3aGV0aGVyIHRoZSBjb250cm9sIGlzIHZhbGlkLiBBIGNvbnRyb2wgaXMgY29uc2lkZXJlZCB2YWxpZCBpZiBub1xuICAgICAqIHZhbGlkYXRpb24gZXJyb3JzIGV4aXN0IHdpdGggdGhlIGN1cnJlbnQgdmFsdWUuXG4gICAgICogSWYgdGhlIGNvbnRyb2wgaXMgbm90IHByZXNlbnQsIG51bGwgaXMgcmV0dXJuZWQuXG4gICAgICovXG4gICAgZ2V0IHZhbGlkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb250cm9sID8gdGhpcy5jb250cm9sLnZhbGlkIDogbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICogUmVwb3J0cyB3aGV0aGVyIHRoZSBjb250cm9sIGlzIGludmFsaWQsIG1lYW5pbmcgdGhhdCBhbiBlcnJvciBleGlzdHMgaW4gdGhlIGlucHV0IHZhbHVlLlxuICAgICAqIElmIHRoZSBjb250cm9sIGlzIG5vdCBwcmVzZW50LCBudWxsIGlzIHJldHVybmVkLlxuICAgICAqL1xuICAgIGdldCBpbnZhbGlkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb250cm9sID8gdGhpcy5jb250cm9sLmludmFsaWQgOiBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKiBSZXBvcnRzIHdoZXRoZXIgYSBjb250cm9sIGlzIHBlbmRpbmcsIG1lYW5pbmcgdGhhdCBhc3luYyB2YWxpZGF0aW9uIGlzIG9jY3VycmluZyBhbmRcbiAgICAgKiBlcnJvcnMgYXJlIG5vdCB5ZXQgYXZhaWxhYmxlIGZvciB0aGUgaW5wdXQgdmFsdWUuIElmIHRoZSBjb250cm9sIGlzIG5vdCBwcmVzZW50LCBudWxsIGlzXG4gICAgICogcmV0dXJuZWQuXG4gICAgICovXG4gICAgZ2V0IHBlbmRpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnRyb2wgPyB0aGlzLmNvbnRyb2wucGVuZGluZyA6IG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqIFJlcG9ydHMgd2hldGhlciB0aGUgY29udHJvbCBpcyBkaXNhYmxlZCwgbWVhbmluZyB0aGF0IHRoZSBjb250cm9sIGlzIGRpc2FibGVkXG4gICAgICogaW4gdGhlIFVJIGFuZCBpcyBleGVtcHQgZnJvbSB2YWxpZGF0aW9uIGNoZWNrcyBhbmQgZXhjbHVkZWQgZnJvbSBhZ2dyZWdhdGVcbiAgICAgKiB2YWx1ZXMgb2YgYW5jZXN0b3IgY29udHJvbHMuIElmIHRoZSBjb250cm9sIGlzIG5vdCBwcmVzZW50LCBudWxsIGlzIHJldHVybmVkLlxuICAgICAqL1xuICAgIGdldCBkaXNhYmxlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29udHJvbCA/IHRoaXMuY29udHJvbC5kaXNhYmxlZCA6IG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqIFJlcG9ydHMgd2hldGhlciB0aGUgY29udHJvbCBpcyBlbmFibGVkLCBtZWFuaW5nIHRoYXQgdGhlIGNvbnRyb2wgaXMgaW5jbHVkZWQgaW4gYW5jZXN0b3JcbiAgICAgKiBjYWxjdWxhdGlvbnMgb2YgdmFsaWRpdHkgb3IgdmFsdWUuIElmIHRoZSBjb250cm9sIGlzIG5vdCBwcmVzZW50LCBudWxsIGlzIHJldHVybmVkLlxuICAgICAqL1xuICAgIGdldCBlbmFibGVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb250cm9sID8gdGhpcy5jb250cm9sLmVuYWJsZWQgOiBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKiBSZXBvcnRzIHRoZSBjb250cm9sJ3MgdmFsaWRhdGlvbiBlcnJvcnMuIElmIHRoZSBjb250cm9sIGlzIG5vdCBwcmVzZW50LCBudWxsIGlzIHJldHVybmVkLlxuICAgICAqL1xuICAgIGdldCBlcnJvcnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnRyb2wgPyB0aGlzLmNvbnRyb2wuZXJyb3JzIDogbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICogUmVwb3J0cyB3aGV0aGVyIHRoZSBjb250cm9sIGlzIHByaXN0aW5lLCBtZWFuaW5nIHRoYXQgdGhlIHVzZXIgaGFzIG5vdCB5ZXQgY2hhbmdlZFxuICAgICAqIHRoZSB2YWx1ZSBpbiB0aGUgVUkuIElmIHRoZSBjb250cm9sIGlzIG5vdCBwcmVzZW50LCBudWxsIGlzIHJldHVybmVkLlxuICAgICAqL1xuICAgIGdldCBwcmlzdGluZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29udHJvbCA/IHRoaXMuY29udHJvbC5wcmlzdGluZSA6IG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqIFJlcG9ydHMgd2hldGhlciB0aGUgY29udHJvbCBpcyBkaXJ0eSwgbWVhbmluZyB0aGF0IHRoZSB1c2VyIGhhcyBjaGFuZ2VkXG4gICAgICogdGhlIHZhbHVlIGluIHRoZSBVSS4gSWYgdGhlIGNvbnRyb2wgaXMgbm90IHByZXNlbnQsIG51bGwgaXMgcmV0dXJuZWQuXG4gICAgICovXG4gICAgZ2V0IGRpcnR5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb250cm9sID8gdGhpcy5jb250cm9sLmRpcnR5IDogbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICogUmVwb3J0cyB3aGV0aGVyIHRoZSBjb250cm9sIGlzIHRvdWNoZWQsIG1lYW5pbmcgdGhhdCB0aGUgdXNlciBoYXMgdHJpZ2dlcmVkXG4gICAgICogYSBgYmx1cmAgZXZlbnQgb24gaXQuIElmIHRoZSBjb250cm9sIGlzIG5vdCBwcmVzZW50LCBudWxsIGlzIHJldHVybmVkLlxuICAgICAqL1xuICAgIGdldCB0b3VjaGVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb250cm9sID8gdGhpcy5jb250cm9sLnRvdWNoZWQgOiBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKiBSZXBvcnRzIHRoZSB2YWxpZGF0aW9uIHN0YXR1cyBvZiB0aGUgY29udHJvbC4gUG9zc2libGUgdmFsdWVzIGluY2x1ZGU6XG4gICAgICogJ1ZBTElEJywgJ0lOVkFMSUQnLCAnRElTQUJMRUQnLCBhbmQgJ1BFTkRJTkcnLlxuICAgICAqIElmIHRoZSBjb250cm9sIGlzIG5vdCBwcmVzZW50LCBudWxsIGlzIHJldHVybmVkLlxuICAgICAqL1xuICAgIGdldCBzdGF0dXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnRyb2wgPyB0aGlzLmNvbnRyb2wuc3RhdHVzIDogbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICogUmVwb3J0cyB3aGV0aGVyIHRoZSBjb250cm9sIGlzIHVudG91Y2hlZCwgbWVhbmluZyB0aGF0IHRoZSB1c2VyIGhhcyBub3QgeWV0IHRyaWdnZXJlZFxuICAgICAqIGEgYGJsdXJgIGV2ZW50IG9uIGl0LiBJZiB0aGUgY29udHJvbCBpcyBub3QgcHJlc2VudCwgbnVsbCBpcyByZXR1cm5lZC5cbiAgICAgKi9cbiAgICBnZXQgdW50b3VjaGVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb250cm9sID8gdGhpcy5jb250cm9sLnVudG91Y2hlZCA6IG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqIFJldHVybnMgYSBtdWx0aWNhc3Rpbmcgb2JzZXJ2YWJsZSB0aGF0IGVtaXRzIGEgdmFsaWRhdGlvbiBzdGF0dXMgd2hlbmV2ZXIgaXQgaXNcbiAgICAgKiBjYWxjdWxhdGVkIGZvciB0aGUgY29udHJvbC4gSWYgdGhlIGNvbnRyb2wgaXMgbm90IHByZXNlbnQsIG51bGwgaXMgcmV0dXJuZWQuXG4gICAgICovXG4gICAgZ2V0IHN0YXR1c0NoYW5nZXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnRyb2wgPyB0aGlzLmNvbnRyb2wuc3RhdHVzQ2hhbmdlcyA6IG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqIFJldHVybnMgYSBtdWx0aWNhc3Rpbmcgb2JzZXJ2YWJsZSBvZiB2YWx1ZSBjaGFuZ2VzIGZvciB0aGUgY29udHJvbCB0aGF0IGVtaXRzIGV2ZXJ5IHRpbWUgdGhlXG4gICAgICogdmFsdWUgb2YgdGhlIGNvbnRyb2wgY2hhbmdlcyBpbiB0aGUgVUkgb3IgcHJvZ3JhbW1hdGljYWxseS5cbiAgICAgKiBJZiB0aGUgY29udHJvbCBpcyBub3QgcHJlc2VudCwgbnVsbCBpcyByZXR1cm5lZC5cbiAgICAgKi9cbiAgICBnZXQgdmFsdWVDaGFuZ2VzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb250cm9sID8gdGhpcy5jb250cm9sLnZhbHVlQ2hhbmdlcyA6IG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqIFJldHVybnMgYW4gYXJyYXkgdGhhdCByZXByZXNlbnRzIHRoZSBwYXRoIGZyb20gdGhlIHRvcC1sZXZlbCBmb3JtIHRvIHRoaXMgY29udHJvbC5cbiAgICAgKiBFYWNoIGluZGV4IGlzIHRoZSBzdHJpbmcgbmFtZSBvZiB0aGUgY29udHJvbCBvbiB0aGF0IGxldmVsLlxuICAgICAqL1xuICAgIGdldCBwYXRoKCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyBzeW5jaHJvbm91cyB2YWxpZGF0b3JzIGZvciB0aGlzIGRpcmVjdGl2ZS5cbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBfc2V0VmFsaWRhdG9ycyh2YWxpZGF0b3JzKSB7XG4gICAgICAgIHRoaXMuX3Jhd1ZhbGlkYXRvcnMgPSB2YWxpZGF0b3JzIHx8IFtdO1xuICAgICAgICB0aGlzLl9jb21wb3NlZFZhbGlkYXRvckZuID0gY29tcG9zZVZhbGlkYXRvcnModGhpcy5fcmF3VmFsaWRhdG9ycyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgYXN5bmNocm9ub3VzIHZhbGlkYXRvcnMgZm9yIHRoaXMgZGlyZWN0aXZlLlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIF9zZXRBc3luY1ZhbGlkYXRvcnModmFsaWRhdG9ycykge1xuICAgICAgICB0aGlzLl9yYXdBc3luY1ZhbGlkYXRvcnMgPSB2YWxpZGF0b3JzIHx8IFtdO1xuICAgICAgICB0aGlzLl9jb21wb3NlZEFzeW5jVmFsaWRhdG9yRm4gPSBjb21wb3NlQXN5bmNWYWxpZGF0b3JzKHRoaXMuX3Jhd0FzeW5jVmFsaWRhdG9ycyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqIFN5bmNocm9ub3VzIHZhbGlkYXRvciBmdW5jdGlvbiBjb21wb3NlZCBvZiBhbGwgdGhlIHN5bmNocm9ub3VzIHZhbGlkYXRvcnMgcmVnaXN0ZXJlZCB3aXRoIHRoaXNcbiAgICAgKiBkaXJlY3RpdmUuXG4gICAgICovXG4gICAgZ2V0IHZhbGlkYXRvcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NvbXBvc2VkVmFsaWRhdG9yRm4gfHwgbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICogQXN5bmNocm9ub3VzIHZhbGlkYXRvciBmdW5jdGlvbiBjb21wb3NlZCBvZiBhbGwgdGhlIGFzeW5jaHJvbm91cyB2YWxpZGF0b3JzIHJlZ2lzdGVyZWQgd2l0aFxuICAgICAqIHRoaXMgZGlyZWN0aXZlLlxuICAgICAqL1xuICAgIGdldCBhc3luY1ZhbGlkYXRvcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NvbXBvc2VkQXN5bmNWYWxpZGF0b3JGbiB8fCBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbnRlcm5hbCBmdW5jdGlvbiB0byByZWdpc3RlciBjYWxsYmFja3MgdGhhdCBzaG91bGQgYmUgaW52b2tlZFxuICAgICAqIHdoZW4gZGlyZWN0aXZlIGluc3RhbmNlIGlzIGJlaW5nIGRlc3Ryb3llZC5cbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBfcmVnaXN0ZXJPbkRlc3Ryb3koZm4pIHtcbiAgICAgICAgdGhpcy5fb25EZXN0cm95Q2FsbGJhY2tzLnB1c2goZm4pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbnRlcm5hbCBmdW5jdGlvbiB0byBpbnZva2UgYWxsIHJlZ2lzdGVyZWQgXCJvbiBkZXN0cm95XCIgY2FsbGJhY2tzLlxuICAgICAqIE5vdGU6IGNhbGxpbmcgdGhpcyBmdW5jdGlvbiBhbHNvIGNsZWFycyB0aGUgbGlzdCBvZiBjYWxsYmFja3MuXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgX2ludm9rZU9uRGVzdHJveUNhbGxiYWNrcygpIHtcbiAgICAgICAgdGhpcy5fb25EZXN0cm95Q2FsbGJhY2tzLmZvckVhY2goZm4gPT4gZm4oKSk7XG4gICAgICAgIHRoaXMuX29uRGVzdHJveUNhbGxiYWNrcyA9IFtdO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKiBSZXNldHMgdGhlIGNvbnRyb2wgd2l0aCB0aGUgcHJvdmlkZWQgdmFsdWUgaWYgdGhlIGNvbnRyb2wgaXMgcHJlc2VudC5cbiAgICAgKi9cbiAgICByZXNldCh2YWx1ZSA9IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAodGhpcy5jb250cm9sKVxuICAgICAgICAgICAgdGhpcy5jb250cm9sLnJlc2V0KHZhbHVlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICogUmVwb3J0cyB3aGV0aGVyIHRoZSBjb250cm9sIHdpdGggdGhlIGdpdmVuIHBhdGggaGFzIHRoZSBlcnJvciBzcGVjaWZpZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZXJyb3JDb2RlIFRoZSBjb2RlIG9mIHRoZSBlcnJvciB0byBjaGVja1xuICAgICAqIEBwYXJhbSBwYXRoIEEgbGlzdCBvZiBjb250cm9sIG5hbWVzIHRoYXQgZGVzaWduYXRlcyBob3cgdG8gbW92ZSBmcm9tIHRoZSBjdXJyZW50IGNvbnRyb2xcbiAgICAgKiB0byB0aGUgY29udHJvbCB0aGF0IHNob3VsZCBiZSBxdWVyaWVkIGZvciBlcnJvcnMuXG4gICAgICpcbiAgICAgKiBAdXNhZ2VOb3Rlc1xuICAgICAqIEZvciBleGFtcGxlLCBmb3IgdGhlIGZvbGxvd2luZyBgRm9ybUdyb3VwYDpcbiAgICAgKlxuICAgICAqIGBgYFxuICAgICAqIGZvcm0gPSBuZXcgRm9ybUdyb3VwKHtcbiAgICAgKiAgIGFkZHJlc3M6IG5ldyBGb3JtR3JvdXAoeyBzdHJlZXQ6IG5ldyBGb3JtQ29udHJvbCgpIH0pXG4gICAgICogfSk7XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBUaGUgcGF0aCB0byB0aGUgJ3N0cmVldCcgY29udHJvbCBmcm9tIHRoZSByb290IGZvcm0gd291bGQgYmUgJ2FkZHJlc3MnIC0+ICdzdHJlZXQnLlxuICAgICAqXG4gICAgICogSXQgY2FuIGJlIHByb3ZpZGVkIHRvIHRoaXMgbWV0aG9kIGluIG9uZSBvZiB0d28gZm9ybWF0czpcbiAgICAgKlxuICAgICAqIDEuIEFuIGFycmF5IG9mIHN0cmluZyBjb250cm9sIG5hbWVzLCBlLmcuIGBbJ2FkZHJlc3MnLCAnc3RyZWV0J11gXG4gICAgICogMS4gQSBwZXJpb2QtZGVsaW1pdGVkIGxpc3Qgb2YgY29udHJvbCBuYW1lcyBpbiBvbmUgc3RyaW5nLCBlLmcuIGAnYWRkcmVzcy5zdHJlZXQnYFxuICAgICAqXG4gICAgICogSWYgbm8gcGF0aCBpcyBnaXZlbiwgdGhpcyBtZXRob2QgY2hlY2tzIGZvciB0aGUgZXJyb3Igb24gdGhlIGN1cnJlbnQgY29udHJvbC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHdoZXRoZXIgdGhlIGdpdmVuIGVycm9yIGlzIHByZXNlbnQgaW4gdGhlIGNvbnRyb2wgYXQgdGhlIGdpdmVuIHBhdGguXG4gICAgICpcbiAgICAgKiBJZiB0aGUgY29udHJvbCBpcyBub3QgcHJlc2VudCwgZmFsc2UgaXMgcmV0dXJuZWQuXG4gICAgICovXG4gICAgaGFzRXJyb3IoZXJyb3JDb2RlLCBwYXRoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnRyb2wgPyB0aGlzLmNvbnRyb2wuaGFzRXJyb3IoZXJyb3JDb2RlLCBwYXRoKSA6IGZhbHNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKiBSZXBvcnRzIGVycm9yIGRhdGEgZm9yIHRoZSBjb250cm9sIHdpdGggdGhlIGdpdmVuIHBhdGguXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZXJyb3JDb2RlIFRoZSBjb2RlIG9mIHRoZSBlcnJvciB0byBjaGVja1xuICAgICAqIEBwYXJhbSBwYXRoIEEgbGlzdCBvZiBjb250cm9sIG5hbWVzIHRoYXQgZGVzaWduYXRlcyBob3cgdG8gbW92ZSBmcm9tIHRoZSBjdXJyZW50IGNvbnRyb2xcbiAgICAgKiB0byB0aGUgY29udHJvbCB0aGF0IHNob3VsZCBiZSBxdWVyaWVkIGZvciBlcnJvcnMuXG4gICAgICpcbiAgICAgKiBAdXNhZ2VOb3Rlc1xuICAgICAqIEZvciBleGFtcGxlLCBmb3IgdGhlIGZvbGxvd2luZyBgRm9ybUdyb3VwYDpcbiAgICAgKlxuICAgICAqIGBgYFxuICAgICAqIGZvcm0gPSBuZXcgRm9ybUdyb3VwKHtcbiAgICAgKiAgIGFkZHJlc3M6IG5ldyBGb3JtR3JvdXAoeyBzdHJlZXQ6IG5ldyBGb3JtQ29udHJvbCgpIH0pXG4gICAgICogfSk7XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBUaGUgcGF0aCB0byB0aGUgJ3N0cmVldCcgY29udHJvbCBmcm9tIHRoZSByb290IGZvcm0gd291bGQgYmUgJ2FkZHJlc3MnIC0+ICdzdHJlZXQnLlxuICAgICAqXG4gICAgICogSXQgY2FuIGJlIHByb3ZpZGVkIHRvIHRoaXMgbWV0aG9kIGluIG9uZSBvZiB0d28gZm9ybWF0czpcbiAgICAgKlxuICAgICAqIDEuIEFuIGFycmF5IG9mIHN0cmluZyBjb250cm9sIG5hbWVzLCBlLmcuIGBbJ2FkZHJlc3MnLCAnc3RyZWV0J11gXG4gICAgICogMS4gQSBwZXJpb2QtZGVsaW1pdGVkIGxpc3Qgb2YgY29udHJvbCBuYW1lcyBpbiBvbmUgc3RyaW5nLCBlLmcuIGAnYWRkcmVzcy5zdHJlZXQnYFxuICAgICAqXG4gICAgICogQHJldHVybnMgZXJyb3IgZGF0YSBmb3IgdGhhdCBwYXJ0aWN1bGFyIGVycm9yLiBJZiB0aGUgY29udHJvbCBvciBlcnJvciBpcyBub3QgcHJlc2VudCxcbiAgICAgKiBudWxsIGlzIHJldHVybmVkLlxuICAgICAqL1xuICAgIGdldEVycm9yKGVycm9yQ29kZSwgcGF0aCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb250cm9sID8gdGhpcy5jb250cm9sLmdldEVycm9yKGVycm9yQ29kZSwgcGF0aCkgOiBudWxsO1xuICAgIH1cbn1cblxuLyoqXG4gKiBAZGVzY3JpcHRpb25cbiAqIEEgYmFzZSBjbGFzcyBmb3IgZGlyZWN0aXZlcyB0aGF0IGNvbnRhaW4gbXVsdGlwbGUgcmVnaXN0ZXJlZCBpbnN0YW5jZXMgb2YgYE5nQ29udHJvbGAuXG4gKiBPbmx5IHVzZWQgYnkgdGhlIGZvcm1zIG1vZHVsZS5cbiAqXG4gKiBAcHVibGljQXBpXG4gKi9cbmNsYXNzIENvbnRyb2xDb250YWluZXIgZXh0ZW5kcyBBYnN0cmFjdENvbnRyb2xEaXJlY3RpdmUge1xuICAgIC8qKlxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqIFRoZSB0b3AtbGV2ZWwgZm9ybSBkaXJlY3RpdmUgZm9yIHRoZSBjb250cm9sLlxuICAgICAqL1xuICAgIGdldCBmb3JtRGlyZWN0aXZlKCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICogVGhlIHBhdGggdG8gdGhpcyBncm91cC5cbiAgICAgKi9cbiAgICBnZXQgcGF0aCgpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxufVxuXG4vKipcbiAqIEBkZXNjcmlwdGlvblxuICogQSBiYXNlIGNsYXNzIHRoYXQgYWxsIGBGb3JtQ29udHJvbGAtYmFzZWQgZGlyZWN0aXZlcyBleHRlbmQuIEl0IGJpbmRzIGEgYEZvcm1Db250cm9sYFxuICogb2JqZWN0IHRvIGEgRE9NIGVsZW1lbnQuXG4gKlxuICogQHB1YmxpY0FwaVxuICovXG5jbGFzcyBOZ0NvbnRyb2wgZXh0ZW5kcyBBYnN0cmFjdENvbnRyb2xEaXJlY3RpdmUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICAvKipcbiAgICAgICAgICogQGRlc2NyaXB0aW9uXG4gICAgICAgICAqIFRoZSBwYXJlbnQgZm9ybSBmb3IgdGhlIGNvbnRyb2wuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBpbnRlcm5hbFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fcGFyZW50ID0gbnVsbDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAgICAgKiBUaGUgbmFtZSBmb3IgdGhlIGNvbnRyb2xcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubmFtZSA9IG51bGw7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgICAgICogVGhlIHZhbHVlIGFjY2Vzc29yIGZvciB0aGUgY29udHJvbFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy52YWx1ZUFjY2Vzc29yID0gbnVsbDtcbiAgICB9XG59XG5cbi8vIERPIE5PVCBSRUZBQ1RPUiFcbi8vIEVhY2ggc3RhdHVzIGlzIHJlcHJlc2VudGVkIGJ5IGEgc2VwYXJhdGUgZnVuY3Rpb24gdG8gbWFrZSBzdXJlIHRoYXRcbi8vIGFkdmFuY2VkIENsb3N1cmUgQ29tcGlsZXIgb3B0aW1pemF0aW9ucyByZWxhdGVkIHRvIHByb3BlcnR5IHJlbmFtaW5nXG4vLyBjYW4gd29yayBjb3JyZWN0bHkuXG5jbGFzcyBBYnN0cmFjdENvbnRyb2xTdGF0dXMge1xuICAgIGNvbnN0cnVjdG9yKGNkKSB7XG4gICAgICAgIHRoaXMuX2NkID0gY2Q7XG4gICAgfVxuICAgIGdldCBpc1RvdWNoZWQoKSB7XG4gICAgICAgIHJldHVybiAhIXRoaXMuX2NkPy5jb250cm9sPy50b3VjaGVkO1xuICAgIH1cbiAgICBnZXQgaXNVbnRvdWNoZWQoKSB7XG4gICAgICAgIHJldHVybiAhIXRoaXMuX2NkPy5jb250cm9sPy51bnRvdWNoZWQ7XG4gICAgfVxuICAgIGdldCBpc1ByaXN0aW5lKCkge1xuICAgICAgICByZXR1cm4gISF0aGlzLl9jZD8uY29udHJvbD8ucHJpc3RpbmU7XG4gICAgfVxuICAgIGdldCBpc0RpcnR5KCkge1xuICAgICAgICByZXR1cm4gISF0aGlzLl9jZD8uY29udHJvbD8uZGlydHk7XG4gICAgfVxuICAgIGdldCBpc1ZhbGlkKCkge1xuICAgICAgICByZXR1cm4gISF0aGlzLl9jZD8uY29udHJvbD8udmFsaWQ7XG4gICAgfVxuICAgIGdldCBpc0ludmFsaWQoKSB7XG4gICAgICAgIHJldHVybiAhIXRoaXMuX2NkPy5jb250cm9sPy5pbnZhbGlkO1xuICAgIH1cbiAgICBnZXQgaXNQZW5kaW5nKCkge1xuICAgICAgICByZXR1cm4gISF0aGlzLl9jZD8uY29udHJvbD8ucGVuZGluZztcbiAgICB9XG4gICAgZ2V0IGlzU3VibWl0dGVkKCkge1xuICAgICAgICAvLyBXZSBjaGVjayBmb3IgdGhlIGBzdWJtaXR0ZWRgIGZpZWxkIGZyb20gYE5nRm9ybWAgYW5kIGBGb3JtR3JvdXBEaXJlY3RpdmVgIGNsYXNzZXMsIGJ1dFxuICAgICAgICAvLyB3ZSBhdm9pZCBpbnN0YW5jZW9mIGNoZWNrcyB0byBwcmV2ZW50IG5vbi10cmVlLXNoYWthYmxlIHJlZmVyZW5jZXMgdG8gdGhvc2UgdHlwZXMuXG4gICAgICAgIHJldHVybiAhIXRoaXMuX2NkPy5zdWJtaXR0ZWQ7XG4gICAgfVxufVxuY29uc3QgbmdDb250cm9sU3RhdHVzSG9zdCA9IHtcbiAgICAnW2NsYXNzLm5nLXVudG91Y2hlZF0nOiAnaXNVbnRvdWNoZWQnLFxuICAgICdbY2xhc3MubmctdG91Y2hlZF0nOiAnaXNUb3VjaGVkJyxcbiAgICAnW2NsYXNzLm5nLXByaXN0aW5lXSc6ICdpc1ByaXN0aW5lJyxcbiAgICAnW2NsYXNzLm5nLWRpcnR5XSc6ICdpc0RpcnR5JyxcbiAgICAnW2NsYXNzLm5nLXZhbGlkXSc6ICdpc1ZhbGlkJyxcbiAgICAnW2NsYXNzLm5nLWludmFsaWRdJzogJ2lzSW52YWxpZCcsXG4gICAgJ1tjbGFzcy5uZy1wZW5kaW5nXSc6ICdpc1BlbmRpbmcnLFxufTtcbmNvbnN0IG5nR3JvdXBTdGF0dXNIb3N0ID0ge1xuICAgIC4uLm5nQ29udHJvbFN0YXR1c0hvc3QsXG4gICAgJ1tjbGFzcy5uZy1zdWJtaXR0ZWRdJzogJ2lzU3VibWl0dGVkJyxcbn07XG4vKipcbiAqIEBkZXNjcmlwdGlvblxuICogRGlyZWN0aXZlIGF1dG9tYXRpY2FsbHkgYXBwbGllZCB0byBBbmd1bGFyIGZvcm0gY29udHJvbHMgdGhhdCBzZXRzIENTUyBjbGFzc2VzXG4gKiBiYXNlZCBvbiBjb250cm9sIHN0YXR1cy5cbiAqXG4gKiBAdXNhZ2VOb3Rlc1xuICpcbiAqICMjIyBDU1MgY2xhc3NlcyBhcHBsaWVkXG4gKlxuICogVGhlIGZvbGxvd2luZyBjbGFzc2VzIGFyZSBhcHBsaWVkIGFzIHRoZSBwcm9wZXJ0aWVzIGJlY29tZSB0cnVlOlxuICpcbiAqICogbmctdmFsaWRcbiAqICogbmctaW52YWxpZFxuICogKiBuZy1wZW5kaW5nXG4gKiAqIG5nLXByaXN0aW5lXG4gKiAqIG5nLWRpcnR5XG4gKiAqIG5nLXVudG91Y2hlZFxuICogKiBuZy10b3VjaGVkXG4gKlxuICogQG5nTW9kdWxlIFJlYWN0aXZlRm9ybXNNb2R1bGVcbiAqIEBuZ01vZHVsZSBGb3Jtc01vZHVsZVxuICogQHB1YmxpY0FwaVxuICovXG5jbGFzcyBOZ0NvbnRyb2xTdGF0dXMgZXh0ZW5kcyBBYnN0cmFjdENvbnRyb2xTdGF0dXMge1xuICAgIGNvbnN0cnVjdG9yKGNkKSB7XG4gICAgICAgIHN1cGVyKGNkKTtcbiAgICB9XG4gICAgc3RhdGljIHsgdGhpcy7JtWZhYyA9IGkwLsm1ybVuZ0RlY2xhcmVGYWN0b3J5KHsgbWluVmVyc2lvbjogXCIxMi4wLjBcIiwgdmVyc2lvbjogXCIxNy4zLjEyXCIsIG5nSW1wb3J0OiBpMCwgdHlwZTogTmdDb250cm9sU3RhdHVzLCBkZXBzOiBbeyB0b2tlbjogTmdDb250cm9sLCBzZWxmOiB0cnVlIH1dLCB0YXJnZXQ6IGkwLsm1ybVGYWN0b3J5VGFyZ2V0LkRpcmVjdGl2ZSB9KTsgfVxuICAgIHN0YXRpYyB7IHRoaXMuybVkaXIgPSBpMC7Jtcm1bmdEZWNsYXJlRGlyZWN0aXZlKHsgbWluVmVyc2lvbjogXCIxNC4wLjBcIiwgdmVyc2lvbjogXCIxNy4zLjEyXCIsIHR5cGU6IE5nQ29udHJvbFN0YXR1cywgc2VsZWN0b3I6IFwiW2Zvcm1Db250cm9sTmFtZV0sW25nTW9kZWxdLFtmb3JtQ29udHJvbF1cIiwgaG9zdDogeyBwcm9wZXJ0aWVzOiB7IFwiY2xhc3MubmctdW50b3VjaGVkXCI6IFwiaXNVbnRvdWNoZWRcIiwgXCJjbGFzcy5uZy10b3VjaGVkXCI6IFwiaXNUb3VjaGVkXCIsIFwiY2xhc3MubmctcHJpc3RpbmVcIjogXCJpc1ByaXN0aW5lXCIsIFwiY2xhc3MubmctZGlydHlcIjogXCJpc0RpcnR5XCIsIFwiY2xhc3MubmctdmFsaWRcIjogXCJpc1ZhbGlkXCIsIFwiY2xhc3MubmctaW52YWxpZFwiOiBcImlzSW52YWxpZFwiLCBcImNsYXNzLm5nLXBlbmRpbmdcIjogXCJpc1BlbmRpbmdcIiB9IH0sIHVzZXNJbmhlcml0YW5jZTogdHJ1ZSwgbmdJbXBvcnQ6IGkwIH0pOyB9XG59XG5pMC7Jtcm1bmdEZWNsYXJlQ2xhc3NNZXRhZGF0YSh7IG1pblZlcnNpb246IFwiMTIuMC4wXCIsIHZlcnNpb246IFwiMTcuMy4xMlwiLCBuZ0ltcG9ydDogaTAsIHR5cGU6IE5nQ29udHJvbFN0YXR1cywgZGVjb3JhdG9yczogW3tcbiAgICAgICAgICAgIHR5cGU6IERpcmVjdGl2ZSxcbiAgICAgICAgICAgIGFyZ3M6IFt7IHNlbGVjdG9yOiAnW2Zvcm1Db250cm9sTmFtZV0sW25nTW9kZWxdLFtmb3JtQ29udHJvbF0nLCBob3N0OiBuZ0NvbnRyb2xTdGF0dXNIb3N0IH1dXG4gICAgICAgIH1dLCBjdG9yUGFyYW1ldGVyczogKCkgPT4gW3sgdHlwZTogTmdDb250cm9sLCBkZWNvcmF0b3JzOiBbe1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBTZWxmXG4gICAgICAgICAgICAgICAgfV0gfV0gfSk7XG4vKipcbiAqIEBkZXNjcmlwdGlvblxuICogRGlyZWN0aXZlIGF1dG9tYXRpY2FsbHkgYXBwbGllZCB0byBBbmd1bGFyIGZvcm0gZ3JvdXBzIHRoYXQgc2V0cyBDU1MgY2xhc3Nlc1xuICogYmFzZWQgb24gY29udHJvbCBzdGF0dXMgKHZhbGlkL2ludmFsaWQvZGlydHkvZXRjKS4gT24gZ3JvdXBzLCB0aGlzIGluY2x1ZGVzIHRoZSBhZGRpdGlvbmFsXG4gKiBjbGFzcyBuZy1zdWJtaXR0ZWQuXG4gKlxuICogQHNlZSB7QGxpbmsgTmdDb250cm9sU3RhdHVzfVxuICpcbiAqIEBuZ01vZHVsZSBSZWFjdGl2ZUZvcm1zTW9kdWxlXG4gKiBAbmdNb2R1bGUgRm9ybXNNb2R1bGVcbiAqIEBwdWJsaWNBcGlcbiAqL1xuY2xhc3MgTmdDb250cm9sU3RhdHVzR3JvdXAgZXh0ZW5kcyBBYnN0cmFjdENvbnRyb2xTdGF0dXMge1xuICAgIGNvbnN0cnVjdG9yKGNkKSB7XG4gICAgICAgIHN1cGVyKGNkKTtcbiAgICB9XG4gICAgc3RhdGljIHsgdGhpcy7JtWZhYyA9IGkwLsm1ybVuZ0RlY2xhcmVGYWN0b3J5KHsgbWluVmVyc2lvbjogXCIxMi4wLjBcIiwgdmVyc2lvbjogXCIxNy4zLjEyXCIsIG5nSW1wb3J0OiBpMCwgdHlwZTogTmdDb250cm9sU3RhdHVzR3JvdXAsIGRlcHM6IFt7IHRva2VuOiBDb250cm9sQ29udGFpbmVyLCBvcHRpb25hbDogdHJ1ZSwgc2VsZjogdHJ1ZSB9XSwgdGFyZ2V0OiBpMC7Jtcm1RmFjdG9yeVRhcmdldC5EaXJlY3RpdmUgfSk7IH1cbiAgICBzdGF0aWMgeyB0aGlzLsm1ZGlyID0gaTAuybXJtW5nRGVjbGFyZURpcmVjdGl2ZSh7IG1pblZlcnNpb246IFwiMTQuMC4wXCIsIHZlcnNpb246IFwiMTcuMy4xMlwiLCB0eXBlOiBOZ0NvbnRyb2xTdGF0dXNHcm91cCwgc2VsZWN0b3I6IFwiW2Zvcm1Hcm91cE5hbWVdLFtmb3JtQXJyYXlOYW1lXSxbbmdNb2RlbEdyb3VwXSxbZm9ybUdyb3VwXSxmb3JtOm5vdChbbmdOb0Zvcm1dKSxbbmdGb3JtXVwiLCBob3N0OiB7IHByb3BlcnRpZXM6IHsgXCJjbGFzcy5uZy11bnRvdWNoZWRcIjogXCJpc1VudG91Y2hlZFwiLCBcImNsYXNzLm5nLXRvdWNoZWRcIjogXCJpc1RvdWNoZWRcIiwgXCJjbGFzcy5uZy1wcmlzdGluZVwiOiBcImlzUHJpc3RpbmVcIiwgXCJjbGFzcy5uZy1kaXJ0eVwiOiBcImlzRGlydHlcIiwgXCJjbGFzcy5uZy12YWxpZFwiOiBcImlzVmFsaWRcIiwgXCJjbGFzcy5uZy1pbnZhbGlkXCI6IFwiaXNJbnZhbGlkXCIsIFwiY2xhc3MubmctcGVuZGluZ1wiOiBcImlzUGVuZGluZ1wiLCBcImNsYXNzLm5nLXN1Ym1pdHRlZFwiOiBcImlzU3VibWl0dGVkXCIgfSB9LCB1c2VzSW5oZXJpdGFuY2U6IHRydWUsIG5nSW1wb3J0OiBpMCB9KTsgfVxufVxuaTAuybXJtW5nRGVjbGFyZUNsYXNzTWV0YWRhdGEoeyBtaW5WZXJzaW9uOiBcIjEyLjAuMFwiLCB2ZXJzaW9uOiBcIjE3LjMuMTJcIiwgbmdJbXBvcnQ6IGkwLCB0eXBlOiBOZ0NvbnRyb2xTdGF0dXNHcm91cCwgZGVjb3JhdG9yczogW3tcbiAgICAgICAgICAgIHR5cGU6IERpcmVjdGl2ZSxcbiAgICAgICAgICAgIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnW2Zvcm1Hcm91cE5hbWVdLFtmb3JtQXJyYXlOYW1lXSxbbmdNb2RlbEdyb3VwXSxbZm9ybUdyb3VwXSxmb3JtOm5vdChbbmdOb0Zvcm1dKSxbbmdGb3JtXScsXG4gICAgICAgICAgICAgICAgICAgIGhvc3Q6IG5nR3JvdXBTdGF0dXNIb3N0XG4gICAgICAgICAgICAgICAgfV1cbiAgICAgICAgfV0sIGN0b3JQYXJhbWV0ZXJzOiAoKSA9PiBbeyB0eXBlOiBDb250cm9sQ29udGFpbmVyLCBkZWNvcmF0b3JzOiBbe1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBPcHRpb25hbFxuICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogU2VsZlxuICAgICAgICAgICAgICAgIH1dIH1dIH0pO1xuXG5jb25zdCBmb3JtQ29udHJvbE5hbWVFeGFtcGxlID0gYFxuICA8ZGl2IFtmb3JtR3JvdXBdPVwibXlHcm91cFwiPlxuICAgIDxpbnB1dCBmb3JtQ29udHJvbE5hbWU9XCJmaXJzdE5hbWVcIj5cbiAgPC9kaXY+XG5cbiAgSW4geW91ciBjbGFzczpcblxuICB0aGlzLm15R3JvdXAgPSBuZXcgRm9ybUdyb3VwKHtcbiAgICAgIGZpcnN0TmFtZTogbmV3IEZvcm1Db250cm9sKClcbiAgfSk7YDtcbmNvbnN0IGZvcm1Hcm91cE5hbWVFeGFtcGxlID0gYFxuICA8ZGl2IFtmb3JtR3JvdXBdPVwibXlHcm91cFwiPlxuICAgICAgPGRpdiBmb3JtR3JvdXBOYW1lPVwicGVyc29uXCI+XG4gICAgICAgIDxpbnB1dCBmb3JtQ29udHJvbE5hbWU9XCJmaXJzdE5hbWVcIj5cbiAgICAgIDwvZGl2PlxuICA8L2Rpdj5cblxuICBJbiB5b3VyIGNsYXNzOlxuXG4gIHRoaXMubXlHcm91cCA9IG5ldyBGb3JtR3JvdXAoe1xuICAgICAgcGVyc29uOiBuZXcgRm9ybUdyb3VwKHsgZmlyc3ROYW1lOiBuZXcgRm9ybUNvbnRyb2woKSB9KVxuICB9KTtgO1xuY29uc3QgZm9ybUFycmF5TmFtZUV4YW1wbGUgPSBgXG4gIDxkaXYgW2Zvcm1Hcm91cF09XCJteUdyb3VwXCI+XG4gICAgPGRpdiBmb3JtQXJyYXlOYW1lPVwiY2l0aWVzXCI+XG4gICAgICA8ZGl2ICpuZ0Zvcj1cImxldCBjaXR5IG9mIGNpdHlBcnJheS5jb250cm9sczsgaW5kZXggYXMgaVwiPlxuICAgICAgICA8aW5wdXQgW2Zvcm1Db250cm9sTmFtZV09XCJpXCI+XG4gICAgICA8L2Rpdj5cbiAgICA8L2Rpdj5cbiAgPC9kaXY+XG5cbiAgSW4geW91ciBjbGFzczpcblxuICB0aGlzLmNpdHlBcnJheSA9IG5ldyBGb3JtQXJyYXkoW25ldyBGb3JtQ29udHJvbCgnU0YnKV0pO1xuICB0aGlzLm15R3JvdXAgPSBuZXcgRm9ybUdyb3VwKHtcbiAgICBjaXRpZXM6IHRoaXMuY2l0eUFycmF5XG4gIH0pO2A7XG5jb25zdCBuZ01vZGVsR3JvdXBFeGFtcGxlID0gYFxuICA8Zm9ybT5cbiAgICAgIDxkaXYgbmdNb2RlbEdyb3VwPVwicGVyc29uXCI+XG4gICAgICAgIDxpbnB1dCBbKG5nTW9kZWwpXT1cInBlcnNvbi5uYW1lXCIgbmFtZT1cImZpcnN0TmFtZVwiPlxuICAgICAgPC9kaXY+XG4gIDwvZm9ybT5gO1xuY29uc3QgbmdNb2RlbFdpdGhGb3JtR3JvdXBFeGFtcGxlID0gYFxuICA8ZGl2IFtmb3JtR3JvdXBdPVwibXlHcm91cFwiPlxuICAgICAgPGlucHV0IGZvcm1Db250cm9sTmFtZT1cImZpcnN0TmFtZVwiPlxuICAgICAgPGlucHV0IFsobmdNb2RlbCldPVwic2hvd01vcmVDb250cm9sc1wiIFtuZ01vZGVsT3B0aW9uc109XCJ7c3RhbmRhbG9uZTogdHJ1ZX1cIj5cbiAgPC9kaXY+XG5gO1xuXG5mdW5jdGlvbiBjb250cm9sUGFyZW50RXhjZXB0aW9uKCkge1xuICAgIHJldHVybiBuZXcgybVSdW50aW1lRXJyb3IoMTA1MCAvKiBSdW50aW1lRXJyb3JDb2RlLkZPUk1fQ09OVFJPTF9OQU1FX01JU1NJTkdfUEFSRU5UICovLCBgZm9ybUNvbnRyb2xOYW1lIG11c3QgYmUgdXNlZCB3aXRoIGEgcGFyZW50IGZvcm1Hcm91cCBkaXJlY3RpdmUuICBZb3UnbGwgd2FudCB0byBhZGQgYSBmb3JtR3JvdXBcbiAgICAgIGRpcmVjdGl2ZSBhbmQgcGFzcyBpdCBhbiBleGlzdGluZyBGb3JtR3JvdXAgaW5zdGFuY2UgKHlvdSBjYW4gY3JlYXRlIG9uZSBpbiB5b3VyIGNsYXNzKS5cblxuICAgIEV4YW1wbGU6XG5cbiAgICAke2Zvcm1Db250cm9sTmFtZUV4YW1wbGV9YCk7XG59XG5mdW5jdGlvbiBuZ01vZGVsR3JvdXBFeGNlcHRpb24oKSB7XG4gICAgcmV0dXJuIG5ldyDJtVJ1bnRpbWVFcnJvcigxMDUxIC8qIFJ1bnRpbWVFcnJvckNvZGUuRk9STV9DT05UUk9MX05BTUVfSU5TSURFX01PREVMX0dST1VQICovLCBgZm9ybUNvbnRyb2xOYW1lIGNhbm5vdCBiZSB1c2VkIHdpdGggYW4gbmdNb2RlbEdyb3VwIHBhcmVudC4gSXQgaXMgb25seSBjb21wYXRpYmxlIHdpdGggcGFyZW50c1xuICAgICAgdGhhdCBhbHNvIGhhdmUgYSBcImZvcm1cIiBwcmVmaXg6IGZvcm1Hcm91cE5hbWUsIGZvcm1BcnJheU5hbWUsIG9yIGZvcm1Hcm91cC5cblxuICAgICAgT3B0aW9uIDE6ICBVcGRhdGUgdGhlIHBhcmVudCB0byBiZSBmb3JtR3JvdXBOYW1lIChyZWFjdGl2ZSBmb3JtIHN0cmF0ZWd5KVxuXG4gICAgICAke2Zvcm1Hcm91cE5hbWVFeGFtcGxlfVxuXG4gICAgICBPcHRpb24gMjogVXNlIG5nTW9kZWwgaW5zdGVhZCBvZiBmb3JtQ29udHJvbE5hbWUgKHRlbXBsYXRlLWRyaXZlbiBzdHJhdGVneSlcblxuICAgICAgJHtuZ01vZGVsR3JvdXBFeGFtcGxlfWApO1xufVxuZnVuY3Rpb24gbWlzc2luZ0Zvcm1FeGNlcHRpb24oKSB7XG4gICAgcmV0dXJuIG5ldyDJtVJ1bnRpbWVFcnJvcigxMDUyIC8qIFJ1bnRpbWVFcnJvckNvZGUuRk9STV9HUk9VUF9NSVNTSU5HX0lOU1RBTkNFICovLCBgZm9ybUdyb3VwIGV4cGVjdHMgYSBGb3JtR3JvdXAgaW5zdGFuY2UuIFBsZWFzZSBwYXNzIG9uZSBpbi5cblxuICAgICAgRXhhbXBsZTpcblxuICAgICAgJHtmb3JtQ29udHJvbE5hbWVFeGFtcGxlfWApO1xufVxuZnVuY3Rpb24gZ3JvdXBQYXJlbnRFeGNlcHRpb24oKSB7XG4gICAgcmV0dXJuIG5ldyDJtVJ1bnRpbWVFcnJvcigxMDUzIC8qIFJ1bnRpbWVFcnJvckNvZGUuRk9STV9HUk9VUF9OQU1FX01JU1NJTkdfUEFSRU5UICovLCBgZm9ybUdyb3VwTmFtZSBtdXN0IGJlIHVzZWQgd2l0aCBhIHBhcmVudCBmb3JtR3JvdXAgZGlyZWN0aXZlLiAgWW91J2xsIHdhbnQgdG8gYWRkIGEgZm9ybUdyb3VwXG4gICAgZGlyZWN0aXZlIGFuZCBwYXNzIGl0IGFuIGV4aXN0aW5nIEZvcm1Hcm91cCBpbnN0YW5jZSAoeW91IGNhbiBjcmVhdGUgb25lIGluIHlvdXIgY2xhc3MpLlxuXG4gICAgRXhhbXBsZTpcblxuICAgICR7Zm9ybUdyb3VwTmFtZUV4YW1wbGV9YCk7XG59XG5mdW5jdGlvbiBhcnJheVBhcmVudEV4Y2VwdGlvbigpIHtcbiAgICByZXR1cm4gbmV3IMm1UnVudGltZUVycm9yKDEwNTQgLyogUnVudGltZUVycm9yQ29kZS5GT1JNX0FSUkFZX05BTUVfTUlTU0lOR19QQVJFTlQgKi8sIGBmb3JtQXJyYXlOYW1lIG11c3QgYmUgdXNlZCB3aXRoIGEgcGFyZW50IGZvcm1Hcm91cCBkaXJlY3RpdmUuICBZb3UnbGwgd2FudCB0byBhZGQgYSBmb3JtR3JvdXBcbiAgICAgIGRpcmVjdGl2ZSBhbmQgcGFzcyBpdCBhbiBleGlzdGluZyBGb3JtR3JvdXAgaW5zdGFuY2UgKHlvdSBjYW4gY3JlYXRlIG9uZSBpbiB5b3VyIGNsYXNzKS5cblxuICAgICAgRXhhbXBsZTpcblxuICAgICAgJHtmb3JtQXJyYXlOYW1lRXhhbXBsZX1gKTtcbn1cbmNvbnN0IGRpc2FibGVkQXR0cldhcm5pbmcgPSBgXG4gIEl0IGxvb2tzIGxpa2UgeW91J3JlIHVzaW5nIHRoZSBkaXNhYmxlZCBhdHRyaWJ1dGUgd2l0aCBhIHJlYWN0aXZlIGZvcm0gZGlyZWN0aXZlLiBJZiB5b3Ugc2V0IGRpc2FibGVkIHRvIHRydWVcbiAgd2hlbiB5b3Ugc2V0IHVwIHRoaXMgY29udHJvbCBpbiB5b3VyIGNvbXBvbmVudCBjbGFzcywgdGhlIGRpc2FibGVkIGF0dHJpYnV0ZSB3aWxsIGFjdHVhbGx5IGJlIHNldCBpbiB0aGUgRE9NIGZvclxuICB5b3UuIFdlIHJlY29tbWVuZCB1c2luZyB0aGlzIGFwcHJvYWNoIHRvIGF2b2lkICdjaGFuZ2VkIGFmdGVyIGNoZWNrZWQnIGVycm9ycy5cblxuICBFeGFtcGxlOlxuICAvLyBTcGVjaWZ5IHRoZSBcXGBkaXNhYmxlZFxcYCBwcm9wZXJ0eSBhdCBjb250cm9sIGNyZWF0aW9uIHRpbWU6XG4gIGZvcm0gPSBuZXcgRm9ybUdyb3VwKHtcbiAgICBmaXJzdDogbmV3IEZvcm1Db250cm9sKHt2YWx1ZTogJ05hbmN5JywgZGlzYWJsZWQ6IHRydWV9LCBWYWxpZGF0b3JzLnJlcXVpcmVkKSxcbiAgICBsYXN0OiBuZXcgRm9ybUNvbnRyb2woJ0RyZXcnLCBWYWxpZGF0b3JzLnJlcXVpcmVkKVxuICB9KTtcblxuICAvLyBDb250cm9scyBjYW4gYWxzbyBiZSBlbmFibGVkL2Rpc2FibGVkIGFmdGVyIGNyZWF0aW9uOlxuICBmb3JtLmdldCgnZmlyc3QnKT8uZW5hYmxlKCk7XG4gIGZvcm0uZ2V0KCdsYXN0Jyk/LmRpc2FibGUoKTtcbmA7XG5jb25zdCBhc3luY1ZhbGlkYXRvcnNEcm9wcGVkV2l0aE9wdHNXYXJuaW5nID0gYFxuICBJdCBsb29rcyBsaWtlIHlvdSdyZSBjb25zdHJ1Y3RpbmcgdXNpbmcgYSBGb3JtQ29udHJvbCB3aXRoIGJvdGggYW4gb3B0aW9ucyBhcmd1bWVudCBhbmQgYW5cbiAgYXN5bmMgdmFsaWRhdG9ycyBhcmd1bWVudC4gTWl4aW5nIHRoZXNlIGFyZ3VtZW50cyB3aWxsIGNhdXNlIHlvdXIgYXN5bmMgdmFsaWRhdG9ycyB0byBiZSBkcm9wcGVkLlxuICBZb3Ugc2hvdWxkIGVpdGhlciBwdXQgYWxsIHlvdXIgdmFsaWRhdG9ycyBpbiB0aGUgb3B0aW9ucyBvYmplY3QsIG9yIGluIHNlcGFyYXRlIHZhbGlkYXRvcnNcbiAgYXJndW1lbnRzLiBGb3IgZXhhbXBsZTpcblxuICAvLyBVc2luZyB2YWxpZGF0b3JzIGFyZ3VtZW50c1xuICBmYyA9IG5ldyBGb3JtQ29udHJvbCg0MiwgVmFsaWRhdG9ycy5yZXF1aXJlZCwgbXlBc3luY1ZhbGlkYXRvcik7XG5cbiAgLy8gVXNpbmcgQWJzdHJhY3RDb250cm9sT3B0aW9uc1xuICBmYyA9IG5ldyBGb3JtQ29udHJvbCg0Miwge3ZhbGlkYXRvcnM6IFZhbGlkYXRvcnMucmVxdWlyZWQsIGFzeW5jVmFsaWRhdG9yczogbXlBVn0pO1xuXG4gIC8vIERvIE5PVCBtaXggdGhlbTogYXN5bmMgdmFsaWRhdG9ycyB3aWxsIGJlIGRyb3BwZWQhXG4gIGZjID0gbmV3IEZvcm1Db250cm9sKDQyLCB7dmFsaWRhdG9yczogVmFsaWRhdG9ycy5yZXF1aXJlZH0sIC8qIE9vcHMhICovIG15QXN5bmNWYWxpZGF0b3IpO1xuYDtcbmZ1bmN0aW9uIG5nTW9kZWxXYXJuaW5nKGRpcmVjdGl2ZU5hbWUpIHtcbiAgICByZXR1cm4gYFxuICBJdCBsb29rcyBsaWtlIHlvdSdyZSB1c2luZyBuZ01vZGVsIG9uIHRoZSBzYW1lIGZvcm0gZmllbGQgYXMgJHtkaXJlY3RpdmVOYW1lfS5cbiAgU3VwcG9ydCBmb3IgdXNpbmcgdGhlIG5nTW9kZWwgaW5wdXQgcHJvcGVydHkgYW5kIG5nTW9kZWxDaGFuZ2UgZXZlbnQgd2l0aFxuICByZWFjdGl2ZSBmb3JtIGRpcmVjdGl2ZXMgaGFzIGJlZW4gZGVwcmVjYXRlZCBpbiBBbmd1bGFyIHY2IGFuZCB3aWxsIGJlIHJlbW92ZWRcbiAgaW4gYSBmdXR1cmUgdmVyc2lvbiBvZiBBbmd1bGFyLlxuXG4gIEZvciBtb3JlIGluZm9ybWF0aW9uIG9uIHRoaXMsIHNlZSBvdXIgQVBJIGRvY3MgaGVyZTpcbiAgaHR0cHM6Ly9hbmd1bGFyLmlvL2FwaS9mb3Jtcy8ke2RpcmVjdGl2ZU5hbWUgPT09ICdmb3JtQ29udHJvbCcgPyAnRm9ybUNvbnRyb2xEaXJlY3RpdmUnIDogJ0Zvcm1Db250cm9sTmFtZSd9I3VzZS13aXRoLW5nbW9kZWxcbiAgYDtcbn1cbmZ1bmN0aW9uIGRlc2NyaWJlS2V5KGlzRm9ybUdyb3VwLCBrZXkpIHtcbiAgICByZXR1cm4gaXNGb3JtR3JvdXAgPyBgd2l0aCBuYW1lOiAnJHtrZXl9J2AgOiBgYXQgaW5kZXg6ICR7a2V5fWA7XG59XG5mdW5jdGlvbiBub0NvbnRyb2xzRXJyb3IoaXNGb3JtR3JvdXApIHtcbiAgICByZXR1cm4gYFxuICAgIFRoZXJlIGFyZSBubyBmb3JtIGNvbnRyb2xzIHJlZ2lzdGVyZWQgd2l0aCB0aGlzICR7aXNGb3JtR3JvdXAgPyAnZ3JvdXAnIDogJ2FycmF5J30geWV0LiBJZiB5b3UncmUgdXNpbmcgbmdNb2RlbCxcbiAgICB5b3UgbWF5IHdhbnQgdG8gY2hlY2sgbmV4dCB0aWNrIChlLmcuIHVzZSBzZXRUaW1lb3V0KS5cbiAgYDtcbn1cbmZ1bmN0aW9uIG1pc3NpbmdDb250cm9sRXJyb3IoaXNGb3JtR3JvdXAsIGtleSkge1xuICAgIHJldHVybiBgQ2Fubm90IGZpbmQgZm9ybSBjb250cm9sICR7ZGVzY3JpYmVLZXkoaXNGb3JtR3JvdXAsIGtleSl9YDtcbn1cbmZ1bmN0aW9uIG1pc3NpbmdDb250cm9sVmFsdWVFcnJvcihpc0Zvcm1Hcm91cCwga2V5KSB7XG4gICAgcmV0dXJuIGBNdXN0IHN1cHBseSBhIHZhbHVlIGZvciBmb3JtIGNvbnRyb2wgJHtkZXNjcmliZUtleShpc0Zvcm1Hcm91cCwga2V5KX1gO1xufVxuXG4vKipcbiAqIFJlcG9ydHMgdGhhdCBhIGNvbnRyb2wgaXMgdmFsaWQsIG1lYW5pbmcgdGhhdCBubyBlcnJvcnMgZXhpc3QgaW4gdGhlIGlucHV0IHZhbHVlLlxuICpcbiAqIEBzZWUge0BsaW5rIHN0YXR1c31cbiAqL1xuY29uc3QgVkFMSUQgPSAnVkFMSUQnO1xuLyoqXG4gKiBSZXBvcnRzIHRoYXQgYSBjb250cm9sIGlzIGludmFsaWQsIG1lYW5pbmcgdGhhdCBhbiBlcnJvciBleGlzdHMgaW4gdGhlIGlucHV0IHZhbHVlLlxuICpcbiAqIEBzZWUge0BsaW5rIHN0YXR1c31cbiAqL1xuY29uc3QgSU5WQUxJRCA9ICdJTlZBTElEJztcbi8qKlxuICogUmVwb3J0cyB0aGF0IGEgY29udHJvbCBpcyBwZW5kaW5nLCBtZWFuaW5nIHRoYXQgYXN5bmMgdmFsaWRhdGlvbiBpcyBvY2N1cnJpbmcgYW5kXG4gKiBlcnJvcnMgYXJlIG5vdCB5ZXQgYXZhaWxhYmxlIGZvciB0aGUgaW5wdXQgdmFsdWUuXG4gKlxuICogQHNlZSB7QGxpbmsgbWFya0FzUGVuZGluZ31cbiAqIEBzZWUge0BsaW5rIHN0YXR1c31cbiAqL1xuY29uc3QgUEVORElORyA9ICdQRU5ESU5HJztcbi8qKlxuICogUmVwb3J0cyB0aGF0IGEgY29udHJvbCBpcyBkaXNhYmxlZCwgbWVhbmluZyB0aGF0IHRoZSBjb250cm9sIGlzIGV4ZW1wdCBmcm9tIGFuY2VzdG9yXG4gKiBjYWxjdWxhdGlvbnMgb2YgdmFsaWRpdHkgb3IgdmFsdWUuXG4gKlxuICogQHNlZSB7QGxpbmsgbWFya0FzRGlzYWJsZWR9XG4gKiBAc2VlIHtAbGluayBzdGF0dXN9XG4gKi9cbmNvbnN0IERJU0FCTEVEID0gJ0RJU0FCTEVEJztcbi8qKlxuICogR2V0cyB2YWxpZGF0b3JzIGZyb20gZWl0aGVyIGFuIG9wdGlvbnMgb2JqZWN0IG9yIGdpdmVuIHZhbGlkYXRvcnMuXG4gKi9cbmZ1bmN0aW9uIHBpY2tWYWxpZGF0b3JzKHZhbGlkYXRvck9yT3B0cykge1xuICAgIHJldHVybiAoaXNPcHRpb25zT2JqKHZhbGlkYXRvck9yT3B0cykgPyB2YWxpZGF0b3JPck9wdHMudmFsaWRhdG9ycyA6IHZhbGlkYXRvck9yT3B0cykgfHwgbnVsbDtcbn1cbi8qKlxuICogQ3JlYXRlcyB2YWxpZGF0b3IgZnVuY3Rpb24gYnkgY29tYmluaW5nIHByb3ZpZGVkIHZhbGlkYXRvcnMuXG4gKi9cbmZ1bmN0aW9uIGNvZXJjZVRvVmFsaWRhdG9yKHZhbGlkYXRvcikge1xuICAgIHJldHVybiBBcnJheS5pc0FycmF5KHZhbGlkYXRvcikgPyBjb21wb3NlVmFsaWRhdG9ycyh2YWxpZGF0b3IpIDogdmFsaWRhdG9yIHx8IG51bGw7XG59XG4vKipcbiAqIEdldHMgYXN5bmMgdmFsaWRhdG9ycyBmcm9tIGVpdGhlciBhbiBvcHRpb25zIG9iamVjdCBvciBnaXZlbiB2YWxpZGF0b3JzLlxuICovXG5mdW5jdGlvbiBwaWNrQXN5bmNWYWxpZGF0b3JzKGFzeW5jVmFsaWRhdG9yLCB2YWxpZGF0b3JPck9wdHMpIHtcbiAgICBpZiAodHlwZW9mIG5nRGV2TW9kZSA9PT0gJ3VuZGVmaW5lZCcgfHwgbmdEZXZNb2RlKSB7XG4gICAgICAgIGlmIChpc09wdGlvbnNPYmoodmFsaWRhdG9yT3JPcHRzKSAmJiBhc3luY1ZhbGlkYXRvcikge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKGFzeW5jVmFsaWRhdG9yc0Ryb3BwZWRXaXRoT3B0c1dhcm5pbmcpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiAoaXNPcHRpb25zT2JqKHZhbGlkYXRvck9yT3B0cykgPyB2YWxpZGF0b3JPck9wdHMuYXN5bmNWYWxpZGF0b3JzIDogYXN5bmNWYWxpZGF0b3IpIHx8IG51bGw7XG59XG4vKipcbiAqIENyZWF0ZXMgYXN5bmMgdmFsaWRhdG9yIGZ1bmN0aW9uIGJ5IGNvbWJpbmluZyBwcm92aWRlZCBhc3luYyB2YWxpZGF0b3JzLlxuICovXG5mdW5jdGlvbiBjb2VyY2VUb0FzeW5jVmFsaWRhdG9yKGFzeW5jVmFsaWRhdG9yKSB7XG4gICAgcmV0dXJuIEFycmF5LmlzQXJyYXkoYXN5bmNWYWxpZGF0b3IpID8gY29tcG9zZUFzeW5jVmFsaWRhdG9ycyhhc3luY1ZhbGlkYXRvcikgOlxuICAgICAgICBhc3luY1ZhbGlkYXRvciB8fCBudWxsO1xufVxuZnVuY3Rpb24gaXNPcHRpb25zT2JqKHZhbGlkYXRvck9yT3B0cykge1xuICAgIHJldHVybiB2YWxpZGF0b3JPck9wdHMgIT0gbnVsbCAmJiAhQXJyYXkuaXNBcnJheSh2YWxpZGF0b3JPck9wdHMpICYmXG4gICAgICAgIHR5cGVvZiB2YWxpZGF0b3JPck9wdHMgPT09ICdvYmplY3QnO1xufVxuZnVuY3Rpb24gYXNzZXJ0Q29udHJvbFByZXNlbnQocGFyZW50LCBpc0dyb3VwLCBrZXkpIHtcbiAgICBjb25zdCBjb250cm9scyA9IHBhcmVudC5jb250cm9scztcbiAgICBjb25zdCBjb2xsZWN0aW9uID0gaXNHcm91cCA/IE9iamVjdC5rZXlzKGNvbnRyb2xzKSA6IGNvbnRyb2xzO1xuICAgIGlmICghY29sbGVjdGlvbi5sZW5ndGgpIHtcbiAgICAgICAgdGhyb3cgbmV3IMm1UnVudGltZUVycm9yKDEwMDAgLyogUnVudGltZUVycm9yQ29kZS5OT19DT05UUk9MUyAqLywgKHR5cGVvZiBuZ0Rldk1vZGUgPT09ICd1bmRlZmluZWQnIHx8IG5nRGV2TW9kZSkgPyBub0NvbnRyb2xzRXJyb3IoaXNHcm91cCkgOiAnJyk7XG4gICAgfVxuICAgIGlmICghY29udHJvbHNba2V5XSkge1xuICAgICAgICB0aHJvdyBuZXcgybVSdW50aW1lRXJyb3IoMTAwMSAvKiBSdW50aW1lRXJyb3JDb2RlLk1JU1NJTkdfQ09OVFJPTCAqLywgKHR5cGVvZiBuZ0Rldk1vZGUgPT09ICd1bmRlZmluZWQnIHx8IG5nRGV2TW9kZSkgPyBtaXNzaW5nQ29udHJvbEVycm9yKGlzR3JvdXAsIGtleSkgOiAnJyk7XG4gICAgfVxufVxuZnVuY3Rpb24gYXNzZXJ0QWxsVmFsdWVzUHJlc2VudChjb250cm9sLCBpc0dyb3VwLCB2YWx1ZSkge1xuICAgIGNvbnRyb2wuX2ZvckVhY2hDaGlsZCgoXywga2V5KSA9PiB7XG4gICAgICAgIGlmICh2YWx1ZVtrZXldID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyDJtVJ1bnRpbWVFcnJvcigxMDAyIC8qIFJ1bnRpbWVFcnJvckNvZGUuTUlTU0lOR19DT05UUk9MX1ZBTFVFICovLCAodHlwZW9mIG5nRGV2TW9kZSA9PT0gJ3VuZGVmaW5lZCcgfHwgbmdEZXZNb2RlKSA/IG1pc3NpbmdDb250cm9sVmFsdWVFcnJvcihpc0dyb3VwLCBrZXkpIDpcbiAgICAgICAgICAgICAgICAnJyk7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbi8vIGNsYW5nLWZvcm1hdCBvblxuLyoqXG4gKiBUaGlzIGlzIHRoZSBiYXNlIGNsYXNzIGZvciBgRm9ybUNvbnRyb2xgLCBgRm9ybUdyb3VwYCwgYW5kIGBGb3JtQXJyYXlgLlxuICpcbiAqIEl0IHByb3ZpZGVzIHNvbWUgb2YgdGhlIHNoYXJlZCBiZWhhdmlvciB0aGF0IGFsbCBjb250cm9scyBhbmQgZ3JvdXBzIG9mIGNvbnRyb2xzIGhhdmUsIGxpa2VcbiAqIHJ1bm5pbmcgdmFsaWRhdG9ycywgY2FsY3VsYXRpbmcgc3RhdHVzLCBhbmQgcmVzZXR0aW5nIHN0YXRlLiBJdCBhbHNvIGRlZmluZXMgdGhlIHByb3BlcnRpZXNcbiAqIHRoYXQgYXJlIHNoYXJlZCBiZXR3ZWVuIGFsbCBzdWItY2xhc3NlcywgbGlrZSBgdmFsdWVgLCBgdmFsaWRgLCBhbmQgYGRpcnR5YC4gSXQgc2hvdWxkbid0IGJlXG4gKiBpbnN0YW50aWF0ZWQgZGlyZWN0bHkuXG4gKlxuICogVGhlIGZpcnN0IHR5cGUgcGFyYW1ldGVyIFRWYWx1ZSByZXByZXNlbnRzIHRoZSB2YWx1ZSB0eXBlIG9mIHRoZSBjb250cm9sIChgY29udHJvbC52YWx1ZWApLlxuICogVGhlIG9wdGlvbmFsIHR5cGUgcGFyYW1ldGVyIFRSYXdWYWx1ZSAgcmVwcmVzZW50cyB0aGUgcmF3IHZhbHVlIHR5cGUgKGBjb250cm9sLmdldFJhd1ZhbHVlKClgKS5cbiAqXG4gKiBAc2VlIFtGb3JtcyBHdWlkZV0oL2d1aWRlL2Zvcm1zKVxuICogQHNlZSBbUmVhY3RpdmUgRm9ybXMgR3VpZGVdKC9ndWlkZS9yZWFjdGl2ZS1mb3JtcylcbiAqIEBzZWUgW0R5bmFtaWMgRm9ybXMgR3VpZGVdKC9ndWlkZS9keW5hbWljLWZvcm0pXG4gKlxuICogQHB1YmxpY0FwaVxuICovXG5jbGFzcyBBYnN0cmFjdENvbnRyb2wge1xuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemUgdGhlIEFic3RyYWN0Q29udHJvbCBpbnN0YW5jZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB2YWxpZGF0b3JzIFRoZSBmdW5jdGlvbiBvciBhcnJheSBvZiBmdW5jdGlvbnMgdGhhdCBpcyB1c2VkIHRvIGRldGVybWluZSB0aGUgdmFsaWRpdHkgb2ZcbiAgICAgKiAgICAgdGhpcyBjb250cm9sIHN5bmNocm9ub3VzbHkuXG4gICAgICogQHBhcmFtIGFzeW5jVmFsaWRhdG9ycyBUaGUgZnVuY3Rpb24gb3IgYXJyYXkgb2YgZnVuY3Rpb25zIHRoYXQgaXMgdXNlZCB0byBkZXRlcm1pbmUgdmFsaWRpdHkgb2ZcbiAgICAgKiAgICAgdGhpcyBjb250cm9sIGFzeW5jaHJvbm91c2x5LlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHZhbGlkYXRvcnMsIGFzeW5jVmFsaWRhdG9ycykge1xuICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgIHRoaXMuX3BlbmRpbmdEaXJ0eSA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogSW5kaWNhdGVzIHRoYXQgYSBjb250cm9sIGhhcyBpdHMgb3duIHBlbmRpbmcgYXN5bmNocm9ub3VzIHZhbGlkYXRpb24gaW4gcHJvZ3Jlc3MuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBpbnRlcm5hbFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5faGFzT3duUGVuZGluZ0FzeW5jVmFsaWRhdG9yID0gZmFsc2U7XG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgdGhpcy5fcGVuZGluZ1RvdWNoZWQgPSBmYWxzZTtcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICB0aGlzLl9vbkNvbGxlY3Rpb25DaGFuZ2UgPSAoKSA9PiB7IH07XG4gICAgICAgIHRoaXMuX3BhcmVudCA9IG51bGw7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIGNvbnRyb2wgaXMgYHByaXN0aW5lYCBpZiB0aGUgdXNlciBoYXMgbm90IHlldCBjaGFuZ2VkXG4gICAgICAgICAqIHRoZSB2YWx1ZSBpbiB0aGUgVUkuXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm5zIFRydWUgaWYgdGhlIHVzZXIgaGFzIG5vdCB5ZXQgY2hhbmdlZCB0aGUgdmFsdWUgaW4gdGhlIFVJOyBjb21wYXJlIGBkaXJ0eWAuXG4gICAgICAgICAqIFByb2dyYW1tYXRpYyBjaGFuZ2VzIHRvIGEgY29udHJvbCdzIHZhbHVlIGRvIG5vdCBtYXJrIGl0IGRpcnR5LlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5wcmlzdGluZSA9IHRydWU7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUcnVlIGlmIHRoZSBjb250cm9sIGlzIG1hcmtlZCBhcyBgdG91Y2hlZGAuXG4gICAgICAgICAqXG4gICAgICAgICAqIEEgY29udHJvbCBpcyBtYXJrZWQgYHRvdWNoZWRgIG9uY2UgdGhlIHVzZXIgaGFzIHRyaWdnZXJlZFxuICAgICAgICAgKiBhIGBibHVyYCBldmVudCBvbiBpdC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudG91Y2hlZCA9IGZhbHNlO1xuICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgIHRoaXMuX29uRGlzYWJsZWRDaGFuZ2UgPSBbXTtcbiAgICAgICAgdGhpcy5fYXNzaWduVmFsaWRhdG9ycyh2YWxpZGF0b3JzKTtcbiAgICAgICAgdGhpcy5fYXNzaWduQXN5bmNWYWxpZGF0b3JzKGFzeW5jVmFsaWRhdG9ycyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGZ1bmN0aW9uIHRoYXQgaXMgdXNlZCB0byBkZXRlcm1pbmUgdGhlIHZhbGlkaXR5IG9mIHRoaXMgY29udHJvbCBzeW5jaHJvbm91c2x5LlxuICAgICAqIElmIG11bHRpcGxlIHZhbGlkYXRvcnMgaGF2ZSBiZWVuIGFkZGVkLCB0aGlzIHdpbGwgYmUgYSBzaW5nbGUgY29tcG9zZWQgZnVuY3Rpb24uXG4gICAgICogU2VlIGBWYWxpZGF0b3JzLmNvbXBvc2UoKWAgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb24uXG4gICAgICovXG4gICAgZ2V0IHZhbGlkYXRvcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NvbXBvc2VkVmFsaWRhdG9yRm47XG4gICAgfVxuICAgIHNldCB2YWxpZGF0b3IodmFsaWRhdG9yRm4pIHtcbiAgICAgICAgdGhpcy5fcmF3VmFsaWRhdG9ycyA9IHRoaXMuX2NvbXBvc2VkVmFsaWRhdG9yRm4gPSB2YWxpZGF0b3JGbjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgZnVuY3Rpb24gdGhhdCBpcyB1c2VkIHRvIGRldGVybWluZSB0aGUgdmFsaWRpdHkgb2YgdGhpcyBjb250cm9sIGFzeW5jaHJvbm91c2x5LlxuICAgICAqIElmIG11bHRpcGxlIHZhbGlkYXRvcnMgaGF2ZSBiZWVuIGFkZGVkLCB0aGlzIHdpbGwgYmUgYSBzaW5nbGUgY29tcG9zZWQgZnVuY3Rpb24uXG4gICAgICogU2VlIGBWYWxpZGF0b3JzLmNvbXBvc2UoKWAgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb24uXG4gICAgICovXG4gICAgZ2V0IGFzeW5jVmFsaWRhdG9yKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY29tcG9zZWRBc3luY1ZhbGlkYXRvckZuO1xuICAgIH1cbiAgICBzZXQgYXN5bmNWYWxpZGF0b3IoYXN5bmNWYWxpZGF0b3JGbikge1xuICAgICAgICB0aGlzLl9yYXdBc3luY1ZhbGlkYXRvcnMgPSB0aGlzLl9jb21wb3NlZEFzeW5jVmFsaWRhdG9yRm4gPSBhc3luY1ZhbGlkYXRvckZuO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgcGFyZW50IGNvbnRyb2wuXG4gICAgICovXG4gICAgZ2V0IHBhcmVudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BhcmVudDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQSBjb250cm9sIGlzIGB2YWxpZGAgd2hlbiBpdHMgYHN0YXR1c2AgaXMgYFZBTElEYC5cbiAgICAgKlxuICAgICAqIEBzZWUge0BsaW5rIEFic3RyYWN0Q29udHJvbC5zdGF0dXN9XG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUcnVlIGlmIHRoZSBjb250cm9sIGhhcyBwYXNzZWQgYWxsIG9mIGl0cyB2YWxpZGF0aW9uIHRlc3RzLFxuICAgICAqIGZhbHNlIG90aGVyd2lzZS5cbiAgICAgKi9cbiAgICBnZXQgdmFsaWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXR1cyA9PT0gVkFMSUQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEEgY29udHJvbCBpcyBgaW52YWxpZGAgd2hlbiBpdHMgYHN0YXR1c2AgaXMgYElOVkFMSURgLlxuICAgICAqXG4gICAgICogQHNlZSB7QGxpbmsgQWJzdHJhY3RDb250cm9sLnN0YXR1c31cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRydWUgaWYgdGhpcyBjb250cm9sIGhhcyBmYWlsZWQgb25lIG9yIG1vcmUgb2YgaXRzIHZhbGlkYXRpb24gY2hlY2tzLFxuICAgICAqIGZhbHNlIG90aGVyd2lzZS5cbiAgICAgKi9cbiAgICBnZXQgaW52YWxpZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdHVzID09PSBJTlZBTElEO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBIGNvbnRyb2wgaXMgYHBlbmRpbmdgIHdoZW4gaXRzIGBzdGF0dXNgIGlzIGBQRU5ESU5HYC5cbiAgICAgKlxuICAgICAqIEBzZWUge0BsaW5rIEFic3RyYWN0Q29udHJvbC5zdGF0dXN9XG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUcnVlIGlmIHRoaXMgY29udHJvbCBpcyBpbiB0aGUgcHJvY2VzcyBvZiBjb25kdWN0aW5nIGEgdmFsaWRhdGlvbiBjaGVjayxcbiAgICAgKiBmYWxzZSBvdGhlcndpc2UuXG4gICAgICovXG4gICAgZ2V0IHBlbmRpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXR1cyA9PSBQRU5ESU5HO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBIGNvbnRyb2wgaXMgYGRpc2FibGVkYCB3aGVuIGl0cyBgc3RhdHVzYCBpcyBgRElTQUJMRURgLlxuICAgICAqXG4gICAgICogRGlzYWJsZWQgY29udHJvbHMgYXJlIGV4ZW1wdCBmcm9tIHZhbGlkYXRpb24gY2hlY2tzIGFuZFxuICAgICAqIGFyZSBub3QgaW5jbHVkZWQgaW4gdGhlIGFnZ3JlZ2F0ZSB2YWx1ZSBvZiB0aGVpciBhbmNlc3RvclxuICAgICAqIGNvbnRyb2xzLlxuICAgICAqXG4gICAgICogQHNlZSB7QGxpbmsgQWJzdHJhY3RDb250cm9sLnN0YXR1c31cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRydWUgaWYgdGhlIGNvbnRyb2wgaXMgZGlzYWJsZWQsIGZhbHNlIG90aGVyd2lzZS5cbiAgICAgKi9cbiAgICBnZXQgZGlzYWJsZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXR1cyA9PT0gRElTQUJMRUQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEEgY29udHJvbCBpcyBgZW5hYmxlZGAgYXMgbG9uZyBhcyBpdHMgYHN0YXR1c2AgaXMgbm90IGBESVNBQkxFRGAuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUcnVlIGlmIHRoZSBjb250cm9sIGhhcyBhbnkgc3RhdHVzIG90aGVyIHRoYW4gJ0RJU0FCTEVEJyxcbiAgICAgKiBmYWxzZSBpZiB0aGUgc3RhdHVzIGlzICdESVNBQkxFRCcuXG4gICAgICpcbiAgICAgKiBAc2VlIHtAbGluayBBYnN0cmFjdENvbnRyb2wuc3RhdHVzfVxuICAgICAqXG4gICAgICovXG4gICAgZ2V0IGVuYWJsZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXR1cyAhPT0gRElTQUJMRUQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEEgY29udHJvbCBpcyBgZGlydHlgIGlmIHRoZSB1c2VyIGhhcyBjaGFuZ2VkIHRoZSB2YWx1ZVxuICAgICAqIGluIHRoZSBVSS5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRydWUgaWYgdGhlIHVzZXIgaGFzIGNoYW5nZWQgdGhlIHZhbHVlIG9mIHRoaXMgY29udHJvbCBpbiB0aGUgVUk7IGNvbXBhcmUgYHByaXN0aW5lYC5cbiAgICAgKiBQcm9ncmFtbWF0aWMgY2hhbmdlcyB0byBhIGNvbnRyb2wncyB2YWx1ZSBkbyBub3QgbWFyayBpdCBkaXJ0eS5cbiAgICAgKi9cbiAgICBnZXQgZGlydHkoKSB7XG4gICAgICAgIHJldHVybiAhdGhpcy5wcmlzdGluZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVHJ1ZSBpZiB0aGUgY29udHJvbCBoYXMgbm90IGJlZW4gbWFya2VkIGFzIHRvdWNoZWRcbiAgICAgKlxuICAgICAqIEEgY29udHJvbCBpcyBgdW50b3VjaGVkYCBpZiB0aGUgdXNlciBoYXMgbm90IHlldCB0cmlnZ2VyZWRcbiAgICAgKiBhIGBibHVyYCBldmVudCBvbiBpdC5cbiAgICAgKi9cbiAgICBnZXQgdW50b3VjaGVkKCkge1xuICAgICAgICByZXR1cm4gIXRoaXMudG91Y2hlZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVwb3J0cyB0aGUgdXBkYXRlIHN0cmF0ZWd5IG9mIHRoZSBgQWJzdHJhY3RDb250cm9sYCAobWVhbmluZ1xuICAgICAqIHRoZSBldmVudCBvbiB3aGljaCB0aGUgY29udHJvbCB1cGRhdGVzIGl0c2VsZikuXG4gICAgICogUG9zc2libGUgdmFsdWVzOiBgJ2NoYW5nZSdgIHwgYCdibHVyJ2AgfCBgJ3N1Ym1pdCdgXG4gICAgICogRGVmYXVsdCB2YWx1ZTogYCdjaGFuZ2UnYFxuICAgICAqL1xuICAgIGdldCB1cGRhdGVPbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3VwZGF0ZU9uID8gdGhpcy5fdXBkYXRlT24gOiAodGhpcy5wYXJlbnQgPyB0aGlzLnBhcmVudC51cGRhdGVPbiA6ICdjaGFuZ2UnKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgc3luY2hyb25vdXMgdmFsaWRhdG9ycyB0aGF0IGFyZSBhY3RpdmUgb24gdGhpcyBjb250cm9sLiAgQ2FsbGluZ1xuICAgICAqIHRoaXMgb3ZlcndyaXRlcyBhbnkgZXhpc3Rpbmcgc3luY2hyb25vdXMgdmFsaWRhdG9ycy5cbiAgICAgKlxuICAgICAqIFdoZW4geW91IGFkZCBvciByZW1vdmUgYSB2YWxpZGF0b3IgYXQgcnVuIHRpbWUsIHlvdSBtdXN0IGNhbGxcbiAgICAgKiBgdXBkYXRlVmFsdWVBbmRWYWxpZGl0eSgpYCBmb3IgdGhlIG5ldyB2YWxpZGF0aW9uIHRvIHRha2UgZWZmZWN0LlxuICAgICAqXG4gICAgICogSWYgeW91IHdhbnQgdG8gYWRkIGEgbmV3IHZhbGlkYXRvciB3aXRob3V0IGFmZmVjdGluZyBleGlzdGluZyBvbmVzLCBjb25zaWRlclxuICAgICAqIHVzaW5nIGBhZGRWYWxpZGF0b3JzKClgIG1ldGhvZCBpbnN0ZWFkLlxuICAgICAqL1xuICAgIHNldFZhbGlkYXRvcnModmFsaWRhdG9ycykge1xuICAgICAgICB0aGlzLl9hc3NpZ25WYWxpZGF0b3JzKHZhbGlkYXRvcnMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBhc3luY2hyb25vdXMgdmFsaWRhdG9ycyB0aGF0IGFyZSBhY3RpdmUgb24gdGhpcyBjb250cm9sLiBDYWxsaW5nIHRoaXNcbiAgICAgKiBvdmVyd3JpdGVzIGFueSBleGlzdGluZyBhc3luY2hyb25vdXMgdmFsaWRhdG9ycy5cbiAgICAgKlxuICAgICAqIFdoZW4geW91IGFkZCBvciByZW1vdmUgYSB2YWxpZGF0b3IgYXQgcnVuIHRpbWUsIHlvdSBtdXN0IGNhbGxcbiAgICAgKiBgdXBkYXRlVmFsdWVBbmRWYWxpZGl0eSgpYCBmb3IgdGhlIG5ldyB2YWxpZGF0aW9uIHRvIHRha2UgZWZmZWN0LlxuICAgICAqXG4gICAgICogSWYgeW91IHdhbnQgdG8gYWRkIGEgbmV3IHZhbGlkYXRvciB3aXRob3V0IGFmZmVjdGluZyBleGlzdGluZyBvbmVzLCBjb25zaWRlclxuICAgICAqIHVzaW5nIGBhZGRBc3luY1ZhbGlkYXRvcnMoKWAgbWV0aG9kIGluc3RlYWQuXG4gICAgICovXG4gICAgc2V0QXN5bmNWYWxpZGF0b3JzKHZhbGlkYXRvcnMpIHtcbiAgICAgICAgdGhpcy5fYXNzaWduQXN5bmNWYWxpZGF0b3JzKHZhbGlkYXRvcnMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGQgYSBzeW5jaHJvbm91cyB2YWxpZGF0b3Igb3IgdmFsaWRhdG9ycyB0byB0aGlzIGNvbnRyb2wsIHdpdGhvdXQgYWZmZWN0aW5nIG90aGVyIHZhbGlkYXRvcnMuXG4gICAgICpcbiAgICAgKiBXaGVuIHlvdSBhZGQgb3IgcmVtb3ZlIGEgdmFsaWRhdG9yIGF0IHJ1biB0aW1lLCB5b3UgbXVzdCBjYWxsXG4gICAgICogYHVwZGF0ZVZhbHVlQW5kVmFsaWRpdHkoKWAgZm9yIHRoZSBuZXcgdmFsaWRhdGlvbiB0byB0YWtlIGVmZmVjdC5cbiAgICAgKlxuICAgICAqIEFkZGluZyBhIHZhbGlkYXRvciB0aGF0IGFscmVhZHkgZXhpc3RzIHdpbGwgaGF2ZSBubyBlZmZlY3QuIElmIGR1cGxpY2F0ZSB2YWxpZGF0b3IgZnVuY3Rpb25zXG4gICAgICogYXJlIHByZXNlbnQgaW4gdGhlIGB2YWxpZGF0b3JzYCBhcnJheSwgb25seSB0aGUgZmlyc3QgaW5zdGFuY2Ugd291bGQgYmUgYWRkZWQgdG8gYSBmb3JtXG4gICAgICogY29udHJvbC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB2YWxpZGF0b3JzIFRoZSBuZXcgdmFsaWRhdG9yIGZ1bmN0aW9uIG9yIGZ1bmN0aW9ucyB0byBhZGQgdG8gdGhpcyBjb250cm9sLlxuICAgICAqL1xuICAgIGFkZFZhbGlkYXRvcnModmFsaWRhdG9ycykge1xuICAgICAgICB0aGlzLnNldFZhbGlkYXRvcnMoYWRkVmFsaWRhdG9ycyh2YWxpZGF0b3JzLCB0aGlzLl9yYXdWYWxpZGF0b3JzKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZCBhbiBhc3luY2hyb25vdXMgdmFsaWRhdG9yIG9yIHZhbGlkYXRvcnMgdG8gdGhpcyBjb250cm9sLCB3aXRob3V0IGFmZmVjdGluZyBvdGhlclxuICAgICAqIHZhbGlkYXRvcnMuXG4gICAgICpcbiAgICAgKiBXaGVuIHlvdSBhZGQgb3IgcmVtb3ZlIGEgdmFsaWRhdG9yIGF0IHJ1biB0aW1lLCB5b3UgbXVzdCBjYWxsXG4gICAgICogYHVwZGF0ZVZhbHVlQW5kVmFsaWRpdHkoKWAgZm9yIHRoZSBuZXcgdmFsaWRhdGlvbiB0byB0YWtlIGVmZmVjdC5cbiAgICAgKlxuICAgICAqIEFkZGluZyBhIHZhbGlkYXRvciB0aGF0IGFscmVhZHkgZXhpc3RzIHdpbGwgaGF2ZSBubyBlZmZlY3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdmFsaWRhdG9ycyBUaGUgbmV3IGFzeW5jaHJvbm91cyB2YWxpZGF0b3IgZnVuY3Rpb24gb3IgZnVuY3Rpb25zIHRvIGFkZCB0byB0aGlzIGNvbnRyb2wuXG4gICAgICovXG4gICAgYWRkQXN5bmNWYWxpZGF0b3JzKHZhbGlkYXRvcnMpIHtcbiAgICAgICAgdGhpcy5zZXRBc3luY1ZhbGlkYXRvcnMoYWRkVmFsaWRhdG9ycyh2YWxpZGF0b3JzLCB0aGlzLl9yYXdBc3luY1ZhbGlkYXRvcnMpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVtb3ZlIGEgc3luY2hyb25vdXMgdmFsaWRhdG9yIGZyb20gdGhpcyBjb250cm9sLCB3aXRob3V0IGFmZmVjdGluZyBvdGhlciB2YWxpZGF0b3JzLlxuICAgICAqIFZhbGlkYXRvcnMgYXJlIGNvbXBhcmVkIGJ5IGZ1bmN0aW9uIHJlZmVyZW5jZTsgeW91IG11c3QgcGFzcyBhIHJlZmVyZW5jZSB0byB0aGUgZXhhY3Qgc2FtZVxuICAgICAqIHZhbGlkYXRvciBmdW5jdGlvbiBhcyB0aGUgb25lIHRoYXQgd2FzIG9yaWdpbmFsbHkgc2V0LiBJZiBhIHByb3ZpZGVkIHZhbGlkYXRvciBpcyBub3QgZm91bmQsXG4gICAgICogaXQgaXMgaWdub3JlZC5cbiAgICAgKlxuICAgICAqIEB1c2FnZU5vdGVzXG4gICAgICpcbiAgICAgKiAjIyMgUmVmZXJlbmNlIHRvIGEgVmFsaWRhdG9yRm5cbiAgICAgKlxuICAgICAqIGBgYFxuICAgICAqIC8vIFJlZmVyZW5jZSB0byB0aGUgUmVxdWlyZWRWYWxpZGF0b3JcbiAgICAgKiBjb25zdCBjdHJsID0gbmV3IEZvcm1Db250cm9sPHN0cmluZyB8IG51bGw+KCcnLCBWYWxpZGF0b3JzLnJlcXVpcmVkKTtcbiAgICAgKiBjdHJsLnJlbW92ZVZhbGlkYXRvcnMoVmFsaWRhdG9ycy5yZXF1aXJlZCk7XG4gICAgICpcbiAgICAgKiAvLyBSZWZlcmVuY2UgdG8gYW5vbnltb3VzIGZ1bmN0aW9uIGluc2lkZSBNaW5WYWxpZGF0b3JcbiAgICAgKiBjb25zdCBtaW5WYWxpZGF0b3IgPSBWYWxpZGF0b3JzLm1pbigzKTtcbiAgICAgKiBjb25zdCBjdHJsID0gbmV3IEZvcm1Db250cm9sPHN0cmluZyB8IG51bGw+KCcnLCBtaW5WYWxpZGF0b3IpO1xuICAgICAqIGV4cGVjdChjdHJsLmhhc1ZhbGlkYXRvcihtaW5WYWxpZGF0b3IpKS50b0VxdWFsKHRydWUpXG4gICAgICogZXhwZWN0KGN0cmwuaGFzVmFsaWRhdG9yKFZhbGlkYXRvcnMubWluKDMpKSkudG9FcXVhbChmYWxzZSlcbiAgICAgKlxuICAgICAqIGN0cmwucmVtb3ZlVmFsaWRhdG9ycyhtaW5WYWxpZGF0b3IpO1xuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogV2hlbiB5b3UgYWRkIG9yIHJlbW92ZSBhIHZhbGlkYXRvciBhdCBydW4gdGltZSwgeW91IG11c3QgY2FsbFxuICAgICAqIGB1cGRhdGVWYWx1ZUFuZFZhbGlkaXR5KClgIGZvciB0aGUgbmV3IHZhbGlkYXRpb24gdG8gdGFrZSBlZmZlY3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdmFsaWRhdG9ycyBUaGUgdmFsaWRhdG9yIG9yIHZhbGlkYXRvcnMgdG8gcmVtb3ZlLlxuICAgICAqL1xuICAgIHJlbW92ZVZhbGlkYXRvcnModmFsaWRhdG9ycykge1xuICAgICAgICB0aGlzLnNldFZhbGlkYXRvcnMocmVtb3ZlVmFsaWRhdG9ycyh2YWxpZGF0b3JzLCB0aGlzLl9yYXdWYWxpZGF0b3JzKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbW92ZSBhbiBhc3luY2hyb25vdXMgdmFsaWRhdG9yIGZyb20gdGhpcyBjb250cm9sLCB3aXRob3V0IGFmZmVjdGluZyBvdGhlciB2YWxpZGF0b3JzLlxuICAgICAqIFZhbGlkYXRvcnMgYXJlIGNvbXBhcmVkIGJ5IGZ1bmN0aW9uIHJlZmVyZW5jZTsgeW91IG11c3QgcGFzcyBhIHJlZmVyZW5jZSB0byB0aGUgZXhhY3Qgc2FtZVxuICAgICAqIHZhbGlkYXRvciBmdW5jdGlvbiBhcyB0aGUgb25lIHRoYXQgd2FzIG9yaWdpbmFsbHkgc2V0LiBJZiBhIHByb3ZpZGVkIHZhbGlkYXRvciBpcyBub3QgZm91bmQsIGl0XG4gICAgICogaXMgaWdub3JlZC5cbiAgICAgKlxuICAgICAqIFdoZW4geW91IGFkZCBvciByZW1vdmUgYSB2YWxpZGF0b3IgYXQgcnVuIHRpbWUsIHlvdSBtdXN0IGNhbGxcbiAgICAgKiBgdXBkYXRlVmFsdWVBbmRWYWxpZGl0eSgpYCBmb3IgdGhlIG5ldyB2YWxpZGF0aW9uIHRvIHRha2UgZWZmZWN0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHZhbGlkYXRvcnMgVGhlIGFzeW5jaHJvbm91cyB2YWxpZGF0b3Igb3IgdmFsaWRhdG9ycyB0byByZW1vdmUuXG4gICAgICovXG4gICAgcmVtb3ZlQXN5bmNWYWxpZGF0b3JzKHZhbGlkYXRvcnMpIHtcbiAgICAgICAgdGhpcy5zZXRBc3luY1ZhbGlkYXRvcnMocmVtb3ZlVmFsaWRhdG9ycyh2YWxpZGF0b3JzLCB0aGlzLl9yYXdBc3luY1ZhbGlkYXRvcnMpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hlY2sgd2hldGhlciBhIHN5bmNocm9ub3VzIHZhbGlkYXRvciBmdW5jdGlvbiBpcyBwcmVzZW50IG9uIHRoaXMgY29udHJvbC4gVGhlIHByb3ZpZGVkXG4gICAgICogdmFsaWRhdG9yIG11c3QgYmUgYSByZWZlcmVuY2UgdG8gdGhlIGV4YWN0IHNhbWUgZnVuY3Rpb24gdGhhdCB3YXMgcHJvdmlkZWQuXG4gICAgICpcbiAgICAgKiBAdXNhZ2VOb3Rlc1xuICAgICAqXG4gICAgICogIyMjIFJlZmVyZW5jZSB0byBhIFZhbGlkYXRvckZuXG4gICAgICpcbiAgICAgKiBgYGBcbiAgICAgKiAvLyBSZWZlcmVuY2UgdG8gdGhlIFJlcXVpcmVkVmFsaWRhdG9yXG4gICAgICogY29uc3QgY3RybCA9IG5ldyBGb3JtQ29udHJvbDxudW1iZXIgfCBudWxsPigwLCBWYWxpZGF0b3JzLnJlcXVpcmVkKTtcbiAgICAgKiBleHBlY3QoY3RybC5oYXNWYWxpZGF0b3IoVmFsaWRhdG9ycy5yZXF1aXJlZCkpLnRvRXF1YWwodHJ1ZSlcbiAgICAgKlxuICAgICAqIC8vIFJlZmVyZW5jZSB0byBhbm9ueW1vdXMgZnVuY3Rpb24gaW5zaWRlIE1pblZhbGlkYXRvclxuICAgICAqIGNvbnN0IG1pblZhbGlkYXRvciA9IFZhbGlkYXRvcnMubWluKDMpO1xuICAgICAqIGNvbnN0IGN0cmwgPSBuZXcgRm9ybUNvbnRyb2w8bnVtYmVyIHwgbnVsbD4oMCwgbWluVmFsaWRhdG9yKTtcbiAgICAgKiBleHBlY3QoY3RybC5oYXNWYWxpZGF0b3IobWluVmFsaWRhdG9yKSkudG9FcXVhbCh0cnVlKVxuICAgICAqIGV4cGVjdChjdHJsLmhhc1ZhbGlkYXRvcihWYWxpZGF0b3JzLm1pbigzKSkpLnRvRXF1YWwoZmFsc2UpXG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdmFsaWRhdG9yIFRoZSB2YWxpZGF0b3IgdG8gY2hlY2sgZm9yIHByZXNlbmNlLiBDb21wYXJlZCBieSBmdW5jdGlvbiByZWZlcmVuY2UuXG4gICAgICogQHJldHVybnMgV2hldGhlciB0aGUgcHJvdmlkZWQgdmFsaWRhdG9yIHdhcyBmb3VuZCBvbiB0aGlzIGNvbnRyb2wuXG4gICAgICovXG4gICAgaGFzVmFsaWRhdG9yKHZhbGlkYXRvcikge1xuICAgICAgICByZXR1cm4gaGFzVmFsaWRhdG9yKHRoaXMuX3Jhd1ZhbGlkYXRvcnMsIHZhbGlkYXRvcik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoZWNrIHdoZXRoZXIgYW4gYXN5bmNocm9ub3VzIHZhbGlkYXRvciBmdW5jdGlvbiBpcyBwcmVzZW50IG9uIHRoaXMgY29udHJvbC4gVGhlIHByb3ZpZGVkXG4gICAgICogdmFsaWRhdG9yIG11c3QgYmUgYSByZWZlcmVuY2UgdG8gdGhlIGV4YWN0IHNhbWUgZnVuY3Rpb24gdGhhdCB3YXMgcHJvdmlkZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdmFsaWRhdG9yIFRoZSBhc3luY2hyb25vdXMgdmFsaWRhdG9yIHRvIGNoZWNrIGZvciBwcmVzZW5jZS4gQ29tcGFyZWQgYnkgZnVuY3Rpb25cbiAgICAgKiAgICAgcmVmZXJlbmNlLlxuICAgICAqIEByZXR1cm5zIFdoZXRoZXIgdGhlIHByb3ZpZGVkIGFzeW5jaHJvbm91cyB2YWxpZGF0b3Igd2FzIGZvdW5kIG9uIHRoaXMgY29udHJvbC5cbiAgICAgKi9cbiAgICBoYXNBc3luY1ZhbGlkYXRvcih2YWxpZGF0b3IpIHtcbiAgICAgICAgcmV0dXJuIGhhc1ZhbGlkYXRvcih0aGlzLl9yYXdBc3luY1ZhbGlkYXRvcnMsIHZhbGlkYXRvcik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVtcHRpZXMgb3V0IHRoZSBzeW5jaHJvbm91cyB2YWxpZGF0b3IgbGlzdC5cbiAgICAgKlxuICAgICAqIFdoZW4geW91IGFkZCBvciByZW1vdmUgYSB2YWxpZGF0b3IgYXQgcnVuIHRpbWUsIHlvdSBtdXN0IGNhbGxcbiAgICAgKiBgdXBkYXRlVmFsdWVBbmRWYWxpZGl0eSgpYCBmb3IgdGhlIG5ldyB2YWxpZGF0aW9uIHRvIHRha2UgZWZmZWN0LlxuICAgICAqXG4gICAgICovXG4gICAgY2xlYXJWYWxpZGF0b3JzKCkge1xuICAgICAgICB0aGlzLnZhbGlkYXRvciA9IG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVtcHRpZXMgb3V0IHRoZSBhc3luYyB2YWxpZGF0b3IgbGlzdC5cbiAgICAgKlxuICAgICAqIFdoZW4geW91IGFkZCBvciByZW1vdmUgYSB2YWxpZGF0b3IgYXQgcnVuIHRpbWUsIHlvdSBtdXN0IGNhbGxcbiAgICAgKiBgdXBkYXRlVmFsdWVBbmRWYWxpZGl0eSgpYCBmb3IgdGhlIG5ldyB2YWxpZGF0aW9uIHRvIHRha2UgZWZmZWN0LlxuICAgICAqXG4gICAgICovXG4gICAgY2xlYXJBc3luY1ZhbGlkYXRvcnMoKSB7XG4gICAgICAgIHRoaXMuYXN5bmNWYWxpZGF0b3IgPSBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNYXJrcyB0aGUgY29udHJvbCBhcyBgdG91Y2hlZGAuIEEgY29udHJvbCBpcyB0b3VjaGVkIGJ5IGZvY3VzIGFuZFxuICAgICAqIGJsdXIgZXZlbnRzIHRoYXQgZG8gbm90IGNoYW5nZSB0aGUgdmFsdWUuXG4gICAgICpcbiAgICAgKiBAc2VlIHtAbGluayBtYXJrQXNVbnRvdWNoZWQoKX1cbiAgICAgKiBAc2VlIHtAbGluayBtYXJrQXNEaXJ0eSgpfVxuICAgICAqIEBzZWUge0BsaW5rIG1hcmtBc1ByaXN0aW5lKCl9XG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3B0cyBDb25maWd1cmF0aW9uIG9wdGlvbnMgdGhhdCBkZXRlcm1pbmUgaG93IHRoZSBjb250cm9sIHByb3BhZ2F0ZXMgY2hhbmdlc1xuICAgICAqIGFuZCBlbWl0cyBldmVudHMgYWZ0ZXIgbWFya2luZyBpcyBhcHBsaWVkLlxuICAgICAqICogYG9ubHlTZWxmYDogV2hlbiB0cnVlLCBtYXJrIG9ubHkgdGhpcyBjb250cm9sLiBXaGVuIGZhbHNlIG9yIG5vdCBzdXBwbGllZCxcbiAgICAgKiBtYXJrcyBhbGwgZGlyZWN0IGFuY2VzdG9ycy4gRGVmYXVsdCBpcyBmYWxzZS5cbiAgICAgKi9cbiAgICBtYXJrQXNUb3VjaGVkKG9wdHMgPSB7fSkge1xuICAgICAgICB0aGlzLnRvdWNoZWQgPSB0cnVlO1xuICAgICAgICBpZiAodGhpcy5fcGFyZW50ICYmICFvcHRzLm9ubHlTZWxmKSB7XG4gICAgICAgICAgICB0aGlzLl9wYXJlbnQubWFya0FzVG91Y2hlZChvcHRzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBNYXJrcyB0aGUgY29udHJvbCBhbmQgYWxsIGl0cyBkZXNjZW5kYW50IGNvbnRyb2xzIGFzIGB0b3VjaGVkYC5cbiAgICAgKiBAc2VlIHtAbGluayBtYXJrQXNUb3VjaGVkKCl9XG4gICAgICovXG4gICAgbWFya0FsbEFzVG91Y2hlZCgpIHtcbiAgICAgICAgdGhpcy5tYXJrQXNUb3VjaGVkKHsgb25seVNlbGY6IHRydWUgfSk7XG4gICAgICAgIHRoaXMuX2ZvckVhY2hDaGlsZCgoY29udHJvbCkgPT4gY29udHJvbC5tYXJrQWxsQXNUb3VjaGVkKCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNYXJrcyB0aGUgY29udHJvbCBhcyBgdW50b3VjaGVkYC5cbiAgICAgKlxuICAgICAqIElmIHRoZSBjb250cm9sIGhhcyBhbnkgY2hpbGRyZW4sIGFsc28gbWFya3MgYWxsIGNoaWxkcmVuIGFzIGB1bnRvdWNoZWRgXG4gICAgICogYW5kIHJlY2FsY3VsYXRlcyB0aGUgYHRvdWNoZWRgIHN0YXR1cyBvZiBhbGwgcGFyZW50IGNvbnRyb2xzLlxuICAgICAqXG4gICAgICogQHNlZSB7QGxpbmsgbWFya0FzVG91Y2hlZCgpfVxuICAgICAqIEBzZWUge0BsaW5rIG1hcmtBc0RpcnR5KCl9XG4gICAgICogQHNlZSB7QGxpbmsgbWFya0FzUHJpc3RpbmUoKX1cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRzIENvbmZpZ3VyYXRpb24gb3B0aW9ucyB0aGF0IGRldGVybWluZSBob3cgdGhlIGNvbnRyb2wgcHJvcGFnYXRlcyBjaGFuZ2VzXG4gICAgICogYW5kIGVtaXRzIGV2ZW50cyBhZnRlciB0aGUgbWFya2luZyBpcyBhcHBsaWVkLlxuICAgICAqICogYG9ubHlTZWxmYDogV2hlbiB0cnVlLCBtYXJrIG9ubHkgdGhpcyBjb250cm9sLiBXaGVuIGZhbHNlIG9yIG5vdCBzdXBwbGllZCxcbiAgICAgKiBtYXJrcyBhbGwgZGlyZWN0IGFuY2VzdG9ycy4gRGVmYXVsdCBpcyBmYWxzZS5cbiAgICAgKi9cbiAgICBtYXJrQXNVbnRvdWNoZWQob3B0cyA9IHt9KSB7XG4gICAgICAgIHRoaXMudG91Y2hlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9wZW5kaW5nVG91Y2hlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9mb3JFYWNoQ2hpbGQoKGNvbnRyb2wpID0+IHtcbiAgICAgICAgICAgIGNvbnRyb2wubWFya0FzVW50b3VjaGVkKHsgb25seVNlbGY6IHRydWUgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAodGhpcy5fcGFyZW50ICYmICFvcHRzLm9ubHlTZWxmKSB7XG4gICAgICAgICAgICB0aGlzLl9wYXJlbnQuX3VwZGF0ZVRvdWNoZWQob3B0cyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogTWFya3MgdGhlIGNvbnRyb2wgYXMgYGRpcnR5YC4gQSBjb250cm9sIGJlY29tZXMgZGlydHkgd2hlblxuICAgICAqIHRoZSBjb250cm9sJ3MgdmFsdWUgaXMgY2hhbmdlZCB0aHJvdWdoIHRoZSBVSTsgY29tcGFyZSBgbWFya0FzVG91Y2hlZGAuXG4gICAgICpcbiAgICAgKiBAc2VlIHtAbGluayBtYXJrQXNUb3VjaGVkKCl9XG4gICAgICogQHNlZSB7QGxpbmsgbWFya0FzVW50b3VjaGVkKCl9XG4gICAgICogQHNlZSB7QGxpbmsgbWFya0FzUHJpc3RpbmUoKX1cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRzIENvbmZpZ3VyYXRpb24gb3B0aW9ucyB0aGF0IGRldGVybWluZSBob3cgdGhlIGNvbnRyb2wgcHJvcGFnYXRlcyBjaGFuZ2VzXG4gICAgICogYW5kIGVtaXRzIGV2ZW50cyBhZnRlciBtYXJraW5nIGlzIGFwcGxpZWQuXG4gICAgICogKiBgb25seVNlbGZgOiBXaGVuIHRydWUsIG1hcmsgb25seSB0aGlzIGNvbnRyb2wuIFdoZW4gZmFsc2Ugb3Igbm90IHN1cHBsaWVkLFxuICAgICAqIG1hcmtzIGFsbCBkaXJlY3QgYW5jZXN0b3JzLiBEZWZhdWx0IGlzIGZhbHNlLlxuICAgICAqL1xuICAgIG1hcmtBc0RpcnR5KG9wdHMgPSB7fSkge1xuICAgICAgICB0aGlzLnByaXN0aW5lID0gZmFsc2U7XG4gICAgICAgIGlmICh0aGlzLl9wYXJlbnQgJiYgIW9wdHMub25seVNlbGYpIHtcbiAgICAgICAgICAgIHRoaXMuX3BhcmVudC5tYXJrQXNEaXJ0eShvcHRzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBNYXJrcyB0aGUgY29udHJvbCBhcyBgcHJpc3RpbmVgLlxuICAgICAqXG4gICAgICogSWYgdGhlIGNvbnRyb2wgaGFzIGFueSBjaGlsZHJlbiwgbWFya3MgYWxsIGNoaWxkcmVuIGFzIGBwcmlzdGluZWAsXG4gICAgICogYW5kIHJlY2FsY3VsYXRlcyB0aGUgYHByaXN0aW5lYCBzdGF0dXMgb2YgYWxsIHBhcmVudFxuICAgICAqIGNvbnRyb2xzLlxuICAgICAqXG4gICAgICogQHNlZSB7QGxpbmsgbWFya0FzVG91Y2hlZCgpfVxuICAgICAqIEBzZWUge0BsaW5rIG1hcmtBc1VudG91Y2hlZCgpfVxuICAgICAqIEBzZWUge0BsaW5rIG1hcmtBc0RpcnR5KCl9XG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3B0cyBDb25maWd1cmF0aW9uIG9wdGlvbnMgdGhhdCBkZXRlcm1pbmUgaG93IHRoZSBjb250cm9sIGVtaXRzIGV2ZW50cyBhZnRlclxuICAgICAqIG1hcmtpbmcgaXMgYXBwbGllZC5cbiAgICAgKiAqIGBvbmx5U2VsZmA6IFdoZW4gdHJ1ZSwgbWFyayBvbmx5IHRoaXMgY29udHJvbC4gV2hlbiBmYWxzZSBvciBub3Qgc3VwcGxpZWQsXG4gICAgICogbWFya3MgYWxsIGRpcmVjdCBhbmNlc3RvcnMuIERlZmF1bHQgaXMgZmFsc2UuXG4gICAgICovXG4gICAgbWFya0FzUHJpc3RpbmUob3B0cyA9IHt9KSB7XG4gICAgICAgIHRoaXMucHJpc3RpbmUgPSB0cnVlO1xuICAgICAgICB0aGlzLl9wZW5kaW5nRGlydHkgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fZm9yRWFjaENoaWxkKChjb250cm9sKSA9PiB7XG4gICAgICAgICAgICBjb250cm9sLm1hcmtBc1ByaXN0aW5lKHsgb25seVNlbGY6IHRydWUgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAodGhpcy5fcGFyZW50ICYmICFvcHRzLm9ubHlTZWxmKSB7XG4gICAgICAgICAgICB0aGlzLl9wYXJlbnQuX3VwZGF0ZVByaXN0aW5lKG9wdHMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1hcmtzIHRoZSBjb250cm9sIGFzIGBwZW5kaW5nYC5cbiAgICAgKlxuICAgICAqIEEgY29udHJvbCBpcyBwZW5kaW5nIHdoaWxlIHRoZSBjb250cm9sIHBlcmZvcm1zIGFzeW5jIHZhbGlkYXRpb24uXG4gICAgICpcbiAgICAgKiBAc2VlIHtAbGluayBBYnN0cmFjdENvbnRyb2wuc3RhdHVzfVxuICAgICAqXG4gICAgICogQHBhcmFtIG9wdHMgQ29uZmlndXJhdGlvbiBvcHRpb25zIHRoYXQgZGV0ZXJtaW5lIGhvdyB0aGUgY29udHJvbCBwcm9wYWdhdGVzIGNoYW5nZXMgYW5kXG4gICAgICogZW1pdHMgZXZlbnRzIGFmdGVyIG1hcmtpbmcgaXMgYXBwbGllZC5cbiAgICAgKiAqIGBvbmx5U2VsZmA6IFdoZW4gdHJ1ZSwgbWFyayBvbmx5IHRoaXMgY29udHJvbC4gV2hlbiBmYWxzZSBvciBub3Qgc3VwcGxpZWQsXG4gICAgICogbWFya3MgYWxsIGRpcmVjdCBhbmNlc3RvcnMuIERlZmF1bHQgaXMgZmFsc2UuXG4gICAgICogKiBgZW1pdEV2ZW50YDogV2hlbiB0cnVlIG9yIG5vdCBzdXBwbGllZCAodGhlIGRlZmF1bHQpLCB0aGUgYHN0YXR1c0NoYW5nZXNgXG4gICAgICogb2JzZXJ2YWJsZSBlbWl0cyBhbiBldmVudCB3aXRoIHRoZSBsYXRlc3Qgc3RhdHVzIHRoZSBjb250cm9sIGlzIG1hcmtlZCBwZW5kaW5nLlxuICAgICAqIFdoZW4gZmFsc2UsIG5vIGV2ZW50cyBhcmUgZW1pdHRlZC5cbiAgICAgKlxuICAgICAqL1xuICAgIG1hcmtBc1BlbmRpbmcob3B0cyA9IHt9KSB7XG4gICAgICAgIHRoaXMuc3RhdHVzID0gUEVORElORztcbiAgICAgICAgaWYgKG9wdHMuZW1pdEV2ZW50ICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgdGhpcy5zdGF0dXNDaGFuZ2VzLmVtaXQodGhpcy5zdGF0dXMpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9wYXJlbnQgJiYgIW9wdHMub25seVNlbGYpIHtcbiAgICAgICAgICAgIHRoaXMuX3BhcmVudC5tYXJrQXNQZW5kaW5nKG9wdHMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERpc2FibGVzIHRoZSBjb250cm9sLiBUaGlzIG1lYW5zIHRoZSBjb250cm9sIGlzIGV4ZW1wdCBmcm9tIHZhbGlkYXRpb24gY2hlY2tzIGFuZFxuICAgICAqIGV4Y2x1ZGVkIGZyb20gdGhlIGFnZ3JlZ2F0ZSB2YWx1ZSBvZiBhbnkgcGFyZW50LiBJdHMgc3RhdHVzIGlzIGBESVNBQkxFRGAuXG4gICAgICpcbiAgICAgKiBJZiB0aGUgY29udHJvbCBoYXMgY2hpbGRyZW4sIGFsbCBjaGlsZHJlbiBhcmUgYWxzbyBkaXNhYmxlZC5cbiAgICAgKlxuICAgICAqIEBzZWUge0BsaW5rIEFic3RyYWN0Q29udHJvbC5zdGF0dXN9XG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3B0cyBDb25maWd1cmF0aW9uIG9wdGlvbnMgdGhhdCBkZXRlcm1pbmUgaG93IHRoZSBjb250cm9sIHByb3BhZ2F0ZXNcbiAgICAgKiBjaGFuZ2VzIGFuZCBlbWl0cyBldmVudHMgYWZ0ZXIgdGhlIGNvbnRyb2wgaXMgZGlzYWJsZWQuXG4gICAgICogKiBgb25seVNlbGZgOiBXaGVuIHRydWUsIG1hcmsgb25seSB0aGlzIGNvbnRyb2wuIFdoZW4gZmFsc2Ugb3Igbm90IHN1cHBsaWVkLFxuICAgICAqIG1hcmtzIGFsbCBkaXJlY3QgYW5jZXN0b3JzLiBEZWZhdWx0IGlzIGZhbHNlLlxuICAgICAqICogYGVtaXRFdmVudGA6IFdoZW4gdHJ1ZSBvciBub3Qgc3VwcGxpZWQgKHRoZSBkZWZhdWx0KSwgYm90aCB0aGUgYHN0YXR1c0NoYW5nZXNgIGFuZFxuICAgICAqIGB2YWx1ZUNoYW5nZXNgXG4gICAgICogb2JzZXJ2YWJsZXMgZW1pdCBldmVudHMgd2l0aCB0aGUgbGF0ZXN0IHN0YXR1cyBhbmQgdmFsdWUgd2hlbiB0aGUgY29udHJvbCBpcyBkaXNhYmxlZC5cbiAgICAgKiBXaGVuIGZhbHNlLCBubyBldmVudHMgYXJlIGVtaXR0ZWQuXG4gICAgICovXG4gICAgZGlzYWJsZShvcHRzID0ge30pIHtcbiAgICAgICAgLy8gSWYgcGFyZW50IGhhcyBiZWVuIG1hcmtlZCBhcnRpZmljaWFsbHkgZGlydHkgd2UgZG9uJ3Qgd2FudCB0byByZS1jYWxjdWxhdGUgdGhlXG4gICAgICAgIC8vIHBhcmVudCdzIGRpcnRpbmVzcyBiYXNlZCBvbiB0aGUgY2hpbGRyZW4uXG4gICAgICAgIGNvbnN0IHNraXBQcmlzdGluZUNoZWNrID0gdGhpcy5fcGFyZW50TWFya2VkRGlydHkob3B0cy5vbmx5U2VsZik7XG4gICAgICAgIHRoaXMuc3RhdHVzID0gRElTQUJMRUQ7XG4gICAgICAgIHRoaXMuZXJyb3JzID0gbnVsbDtcbiAgICAgICAgdGhpcy5fZm9yRWFjaENoaWxkKChjb250cm9sKSA9PiB7XG4gICAgICAgICAgICBjb250cm9sLmRpc2FibGUoeyAuLi5vcHRzLCBvbmx5U2VsZjogdHJ1ZSB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX3VwZGF0ZVZhbHVlKCk7XG4gICAgICAgIGlmIChvcHRzLmVtaXRFdmVudCAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHRoaXMudmFsdWVDaGFuZ2VzLmVtaXQodGhpcy52YWx1ZSk7XG4gICAgICAgICAgICB0aGlzLnN0YXR1c0NoYW5nZXMuZW1pdCh0aGlzLnN0YXR1cyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fdXBkYXRlQW5jZXN0b3JzKHsgLi4ub3B0cywgc2tpcFByaXN0aW5lQ2hlY2sgfSk7XG4gICAgICAgIHRoaXMuX29uRGlzYWJsZWRDaGFuZ2UuZm9yRWFjaCgoY2hhbmdlRm4pID0+IGNoYW5nZUZuKHRydWUpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRW5hYmxlcyB0aGUgY29udHJvbC4gVGhpcyBtZWFucyB0aGUgY29udHJvbCBpcyBpbmNsdWRlZCBpbiB2YWxpZGF0aW9uIGNoZWNrcyBhbmRcbiAgICAgKiB0aGUgYWdncmVnYXRlIHZhbHVlIG9mIGl0cyBwYXJlbnQuIEl0cyBzdGF0dXMgcmVjYWxjdWxhdGVzIGJhc2VkIG9uIGl0cyB2YWx1ZSBhbmRcbiAgICAgKiBpdHMgdmFsaWRhdG9ycy5cbiAgICAgKlxuICAgICAqIEJ5IGRlZmF1bHQsIGlmIHRoZSBjb250cm9sIGhhcyBjaGlsZHJlbiwgYWxsIGNoaWxkcmVuIGFyZSBlbmFibGVkLlxuICAgICAqXG4gICAgICogQHNlZSB7QGxpbmsgQWJzdHJhY3RDb250cm9sLnN0YXR1c31cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRzIENvbmZpZ3VyZSBvcHRpb25zIHRoYXQgY29udHJvbCBob3cgdGhlIGNvbnRyb2wgcHJvcGFnYXRlcyBjaGFuZ2VzIGFuZFxuICAgICAqIGVtaXRzIGV2ZW50cyB3aGVuIG1hcmtlZCBhcyB1bnRvdWNoZWRcbiAgICAgKiAqIGBvbmx5U2VsZmA6IFdoZW4gdHJ1ZSwgbWFyayBvbmx5IHRoaXMgY29udHJvbC4gV2hlbiBmYWxzZSBvciBub3Qgc3VwcGxpZWQsXG4gICAgICogbWFya3MgYWxsIGRpcmVjdCBhbmNlc3RvcnMuIERlZmF1bHQgaXMgZmFsc2UuXG4gICAgICogKiBgZW1pdEV2ZW50YDogV2hlbiB0cnVlIG9yIG5vdCBzdXBwbGllZCAodGhlIGRlZmF1bHQpLCBib3RoIHRoZSBgc3RhdHVzQ2hhbmdlc2AgYW5kXG4gICAgICogYHZhbHVlQ2hhbmdlc2BcbiAgICAgKiBvYnNlcnZhYmxlcyBlbWl0IGV2ZW50cyB3aXRoIHRoZSBsYXRlc3Qgc3RhdHVzIGFuZCB2YWx1ZSB3aGVuIHRoZSBjb250cm9sIGlzIGVuYWJsZWQuXG4gICAgICogV2hlbiBmYWxzZSwgbm8gZXZlbnRzIGFyZSBlbWl0dGVkLlxuICAgICAqL1xuICAgIGVuYWJsZShvcHRzID0ge30pIHtcbiAgICAgICAgLy8gSWYgcGFyZW50IGhhcyBiZWVuIG1hcmtlZCBhcnRpZmljaWFsbHkgZGlydHkgd2UgZG9uJ3Qgd2FudCB0byByZS1jYWxjdWxhdGUgdGhlXG4gICAgICAgIC8vIHBhcmVudCdzIGRpcnRpbmVzcyBiYXNlZCBvbiB0aGUgY2hpbGRyZW4uXG4gICAgICAgIGNvbnN0IHNraXBQcmlzdGluZUNoZWNrID0gdGhpcy5fcGFyZW50TWFya2VkRGlydHkob3B0cy5vbmx5U2VsZik7XG4gICAgICAgIHRoaXMuc3RhdHVzID0gVkFMSUQ7XG4gICAgICAgIHRoaXMuX2ZvckVhY2hDaGlsZCgoY29udHJvbCkgPT4ge1xuICAgICAgICAgICAgY29udHJvbC5lbmFibGUoeyAuLi5vcHRzLCBvbmx5U2VsZjogdHJ1ZSB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMudXBkYXRlVmFsdWVBbmRWYWxpZGl0eSh7IG9ubHlTZWxmOiB0cnVlLCBlbWl0RXZlbnQ6IG9wdHMuZW1pdEV2ZW50IH0pO1xuICAgICAgICB0aGlzLl91cGRhdGVBbmNlc3RvcnMoeyAuLi5vcHRzLCBza2lwUHJpc3RpbmVDaGVjayB9KTtcbiAgICAgICAgdGhpcy5fb25EaXNhYmxlZENoYW5nZS5mb3JFYWNoKChjaGFuZ2VGbikgPT4gY2hhbmdlRm4oZmFsc2UpKTtcbiAgICB9XG4gICAgX3VwZGF0ZUFuY2VzdG9ycyhvcHRzKSB7XG4gICAgICAgIGlmICh0aGlzLl9wYXJlbnQgJiYgIW9wdHMub25seVNlbGYpIHtcbiAgICAgICAgICAgIHRoaXMuX3BhcmVudC51cGRhdGVWYWx1ZUFuZFZhbGlkaXR5KG9wdHMpO1xuICAgICAgICAgICAgaWYgKCFvcHRzLnNraXBQcmlzdGluZUNoZWNrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcGFyZW50Ll91cGRhdGVQcmlzdGluZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fcGFyZW50Ll91cGRhdGVUb3VjaGVkKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgcGFyZW50IG9mIHRoZSBjb250cm9sXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcGFyZW50IFRoZSBuZXcgcGFyZW50LlxuICAgICAqL1xuICAgIHNldFBhcmVudChwYXJlbnQpIHtcbiAgICAgICAgdGhpcy5fcGFyZW50ID0gcGFyZW50O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgcmF3IHZhbHVlIG9mIHRoaXMgY29udHJvbC4gRm9yIG1vc3QgY29udHJvbCBpbXBsZW1lbnRhdGlvbnMsIHRoZSByYXcgdmFsdWUgd2lsbCBpbmNsdWRlXG4gICAgICogZGlzYWJsZWQgY2hpbGRyZW4uXG4gICAgICovXG4gICAgZ2V0UmF3VmFsdWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZhbHVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWNhbGN1bGF0ZXMgdGhlIHZhbHVlIGFuZCB2YWxpZGF0aW9uIHN0YXR1cyBvZiB0aGUgY29udHJvbC5cbiAgICAgKlxuICAgICAqIEJ5IGRlZmF1bHQsIGl0IGFsc28gdXBkYXRlcyB0aGUgdmFsdWUgYW5kIHZhbGlkaXR5IG9mIGl0cyBhbmNlc3RvcnMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3B0cyBDb25maWd1cmF0aW9uIG9wdGlvbnMgZGV0ZXJtaW5lIGhvdyB0aGUgY29udHJvbCBwcm9wYWdhdGVzIGNoYW5nZXMgYW5kIGVtaXRzIGV2ZW50c1xuICAgICAqIGFmdGVyIHVwZGF0ZXMgYW5kIHZhbGlkaXR5IGNoZWNrcyBhcmUgYXBwbGllZC5cbiAgICAgKiAqIGBvbmx5U2VsZmA6IFdoZW4gdHJ1ZSwgb25seSB1cGRhdGUgdGhpcyBjb250cm9sLiBXaGVuIGZhbHNlIG9yIG5vdCBzdXBwbGllZCxcbiAgICAgKiB1cGRhdGUgYWxsIGRpcmVjdCBhbmNlc3RvcnMuIERlZmF1bHQgaXMgZmFsc2UuXG4gICAgICogKiBgZW1pdEV2ZW50YDogV2hlbiB0cnVlIG9yIG5vdCBzdXBwbGllZCAodGhlIGRlZmF1bHQpLCBib3RoIHRoZSBgc3RhdHVzQ2hhbmdlc2AgYW5kXG4gICAgICogYHZhbHVlQ2hhbmdlc2BcbiAgICAgKiBvYnNlcnZhYmxlcyBlbWl0IGV2ZW50cyB3aXRoIHRoZSBsYXRlc3Qgc3RhdHVzIGFuZCB2YWx1ZSB3aGVuIHRoZSBjb250cm9sIGlzIHVwZGF0ZWQuXG4gICAgICogV2hlbiBmYWxzZSwgbm8gZXZlbnRzIGFyZSBlbWl0dGVkLlxuICAgICAqL1xuICAgIHVwZGF0ZVZhbHVlQW5kVmFsaWRpdHkob3B0cyA9IHt9KSB7XG4gICAgICAgIHRoaXMuX3NldEluaXRpYWxTdGF0dXMoKTtcbiAgICAgICAgdGhpcy5fdXBkYXRlVmFsdWUoKTtcbiAgICAgICAgaWYgKHRoaXMuZW5hYmxlZCkge1xuICAgICAgICAgICAgdGhpcy5fY2FuY2VsRXhpc3RpbmdTdWJzY3JpcHRpb24oKTtcbiAgICAgICAgICAgIHRoaXMuZXJyb3JzID0gdGhpcy5fcnVuVmFsaWRhdG9yKCk7XG4gICAgICAgICAgICB0aGlzLnN0YXR1cyA9IHRoaXMuX2NhbGN1bGF0ZVN0YXR1cygpO1xuICAgICAgICAgICAgaWYgKHRoaXMuc3RhdHVzID09PSBWQUxJRCB8fCB0aGlzLnN0YXR1cyA9PT0gUEVORElORykge1xuICAgICAgICAgICAgICAgIHRoaXMuX3J1bkFzeW5jVmFsaWRhdG9yKG9wdHMuZW1pdEV2ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0cy5lbWl0RXZlbnQgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICB0aGlzLnZhbHVlQ2hhbmdlcy5lbWl0KHRoaXMudmFsdWUpO1xuICAgICAgICAgICAgdGhpcy5zdGF0dXNDaGFuZ2VzLmVtaXQodGhpcy5zdGF0dXMpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9wYXJlbnQgJiYgIW9wdHMub25seVNlbGYpIHtcbiAgICAgICAgICAgIHRoaXMuX3BhcmVudC51cGRhdGVWYWx1ZUFuZFZhbGlkaXR5KG9wdHMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBfdXBkYXRlVHJlZVZhbGlkaXR5KG9wdHMgPSB7IGVtaXRFdmVudDogdHJ1ZSB9KSB7XG4gICAgICAgIHRoaXMuX2ZvckVhY2hDaGlsZCgoY3RybCkgPT4gY3RybC5fdXBkYXRlVHJlZVZhbGlkaXR5KG9wdHMpKTtcbiAgICAgICAgdGhpcy51cGRhdGVWYWx1ZUFuZFZhbGlkaXR5KHsgb25seVNlbGY6IHRydWUsIGVtaXRFdmVudDogb3B0cy5lbWl0RXZlbnQgfSk7XG4gICAgfVxuICAgIF9zZXRJbml0aWFsU3RhdHVzKCkge1xuICAgICAgICB0aGlzLnN0YXR1cyA9IHRoaXMuX2FsbENvbnRyb2xzRGlzYWJsZWQoKSA/IERJU0FCTEVEIDogVkFMSUQ7XG4gICAgfVxuICAgIF9ydW5WYWxpZGF0b3IoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZhbGlkYXRvciA/IHRoaXMudmFsaWRhdG9yKHRoaXMpIDogbnVsbDtcbiAgICB9XG4gICAgX3J1bkFzeW5jVmFsaWRhdG9yKGVtaXRFdmVudCkge1xuICAgICAgICBpZiAodGhpcy5hc3luY1ZhbGlkYXRvcikge1xuICAgICAgICAgICAgdGhpcy5zdGF0dXMgPSBQRU5ESU5HO1xuICAgICAgICAgICAgdGhpcy5faGFzT3duUGVuZGluZ0FzeW5jVmFsaWRhdG9yID0gdHJ1ZTtcbiAgICAgICAgICAgIGNvbnN0IG9icyA9IHRvT2JzZXJ2YWJsZSh0aGlzLmFzeW5jVmFsaWRhdG9yKHRoaXMpKTtcbiAgICAgICAgICAgIHRoaXMuX2FzeW5jVmFsaWRhdGlvblN1YnNjcmlwdGlvbiA9IG9icy5zdWJzY3JpYmUoKGVycm9ycykgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuX2hhc093blBlbmRpbmdBc3luY1ZhbGlkYXRvciA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIC8vIFRoaXMgd2lsbCB0cmlnZ2VyIHRoZSByZWNhbGN1bGF0aW9uIG9mIHRoZSB2YWxpZGF0aW9uIHN0YXR1cywgd2hpY2ggZGVwZW5kcyBvblxuICAgICAgICAgICAgICAgIC8vIHRoZSBzdGF0ZSBvZiB0aGUgYXN5bmNocm9ub3VzIHZhbGlkYXRpb24gKHdoZXRoZXIgaXQgaXMgaW4gcHJvZ3Jlc3Mgb3Igbm90KS4gU28sIGl0IGlzXG4gICAgICAgICAgICAgICAgLy8gbmVjZXNzYXJ5IHRoYXQgd2UgaGF2ZSB1cGRhdGVkIHRoZSBgX2hhc093blBlbmRpbmdBc3luY1ZhbGlkYXRvcmAgYm9vbGVhbiBmbGFnIGZpcnN0LlxuICAgICAgICAgICAgICAgIHRoaXMuc2V0RXJyb3JzKGVycm9ycywgeyBlbWl0RXZlbnQgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfY2FuY2VsRXhpc3RpbmdTdWJzY3JpcHRpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLl9hc3luY1ZhbGlkYXRpb25TdWJzY3JpcHRpb24pIHtcbiAgICAgICAgICAgIHRoaXMuX2FzeW5jVmFsaWRhdGlvblN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgdGhpcy5faGFzT3duUGVuZGluZ0FzeW5jVmFsaWRhdG9yID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyBlcnJvcnMgb24gYSBmb3JtIGNvbnRyb2wgd2hlbiBydW5uaW5nIHZhbGlkYXRpb25zIG1hbnVhbGx5LCByYXRoZXIgdGhhbiBhdXRvbWF0aWNhbGx5LlxuICAgICAqXG4gICAgICogQ2FsbGluZyBgc2V0RXJyb3JzYCBhbHNvIHVwZGF0ZXMgdGhlIHZhbGlkaXR5IG9mIHRoZSBwYXJlbnQgY29udHJvbC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRzIENvbmZpZ3VyYXRpb24gb3B0aW9ucyB0aGF0IGRldGVybWluZSBob3cgdGhlIGNvbnRyb2wgcHJvcGFnYXRlc1xuICAgICAqIGNoYW5nZXMgYW5kIGVtaXRzIGV2ZW50cyBhZnRlciB0aGUgY29udHJvbCBlcnJvcnMgYXJlIHNldC5cbiAgICAgKiAqIGBlbWl0RXZlbnRgOiBXaGVuIHRydWUgb3Igbm90IHN1cHBsaWVkICh0aGUgZGVmYXVsdCksIHRoZSBgc3RhdHVzQ2hhbmdlc2BcbiAgICAgKiBvYnNlcnZhYmxlIGVtaXRzIGFuIGV2ZW50IGFmdGVyIHRoZSBlcnJvcnMgYXJlIHNldC5cbiAgICAgKlxuICAgICAqIEB1c2FnZU5vdGVzXG4gICAgICpcbiAgICAgKiAjIyMgTWFudWFsbHkgc2V0IHRoZSBlcnJvcnMgZm9yIGEgY29udHJvbFxuICAgICAqXG4gICAgICogYGBgXG4gICAgICogY29uc3QgbG9naW4gPSBuZXcgRm9ybUNvbnRyb2woJ3NvbWVMb2dpbicpO1xuICAgICAqIGxvZ2luLnNldEVycm9ycyh7XG4gICAgICogICBub3RVbmlxdWU6IHRydWVcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIGV4cGVjdChsb2dpbi52YWxpZCkudG9FcXVhbChmYWxzZSk7XG4gICAgICogZXhwZWN0KGxvZ2luLmVycm9ycykudG9FcXVhbCh7IG5vdFVuaXF1ZTogdHJ1ZSB9KTtcbiAgICAgKlxuICAgICAqIGxvZ2luLnNldFZhbHVlKCdzb21lT3RoZXJMb2dpbicpO1xuICAgICAqXG4gICAgICogZXhwZWN0KGxvZ2luLnZhbGlkKS50b0VxdWFsKHRydWUpO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIHNldEVycm9ycyhlcnJvcnMsIG9wdHMgPSB7fSkge1xuICAgICAgICB0aGlzLmVycm9ycyA9IGVycm9ycztcbiAgICAgICAgdGhpcy5fdXBkYXRlQ29udHJvbHNFcnJvcnMob3B0cy5lbWl0RXZlbnQgIT09IGZhbHNlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIGEgY2hpbGQgY29udHJvbCBnaXZlbiB0aGUgY29udHJvbCdzIG5hbWUgb3IgcGF0aC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBwYXRoIEEgZG90LWRlbGltaXRlZCBzdHJpbmcgb3IgYXJyYXkgb2Ygc3RyaW5nL251bWJlciB2YWx1ZXMgdGhhdCBkZWZpbmUgdGhlIHBhdGggdG8gdGhlXG4gICAgICogY29udHJvbC4gSWYgYSBzdHJpbmcgaXMgcHJvdmlkZWQsIHBhc3NpbmcgaXQgYXMgYSBzdHJpbmcgbGl0ZXJhbCB3aWxsIHJlc3VsdCBpbiBpbXByb3ZlZCB0eXBlXG4gICAgICogaW5mb3JtYXRpb24uIExpa2V3aXNlLCBpZiBhbiBhcnJheSBpcyBwcm92aWRlZCwgcGFzc2luZyBpdCBgYXMgY29uc3RgIHdpbGwgY2F1c2UgaW1wcm92ZWQgdHlwZVxuICAgICAqIGluZm9ybWF0aW9uIHRvIGJlIGF2YWlsYWJsZS5cbiAgICAgKlxuICAgICAqIEB1c2FnZU5vdGVzXG4gICAgICogIyMjIFJldHJpZXZlIGEgbmVzdGVkIGNvbnRyb2xcbiAgICAgKlxuICAgICAqIEZvciBleGFtcGxlLCB0byBnZXQgYSBgbmFtZWAgY29udHJvbCBuZXN0ZWQgd2l0aGluIGEgYHBlcnNvbmAgc3ViLWdyb3VwOlxuICAgICAqXG4gICAgICogKiBgdGhpcy5mb3JtLmdldCgncGVyc29uLm5hbWUnKTtgXG4gICAgICpcbiAgICAgKiAtT1ItXG4gICAgICpcbiAgICAgKiAqIGB0aGlzLmZvcm0uZ2V0KFsncGVyc29uJywgJ25hbWUnXSBhcyBjb25zdCk7YCAvLyBgYXMgY29uc3RgIGdpdmVzIGltcHJvdmVkIHR5cGluZ3NcbiAgICAgKlxuICAgICAqICMjIyBSZXRyaWV2ZSBhIGNvbnRyb2wgaW4gYSBGb3JtQXJyYXlcbiAgICAgKlxuICAgICAqIFdoZW4gYWNjZXNzaW5nIGFuIGVsZW1lbnQgaW5zaWRlIGEgRm9ybUFycmF5LCB5b3UgY2FuIHVzZSBhbiBlbGVtZW50IGluZGV4LlxuICAgICAqIEZvciBleGFtcGxlLCB0byBnZXQgYSBgcHJpY2VgIGNvbnRyb2wgZnJvbSB0aGUgZmlyc3QgZWxlbWVudCBpbiBhbiBgaXRlbXNgIGFycmF5IHlvdSBjYW4gdXNlOlxuICAgICAqXG4gICAgICogKiBgdGhpcy5mb3JtLmdldCgnaXRlbXMuMC5wcmljZScpO2BcbiAgICAgKlxuICAgICAqIC1PUi1cbiAgICAgKlxuICAgICAqICogYHRoaXMuZm9ybS5nZXQoWydpdGVtcycsIDAsICdwcmljZSddKTtgXG4gICAgICovXG4gICAgZ2V0KHBhdGgpIHtcbiAgICAgICAgbGV0IGN1cnJQYXRoID0gcGF0aDtcbiAgICAgICAgaWYgKGN1cnJQYXRoID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGN1cnJQYXRoKSlcbiAgICAgICAgICAgIGN1cnJQYXRoID0gY3VyclBhdGguc3BsaXQoJy4nKTtcbiAgICAgICAgaWYgKGN1cnJQYXRoLmxlbmd0aCA9PT0gMClcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICByZXR1cm4gY3VyclBhdGgucmVkdWNlKChjb250cm9sLCBuYW1lKSA9PiBjb250cm9sICYmIGNvbnRyb2wuX2ZpbmQobmFtZSksIHRoaXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKiBSZXBvcnRzIGVycm9yIGRhdGEgZm9yIHRoZSBjb250cm9sIHdpdGggdGhlIGdpdmVuIHBhdGguXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZXJyb3JDb2RlIFRoZSBjb2RlIG9mIHRoZSBlcnJvciB0byBjaGVja1xuICAgICAqIEBwYXJhbSBwYXRoIEEgbGlzdCBvZiBjb250cm9sIG5hbWVzIHRoYXQgZGVzaWduYXRlcyBob3cgdG8gbW92ZSBmcm9tIHRoZSBjdXJyZW50IGNvbnRyb2xcbiAgICAgKiB0byB0aGUgY29udHJvbCB0aGF0IHNob3VsZCBiZSBxdWVyaWVkIGZvciBlcnJvcnMuXG4gICAgICpcbiAgICAgKiBAdXNhZ2VOb3Rlc1xuICAgICAqIEZvciBleGFtcGxlLCBmb3IgdGhlIGZvbGxvd2luZyBgRm9ybUdyb3VwYDpcbiAgICAgKlxuICAgICAqIGBgYFxuICAgICAqIGZvcm0gPSBuZXcgRm9ybUdyb3VwKHtcbiAgICAgKiAgIGFkZHJlc3M6IG5ldyBGb3JtR3JvdXAoeyBzdHJlZXQ6IG5ldyBGb3JtQ29udHJvbCgpIH0pXG4gICAgICogfSk7XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBUaGUgcGF0aCB0byB0aGUgJ3N0cmVldCcgY29udHJvbCBmcm9tIHRoZSByb290IGZvcm0gd291bGQgYmUgJ2FkZHJlc3MnIC0+ICdzdHJlZXQnLlxuICAgICAqXG4gICAgICogSXQgY2FuIGJlIHByb3ZpZGVkIHRvIHRoaXMgbWV0aG9kIGluIG9uZSBvZiB0d28gZm9ybWF0czpcbiAgICAgKlxuICAgICAqIDEuIEFuIGFycmF5IG9mIHN0cmluZyBjb250cm9sIG5hbWVzLCBlLmcuIGBbJ2FkZHJlc3MnLCAnc3RyZWV0J11gXG4gICAgICogMS4gQSBwZXJpb2QtZGVsaW1pdGVkIGxpc3Qgb2YgY29udHJvbCBuYW1lcyBpbiBvbmUgc3RyaW5nLCBlLmcuIGAnYWRkcmVzcy5zdHJlZXQnYFxuICAgICAqXG4gICAgICogQHJldHVybnMgZXJyb3IgZGF0YSBmb3IgdGhhdCBwYXJ0aWN1bGFyIGVycm9yLiBJZiB0aGUgY29udHJvbCBvciBlcnJvciBpcyBub3QgcHJlc2VudCxcbiAgICAgKiBudWxsIGlzIHJldHVybmVkLlxuICAgICAqL1xuICAgIGdldEVycm9yKGVycm9yQ29kZSwgcGF0aCkge1xuICAgICAgICBjb25zdCBjb250cm9sID0gcGF0aCA/IHRoaXMuZ2V0KHBhdGgpIDogdGhpcztcbiAgICAgICAgcmV0dXJuIGNvbnRyb2wgJiYgY29udHJvbC5lcnJvcnMgPyBjb250cm9sLmVycm9yc1tlcnJvckNvZGVdIDogbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICogUmVwb3J0cyB3aGV0aGVyIHRoZSBjb250cm9sIHdpdGggdGhlIGdpdmVuIHBhdGggaGFzIHRoZSBlcnJvciBzcGVjaWZpZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZXJyb3JDb2RlIFRoZSBjb2RlIG9mIHRoZSBlcnJvciB0byBjaGVja1xuICAgICAqIEBwYXJhbSBwYXRoIEEgbGlzdCBvZiBjb250cm9sIG5hbWVzIHRoYXQgZGVzaWduYXRlcyBob3cgdG8gbW92ZSBmcm9tIHRoZSBjdXJyZW50IGNvbnRyb2xcbiAgICAgKiB0byB0aGUgY29udHJvbCB0aGF0IHNob3VsZCBiZSBxdWVyaWVkIGZvciBlcnJvcnMuXG4gICAgICpcbiAgICAgKiBAdXNhZ2VOb3Rlc1xuICAgICAqIEZvciBleGFtcGxlLCBmb3IgdGhlIGZvbGxvd2luZyBgRm9ybUdyb3VwYDpcbiAgICAgKlxuICAgICAqIGBgYFxuICAgICAqIGZvcm0gPSBuZXcgRm9ybUdyb3VwKHtcbiAgICAgKiAgIGFkZHJlc3M6IG5ldyBGb3JtR3JvdXAoeyBzdHJlZXQ6IG5ldyBGb3JtQ29udHJvbCgpIH0pXG4gICAgICogfSk7XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBUaGUgcGF0aCB0byB0aGUgJ3N0cmVldCcgY29udHJvbCBmcm9tIHRoZSByb290IGZvcm0gd291bGQgYmUgJ2FkZHJlc3MnIC0+ICdzdHJlZXQnLlxuICAgICAqXG4gICAgICogSXQgY2FuIGJlIHByb3ZpZGVkIHRvIHRoaXMgbWV0aG9kIGluIG9uZSBvZiB0d28gZm9ybWF0czpcbiAgICAgKlxuICAgICAqIDEuIEFuIGFycmF5IG9mIHN0cmluZyBjb250cm9sIG5hbWVzLCBlLmcuIGBbJ2FkZHJlc3MnLCAnc3RyZWV0J11gXG4gICAgICogMS4gQSBwZXJpb2QtZGVsaW1pdGVkIGxpc3Qgb2YgY29udHJvbCBuYW1lcyBpbiBvbmUgc3RyaW5nLCBlLmcuIGAnYWRkcmVzcy5zdHJlZXQnYFxuICAgICAqXG4gICAgICogSWYgbm8gcGF0aCBpcyBnaXZlbiwgdGhpcyBtZXRob2QgY2hlY2tzIGZvciB0aGUgZXJyb3Igb24gdGhlIGN1cnJlbnQgY29udHJvbC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHdoZXRoZXIgdGhlIGdpdmVuIGVycm9yIGlzIHByZXNlbnQgaW4gdGhlIGNvbnRyb2wgYXQgdGhlIGdpdmVuIHBhdGguXG4gICAgICpcbiAgICAgKiBJZiB0aGUgY29udHJvbCBpcyBub3QgcHJlc2VudCwgZmFsc2UgaXMgcmV0dXJuZWQuXG4gICAgICovXG4gICAgaGFzRXJyb3IoZXJyb3JDb2RlLCBwYXRoKSB7XG4gICAgICAgIHJldHVybiAhIXRoaXMuZ2V0RXJyb3IoZXJyb3JDb2RlLCBwYXRoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIHRoZSB0b3AtbGV2ZWwgYW5jZXN0b3Igb2YgdGhpcyBjb250cm9sLlxuICAgICAqL1xuICAgIGdldCByb290KCkge1xuICAgICAgICBsZXQgeCA9IHRoaXM7XG4gICAgICAgIHdoaWxlICh4Ll9wYXJlbnQpIHtcbiAgICAgICAgICAgIHggPSB4Ll9wYXJlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHg7XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBfdXBkYXRlQ29udHJvbHNFcnJvcnMoZW1pdEV2ZW50KSB7XG4gICAgICAgIHRoaXMuc3RhdHVzID0gdGhpcy5fY2FsY3VsYXRlU3RhdHVzKCk7XG4gICAgICAgIGlmIChlbWl0RXZlbnQpIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdHVzQ2hhbmdlcy5lbWl0KHRoaXMuc3RhdHVzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fcGFyZW50KSB7XG4gICAgICAgICAgICB0aGlzLl9wYXJlbnQuX3VwZGF0ZUNvbnRyb2xzRXJyb3JzKGVtaXRFdmVudCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIF9pbml0T2JzZXJ2YWJsZXMoKSB7XG4gICAgICAgIHRoaXMudmFsdWVDaGFuZ2VzID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICB0aGlzLnN0YXR1c0NoYW5nZXMgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgfVxuICAgIF9jYWxjdWxhdGVTdGF0dXMoKSB7XG4gICAgICAgIGlmICh0aGlzLl9hbGxDb250cm9sc0Rpc2FibGVkKCkpXG4gICAgICAgICAgICByZXR1cm4gRElTQUJMRUQ7XG4gICAgICAgIGlmICh0aGlzLmVycm9ycylcbiAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICBpZiAodGhpcy5faGFzT3duUGVuZGluZ0FzeW5jVmFsaWRhdG9yIHx8IHRoaXMuX2FueUNvbnRyb2xzSGF2ZVN0YXR1cyhQRU5ESU5HKSlcbiAgICAgICAgICAgIHJldHVybiBQRU5ESU5HO1xuICAgICAgICBpZiAodGhpcy5fYW55Q29udHJvbHNIYXZlU3RhdHVzKElOVkFMSUQpKVxuICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgIHJldHVybiBWQUxJRDtcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIF9hbnlDb250cm9sc0hhdmVTdGF0dXMoc3RhdHVzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hbnlDb250cm9scygoY29udHJvbCkgPT4gY29udHJvbC5zdGF0dXMgPT09IHN0YXR1cyk7XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBfYW55Q29udHJvbHNEaXJ0eSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FueUNvbnRyb2xzKChjb250cm9sKSA9PiBjb250cm9sLmRpcnR5KTtcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIF9hbnlDb250cm9sc1RvdWNoZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hbnlDb250cm9scygoY29udHJvbCkgPT4gY29udHJvbC50b3VjaGVkKTtcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIF91cGRhdGVQcmlzdGluZShvcHRzID0ge30pIHtcbiAgICAgICAgdGhpcy5wcmlzdGluZSA9ICF0aGlzLl9hbnlDb250cm9sc0RpcnR5KCk7XG4gICAgICAgIGlmICh0aGlzLl9wYXJlbnQgJiYgIW9wdHMub25seVNlbGYpIHtcbiAgICAgICAgICAgIHRoaXMuX3BhcmVudC5fdXBkYXRlUHJpc3RpbmUob3B0cyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIF91cGRhdGVUb3VjaGVkKG9wdHMgPSB7fSkge1xuICAgICAgICB0aGlzLnRvdWNoZWQgPSB0aGlzLl9hbnlDb250cm9sc1RvdWNoZWQoKTtcbiAgICAgICAgaWYgKHRoaXMuX3BhcmVudCAmJiAhb3B0cy5vbmx5U2VsZikge1xuICAgICAgICAgICAgdGhpcy5fcGFyZW50Ll91cGRhdGVUb3VjaGVkKG9wdHMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBfcmVnaXN0ZXJPbkNvbGxlY3Rpb25DaGFuZ2UoZm4pIHtcbiAgICAgICAgdGhpcy5fb25Db2xsZWN0aW9uQ2hhbmdlID0gZm47XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBfc2V0VXBkYXRlU3RyYXRlZ3kob3B0cykge1xuICAgICAgICBpZiAoaXNPcHRpb25zT2JqKG9wdHMpICYmIG9wdHMudXBkYXRlT24gIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5fdXBkYXRlT24gPSBvcHRzLnVwZGF0ZU9uO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoZWNrIHRvIHNlZSBpZiBwYXJlbnQgaGFzIGJlZW4gbWFya2VkIGFydGlmaWNpYWxseSBkaXJ0eS5cbiAgICAgKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIF9wYXJlbnRNYXJrZWREaXJ0eShvbmx5U2VsZikge1xuICAgICAgICBjb25zdCBwYXJlbnREaXJ0eSA9IHRoaXMuX3BhcmVudCAmJiB0aGlzLl9wYXJlbnQuZGlydHk7XG4gICAgICAgIHJldHVybiAhb25seVNlbGYgJiYgISFwYXJlbnREaXJ0eSAmJiAhdGhpcy5fcGFyZW50Ll9hbnlDb250cm9sc0RpcnR5KCk7XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBfZmluZChuYW1lKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbnRlcm5hbCBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgYHNldFZhbGlkYXRvcnNgIG1ldGhvZC4gTmVlZHMgdG8gYmUgc2VwYXJhdGVkIG91dCBpbnRvIGFcbiAgICAgKiBkaWZmZXJlbnQgbWV0aG9kLCBiZWNhdXNlIGl0IGlzIGNhbGxlZCBpbiB0aGUgY29uc3RydWN0b3IgYW5kIGl0IGNhbiBicmVhayBjYXNlcyB3aGVyZVxuICAgICAqIGEgY29udHJvbCBpcyBleHRlbmRlZC5cbiAgICAgKi9cbiAgICBfYXNzaWduVmFsaWRhdG9ycyh2YWxpZGF0b3JzKSB7XG4gICAgICAgIHRoaXMuX3Jhd1ZhbGlkYXRvcnMgPSBBcnJheS5pc0FycmF5KHZhbGlkYXRvcnMpID8gdmFsaWRhdG9ycy5zbGljZSgpIDogdmFsaWRhdG9ycztcbiAgICAgICAgdGhpcy5fY29tcG9zZWRWYWxpZGF0b3JGbiA9IGNvZXJjZVRvVmFsaWRhdG9yKHRoaXMuX3Jhd1ZhbGlkYXRvcnMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbnRlcm5hbCBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgYHNldEFzeW5jVmFsaWRhdG9yc2AgbWV0aG9kLiBOZWVkcyB0byBiZSBzZXBhcmF0ZWQgb3V0IGludG8gYVxuICAgICAqIGRpZmZlcmVudCBtZXRob2QsIGJlY2F1c2UgaXQgaXMgY2FsbGVkIGluIHRoZSBjb25zdHJ1Y3RvciBhbmQgaXQgY2FuIGJyZWFrIGNhc2VzIHdoZXJlXG4gICAgICogYSBjb250cm9sIGlzIGV4dGVuZGVkLlxuICAgICAqL1xuICAgIF9hc3NpZ25Bc3luY1ZhbGlkYXRvcnModmFsaWRhdG9ycykge1xuICAgICAgICB0aGlzLl9yYXdBc3luY1ZhbGlkYXRvcnMgPSBBcnJheS5pc0FycmF5KHZhbGlkYXRvcnMpID8gdmFsaWRhdG9ycy5zbGljZSgpIDogdmFsaWRhdG9ycztcbiAgICAgICAgdGhpcy5fY29tcG9zZWRBc3luY1ZhbGlkYXRvckZuID0gY29lcmNlVG9Bc3luY1ZhbGlkYXRvcih0aGlzLl9yYXdBc3luY1ZhbGlkYXRvcnMpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBUcmFja3MgdGhlIHZhbHVlIGFuZCB2YWxpZGl0eSBzdGF0ZSBvZiBhIGdyb3VwIG9mIGBGb3JtQ29udHJvbGAgaW5zdGFuY2VzLlxuICpcbiAqIEEgYEZvcm1Hcm91cGAgYWdncmVnYXRlcyB0aGUgdmFsdWVzIG9mIGVhY2ggY2hpbGQgYEZvcm1Db250cm9sYCBpbnRvIG9uZSBvYmplY3QsXG4gKiB3aXRoIGVhY2ggY29udHJvbCBuYW1lIGFzIHRoZSBrZXkuICBJdCBjYWxjdWxhdGVzIGl0cyBzdGF0dXMgYnkgcmVkdWNpbmcgdGhlIHN0YXR1cyB2YWx1ZXNcbiAqIG9mIGl0cyBjaGlsZHJlbi4gRm9yIGV4YW1wbGUsIGlmIG9uZSBvZiB0aGUgY29udHJvbHMgaW4gYSBncm91cCBpcyBpbnZhbGlkLCB0aGUgZW50aXJlXG4gKiBncm91cCBiZWNvbWVzIGludmFsaWQuXG4gKlxuICogYEZvcm1Hcm91cGAgaXMgb25lIG9mIHRoZSBmb3VyIGZ1bmRhbWVudGFsIGJ1aWxkaW5nIGJsb2NrcyB1c2VkIHRvIGRlZmluZSBmb3JtcyBpbiBBbmd1bGFyLFxuICogYWxvbmcgd2l0aCBgRm9ybUNvbnRyb2xgLCBgRm9ybUFycmF5YCwgYW5kIGBGb3JtUmVjb3JkYC5cbiAqXG4gKiBXaGVuIGluc3RhbnRpYXRpbmcgYSBgRm9ybUdyb3VwYCwgcGFzcyBpbiBhIGNvbGxlY3Rpb24gb2YgY2hpbGQgY29udHJvbHMgYXMgdGhlIGZpcnN0XG4gKiBhcmd1bWVudC4gVGhlIGtleSBmb3IgZWFjaCBjaGlsZCByZWdpc3RlcnMgdGhlIG5hbWUgZm9yIHRoZSBjb250cm9sLlxuICpcbiAqIGBGb3JtR3JvdXBgIGlzIGludGVuZGVkIGZvciB1c2UgY2FzZXMgd2hlcmUgdGhlIGtleXMgYXJlIGtub3duIGFoZWFkIG9mIHRpbWUuXG4gKiBJZiB5b3UgbmVlZCB0byBkeW5hbWljYWxseSBhZGQgYW5kIHJlbW92ZSBjb250cm9scywgdXNlIHtAbGluayBGb3JtUmVjb3JkfSBpbnN0ZWFkLlxuICpcbiAqIGBGb3JtR3JvdXBgIGFjY2VwdHMgYW4gb3B0aW9uYWwgdHlwZSBwYXJhbWV0ZXIgYFRDb250cm9sYCwgd2hpY2ggaXMgYW4gb2JqZWN0IHR5cGUgd2l0aCBpbm5lclxuICogY29udHJvbCB0eXBlcyBhcyB2YWx1ZXMuXG4gKlxuICogQHVzYWdlTm90ZXNcbiAqXG4gKiAjIyMgQ3JlYXRlIGEgZm9ybSBncm91cCB3aXRoIDIgY29udHJvbHNcbiAqXG4gKiBgYGBcbiAqIGNvbnN0IGZvcm0gPSBuZXcgRm9ybUdyb3VwKHtcbiAqICAgZmlyc3Q6IG5ldyBGb3JtQ29udHJvbCgnTmFuY3knLCBWYWxpZGF0b3JzLm1pbkxlbmd0aCgyKSksXG4gKiAgIGxhc3Q6IG5ldyBGb3JtQ29udHJvbCgnRHJldycpLFxuICogfSk7XG4gKlxuICogY29uc29sZS5sb2coZm9ybS52YWx1ZSk7ICAgLy8ge2ZpcnN0OiAnTmFuY3knLCBsYXN0OyAnRHJldyd9XG4gKiBjb25zb2xlLmxvZyhmb3JtLnN0YXR1cyk7ICAvLyAnVkFMSUQnXG4gKiBgYGBcbiAqXG4gKiAjIyMgVGhlIHR5cGUgYXJndW1lbnQsIGFuZCBvcHRpb25hbCBjb250cm9sc1xuICpcbiAqIGBGb3JtR3JvdXBgIGFjY2VwdHMgb25lIGdlbmVyaWMgYXJndW1lbnQsIHdoaWNoIGlzIGFuIG9iamVjdCBjb250YWluaW5nIGl0cyBpbm5lciBjb250cm9scy5cbiAqIFRoaXMgdHlwZSB3aWxsIHVzdWFsbHkgYmUgaW5mZXJyZWQgYXV0b21hdGljYWxseSwgYnV0IHlvdSBjYW4gYWx3YXlzIHNwZWNpZnkgaXQgZXhwbGljaXRseSBpZiB5b3VcbiAqIHdpc2guXG4gKlxuICogSWYgeW91IGhhdmUgY29udHJvbHMgdGhhdCBhcmUgb3B0aW9uYWwgKGkuZS4gdGhleSBjYW4gYmUgcmVtb3ZlZCwgeW91IGNhbiB1c2UgdGhlIGA/YCBpbiB0aGVcbiAqIHR5cGUpOlxuICpcbiAqIGBgYFxuICogY29uc3QgZm9ybSA9IG5ldyBGb3JtR3JvdXA8e1xuICogICBmaXJzdDogRm9ybUNvbnRyb2w8c3RyaW5nfG51bGw+LFxuICogICBtaWRkbGU/OiBGb3JtQ29udHJvbDxzdHJpbmd8bnVsbD4sIC8vIE1pZGRsZSBuYW1lIGlzIG9wdGlvbmFsLlxuICogICBsYXN0OiBGb3JtQ29udHJvbDxzdHJpbmd8bnVsbD4sXG4gKiB9Pih7XG4gKiAgIGZpcnN0OiBuZXcgRm9ybUNvbnRyb2woJ05hbmN5JyksXG4gKiAgIGxhc3Q6IG5ldyBGb3JtQ29udHJvbCgnRHJldycpLFxuICogfSk7XG4gKiBgYGBcbiAqXG4gKiAjIyMgQ3JlYXRlIGEgZm9ybSBncm91cCB3aXRoIGEgZ3JvdXAtbGV2ZWwgdmFsaWRhdG9yXG4gKlxuICogWW91IGluY2x1ZGUgZ3JvdXAtbGV2ZWwgdmFsaWRhdG9ycyBhcyB0aGUgc2Vjb25kIGFyZywgb3IgZ3JvdXAtbGV2ZWwgYXN5bmNcbiAqIHZhbGlkYXRvcnMgYXMgdGhlIHRoaXJkIGFyZy4gVGhlc2UgY29tZSBpbiBoYW5keSB3aGVuIHlvdSB3YW50IHRvIHBlcmZvcm0gdmFsaWRhdGlvblxuICogdGhhdCBjb25zaWRlcnMgdGhlIHZhbHVlIG9mIG1vcmUgdGhhbiBvbmUgY2hpbGQgY29udHJvbC5cbiAqXG4gKiBgYGBcbiAqIGNvbnN0IGZvcm0gPSBuZXcgRm9ybUdyb3VwKHtcbiAqICAgcGFzc3dvcmQ6IG5ldyBGb3JtQ29udHJvbCgnJywgVmFsaWRhdG9ycy5taW5MZW5ndGgoMikpLFxuICogICBwYXNzd29yZENvbmZpcm06IG5ldyBGb3JtQ29udHJvbCgnJywgVmFsaWRhdG9ycy5taW5MZW5ndGgoMikpLFxuICogfSwgcGFzc3dvcmRNYXRjaFZhbGlkYXRvcik7XG4gKlxuICpcbiAqIGZ1bmN0aW9uIHBhc3N3b3JkTWF0Y2hWYWxpZGF0b3IoZzogRm9ybUdyb3VwKSB7XG4gKiAgICByZXR1cm4gZy5nZXQoJ3Bhc3N3b3JkJykudmFsdWUgPT09IGcuZ2V0KCdwYXNzd29yZENvbmZpcm0nKS52YWx1ZVxuICogICAgICAgPyBudWxsIDogeydtaXNtYXRjaCc6IHRydWV9O1xuICogfVxuICogYGBgXG4gKlxuICogTGlrZSBgRm9ybUNvbnRyb2xgIGluc3RhbmNlcywgeW91IGNob29zZSB0byBwYXNzIGluXG4gKiB2YWxpZGF0b3JzIGFuZCBhc3luYyB2YWxpZGF0b3JzIGFzIHBhcnQgb2YgYW4gb3B0aW9ucyBvYmplY3QuXG4gKlxuICogYGBgXG4gKiBjb25zdCBmb3JtID0gbmV3IEZvcm1Hcm91cCh7XG4gKiAgIHBhc3N3b3JkOiBuZXcgRm9ybUNvbnRyb2woJycpXG4gKiAgIHBhc3N3b3JkQ29uZmlybTogbmV3IEZvcm1Db250cm9sKCcnKVxuICogfSwgeyB2YWxpZGF0b3JzOiBwYXNzd29yZE1hdGNoVmFsaWRhdG9yLCBhc3luY1ZhbGlkYXRvcnM6IG90aGVyVmFsaWRhdG9yIH0pO1xuICogYGBgXG4gKlxuICogIyMjIFNldCB0aGUgdXBkYXRlT24gcHJvcGVydHkgZm9yIGFsbCBjb250cm9scyBpbiBhIGZvcm0gZ3JvdXBcbiAqXG4gKiBUaGUgb3B0aW9ucyBvYmplY3QgaXMgdXNlZCB0byBzZXQgYSBkZWZhdWx0IHZhbHVlIGZvciBlYWNoIGNoaWxkXG4gKiBjb250cm9sJ3MgYHVwZGF0ZU9uYCBwcm9wZXJ0eS4gSWYgeW91IHNldCBgdXBkYXRlT25gIHRvIGAnYmx1cidgIGF0IHRoZVxuICogZ3JvdXAgbGV2ZWwsIGFsbCBjaGlsZCBjb250cm9scyBkZWZhdWx0IHRvICdibHVyJywgdW5sZXNzIHRoZSBjaGlsZFxuICogaGFzIGV4cGxpY2l0bHkgc3BlY2lmaWVkIGEgZGlmZmVyZW50IGB1cGRhdGVPbmAgdmFsdWUuXG4gKlxuICogYGBgdHNcbiAqIGNvbnN0IGMgPSBuZXcgRm9ybUdyb3VwKHtcbiAqICAgb25lOiBuZXcgRm9ybUNvbnRyb2woKVxuICogfSwgeyB1cGRhdGVPbjogJ2JsdXInIH0pO1xuICogYGBgXG4gKlxuICogIyMjIFVzaW5nIGEgRm9ybUdyb3VwIHdpdGggb3B0aW9uYWwgY29udHJvbHNcbiAqXG4gKiBJdCBpcyBwb3NzaWJsZSB0byBoYXZlIG9wdGlvbmFsIGNvbnRyb2xzIGluIGEgRm9ybUdyb3VwLiBBbiBvcHRpb25hbCBjb250cm9sIGNhbiBiZSByZW1vdmVkIGxhdGVyXG4gKiB1c2luZyBgcmVtb3ZlQ29udHJvbGAsIGFuZCBjYW4gYmUgb21pdHRlZCB3aGVuIGNhbGxpbmcgYHJlc2V0YC4gT3B0aW9uYWwgY29udHJvbHMgbXVzdCBiZVxuICogZGVjbGFyZWQgb3B0aW9uYWwgaW4gdGhlIGdyb3VwJ3MgdHlwZS5cbiAqXG4gKiBgYGB0c1xuICogY29uc3QgYyA9IG5ldyBGb3JtR3JvdXA8e29uZT86IEZvcm1Db250cm9sPHN0cmluZz59Pih7XG4gKiAgIG9uZTogbmV3IEZvcm1Db250cm9sKCcnKVxuICogfSk7XG4gKiBgYGBcbiAqXG4gKiBOb3RpY2UgdGhhdCBgYy52YWx1ZS5vbmVgIGhhcyB0eXBlIGBzdHJpbmd8bnVsbHx1bmRlZmluZWRgLiBUaGlzIGlzIGJlY2F1c2UgY2FsbGluZyBgYy5yZXNldCh7fSlgXG4gKiB3aXRob3V0IHByb3ZpZGluZyB0aGUgb3B0aW9uYWwga2V5IGBvbmVgIHdpbGwgY2F1c2UgaXQgdG8gYmVjb21lIGBudWxsYC5cbiAqXG4gKiBAcHVibGljQXBpXG4gKi9cbmNsYXNzIEZvcm1Hcm91cCBleHRlbmRzIEFic3RyYWN0Q29udHJvbCB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBgRm9ybUdyb3VwYCBpbnN0YW5jZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBjb250cm9scyBBIGNvbGxlY3Rpb24gb2YgY2hpbGQgY29udHJvbHMuIFRoZSBrZXkgZm9yIGVhY2ggY2hpbGQgaXMgdGhlIG5hbWVcbiAgICAgKiB1bmRlciB3aGljaCBpdCBpcyByZWdpc3RlcmVkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHZhbGlkYXRvck9yT3B0cyBBIHN5bmNocm9ub3VzIHZhbGlkYXRvciBmdW5jdGlvbiwgb3IgYW4gYXJyYXkgb2ZcbiAgICAgKiBzdWNoIGZ1bmN0aW9ucywgb3IgYW4gYEFic3RyYWN0Q29udHJvbE9wdGlvbnNgIG9iamVjdCB0aGF0IGNvbnRhaW5zIHZhbGlkYXRpb24gZnVuY3Rpb25zXG4gICAgICogYW5kIGEgdmFsaWRhdGlvbiB0cmlnZ2VyLlxuICAgICAqXG4gICAgICogQHBhcmFtIGFzeW5jVmFsaWRhdG9yIEEgc2luZ2xlIGFzeW5jIHZhbGlkYXRvciBvciBhcnJheSBvZiBhc3luYyB2YWxpZGF0b3IgZnVuY3Rpb25zXG4gICAgICpcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihjb250cm9scywgdmFsaWRhdG9yT3JPcHRzLCBhc3luY1ZhbGlkYXRvcikge1xuICAgICAgICBzdXBlcihwaWNrVmFsaWRhdG9ycyh2YWxpZGF0b3JPck9wdHMpLCBwaWNrQXN5bmNWYWxpZGF0b3JzKGFzeW5jVmFsaWRhdG9yLCB2YWxpZGF0b3JPck9wdHMpKTtcbiAgICAgICAgKHR5cGVvZiBuZ0Rldk1vZGUgPT09ICd1bmRlZmluZWQnIHx8IG5nRGV2TW9kZSkgJiYgdmFsaWRhdGVGb3JtR3JvdXBDb250cm9scyhjb250cm9scyk7XG4gICAgICAgIHRoaXMuY29udHJvbHMgPSBjb250cm9scztcbiAgICAgICAgdGhpcy5faW5pdE9ic2VydmFibGVzKCk7XG4gICAgICAgIHRoaXMuX3NldFVwZGF0ZVN0cmF0ZWd5KHZhbGlkYXRvck9yT3B0cyk7XG4gICAgICAgIHRoaXMuX3NldFVwQ29udHJvbHMoKTtcbiAgICAgICAgdGhpcy51cGRhdGVWYWx1ZUFuZFZhbGlkaXR5KHtcbiAgICAgICAgICAgIG9ubHlTZWxmOiB0cnVlLFxuICAgICAgICAgICAgLy8gSWYgYGFzeW5jVmFsaWRhdG9yYCBpcyBwcmVzZW50LCBpdCB3aWxsIHRyaWdnZXIgY29udHJvbCBzdGF0dXMgY2hhbmdlIGZyb20gYFBFTkRJTkdgIHRvXG4gICAgICAgICAgICAvLyBgVkFMSURgIG9yIGBJTlZBTElEYC4gVGhlIHN0YXR1cyBzaG91bGQgYmUgYnJvYWRjYXN0ZWQgdmlhIHRoZSBgc3RhdHVzQ2hhbmdlc2Agb2JzZXJ2YWJsZSxcbiAgICAgICAgICAgIC8vIHNvIHdlIHNldCBgZW1pdEV2ZW50YCB0byBgdHJ1ZWAgdG8gYWxsb3cgdGhhdCBkdXJpbmcgdGhlIGNvbnRyb2wgY3JlYXRpb24gcHJvY2Vzcy5cbiAgICAgICAgICAgIGVtaXRFdmVudDogISF0aGlzLmFzeW5jVmFsaWRhdG9yXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZWdpc3RlckNvbnRyb2wobmFtZSwgY29udHJvbCkge1xuICAgICAgICBpZiAodGhpcy5jb250cm9sc1tuYW1lXSlcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbnRyb2xzW25hbWVdO1xuICAgICAgICB0aGlzLmNvbnRyb2xzW25hbWVdID0gY29udHJvbDtcbiAgICAgICAgY29udHJvbC5zZXRQYXJlbnQodGhpcyk7XG4gICAgICAgIGNvbnRyb2wuX3JlZ2lzdGVyT25Db2xsZWN0aW9uQ2hhbmdlKHRoaXMuX29uQ29sbGVjdGlvbkNoYW5nZSk7XG4gICAgICAgIHJldHVybiBjb250cm9sO1xuICAgIH1cbiAgICBhZGRDb250cm9sKG5hbWUsIGNvbnRyb2wsIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICB0aGlzLnJlZ2lzdGVyQ29udHJvbChuYW1lLCBjb250cm9sKTtcbiAgICAgICAgdGhpcy51cGRhdGVWYWx1ZUFuZFZhbGlkaXR5KHsgZW1pdEV2ZW50OiBvcHRpb25zLmVtaXRFdmVudCB9KTtcbiAgICAgICAgdGhpcy5fb25Db2xsZWN0aW9uQ2hhbmdlKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbW92ZSBhIGNvbnRyb2wgZnJvbSB0aGlzIGdyb3VwLiBJbiBhIHN0cm9uZ2x5LXR5cGVkIGdyb3VwLCByZXF1aXJlZCBjb250cm9scyBjYW5ub3QgYmVcbiAgICAgKiByZW1vdmVkLlxuICAgICAqXG4gICAgICogVGhpcyBtZXRob2QgYWxzbyB1cGRhdGVzIHRoZSB2YWx1ZSBhbmQgdmFsaWRpdHkgb2YgdGhlIGNvbnRyb2wuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbmFtZSBUaGUgY29udHJvbCBuYW1lIHRvIHJlbW92ZSBmcm9tIHRoZSBjb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIG9wdGlvbnMgU3BlY2lmaWVzIHdoZXRoZXIgdGhpcyBGb3JtR3JvdXAgaW5zdGFuY2Ugc2hvdWxkIGVtaXQgZXZlbnRzIGFmdGVyIGFcbiAgICAgKiAgICAgY29udHJvbCBpcyByZW1vdmVkLlxuICAgICAqICogYGVtaXRFdmVudGA6IFdoZW4gdHJ1ZSBvciBub3Qgc3VwcGxpZWQgKHRoZSBkZWZhdWx0KSwgYm90aCB0aGUgYHN0YXR1c0NoYW5nZXNgIGFuZFxuICAgICAqIGB2YWx1ZUNoYW5nZXNgIG9ic2VydmFibGVzIGVtaXQgZXZlbnRzIHdpdGggdGhlIGxhdGVzdCBzdGF0dXMgYW5kIHZhbHVlIHdoZW4gdGhlIGNvbnRyb2wgaXNcbiAgICAgKiByZW1vdmVkLiBXaGVuIGZhbHNlLCBubyBldmVudHMgYXJlIGVtaXR0ZWQuXG4gICAgICovXG4gICAgcmVtb3ZlQ29udHJvbChuYW1lLCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgaWYgKHRoaXMuY29udHJvbHNbbmFtZV0pXG4gICAgICAgICAgICB0aGlzLmNvbnRyb2xzW25hbWVdLl9yZWdpc3Rlck9uQ29sbGVjdGlvbkNoYW5nZSgoKSA9PiB7IH0pO1xuICAgICAgICBkZWxldGUgKHRoaXMuY29udHJvbHNbbmFtZV0pO1xuICAgICAgICB0aGlzLnVwZGF0ZVZhbHVlQW5kVmFsaWRpdHkoeyBlbWl0RXZlbnQ6IG9wdGlvbnMuZW1pdEV2ZW50IH0pO1xuICAgICAgICB0aGlzLl9vbkNvbGxlY3Rpb25DaGFuZ2UoKTtcbiAgICB9XG4gICAgc2V0Q29udHJvbChuYW1lLCBjb250cm9sLCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgaWYgKHRoaXMuY29udHJvbHNbbmFtZV0pXG4gICAgICAgICAgICB0aGlzLmNvbnRyb2xzW25hbWVdLl9yZWdpc3Rlck9uQ29sbGVjdGlvbkNoYW5nZSgoKSA9PiB7IH0pO1xuICAgICAgICBkZWxldGUgKHRoaXMuY29udHJvbHNbbmFtZV0pO1xuICAgICAgICBpZiAoY29udHJvbClcbiAgICAgICAgICAgIHRoaXMucmVnaXN0ZXJDb250cm9sKG5hbWUsIGNvbnRyb2wpO1xuICAgICAgICB0aGlzLnVwZGF0ZVZhbHVlQW5kVmFsaWRpdHkoeyBlbWl0RXZlbnQ6IG9wdGlvbnMuZW1pdEV2ZW50IH0pO1xuICAgICAgICB0aGlzLl9vbkNvbGxlY3Rpb25DaGFuZ2UoKTtcbiAgICB9XG4gICAgY29udGFpbnMoY29udHJvbE5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29udHJvbHMuaGFzT3duUHJvcGVydHkoY29udHJvbE5hbWUpICYmIHRoaXMuY29udHJvbHNbY29udHJvbE5hbWVdLmVuYWJsZWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHZhbHVlIG9mIHRoZSBgRm9ybUdyb3VwYC4gSXQgYWNjZXB0cyBhbiBvYmplY3QgdGhhdCBtYXRjaGVzXG4gICAgICogdGhlIHN0cnVjdHVyZSBvZiB0aGUgZ3JvdXAsIHdpdGggY29udHJvbCBuYW1lcyBhcyBrZXlzLlxuICAgICAqXG4gICAgICogQHVzYWdlTm90ZXNcbiAgICAgKiAjIyMgU2V0IHRoZSBjb21wbGV0ZSB2YWx1ZSBmb3IgdGhlIGZvcm0gZ3JvdXBcbiAgICAgKlxuICAgICAqIGBgYFxuICAgICAqIGNvbnN0IGZvcm0gPSBuZXcgRm9ybUdyb3VwKHtcbiAgICAgKiAgIGZpcnN0OiBuZXcgRm9ybUNvbnRyb2woKSxcbiAgICAgKiAgIGxhc3Q6IG5ldyBGb3JtQ29udHJvbCgpXG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBjb25zb2xlLmxvZyhmb3JtLnZhbHVlKTsgICAvLyB7Zmlyc3Q6IG51bGwsIGxhc3Q6IG51bGx9XG4gICAgICpcbiAgICAgKiBmb3JtLnNldFZhbHVlKHtmaXJzdDogJ05hbmN5JywgbGFzdDogJ0RyZXcnfSk7XG4gICAgICogY29uc29sZS5sb2coZm9ybS52YWx1ZSk7ICAgLy8ge2ZpcnN0OiAnTmFuY3knLCBsYXN0OiAnRHJldyd9XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAdGhyb3dzIFdoZW4gc3RyaWN0IGNoZWNrcyBmYWlsLCBzdWNoIGFzIHNldHRpbmcgdGhlIHZhbHVlIG9mIGEgY29udHJvbFxuICAgICAqIHRoYXQgZG9lc24ndCBleGlzdCBvciBpZiB5b3UgZXhjbHVkZSBhIHZhbHVlIG9mIGEgY29udHJvbCB0aGF0IGRvZXMgZXhpc3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdmFsdWUgVGhlIG5ldyB2YWx1ZSBmb3IgdGhlIGNvbnRyb2wgdGhhdCBtYXRjaGVzIHRoZSBzdHJ1Y3R1cmUgb2YgdGhlIGdyb3VwLlxuICAgICAqIEBwYXJhbSBvcHRpb25zIENvbmZpZ3VyYXRpb24gb3B0aW9ucyB0aGF0IGRldGVybWluZSBob3cgdGhlIGNvbnRyb2wgcHJvcGFnYXRlcyBjaGFuZ2VzXG4gICAgICogYW5kIGVtaXRzIGV2ZW50cyBhZnRlciB0aGUgdmFsdWUgY2hhbmdlcy5cbiAgICAgKiBUaGUgY29uZmlndXJhdGlvbiBvcHRpb25zIGFyZSBwYXNzZWQgdG8gdGhlIHtAbGluayBBYnN0cmFjdENvbnRyb2wjdXBkYXRlVmFsdWVBbmRWYWxpZGl0eVxuICAgICAqIHVwZGF0ZVZhbHVlQW5kVmFsaWRpdHl9IG1ldGhvZC5cbiAgICAgKlxuICAgICAqICogYG9ubHlTZWxmYDogV2hlbiB0cnVlLCBlYWNoIGNoYW5nZSBvbmx5IGFmZmVjdHMgdGhpcyBjb250cm9sLCBhbmQgbm90IGl0cyBwYXJlbnQuIERlZmF1bHQgaXNcbiAgICAgKiBmYWxzZS5cbiAgICAgKiAqIGBlbWl0RXZlbnRgOiBXaGVuIHRydWUgb3Igbm90IHN1cHBsaWVkICh0aGUgZGVmYXVsdCksIGJvdGggdGhlIGBzdGF0dXNDaGFuZ2VzYCBhbmRcbiAgICAgKiBgdmFsdWVDaGFuZ2VzYFxuICAgICAqIG9ic2VydmFibGVzIGVtaXQgZXZlbnRzIHdpdGggdGhlIGxhdGVzdCBzdGF0dXMgYW5kIHZhbHVlIHdoZW4gdGhlIGNvbnRyb2wgdmFsdWUgaXMgdXBkYXRlZC5cbiAgICAgKiBXaGVuIGZhbHNlLCBubyBldmVudHMgYXJlIGVtaXR0ZWQuXG4gICAgICovXG4gICAgc2V0VmFsdWUodmFsdWUsIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICBhc3NlcnRBbGxWYWx1ZXNQcmVzZW50KHRoaXMsIHRydWUsIHZhbHVlKTtcbiAgICAgICAgT2JqZWN0LmtleXModmFsdWUpLmZvckVhY2gobmFtZSA9PiB7XG4gICAgICAgICAgICBhc3NlcnRDb250cm9sUHJlc2VudCh0aGlzLCB0cnVlLCBuYW1lKTtcbiAgICAgICAgICAgIHRoaXMuY29udHJvbHNbbmFtZV0uc2V0VmFsdWUodmFsdWVbbmFtZV0sIHsgb25seVNlbGY6IHRydWUsIGVtaXRFdmVudDogb3B0aW9ucy5lbWl0RXZlbnQgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnVwZGF0ZVZhbHVlQW5kVmFsaWRpdHkob3B0aW9ucyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBhdGNoZXMgdGhlIHZhbHVlIG9mIHRoZSBgRm9ybUdyb3VwYC4gSXQgYWNjZXB0cyBhbiBvYmplY3Qgd2l0aCBjb250cm9sXG4gICAgICogbmFtZXMgYXMga2V5cywgYW5kIGRvZXMgaXRzIGJlc3QgdG8gbWF0Y2ggdGhlIHZhbHVlcyB0byB0aGUgY29ycmVjdCBjb250cm9sc1xuICAgICAqIGluIHRoZSBncm91cC5cbiAgICAgKlxuICAgICAqIEl0IGFjY2VwdHMgYm90aCBzdXBlci1zZXRzIGFuZCBzdWItc2V0cyBvZiB0aGUgZ3JvdXAgd2l0aG91dCB0aHJvd2luZyBhbiBlcnJvci5cbiAgICAgKlxuICAgICAqIEB1c2FnZU5vdGVzXG4gICAgICogIyMjIFBhdGNoIHRoZSB2YWx1ZSBmb3IgYSBmb3JtIGdyb3VwXG4gICAgICpcbiAgICAgKiBgYGBcbiAgICAgKiBjb25zdCBmb3JtID0gbmV3IEZvcm1Hcm91cCh7XG4gICAgICogICAgZmlyc3Q6IG5ldyBGb3JtQ29udHJvbCgpLFxuICAgICAqICAgIGxhc3Q6IG5ldyBGb3JtQ29udHJvbCgpXG4gICAgICogfSk7XG4gICAgICogY29uc29sZS5sb2coZm9ybS52YWx1ZSk7ICAgLy8ge2ZpcnN0OiBudWxsLCBsYXN0OiBudWxsfVxuICAgICAqXG4gICAgICogZm9ybS5wYXRjaFZhbHVlKHtmaXJzdDogJ05hbmN5J30pO1xuICAgICAqIGNvbnNvbGUubG9nKGZvcm0udmFsdWUpOyAgIC8vIHtmaXJzdDogJ05hbmN5JywgbGFzdDogbnVsbH1cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBwYXJhbSB2YWx1ZSBUaGUgb2JqZWN0IHRoYXQgbWF0Y2hlcyB0aGUgc3RydWN0dXJlIG9mIHRoZSBncm91cC5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBDb25maWd1cmF0aW9uIG9wdGlvbnMgdGhhdCBkZXRlcm1pbmUgaG93IHRoZSBjb250cm9sIHByb3BhZ2F0ZXMgY2hhbmdlcyBhbmRcbiAgICAgKiBlbWl0cyBldmVudHMgYWZ0ZXIgdGhlIHZhbHVlIGlzIHBhdGNoZWQuXG4gICAgICogKiBgb25seVNlbGZgOiBXaGVuIHRydWUsIGVhY2ggY2hhbmdlIG9ubHkgYWZmZWN0cyB0aGlzIGNvbnRyb2wgYW5kIG5vdCBpdHMgcGFyZW50LiBEZWZhdWx0IGlzXG4gICAgICogdHJ1ZS5cbiAgICAgKiAqIGBlbWl0RXZlbnRgOiBXaGVuIHRydWUgb3Igbm90IHN1cHBsaWVkICh0aGUgZGVmYXVsdCksIGJvdGggdGhlIGBzdGF0dXNDaGFuZ2VzYCBhbmRcbiAgICAgKiBgdmFsdWVDaGFuZ2VzYCBvYnNlcnZhYmxlcyBlbWl0IGV2ZW50cyB3aXRoIHRoZSBsYXRlc3Qgc3RhdHVzIGFuZCB2YWx1ZSB3aGVuIHRoZSBjb250cm9sIHZhbHVlXG4gICAgICogaXMgdXBkYXRlZC4gV2hlbiBmYWxzZSwgbm8gZXZlbnRzIGFyZSBlbWl0dGVkLiBUaGUgY29uZmlndXJhdGlvbiBvcHRpb25zIGFyZSBwYXNzZWQgdG9cbiAgICAgKiB0aGUge0BsaW5rIEFic3RyYWN0Q29udHJvbCN1cGRhdGVWYWx1ZUFuZFZhbGlkaXR5IHVwZGF0ZVZhbHVlQW5kVmFsaWRpdHl9IG1ldGhvZC5cbiAgICAgKi9cbiAgICBwYXRjaFZhbHVlKHZhbHVlLCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgLy8gRXZlbiB0aG91Z2ggdGhlIGB2YWx1ZWAgYXJndW1lbnQgdHlwZSBkb2Vzbid0IGFsbG93IGBudWxsYCBhbmQgYHVuZGVmaW5lZGAgdmFsdWVzLCB0aGVcbiAgICAgICAgLy8gYHBhdGNoVmFsdWVgIGNhbiBiZSBjYWxsZWQgcmVjdXJzaXZlbHkgYW5kIGlubmVyIGRhdGEgc3RydWN0dXJlcyBtaWdodCBoYXZlIHRoZXNlIHZhbHVlcywgc29cbiAgICAgICAgLy8gd2UganVzdCBpZ25vcmUgc3VjaCBjYXNlcyB3aGVuIGEgZmllbGQgY29udGFpbmluZyBGb3JtR3JvdXAgaW5zdGFuY2UgcmVjZWl2ZXMgYG51bGxgIG9yXG4gICAgICAgIC8vIGB1bmRlZmluZWRgIGFzIGEgdmFsdWUuXG4gICAgICAgIGlmICh2YWx1ZSA9PSBudWxsIC8qIGJvdGggYG51bGxgIGFuZCBgdW5kZWZpbmVkYCAqLylcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgT2JqZWN0LmtleXModmFsdWUpLmZvckVhY2gobmFtZSA9PiB7XG4gICAgICAgICAgICAvLyBUaGUgY29tcGlsZXIgY2Fubm90IHNlZSB0aHJvdWdoIHRoZSB1bmluc3RhbnRpYXRlZCBjb25kaXRpb25hbCB0eXBlIG9mIGB0aGlzLmNvbnRyb2xzYCwgc29cbiAgICAgICAgICAgIC8vIGBhcyBhbnlgIGlzIHJlcXVpcmVkLlxuICAgICAgICAgICAgY29uc3QgY29udHJvbCA9IHRoaXMuY29udHJvbHNbbmFtZV07XG4gICAgICAgICAgICBpZiAoY29udHJvbCkge1xuICAgICAgICAgICAgICAgIGNvbnRyb2wucGF0Y2hWYWx1ZShcbiAgICAgICAgICAgICAgICAvKiBHdWFyYW50ZWVkIHRvIGJlIHByZXNlbnQsIGR1ZSB0byB0aGUgb3V0ZXIgZm9yRWFjaC4gKi8gdmFsdWVbbmFtZV0sIHsgb25seVNlbGY6IHRydWUsIGVtaXRFdmVudDogb3B0aW9ucy5lbWl0RXZlbnQgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnVwZGF0ZVZhbHVlQW5kVmFsaWRpdHkob3B0aW9ucyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlc2V0cyB0aGUgYEZvcm1Hcm91cGAsIG1hcmtzIGFsbCBkZXNjZW5kYW50cyBgcHJpc3RpbmVgIGFuZCBgdW50b3VjaGVkYCBhbmQgc2V0c1xuICAgICAqIHRoZSB2YWx1ZSBvZiBhbGwgZGVzY2VuZGFudHMgdG8gdGhlaXIgZGVmYXVsdCB2YWx1ZXMsIG9yIG51bGwgaWYgbm8gZGVmYXVsdHMgd2VyZSBwcm92aWRlZC5cbiAgICAgKlxuICAgICAqIFlvdSByZXNldCB0byBhIHNwZWNpZmljIGZvcm0gc3RhdGUgYnkgcGFzc2luZyBpbiBhIG1hcCBvZiBzdGF0ZXNcbiAgICAgKiB0aGF0IG1hdGNoZXMgdGhlIHN0cnVjdHVyZSBvZiB5b3VyIGZvcm0sIHdpdGggY29udHJvbCBuYW1lcyBhcyBrZXlzLiBUaGUgc3RhdGVcbiAgICAgKiBpcyBhIHN0YW5kYWxvbmUgdmFsdWUgb3IgYSBmb3JtIHN0YXRlIG9iamVjdCB3aXRoIGJvdGggYSB2YWx1ZSBhbmQgYSBkaXNhYmxlZFxuICAgICAqIHN0YXR1cy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB2YWx1ZSBSZXNldHMgdGhlIGNvbnRyb2wgd2l0aCBhbiBpbml0aWFsIHZhbHVlLFxuICAgICAqIG9yIGFuIG9iamVjdCB0aGF0IGRlZmluZXMgdGhlIGluaXRpYWwgdmFsdWUgYW5kIGRpc2FibGVkIHN0YXRlLlxuICAgICAqXG4gICAgICogQHBhcmFtIG9wdGlvbnMgQ29uZmlndXJhdGlvbiBvcHRpb25zIHRoYXQgZGV0ZXJtaW5lIGhvdyB0aGUgY29udHJvbCBwcm9wYWdhdGVzIGNoYW5nZXNcbiAgICAgKiBhbmQgZW1pdHMgZXZlbnRzIHdoZW4gdGhlIGdyb3VwIGlzIHJlc2V0LlxuICAgICAqICogYG9ubHlTZWxmYDogV2hlbiB0cnVlLCBlYWNoIGNoYW5nZSBvbmx5IGFmZmVjdHMgdGhpcyBjb250cm9sLCBhbmQgbm90IGl0cyBwYXJlbnQuIERlZmF1bHQgaXNcbiAgICAgKiBmYWxzZS5cbiAgICAgKiAqIGBlbWl0RXZlbnRgOiBXaGVuIHRydWUgb3Igbm90IHN1cHBsaWVkICh0aGUgZGVmYXVsdCksIGJvdGggdGhlIGBzdGF0dXNDaGFuZ2VzYCBhbmRcbiAgICAgKiBgdmFsdWVDaGFuZ2VzYFxuICAgICAqIG9ic2VydmFibGVzIGVtaXQgZXZlbnRzIHdpdGggdGhlIGxhdGVzdCBzdGF0dXMgYW5kIHZhbHVlIHdoZW4gdGhlIGNvbnRyb2wgaXMgcmVzZXQuXG4gICAgICogV2hlbiBmYWxzZSwgbm8gZXZlbnRzIGFyZSBlbWl0dGVkLlxuICAgICAqIFRoZSBjb25maWd1cmF0aW9uIG9wdGlvbnMgYXJlIHBhc3NlZCB0byB0aGUge0BsaW5rIEFic3RyYWN0Q29udHJvbCN1cGRhdGVWYWx1ZUFuZFZhbGlkaXR5XG4gICAgICogdXBkYXRlVmFsdWVBbmRWYWxpZGl0eX0gbWV0aG9kLlxuICAgICAqXG4gICAgICogQHVzYWdlTm90ZXNcbiAgICAgKlxuICAgICAqICMjIyBSZXNldCB0aGUgZm9ybSBncm91cCB2YWx1ZXNcbiAgICAgKlxuICAgICAqIGBgYHRzXG4gICAgICogY29uc3QgZm9ybSA9IG5ldyBGb3JtR3JvdXAoe1xuICAgICAqICAgZmlyc3Q6IG5ldyBGb3JtQ29udHJvbCgnZmlyc3QgbmFtZScpLFxuICAgICAqICAgbGFzdDogbmV3IEZvcm1Db250cm9sKCdsYXN0IG5hbWUnKVxuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogY29uc29sZS5sb2coZm9ybS52YWx1ZSk7ICAvLyB7Zmlyc3Q6ICdmaXJzdCBuYW1lJywgbGFzdDogJ2xhc3QgbmFtZSd9XG4gICAgICpcbiAgICAgKiBmb3JtLnJlc2V0KHsgZmlyc3Q6ICduYW1lJywgbGFzdDogJ2xhc3QgbmFtZScgfSk7XG4gICAgICpcbiAgICAgKiBjb25zb2xlLmxvZyhmb3JtLnZhbHVlKTsgIC8vIHtmaXJzdDogJ25hbWUnLCBsYXN0OiAnbGFzdCBuYW1lJ31cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqICMjIyBSZXNldCB0aGUgZm9ybSBncm91cCB2YWx1ZXMgYW5kIGRpc2FibGVkIHN0YXR1c1xuICAgICAqXG4gICAgICogYGBgXG4gICAgICogY29uc3QgZm9ybSA9IG5ldyBGb3JtR3JvdXAoe1xuICAgICAqICAgZmlyc3Q6IG5ldyBGb3JtQ29udHJvbCgnZmlyc3QgbmFtZScpLFxuICAgICAqICAgbGFzdDogbmV3IEZvcm1Db250cm9sKCdsYXN0IG5hbWUnKVxuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogZm9ybS5yZXNldCh7XG4gICAgICogICBmaXJzdDoge3ZhbHVlOiAnbmFtZScsIGRpc2FibGVkOiB0cnVlfSxcbiAgICAgKiAgIGxhc3Q6ICdsYXN0J1xuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogY29uc29sZS5sb2coZm9ybS52YWx1ZSk7ICAvLyB7bGFzdDogJ2xhc3QnfVxuICAgICAqIGNvbnNvbGUubG9nKGZvcm0uZ2V0KCdmaXJzdCcpLnN0YXR1cyk7ICAvLyAnRElTQUJMRUQnXG4gICAgICogYGBgXG4gICAgICovXG4gICAgcmVzZXQodmFsdWUgPSB7fSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIHRoaXMuX2ZvckVhY2hDaGlsZCgoY29udHJvbCwgbmFtZSkgPT4ge1xuICAgICAgICAgICAgY29udHJvbC5yZXNldCh2YWx1ZSA/IHZhbHVlW25hbWVdIDogbnVsbCwgeyBvbmx5U2VsZjogdHJ1ZSwgZW1pdEV2ZW50OiBvcHRpb25zLmVtaXRFdmVudCB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX3VwZGF0ZVByaXN0aW5lKG9wdGlvbnMpO1xuICAgICAgICB0aGlzLl91cGRhdGVUb3VjaGVkKG9wdGlvbnMpO1xuICAgICAgICB0aGlzLnVwZGF0ZVZhbHVlQW5kVmFsaWRpdHkob3B0aW9ucyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBhZ2dyZWdhdGUgdmFsdWUgb2YgdGhlIGBGb3JtR3JvdXBgLCBpbmNsdWRpbmcgYW55IGRpc2FibGVkIGNvbnRyb2xzLlxuICAgICAqXG4gICAgICogUmV0cmlldmVzIGFsbCB2YWx1ZXMgcmVnYXJkbGVzcyBvZiBkaXNhYmxlZCBzdGF0dXMuXG4gICAgICovXG4gICAgZ2V0UmF3VmFsdWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yZWR1Y2VDaGlsZHJlbih7fSwgKGFjYywgY29udHJvbCwgbmFtZSkgPT4ge1xuICAgICAgICAgICAgYWNjW25hbWVdID0gY29udHJvbC5nZXRSYXdWYWx1ZSgpO1xuICAgICAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBfc3luY1BlbmRpbmdDb250cm9scygpIHtcbiAgICAgICAgbGV0IHN1YnRyZWVVcGRhdGVkID0gdGhpcy5fcmVkdWNlQ2hpbGRyZW4oZmFsc2UsICh1cGRhdGVkLCBjaGlsZCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGNoaWxkLl9zeW5jUGVuZGluZ0NvbnRyb2xzKCkgPyB0cnVlIDogdXBkYXRlZDtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChzdWJ0cmVlVXBkYXRlZClcbiAgICAgICAgICAgIHRoaXMudXBkYXRlVmFsdWVBbmRWYWxpZGl0eSh7IG9ubHlTZWxmOiB0cnVlIH0pO1xuICAgICAgICByZXR1cm4gc3VidHJlZVVwZGF0ZWQ7XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBfZm9yRWFjaENoaWxkKGNiKSB7XG4gICAgICAgIE9iamVjdC5rZXlzKHRoaXMuY29udHJvbHMpLmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgICAgIC8vIFRoZSBsaXN0IG9mIGNvbnRyb2xzIGNhbiBjaGFuZ2UgKGZvciBleC4gY29udHJvbHMgbWlnaHQgYmUgcmVtb3ZlZCkgd2hpbGUgdGhlIGxvb3BcbiAgICAgICAgICAgIC8vIGlzIHJ1bm5pbmcgKGFzIGEgcmVzdWx0IG9mIGludm9raW5nIEZvcm1zIEFQSSBpbiBgdmFsdWVDaGFuZ2VzYCBzdWJzY3JpcHRpb24pLCBzbyB3ZVxuICAgICAgICAgICAgLy8gaGF2ZSB0byBudWxsIGNoZWNrIGJlZm9yZSBpbnZva2luZyB0aGUgY2FsbGJhY2suXG4gICAgICAgICAgICBjb25zdCBjb250cm9sID0gdGhpcy5jb250cm9sc1trZXldO1xuICAgICAgICAgICAgY29udHJvbCAmJiBjYihjb250cm9sLCBrZXkpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIF9zZXRVcENvbnRyb2xzKCkge1xuICAgICAgICB0aGlzLl9mb3JFYWNoQ2hpbGQoKGNvbnRyb2wpID0+IHtcbiAgICAgICAgICAgIGNvbnRyb2wuc2V0UGFyZW50KHRoaXMpO1xuICAgICAgICAgICAgY29udHJvbC5fcmVnaXN0ZXJPbkNvbGxlY3Rpb25DaGFuZ2UodGhpcy5fb25Db2xsZWN0aW9uQ2hhbmdlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBfdXBkYXRlVmFsdWUoKSB7XG4gICAgICAgIHRoaXMudmFsdWUgPSB0aGlzLl9yZWR1Y2VWYWx1ZSgpO1xuICAgIH1cbiAgICAvKiogQGludGVybmFsICovXG4gICAgX2FueUNvbnRyb2xzKGNvbmRpdGlvbikge1xuICAgICAgICBmb3IgKGNvbnN0IFtjb250cm9sTmFtZSwgY29udHJvbF0gb2YgT2JqZWN0LmVudHJpZXModGhpcy5jb250cm9scykpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbnRhaW5zKGNvbnRyb2xOYW1lKSAmJiBjb25kaXRpb24oY29udHJvbCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBfcmVkdWNlVmFsdWUoKSB7XG4gICAgICAgIGxldCBhY2MgPSB7fTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlZHVjZUNoaWxkcmVuKGFjYywgKGFjYywgY29udHJvbCwgbmFtZSkgPT4ge1xuICAgICAgICAgICAgaWYgKGNvbnRyb2wuZW5hYmxlZCB8fCB0aGlzLmRpc2FibGVkKSB7XG4gICAgICAgICAgICAgICAgYWNjW25hbWVdID0gY29udHJvbC52YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBhY2M7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKiogQGludGVybmFsICovXG4gICAgX3JlZHVjZUNoaWxkcmVuKGluaXRWYWx1ZSwgZm4pIHtcbiAgICAgICAgbGV0IHJlcyA9IGluaXRWYWx1ZTtcbiAgICAgICAgdGhpcy5fZm9yRWFjaENoaWxkKChjb250cm9sLCBuYW1lKSA9PiB7XG4gICAgICAgICAgICByZXMgPSBmbihyZXMsIGNvbnRyb2wsIG5hbWUpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIF9hbGxDb250cm9sc0Rpc2FibGVkKCkge1xuICAgICAgICBmb3IgKGNvbnN0IGNvbnRyb2xOYW1lIG9mIE9iamVjdC5rZXlzKHRoaXMuY29udHJvbHMpKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5jb250cm9sc1tjb250cm9sTmFtZV0uZW5hYmxlZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gT2JqZWN0LmtleXModGhpcy5jb250cm9scykubGVuZ3RoID4gMCB8fCB0aGlzLmRpc2FibGVkO1xuICAgIH1cbiAgICAvKiogQGludGVybmFsICovXG4gICAgX2ZpbmQobmFtZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb250cm9scy5oYXNPd25Qcm9wZXJ0eShuYW1lKSA/XG4gICAgICAgICAgICB0aGlzLmNvbnRyb2xzW25hbWVdIDpcbiAgICAgICAgICAgIG51bGw7XG4gICAgfVxufVxuLyoqXG4gKiBXaWxsIHZhbGlkYXRlIHRoYXQgbm9uZSBvZiB0aGUgY29udHJvbHMgaGFzIGEga2V5IHdpdGggYSBkb3RcbiAqIFRocm93cyBvdGhlciB3aXNlXG4gKi9cbmZ1bmN0aW9uIHZhbGlkYXRlRm9ybUdyb3VwQ29udHJvbHMoY29udHJvbHMpIHtcbiAgICBjb25zdCBpbnZhbGlkS2V5cyA9IE9iamVjdC5rZXlzKGNvbnRyb2xzKS5maWx0ZXIoa2V5ID0+IGtleS5pbmNsdWRlcygnLicpKTtcbiAgICBpZiAoaW52YWxpZEtleXMubGVuZ3RoID4gMCkge1xuICAgICAgICAvLyBUT0RPOiBtYWtlIHRoaXMgYW4gZXJyb3Igb25jZSB0aGVyZSBhcmUgbm8gbW9yZSB1c2VzIGluIEczXG4gICAgICAgIGNvbnNvbGUud2FybihgRm9ybUdyb3VwIGtleXMgY2Fubm90IGluY2x1ZGUgXFxgLlxcYCwgcGxlYXNlIHJlcGxhY2UgdGhlIGtleXMgZm9yOiAke2ludmFsaWRLZXlzLmpvaW4oJywnKX0uYCk7XG4gICAgfVxufVxuY29uc3QgVW50eXBlZEZvcm1Hcm91cCA9IEZvcm1Hcm91cDtcbi8qKlxuICogQGRlc2NyaXB0aW9uXG4gKiBBc3NlcnRzIHRoYXQgdGhlIGdpdmVuIGNvbnRyb2wgaXMgYW4gaW5zdGFuY2Ugb2YgYEZvcm1Hcm91cGBcbiAqXG4gKiBAcHVibGljQXBpXG4gKi9cbmNvbnN0IGlzRm9ybUdyb3VwID0gKGNvbnRyb2wpID0+IGNvbnRyb2wgaW5zdGFuY2VvZiBGb3JtR3JvdXA7XG4vKipcbiAqIFRyYWNrcyB0aGUgdmFsdWUgYW5kIHZhbGlkaXR5IHN0YXRlIG9mIGEgY29sbGVjdGlvbiBvZiBgRm9ybUNvbnRyb2xgIGluc3RhbmNlcywgZWFjaCBvZiB3aGljaCBoYXNcbiAqIHRoZSBzYW1lIHZhbHVlIHR5cGUuXG4gKlxuICogYEZvcm1SZWNvcmRgIGlzIHZlcnkgc2ltaWxhciB0byB7QGxpbmsgRm9ybUdyb3VwfSwgZXhjZXB0IGl0IGNhbiBiZSB1c2VkIHdpdGggYSBkeW5hbWljIGtleXMsXG4gKiB3aXRoIGNvbnRyb2xzIGFkZGVkIGFuZCByZW1vdmVkIGFzIG5lZWRlZC5cbiAqXG4gKiBgRm9ybVJlY29yZGAgYWNjZXB0cyBvbmUgZ2VuZXJpYyBhcmd1bWVudCwgd2hpY2ggZGVzY3JpYmVzIHRoZSB0eXBlIG9mIHRoZSBjb250cm9scyBpdCBjb250YWlucy5cbiAqXG4gKiBAdXNhZ2VOb3Rlc1xuICpcbiAqIGBgYFxuICogbGV0IG51bWJlcnMgPSBuZXcgRm9ybVJlY29yZCh7YmlsbDogbmV3IEZvcm1Db250cm9sKCc0MTUtMTIzLTQ1NicpfSk7XG4gKiBudW1iZXJzLmFkZENvbnRyb2woJ2JvYicsIG5ldyBGb3JtQ29udHJvbCgnNDE1LTIzNC01NjcnKSk7XG4gKiBudW1iZXJzLnJlbW92ZUNvbnRyb2woJ2JpbGwnKTtcbiAqIGBgYFxuICpcbiAqIEBwdWJsaWNBcGlcbiAqL1xuY2xhc3MgRm9ybVJlY29yZCBleHRlbmRzIEZvcm1Hcm91cCB7XG59XG4vKipcbiAqIEBkZXNjcmlwdGlvblxuICogQXNzZXJ0cyB0aGF0IHRoZSBnaXZlbiBjb250cm9sIGlzIGFuIGluc3RhbmNlIG9mIGBGb3JtUmVjb3JkYFxuICpcbiAqIEBwdWJsaWNBcGlcbiAqL1xuY29uc3QgaXNGb3JtUmVjb3JkID0gKGNvbnRyb2wpID0+IGNvbnRyb2wgaW5zdGFuY2VvZiBGb3JtUmVjb3JkO1xuXG4vKipcbiAqIFRva2VuIHRvIHByb3ZpZGUgdG8gYWxsb3cgU2V0RGlzYWJsZWRTdGF0ZSB0byBhbHdheXMgYmUgY2FsbGVkIHdoZW4gYSBDVkEgaXMgYWRkZWQsIHJlZ2FyZGxlc3Mgb2ZcbiAqIHdoZXRoZXIgdGhlIGNvbnRyb2wgaXMgZGlzYWJsZWQgb3IgZW5hYmxlZC5cbiAqXG4gKiBAc2VlIHtAbGluayBGb3Jtc01vZHVsZSN3aXRoY29uZmlnfVxuICovXG5jb25zdCBDQUxMX1NFVF9ESVNBQkxFRF9TVEFURSA9IG5ldyBJbmplY3Rpb25Ub2tlbignQ2FsbFNldERpc2FibGVkU3RhdGUnLCB7IHByb3ZpZGVkSW46ICdyb290JywgZmFjdG9yeTogKCkgPT4gc2V0RGlzYWJsZWRTdGF0ZURlZmF1bHQgfSk7XG4vKipcbiAqIFdoZXRoZXIgdG8gdXNlIHRoZSBmaXhlZCBzZXREaXNhYmxlZFN0YXRlIGJlaGF2aW9yIGJ5IGRlZmF1bHQuXG4gKi9cbmNvbnN0IHNldERpc2FibGVkU3RhdGVEZWZhdWx0ID0gJ2Fsd2F5cyc7XG5mdW5jdGlvbiBjb250cm9sUGF0aChuYW1lLCBwYXJlbnQpIHtcbiAgICByZXR1cm4gWy4uLnBhcmVudC5wYXRoLCBuYW1lXTtcbn1cbi8qKlxuICogTGlua3MgYSBGb3JtIGNvbnRyb2wgYW5kIGEgRm9ybSBkaXJlY3RpdmUgYnkgc2V0dGluZyB1cCBjYWxsYmFja3MgKHN1Y2ggYXMgYG9uQ2hhbmdlYCkgb24gYm90aFxuICogaW5zdGFuY2VzLiBUaGlzIGZ1bmN0aW9uIGlzIHR5cGljYWxseSBpbnZva2VkIHdoZW4gZm9ybSBkaXJlY3RpdmUgaXMgYmVpbmcgaW5pdGlhbGl6ZWQuXG4gKlxuICogQHBhcmFtIGNvbnRyb2wgRm9ybSBjb250cm9sIGluc3RhbmNlIHRoYXQgc2hvdWxkIGJlIGxpbmtlZC5cbiAqIEBwYXJhbSBkaXIgRGlyZWN0aXZlIHRoYXQgc2hvdWxkIGJlIGxpbmtlZCB3aXRoIGEgZ2l2ZW4gY29udHJvbC5cbiAqL1xuZnVuY3Rpb24gc2V0VXBDb250cm9sKGNvbnRyb2wsIGRpciwgY2FsbFNldERpc2FibGVkU3RhdGUgPSBzZXREaXNhYmxlZFN0YXRlRGVmYXVsdCkge1xuICAgIGlmICh0eXBlb2YgbmdEZXZNb2RlID09PSAndW5kZWZpbmVkJyB8fCBuZ0Rldk1vZGUpIHtcbiAgICAgICAgaWYgKCFjb250cm9sKVxuICAgICAgICAgICAgX3Rocm93RXJyb3IoZGlyLCAnQ2Fubm90IGZpbmQgY29udHJvbCB3aXRoJyk7XG4gICAgICAgIGlmICghZGlyLnZhbHVlQWNjZXNzb3IpXG4gICAgICAgICAgICBfdGhyb3dNaXNzaW5nVmFsdWVBY2Nlc3NvckVycm9yKGRpcik7XG4gICAgfVxuICAgIHNldFVwVmFsaWRhdG9ycyhjb250cm9sLCBkaXIpO1xuICAgIGRpci52YWx1ZUFjY2Vzc29yLndyaXRlVmFsdWUoY29udHJvbC52YWx1ZSk7XG4gICAgLy8gVGhlIGxlZ2FjeSBiZWhhdmlvciBvbmx5IGNhbGxzIHRoZSBDVkEncyBgc2V0RGlzYWJsZWRTdGF0ZWAgaWYgdGhlIGNvbnRyb2wgaXMgZGlzYWJsZWQuXG4gICAgLy8gSWYgdGhlIGBjYWxsU2V0RGlzYWJsZWRTdGF0ZWAgb3B0aW9uIGlzIHNldCB0byBgYWx3YXlzYCwgdGhlbiB0aGlzIGJ1ZyBpcyBmaXhlZCBhbmRcbiAgICAvLyB0aGUgbWV0aG9kIGlzIGFsd2F5cyBjYWxsZWQuXG4gICAgaWYgKGNvbnRyb2wuZGlzYWJsZWQgfHwgY2FsbFNldERpc2FibGVkU3RhdGUgPT09ICdhbHdheXMnKSB7XG4gICAgICAgIGRpci52YWx1ZUFjY2Vzc29yLnNldERpc2FibGVkU3RhdGU/Lihjb250cm9sLmRpc2FibGVkKTtcbiAgICB9XG4gICAgc2V0VXBWaWV3Q2hhbmdlUGlwZWxpbmUoY29udHJvbCwgZGlyKTtcbiAgICBzZXRVcE1vZGVsQ2hhbmdlUGlwZWxpbmUoY29udHJvbCwgZGlyKTtcbiAgICBzZXRVcEJsdXJQaXBlbGluZShjb250cm9sLCBkaXIpO1xuICAgIHNldFVwRGlzYWJsZWRDaGFuZ2VIYW5kbGVyKGNvbnRyb2wsIGRpcik7XG59XG4vKipcbiAqIFJldmVydHMgY29uZmlndXJhdGlvbiBwZXJmb3JtZWQgYnkgdGhlIGBzZXRVcENvbnRyb2xgIGNvbnRyb2wgZnVuY3Rpb24uXG4gKiBFZmZlY3RpdmVseSBkaXNjb25uZWN0cyBmb3JtIGNvbnRyb2wgd2l0aCBhIGdpdmVuIGZvcm0gZGlyZWN0aXZlLlxuICogVGhpcyBmdW5jdGlvbiBpcyB0eXBpY2FsbHkgaW52b2tlZCB3aGVuIGNvcnJlc3BvbmRpbmcgZm9ybSBkaXJlY3RpdmUgaXMgYmVpbmcgZGVzdHJveWVkLlxuICpcbiAqIEBwYXJhbSBjb250cm9sIEZvcm0gY29udHJvbCB3aGljaCBzaG91bGQgYmUgY2xlYW5lZCB1cC5cbiAqIEBwYXJhbSBkaXIgRGlyZWN0aXZlIHRoYXQgc2hvdWxkIGJlIGRpc2Nvbm5lY3RlZCBmcm9tIGEgZ2l2ZW4gY29udHJvbC5cbiAqIEBwYXJhbSB2YWxpZGF0ZUNvbnRyb2xQcmVzZW5jZU9uQ2hhbmdlIEZsYWcgdGhhdCBpbmRpY2F0ZXMgd2hldGhlciBvbkNoYW5nZSBoYW5kbGVyIHNob3VsZFxuICogICAgIGNvbnRhaW4gYXNzZXJ0cyB0byB2ZXJpZnkgdGhhdCBpdCdzIG5vdCBjYWxsZWQgb25jZSBkaXJlY3RpdmUgaXMgZGVzdHJveWVkLiBXZSBuZWVkIHRoaXMgZmxhZ1xuICogICAgIHRvIGF2b2lkIHBvdGVudGlhbGx5IGJyZWFraW5nIGNoYW5nZXMgY2F1c2VkIGJ5IGJldHRlciBjb250cm9sIGNsZWFudXAgaW50cm9kdWNlZCBpbiAjMzkyMzUuXG4gKi9cbmZ1bmN0aW9uIGNsZWFuVXBDb250cm9sKGNvbnRyb2wsIGRpciwgdmFsaWRhdGVDb250cm9sUHJlc2VuY2VPbkNoYW5nZSA9IHRydWUpIHtcbiAgICBjb25zdCBub29wID0gKCkgPT4ge1xuICAgICAgICBpZiAodmFsaWRhdGVDb250cm9sUHJlc2VuY2VPbkNoYW5nZSAmJiAodHlwZW9mIG5nRGV2TW9kZSA9PT0gJ3VuZGVmaW5lZCcgfHwgbmdEZXZNb2RlKSkge1xuICAgICAgICAgICAgX25vQ29udHJvbEVycm9yKGRpcik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8vIFRoZSBgdmFsdWVBY2Nlc3NvcmAgZmllbGQgaXMgdHlwaWNhbGx5IGRlZmluZWQgb24gRnJvbUNvbnRyb2wgYW5kIEZvcm1Db250cm9sTmFtZSBkaXJlY3RpdmVcbiAgICAvLyBpbnN0YW5jZXMgYW5kIHRoZXJlIGlzIGEgbG9naWMgaW4gYHNlbGVjdFZhbHVlQWNjZXNzb3JgIGZ1bmN0aW9uIHRoYXQgdGhyb3dzIGlmIGl0J3Mgbm90IHRoZVxuICAgIC8vIGNhc2UuIFdlIHN0aWxsIGNoZWNrIHRoZSBwcmVzZW5jZSBvZiBgdmFsdWVBY2Nlc3NvcmAgYmVmb3JlIGludm9raW5nIGl0cyBtZXRob2RzIHRvIG1ha2Ugc3VyZVxuICAgIC8vIHRoYXQgY2xlYW51cCB3b3JrcyBjb3JyZWN0bHkgaWYgYXBwIGNvZGUgb3IgdGVzdHMgYXJlIHNldHVwIHRvIGlnbm9yZSB0aGUgZXJyb3IgdGhyb3duIGZyb21cbiAgICAvLyBgc2VsZWN0VmFsdWVBY2Nlc3NvcmAuIFNlZSBodHRwczovL2dpdGh1Yi5jb20vYW5ndWxhci9hbmd1bGFyL2lzc3Vlcy80MDUyMS5cbiAgICBpZiAoZGlyLnZhbHVlQWNjZXNzb3IpIHtcbiAgICAgICAgZGlyLnZhbHVlQWNjZXNzb3IucmVnaXN0ZXJPbkNoYW5nZShub29wKTtcbiAgICAgICAgZGlyLnZhbHVlQWNjZXNzb3IucmVnaXN0ZXJPblRvdWNoZWQobm9vcCk7XG4gICAgfVxuICAgIGNsZWFuVXBWYWxpZGF0b3JzKGNvbnRyb2wsIGRpcik7XG4gICAgaWYgKGNvbnRyb2wpIHtcbiAgICAgICAgZGlyLl9pbnZva2VPbkRlc3Ryb3lDYWxsYmFja3MoKTtcbiAgICAgICAgY29udHJvbC5fcmVnaXN0ZXJPbkNvbGxlY3Rpb25DaGFuZ2UoKCkgPT4geyB9KTtcbiAgICB9XG59XG5mdW5jdGlvbiByZWdpc3Rlck9uVmFsaWRhdG9yQ2hhbmdlKHZhbGlkYXRvcnMsIG9uQ2hhbmdlKSB7XG4gICAgdmFsaWRhdG9ycy5mb3JFYWNoKCh2YWxpZGF0b3IpID0+IHtcbiAgICAgICAgaWYgKHZhbGlkYXRvci5yZWdpc3Rlck9uVmFsaWRhdG9yQ2hhbmdlKVxuICAgICAgICAgICAgdmFsaWRhdG9yLnJlZ2lzdGVyT25WYWxpZGF0b3JDaGFuZ2Uob25DaGFuZ2UpO1xuICAgIH0pO1xufVxuLyoqXG4gKiBTZXRzIHVwIGRpc2FibGVkIGNoYW5nZSBoYW5kbGVyIGZ1bmN0aW9uIG9uIGEgZ2l2ZW4gZm9ybSBjb250cm9sIGlmIENvbnRyb2xWYWx1ZUFjY2Vzc29yXG4gKiBhc3NvY2lhdGVkIHdpdGggYSBnaXZlbiBkaXJlY3RpdmUgaW5zdGFuY2Ugc3VwcG9ydHMgdGhlIGBzZXREaXNhYmxlZFN0YXRlYCBjYWxsLlxuICpcbiAqIEBwYXJhbSBjb250cm9sIEZvcm0gY29udHJvbCB3aGVyZSBkaXNhYmxlZCBjaGFuZ2UgaGFuZGxlciBzaG91bGQgYmUgc2V0dXAuXG4gKiBAcGFyYW0gZGlyIENvcnJlc3BvbmRpbmcgZGlyZWN0aXZlIGluc3RhbmNlIGFzc29jaWF0ZWQgd2l0aCB0aGlzIGNvbnRyb2wuXG4gKi9cbmZ1bmN0aW9uIHNldFVwRGlzYWJsZWRDaGFuZ2VIYW5kbGVyKGNvbnRyb2wsIGRpcikge1xuICAgIGlmIChkaXIudmFsdWVBY2Nlc3Nvci5zZXREaXNhYmxlZFN0YXRlKSB7XG4gICAgICAgIGNvbnN0IG9uRGlzYWJsZWRDaGFuZ2UgPSAoaXNEaXNhYmxlZCkgPT4ge1xuICAgICAgICAgICAgZGlyLnZhbHVlQWNjZXNzb3Iuc2V0RGlzYWJsZWRTdGF0ZShpc0Rpc2FibGVkKTtcbiAgICAgICAgfTtcbiAgICAgICAgY29udHJvbC5yZWdpc3Rlck9uRGlzYWJsZWRDaGFuZ2Uob25EaXNhYmxlZENoYW5nZSk7XG4gICAgICAgIC8vIFJlZ2lzdGVyIGEgY2FsbGJhY2sgZnVuY3Rpb24gdG8gY2xlYW51cCBkaXNhYmxlZCBjaGFuZ2UgaGFuZGxlclxuICAgICAgICAvLyBmcm9tIGEgY29udHJvbCBpbnN0YW5jZSB3aGVuIGEgZGlyZWN0aXZlIGlzIGRlc3Ryb3llZC5cbiAgICAgICAgZGlyLl9yZWdpc3Rlck9uRGVzdHJveSgoKSA9PiB7XG4gICAgICAgICAgICBjb250cm9sLl91bnJlZ2lzdGVyT25EaXNhYmxlZENoYW5nZShvbkRpc2FibGVkQ2hhbmdlKTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuLyoqXG4gKiBTZXRzIHVwIHN5bmMgYW5kIGFzeW5jIGRpcmVjdGl2ZSB2YWxpZGF0b3JzIG9uIHByb3ZpZGVkIGZvcm0gY29udHJvbC5cbiAqIFRoaXMgZnVuY3Rpb24gbWVyZ2VzIHZhbGlkYXRvcnMgZnJvbSB0aGUgZGlyZWN0aXZlIGludG8gdGhlIHZhbGlkYXRvcnMgb2YgdGhlIGNvbnRyb2wuXG4gKlxuICogQHBhcmFtIGNvbnRyb2wgRm9ybSBjb250cm9sIHdoZXJlIGRpcmVjdGl2ZSB2YWxpZGF0b3JzIHNob3VsZCBiZSBzZXR1cC5cbiAqIEBwYXJhbSBkaXIgRGlyZWN0aXZlIGluc3RhbmNlIHRoYXQgY29udGFpbnMgdmFsaWRhdG9ycyB0byBiZSBzZXR1cC5cbiAqL1xuZnVuY3Rpb24gc2V0VXBWYWxpZGF0b3JzKGNvbnRyb2wsIGRpcikge1xuICAgIGNvbnN0IHZhbGlkYXRvcnMgPSBnZXRDb250cm9sVmFsaWRhdG9ycyhjb250cm9sKTtcbiAgICBpZiAoZGlyLnZhbGlkYXRvciAhPT0gbnVsbCkge1xuICAgICAgICBjb250cm9sLnNldFZhbGlkYXRvcnMobWVyZ2VWYWxpZGF0b3JzKHZhbGlkYXRvcnMsIGRpci52YWxpZGF0b3IpKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIHZhbGlkYXRvcnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgLy8gSWYgc3luYyB2YWxpZGF0b3JzIGFyZSByZXByZXNlbnRlZCBieSBhIHNpbmdsZSB2YWxpZGF0b3IgZnVuY3Rpb24sIHdlIGZvcmNlIHRoZVxuICAgICAgICAvLyBgVmFsaWRhdG9ycy5jb21wb3NlYCBjYWxsIHRvIGhhcHBlbiBieSBleGVjdXRpbmcgdGhlIGBzZXRWYWxpZGF0b3JzYCBmdW5jdGlvbiB3aXRoXG4gICAgICAgIC8vIGFuIGFycmF5IHRoYXQgY29udGFpbnMgdGhhdCBmdW5jdGlvbi4gV2UgbmVlZCB0aGlzIHRvIGF2b2lkIHBvc3NpYmxlIGRpc2NyZXBhbmNpZXMgaW5cbiAgICAgICAgLy8gdmFsaWRhdG9ycyBiZWhhdmlvciwgc28gc3luYyB2YWxpZGF0b3JzIGFyZSBhbHdheXMgcHJvY2Vzc2VkIGJ5IHRoZSBgVmFsaWRhdG9ycy5jb21wb3NlYC5cbiAgICAgICAgLy8gTm90ZTogd2Ugc2hvdWxkIGNvbnNpZGVyIG1vdmluZyB0aGlzIGxvZ2ljIGluc2lkZSB0aGUgYHNldFZhbGlkYXRvcnNgIGZ1bmN0aW9uIGl0c2VsZiwgc28gd2VcbiAgICAgICAgLy8gaGF2ZSBjb25zaXN0ZW50IGJlaGF2aW9yIG9uIEFic3RyYWN0Q29udHJvbCBBUEkgbGV2ZWwuIFRoZSBzYW1lIGFwcGxpZXMgdG8gdGhlIGFzeW5jXG4gICAgICAgIC8vIHZhbGlkYXRvcnMgbG9naWMgYmVsb3cuXG4gICAgICAgIGNvbnRyb2wuc2V0VmFsaWRhdG9ycyhbdmFsaWRhdG9yc10pO1xuICAgIH1cbiAgICBjb25zdCBhc3luY1ZhbGlkYXRvcnMgPSBnZXRDb250cm9sQXN5bmNWYWxpZGF0b3JzKGNvbnRyb2wpO1xuICAgIGlmIChkaXIuYXN5bmNWYWxpZGF0b3IgIT09IG51bGwpIHtcbiAgICAgICAgY29udHJvbC5zZXRBc3luY1ZhbGlkYXRvcnMobWVyZ2VWYWxpZGF0b3JzKGFzeW5jVmFsaWRhdG9ycywgZGlyLmFzeW5jVmFsaWRhdG9yKSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiBhc3luY1ZhbGlkYXRvcnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgY29udHJvbC5zZXRBc3luY1ZhbGlkYXRvcnMoW2FzeW5jVmFsaWRhdG9yc10pO1xuICAgIH1cbiAgICAvLyBSZS1ydW4gdmFsaWRhdGlvbiB3aGVuIHZhbGlkYXRvciBiaW5kaW5nIGNoYW5nZXMsIGUuZy4gbWlubGVuZ3RoPTMgLT4gbWlubGVuZ3RoPTRcbiAgICBjb25zdCBvblZhbGlkYXRvckNoYW5nZSA9ICgpID0+IGNvbnRyb2wudXBkYXRlVmFsdWVBbmRWYWxpZGl0eSgpO1xuICAgIHJlZ2lzdGVyT25WYWxpZGF0b3JDaGFuZ2UoZGlyLl9yYXdWYWxpZGF0b3JzLCBvblZhbGlkYXRvckNoYW5nZSk7XG4gICAgcmVnaXN0ZXJPblZhbGlkYXRvckNoYW5nZShkaXIuX3Jhd0FzeW5jVmFsaWRhdG9ycywgb25WYWxpZGF0b3JDaGFuZ2UpO1xufVxuLyoqXG4gKiBDbGVhbnMgdXAgc3luYyBhbmQgYXN5bmMgZGlyZWN0aXZlIHZhbGlkYXRvcnMgb24gcHJvdmlkZWQgZm9ybSBjb250cm9sLlxuICogVGhpcyBmdW5jdGlvbiByZXZlcnRzIHRoZSBzZXR1cCBwZXJmb3JtZWQgYnkgdGhlIGBzZXRVcFZhbGlkYXRvcnNgIGZ1bmN0aW9uLCBpLmUuXG4gKiByZW1vdmVzIGRpcmVjdGl2ZS1zcGVjaWZpYyB2YWxpZGF0b3JzIGZyb20gYSBnaXZlbiBjb250cm9sIGluc3RhbmNlLlxuICpcbiAqIEBwYXJhbSBjb250cm9sIEZvcm0gY29udHJvbCBmcm9tIHdoZXJlIGRpcmVjdGl2ZSB2YWxpZGF0b3JzIHNob3VsZCBiZSByZW1vdmVkLlxuICogQHBhcmFtIGRpciBEaXJlY3RpdmUgaW5zdGFuY2UgdGhhdCBjb250YWlucyB2YWxpZGF0b3JzIHRvIGJlIHJlbW92ZWQuXG4gKiBAcmV0dXJucyB0cnVlIGlmIGEgY29udHJvbCB3YXMgdXBkYXRlZCBhcyBhIHJlc3VsdCBvZiB0aGlzIGFjdGlvbi5cbiAqL1xuZnVuY3Rpb24gY2xlYW5VcFZhbGlkYXRvcnMoY29udHJvbCwgZGlyKSB7XG4gICAgbGV0IGlzQ29udHJvbFVwZGF0ZWQgPSBmYWxzZTtcbiAgICBpZiAoY29udHJvbCAhPT0gbnVsbCkge1xuICAgICAgICBpZiAoZGlyLnZhbGlkYXRvciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgY29uc3QgdmFsaWRhdG9ycyA9IGdldENvbnRyb2xWYWxpZGF0b3JzKGNvbnRyb2wpO1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsaWRhdG9ycykgJiYgdmFsaWRhdG9ycy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgLy8gRmlsdGVyIG91dCBkaXJlY3RpdmUgdmFsaWRhdG9yIGZ1bmN0aW9uLlxuICAgICAgICAgICAgICAgIGNvbnN0IHVwZGF0ZWRWYWxpZGF0b3JzID0gdmFsaWRhdG9ycy5maWx0ZXIoKHZhbGlkYXRvcikgPT4gdmFsaWRhdG9yICE9PSBkaXIudmFsaWRhdG9yKTtcbiAgICAgICAgICAgICAgICBpZiAodXBkYXRlZFZhbGlkYXRvcnMubGVuZ3RoICE9PSB2YWxpZGF0b3JzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBpc0NvbnRyb2xVcGRhdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgY29udHJvbC5zZXRWYWxpZGF0b3JzKHVwZGF0ZWRWYWxpZGF0b3JzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRpci5hc3luY1ZhbGlkYXRvciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgY29uc3QgYXN5bmNWYWxpZGF0b3JzID0gZ2V0Q29udHJvbEFzeW5jVmFsaWRhdG9ycyhjb250cm9sKTtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGFzeW5jVmFsaWRhdG9ycykgJiYgYXN5bmNWYWxpZGF0b3JzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAvLyBGaWx0ZXIgb3V0IGRpcmVjdGl2ZSBhc3luYyB2YWxpZGF0b3IgZnVuY3Rpb24uXG4gICAgICAgICAgICAgICAgY29uc3QgdXBkYXRlZEFzeW5jVmFsaWRhdG9ycyA9IGFzeW5jVmFsaWRhdG9ycy5maWx0ZXIoKGFzeW5jVmFsaWRhdG9yKSA9PiBhc3luY1ZhbGlkYXRvciAhPT0gZGlyLmFzeW5jVmFsaWRhdG9yKTtcbiAgICAgICAgICAgICAgICBpZiAodXBkYXRlZEFzeW5jVmFsaWRhdG9ycy5sZW5ndGggIT09IGFzeW5jVmFsaWRhdG9ycy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgaXNDb250cm9sVXBkYXRlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRyb2wuc2V0QXN5bmNWYWxpZGF0b3JzKHVwZGF0ZWRBc3luY1ZhbGlkYXRvcnMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBDbGVhciBvblZhbGlkYXRvckNoYW5nZSBjYWxsYmFja3MgYnkgcHJvdmlkaW5nIGEgbm9vcCBmdW5jdGlvbi5cbiAgICBjb25zdCBub29wID0gKCkgPT4geyB9O1xuICAgIHJlZ2lzdGVyT25WYWxpZGF0b3JDaGFuZ2UoZGlyLl9yYXdWYWxpZGF0b3JzLCBub29wKTtcbiAgICByZWdpc3Rlck9uVmFsaWRhdG9yQ2hhbmdlKGRpci5fcmF3QXN5bmNWYWxpZGF0b3JzLCBub29wKTtcbiAgICByZXR1cm4gaXNDb250cm9sVXBkYXRlZDtcbn1cbmZ1bmN0aW9uIHNldFVwVmlld0NoYW5nZVBpcGVsaW5lKGNvbnRyb2wsIGRpcikge1xuICAgIGRpci52YWx1ZUFjY2Vzc29yLnJlZ2lzdGVyT25DaGFuZ2UoKG5ld1ZhbHVlKSA9PiB7XG4gICAgICAgIGNvbnRyb2wuX3BlbmRpbmdWYWx1ZSA9IG5ld1ZhbHVlO1xuICAgICAgICBjb250cm9sLl9wZW5kaW5nQ2hhbmdlID0gdHJ1ZTtcbiAgICAgICAgY29udHJvbC5fcGVuZGluZ0RpcnR5ID0gdHJ1ZTtcbiAgICAgICAgaWYgKGNvbnRyb2wudXBkYXRlT24gPT09ICdjaGFuZ2UnKVxuICAgICAgICAgICAgdXBkYXRlQ29udHJvbChjb250cm9sLCBkaXIpO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gc2V0VXBCbHVyUGlwZWxpbmUoY29udHJvbCwgZGlyKSB7XG4gICAgZGlyLnZhbHVlQWNjZXNzb3IucmVnaXN0ZXJPblRvdWNoZWQoKCkgPT4ge1xuICAgICAgICBjb250cm9sLl9wZW5kaW5nVG91Y2hlZCA9IHRydWU7XG4gICAgICAgIGlmIChjb250cm9sLnVwZGF0ZU9uID09PSAnYmx1cicgJiYgY29udHJvbC5fcGVuZGluZ0NoYW5nZSlcbiAgICAgICAgICAgIHVwZGF0ZUNvbnRyb2woY29udHJvbCwgZGlyKTtcbiAgICAgICAgaWYgKGNvbnRyb2wudXBkYXRlT24gIT09ICdzdWJtaXQnKVxuICAgICAgICAgICAgY29udHJvbC5tYXJrQXNUb3VjaGVkKCk7XG4gICAgfSk7XG59XG5mdW5jdGlvbiB1cGRhdGVDb250cm9sKGNvbnRyb2wsIGRpcikge1xuICAgIGlmIChjb250cm9sLl9wZW5kaW5nRGlydHkpXG4gICAgICAgIGNvbnRyb2wubWFya0FzRGlydHkoKTtcbiAgICBjb250cm9sLnNldFZhbHVlKGNvbnRyb2wuX3BlbmRpbmdWYWx1ZSwgeyBlbWl0TW9kZWxUb1ZpZXdDaGFuZ2U6IGZhbHNlIH0pO1xuICAgIGRpci52aWV3VG9Nb2RlbFVwZGF0ZShjb250cm9sLl9wZW5kaW5nVmFsdWUpO1xuICAgIGNvbnRyb2wuX3BlbmRpbmdDaGFuZ2UgPSBmYWxzZTtcbn1cbmZ1bmN0aW9uIHNldFVwTW9kZWxDaGFuZ2VQaXBlbGluZShjb250cm9sLCBkaXIpIHtcbiAgICBjb25zdCBvbkNoYW5nZSA9IChuZXdWYWx1ZSwgZW1pdE1vZGVsRXZlbnQpID0+IHtcbiAgICAgICAgLy8gY29udHJvbCAtPiB2aWV3XG4gICAgICAgIGRpci52YWx1ZUFjY2Vzc29yLndyaXRlVmFsdWUobmV3VmFsdWUpO1xuICAgICAgICAvLyBjb250cm9sIC0+IG5nTW9kZWxcbiAgICAgICAgaWYgKGVtaXRNb2RlbEV2ZW50KVxuICAgICAgICAgICAgZGlyLnZpZXdUb01vZGVsVXBkYXRlKG5ld1ZhbHVlKTtcbiAgICB9O1xuICAgIGNvbnRyb2wucmVnaXN0ZXJPbkNoYW5nZShvbkNoYW5nZSk7XG4gICAgLy8gUmVnaXN0ZXIgYSBjYWxsYmFjayBmdW5jdGlvbiB0byBjbGVhbnVwIG9uQ2hhbmdlIGhhbmRsZXJcbiAgICAvLyBmcm9tIGEgY29udHJvbCBpbnN0YW5jZSB3aGVuIGEgZGlyZWN0aXZlIGlzIGRlc3Ryb3llZC5cbiAgICBkaXIuX3JlZ2lzdGVyT25EZXN0cm95KCgpID0+IHtcbiAgICAgICAgY29udHJvbC5fdW5yZWdpc3Rlck9uQ2hhbmdlKG9uQ2hhbmdlKTtcbiAgICB9KTtcbn1cbi8qKlxuICogTGlua3MgYSBGb3JtR3JvdXAgb3IgRm9ybUFycmF5IGluc3RhbmNlIGFuZCBjb3JyZXNwb25kaW5nIEZvcm0gZGlyZWN0aXZlIGJ5IHNldHRpbmcgdXAgdmFsaWRhdG9yc1xuICogcHJlc2VudCBpbiB0aGUgdmlldy5cbiAqXG4gKiBAcGFyYW0gY29udHJvbCBGb3JtR3JvdXAgb3IgRm9ybUFycmF5IGluc3RhbmNlIHRoYXQgc2hvdWxkIGJlIGxpbmtlZC5cbiAqIEBwYXJhbSBkaXIgRGlyZWN0aXZlIHRoYXQgcHJvdmlkZXMgdmlldyB2YWxpZGF0b3JzLlxuICovXG5mdW5jdGlvbiBzZXRVcEZvcm1Db250YWluZXIoY29udHJvbCwgZGlyKSB7XG4gICAgaWYgKGNvbnRyb2wgPT0gbnVsbCAmJiAodHlwZW9mIG5nRGV2TW9kZSA9PT0gJ3VuZGVmaW5lZCcgfHwgbmdEZXZNb2RlKSlcbiAgICAgICAgX3Rocm93RXJyb3IoZGlyLCAnQ2Fubm90IGZpbmQgY29udHJvbCB3aXRoJyk7XG4gICAgc2V0VXBWYWxpZGF0b3JzKGNvbnRyb2wsIGRpcik7XG59XG4vKipcbiAqIFJldmVydHMgdGhlIHNldHVwIHBlcmZvcm1lZCBieSB0aGUgYHNldFVwRm9ybUNvbnRhaW5lcmAgZnVuY3Rpb24uXG4gKlxuICogQHBhcmFtIGNvbnRyb2wgRm9ybUdyb3VwIG9yIEZvcm1BcnJheSBpbnN0YW5jZSB0aGF0IHNob3VsZCBiZSBjbGVhbmVkIHVwLlxuICogQHBhcmFtIGRpciBEaXJlY3RpdmUgdGhhdCBwcm92aWRlZCB2aWV3IHZhbGlkYXRvcnMuXG4gKiBAcmV0dXJucyB0cnVlIGlmIGEgY29udHJvbCB3YXMgdXBkYXRlZCBhcyBhIHJlc3VsdCBvZiB0aGlzIGFjdGlvbi5cbiAqL1xuZnVuY3Rpb24gY2xlYW5VcEZvcm1Db250YWluZXIoY29udHJvbCwgZGlyKSB7XG4gICAgcmV0dXJuIGNsZWFuVXBWYWxpZGF0b3JzKGNvbnRyb2wsIGRpcik7XG59XG5mdW5jdGlvbiBfbm9Db250cm9sRXJyb3IoZGlyKSB7XG4gICAgcmV0dXJuIF90aHJvd0Vycm9yKGRpciwgJ1RoZXJlIGlzIG5vIEZvcm1Db250cm9sIGluc3RhbmNlIGF0dGFjaGVkIHRvIGZvcm0gY29udHJvbCBlbGVtZW50IHdpdGgnKTtcbn1cbmZ1bmN0aW9uIF90aHJvd0Vycm9yKGRpciwgbWVzc2FnZSkge1xuICAgIGNvbnN0IG1lc3NhZ2VFbmQgPSBfZGVzY3JpYmVDb250cm9sTG9jYXRpb24oZGlyKTtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYCR7bWVzc2FnZX0gJHttZXNzYWdlRW5kfWApO1xufVxuZnVuY3Rpb24gX2Rlc2NyaWJlQ29udHJvbExvY2F0aW9uKGRpcikge1xuICAgIGNvbnN0IHBhdGggPSBkaXIucGF0aDtcbiAgICBpZiAocGF0aCAmJiBwYXRoLmxlbmd0aCA+IDEpXG4gICAgICAgIHJldHVybiBgcGF0aDogJyR7cGF0aC5qb2luKCcgLT4gJyl9J2A7XG4gICAgaWYgKHBhdGg/LlswXSlcbiAgICAgICAgcmV0dXJuIGBuYW1lOiAnJHtwYXRofSdgO1xuICAgIHJldHVybiAndW5zcGVjaWZpZWQgbmFtZSBhdHRyaWJ1dGUnO1xufVxuZnVuY3Rpb24gX3Rocm93TWlzc2luZ1ZhbHVlQWNjZXNzb3JFcnJvcihkaXIpIHtcbiAgICBjb25zdCBsb2MgPSBfZGVzY3JpYmVDb250cm9sTG9jYXRpb24oZGlyKTtcbiAgICB0aHJvdyBuZXcgybVSdW50aW1lRXJyb3IoLTEyMDMgLyogUnVudGltZUVycm9yQ29kZS5OR19NSVNTSU5HX1ZBTFVFX0FDQ0VTU09SICovLCBgTm8gdmFsdWUgYWNjZXNzb3IgZm9yIGZvcm0gY29udHJvbCAke2xvY30uYCk7XG59XG5mdW5jdGlvbiBfdGhyb3dJbnZhbGlkVmFsdWVBY2Nlc3NvckVycm9yKGRpcikge1xuICAgIGNvbnN0IGxvYyA9IF9kZXNjcmliZUNvbnRyb2xMb2NhdGlvbihkaXIpO1xuICAgIHRocm93IG5ldyDJtVJ1bnRpbWVFcnJvcigxMjAwIC8qIFJ1bnRpbWVFcnJvckNvZGUuTkdfVkFMVUVfQUNDRVNTT1JfTk9UX1BST1ZJREVEICovLCBgVmFsdWUgYWNjZXNzb3Igd2FzIG5vdCBwcm92aWRlZCBhcyBhbiBhcnJheSBmb3IgZm9ybSBjb250cm9sIHdpdGggJHtsb2N9LiBgICtcbiAgICAgICAgYENoZWNrIHRoYXQgdGhlIFxcYE5HX1ZBTFVFX0FDQ0VTU09SXFxgIHRva2VuIGlzIGNvbmZpZ3VyZWQgYXMgYSBcXGBtdWx0aTogdHJ1ZVxcYCBwcm92aWRlci5gKTtcbn1cbmZ1bmN0aW9uIGlzUHJvcGVydHlVcGRhdGVkKGNoYW5nZXMsIHZpZXdNb2RlbCkge1xuICAgIGlmICghY2hhbmdlcy5oYXNPd25Qcm9wZXJ0eSgnbW9kZWwnKSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGNvbnN0IGNoYW5nZSA9IGNoYW5nZXNbJ21vZGVsJ107XG4gICAgaWYgKGNoYW5nZS5pc0ZpcnN0Q2hhbmdlKCkpXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIHJldHVybiAhT2JqZWN0LmlzKHZpZXdNb2RlbCwgY2hhbmdlLmN1cnJlbnRWYWx1ZSk7XG59XG5mdW5jdGlvbiBpc0J1aWx0SW5BY2Nlc3Nvcih2YWx1ZUFjY2Vzc29yKSB7XG4gICAgLy8gQ2hlY2sgaWYgYSBnaXZlbiB2YWx1ZSBhY2Nlc3NvciBpcyBhbiBpbnN0YW5jZSBvZiBhIGNsYXNzIHRoYXQgZGlyZWN0bHkgZXh0ZW5kc1xuICAgIC8vIGBCdWlsdEluQ29udHJvbFZhbHVlQWNjZXNzb3JgIG9uZS5cbiAgICByZXR1cm4gT2JqZWN0LmdldFByb3RvdHlwZU9mKHZhbHVlQWNjZXNzb3IuY29uc3RydWN0b3IpID09PSBCdWlsdEluQ29udHJvbFZhbHVlQWNjZXNzb3I7XG59XG5mdW5jdGlvbiBzeW5jUGVuZGluZ0NvbnRyb2xzKGZvcm0sIGRpcmVjdGl2ZXMpIHtcbiAgICBmb3JtLl9zeW5jUGVuZGluZ0NvbnRyb2xzKCk7XG4gICAgZGlyZWN0aXZlcy5mb3JFYWNoKChkaXIpID0+IHtcbiAgICAgICAgY29uc3QgY29udHJvbCA9IGRpci5jb250cm9sO1xuICAgICAgICBpZiAoY29udHJvbC51cGRhdGVPbiA9PT0gJ3N1Ym1pdCcgJiYgY29udHJvbC5fcGVuZGluZ0NoYW5nZSkge1xuICAgICAgICAgICAgZGlyLnZpZXdUb01vZGVsVXBkYXRlKGNvbnRyb2wuX3BlbmRpbmdWYWx1ZSk7XG4gICAgICAgICAgICBjb250cm9sLl9wZW5kaW5nQ2hhbmdlID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbi8vIFRPRE86IHZzYXZraW4gcmVtb3ZlIGl0IG9uY2UgaHR0cHM6Ly9naXRodWIuY29tL2FuZ3VsYXIvYW5ndWxhci9pc3N1ZXMvMzAxMSBpcyBpbXBsZW1lbnRlZFxuZnVuY3Rpb24gc2VsZWN0VmFsdWVBY2Nlc3NvcihkaXIsIHZhbHVlQWNjZXNzb3JzKSB7XG4gICAgaWYgKCF2YWx1ZUFjY2Vzc29ycylcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHZhbHVlQWNjZXNzb3JzKSAmJiAodHlwZW9mIG5nRGV2TW9kZSA9PT0gJ3VuZGVmaW5lZCcgfHwgbmdEZXZNb2RlKSlcbiAgICAgICAgX3Rocm93SW52YWxpZFZhbHVlQWNjZXNzb3JFcnJvcihkaXIpO1xuICAgIGxldCBkZWZhdWx0QWNjZXNzb3IgPSB1bmRlZmluZWQ7XG4gICAgbGV0IGJ1aWx0aW5BY2Nlc3NvciA9IHVuZGVmaW5lZDtcbiAgICBsZXQgY3VzdG9tQWNjZXNzb3IgPSB1bmRlZmluZWQ7XG4gICAgdmFsdWVBY2Nlc3NvcnMuZm9yRWFjaCgodikgPT4ge1xuICAgICAgICBpZiAodi5jb25zdHJ1Y3RvciA9PT0gRGVmYXVsdFZhbHVlQWNjZXNzb3IpIHtcbiAgICAgICAgICAgIGRlZmF1bHRBY2Nlc3NvciA9IHY7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNCdWlsdEluQWNjZXNzb3IodikpIHtcbiAgICAgICAgICAgIGlmIChidWlsdGluQWNjZXNzb3IgJiYgKHR5cGVvZiBuZ0Rldk1vZGUgPT09ICd1bmRlZmluZWQnIHx8IG5nRGV2TW9kZSkpXG4gICAgICAgICAgICAgICAgX3Rocm93RXJyb3IoZGlyLCAnTW9yZSB0aGFuIG9uZSBidWlsdC1pbiB2YWx1ZSBhY2Nlc3NvciBtYXRjaGVzIGZvcm0gY29udHJvbCB3aXRoJyk7XG4gICAgICAgICAgICBidWlsdGluQWNjZXNzb3IgPSB2O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKGN1c3RvbUFjY2Vzc29yICYmICh0eXBlb2YgbmdEZXZNb2RlID09PSAndW5kZWZpbmVkJyB8fCBuZ0Rldk1vZGUpKVxuICAgICAgICAgICAgICAgIF90aHJvd0Vycm9yKGRpciwgJ01vcmUgdGhhbiBvbmUgY3VzdG9tIHZhbHVlIGFjY2Vzc29yIG1hdGNoZXMgZm9ybSBjb250cm9sIHdpdGgnKTtcbiAgICAgICAgICAgIGN1c3RvbUFjY2Vzc29yID0gdjtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIGlmIChjdXN0b21BY2Nlc3NvcilcbiAgICAgICAgcmV0dXJuIGN1c3RvbUFjY2Vzc29yO1xuICAgIGlmIChidWlsdGluQWNjZXNzb3IpXG4gICAgICAgIHJldHVybiBidWlsdGluQWNjZXNzb3I7XG4gICAgaWYgKGRlZmF1bHRBY2Nlc3NvcilcbiAgICAgICAgcmV0dXJuIGRlZmF1bHRBY2Nlc3NvcjtcbiAgICBpZiAodHlwZW9mIG5nRGV2TW9kZSA9PT0gJ3VuZGVmaW5lZCcgfHwgbmdEZXZNb2RlKSB7XG4gICAgICAgIF90aHJvd0Vycm9yKGRpciwgJ05vIHZhbGlkIHZhbHVlIGFjY2Vzc29yIGZvciBmb3JtIGNvbnRyb2wgd2l0aCcpO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIHJlbW92ZUxpc3RJdGVtJDEobGlzdCwgZWwpIHtcbiAgICBjb25zdCBpbmRleCA9IGxpc3QuaW5kZXhPZihlbCk7XG4gICAgaWYgKGluZGV4ID4gLTEpXG4gICAgICAgIGxpc3Quc3BsaWNlKGluZGV4LCAxKTtcbn1cbi8vIFRPRE8oa2FyYSk6IHJlbW92ZSBhZnRlciBkZXByZWNhdGlvbiBwZXJpb2RcbmZ1bmN0aW9uIF9uZ01vZGVsV2FybmluZyhuYW1lLCB0eXBlLCBpbnN0YW5jZSwgd2FybmluZ0NvbmZpZykge1xuICAgIGlmICh3YXJuaW5nQ29uZmlnID09PSAnbmV2ZXInKVxuICAgICAgICByZXR1cm47XG4gICAgaWYgKCgod2FybmluZ0NvbmZpZyA9PT0gbnVsbCB8fCB3YXJuaW5nQ29uZmlnID09PSAnb25jZScpICYmICF0eXBlLl9uZ01vZGVsV2FybmluZ1NlbnRPbmNlKSB8fFxuICAgICAgICAod2FybmluZ0NvbmZpZyA9PT0gJ2Fsd2F5cycgJiYgIWluc3RhbmNlLl9uZ01vZGVsV2FybmluZ1NlbnQpKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihuZ01vZGVsV2FybmluZyhuYW1lKSk7XG4gICAgICAgIHR5cGUuX25nTW9kZWxXYXJuaW5nU2VudE9uY2UgPSB0cnVlO1xuICAgICAgICBpbnN0YW5jZS5fbmdNb2RlbFdhcm5pbmdTZW50ID0gdHJ1ZTtcbiAgICB9XG59XG5cbmNvbnN0IGZvcm1EaXJlY3RpdmVQcm92aWRlciQxID0ge1xuICAgIHByb3ZpZGU6IENvbnRyb2xDb250YWluZXIsXG4gICAgdXNlRXhpc3Rpbmc6IGZvcndhcmRSZWYoKCkgPT4gTmdGb3JtKVxufTtcbmNvbnN0IHJlc29sdmVkUHJvbWlzZSQxID0gKCgpID0+IFByb21pc2UucmVzb2x2ZSgpKSgpO1xuLyoqXG4gKiBAZGVzY3JpcHRpb25cbiAqIENyZWF0ZXMgYSB0b3AtbGV2ZWwgYEZvcm1Hcm91cGAgaW5zdGFuY2UgYW5kIGJpbmRzIGl0IHRvIGEgZm9ybVxuICogdG8gdHJhY2sgYWdncmVnYXRlIGZvcm0gdmFsdWUgYW5kIHZhbGlkYXRpb24gc3RhdHVzLlxuICpcbiAqIEFzIHNvb24gYXMgeW91IGltcG9ydCB0aGUgYEZvcm1zTW9kdWxlYCwgdGhpcyBkaXJlY3RpdmUgYmVjb21lcyBhY3RpdmUgYnkgZGVmYXVsdCBvblxuICogYWxsIGA8Zm9ybT5gIHRhZ3MuICBZb3UgZG9uJ3QgbmVlZCB0byBhZGQgYSBzcGVjaWFsIHNlbGVjdG9yLlxuICpcbiAqIFlvdSBvcHRpb25hbGx5IGV4cG9ydCB0aGUgZGlyZWN0aXZlIGludG8gYSBsb2NhbCB0ZW1wbGF0ZSB2YXJpYWJsZSB1c2luZyBgbmdGb3JtYCBhcyB0aGUga2V5XG4gKiAoZXg6IGAjbXlGb3JtPVwibmdGb3JtXCJgKS4gVGhpcyBpcyBvcHRpb25hbCwgYnV0IHVzZWZ1bC4gIE1hbnkgcHJvcGVydGllcyBmcm9tIHRoZSB1bmRlcmx5aW5nXG4gKiBgRm9ybUdyb3VwYCBpbnN0YW5jZSBhcmUgZHVwbGljYXRlZCBvbiB0aGUgZGlyZWN0aXZlIGl0c2VsZiwgc28gYSByZWZlcmVuY2UgdG8gaXRcbiAqIGdpdmVzIHlvdSBhY2Nlc3MgdG8gdGhlIGFnZ3JlZ2F0ZSB2YWx1ZSBhbmQgdmFsaWRpdHkgc3RhdHVzIG9mIHRoZSBmb3JtLCBhcyB3ZWxsIGFzXG4gKiB1c2VyIGludGVyYWN0aW9uIHByb3BlcnRpZXMgbGlrZSBgZGlydHlgIGFuZCBgdG91Y2hlZGAuXG4gKlxuICogVG8gcmVnaXN0ZXIgY2hpbGQgY29udHJvbHMgd2l0aCB0aGUgZm9ybSwgdXNlIGBOZ01vZGVsYCB3aXRoIGEgYG5hbWVgXG4gKiBhdHRyaWJ1dGUuIFlvdSBtYXkgdXNlIGBOZ01vZGVsR3JvdXBgIHRvIGNyZWF0ZSBzdWItZ3JvdXBzIHdpdGhpbiB0aGUgZm9ybS5cbiAqXG4gKiBJZiBuZWNlc3NhcnksIGxpc3RlbiB0byB0aGUgZGlyZWN0aXZlJ3MgYG5nU3VibWl0YCBldmVudCB0byBiZSBub3RpZmllZCB3aGVuIHRoZSB1c2VyIGhhc1xuICogdHJpZ2dlcmVkIGEgZm9ybSBzdWJtaXNzaW9uLiBUaGUgYG5nU3VibWl0YCBldmVudCBlbWl0cyB0aGUgb3JpZ2luYWwgZm9ybVxuICogc3VibWlzc2lvbiBldmVudC5cbiAqXG4gKiBJbiB0ZW1wbGF0ZSBkcml2ZW4gZm9ybXMsIGFsbCBgPGZvcm0+YCB0YWdzIGFyZSBhdXRvbWF0aWNhbGx5IHRhZ2dlZCBhcyBgTmdGb3JtYC5cbiAqIFRvIGltcG9ydCB0aGUgYEZvcm1zTW9kdWxlYCBidXQgc2tpcCBpdHMgdXNhZ2UgaW4gc29tZSBmb3JtcyxcbiAqIGZvciBleGFtcGxlLCB0byB1c2UgbmF0aXZlIEhUTUw1IHZhbGlkYXRpb24sIGFkZCB0aGUgYG5nTm9Gb3JtYCBhbmQgdGhlIGA8Zm9ybT5gXG4gKiB0YWdzIHdvbid0IGNyZWF0ZSBhbiBgTmdGb3JtYCBkaXJlY3RpdmUuIEluIHJlYWN0aXZlIGZvcm1zLCB1c2luZyBgbmdOb0Zvcm1gIGlzXG4gKiB1bm5lY2Vzc2FyeSBiZWNhdXNlIHRoZSBgPGZvcm0+YCB0YWdzIGFyZSBpbmVydC4gSW4gdGhhdCBjYXNlLCB5b3Ugd291bGRcbiAqIHJlZnJhaW4gZnJvbSB1c2luZyB0aGUgYGZvcm1Hcm91cGAgZGlyZWN0aXZlLlxuICpcbiAqIEB1c2FnZU5vdGVzXG4gKlxuICogIyMjIExpc3RlbmluZyBmb3IgZm9ybSBzdWJtaXNzaW9uXG4gKlxuICogVGhlIGZvbGxvd2luZyBleGFtcGxlIHNob3dzIGhvdyB0byBjYXB0dXJlIHRoZSBmb3JtIHZhbHVlcyBmcm9tIHRoZSBcIm5nU3VibWl0XCIgZXZlbnQuXG4gKlxuICoge0BleGFtcGxlIGZvcm1zL3RzL3NpbXBsZUZvcm0vc2ltcGxlX2Zvcm1fZXhhbXBsZS50cyByZWdpb249J0NvbXBvbmVudCd9XG4gKlxuICogIyMjIFNldHRpbmcgdGhlIHVwZGF0ZSBvcHRpb25zXG4gKlxuICogVGhlIGZvbGxvd2luZyBleGFtcGxlIHNob3dzIHlvdSBob3cgdG8gY2hhbmdlIHRoZSBcInVwZGF0ZU9uXCIgb3B0aW9uIGZyb20gaXRzIGRlZmF1bHQgdXNpbmdcbiAqIG5nRm9ybU9wdGlvbnMuXG4gKlxuICogYGBgaHRtbFxuICogPGZvcm0gW25nRm9ybU9wdGlvbnNdPVwie3VwZGF0ZU9uOiAnYmx1cid9XCI+XG4gKiAgICA8aW5wdXQgbmFtZT1cIm9uZVwiIG5nTW9kZWw+ICA8IS0tIHRoaXMgbmdNb2RlbCB3aWxsIHVwZGF0ZSBvbiBibHVyIC0tPlxuICogPC9mb3JtPlxuICogYGBgXG4gKlxuICogIyMjIE5hdGl2ZSBET00gdmFsaWRhdGlvbiBVSVxuICpcbiAqIEluIG9yZGVyIHRvIHByZXZlbnQgdGhlIG5hdGl2ZSBET00gZm9ybSB2YWxpZGF0aW9uIFVJIGZyb20gaW50ZXJmZXJpbmcgd2l0aCBBbmd1bGFyJ3MgZm9ybVxuICogdmFsaWRhdGlvbiwgQW5ndWxhciBhdXRvbWF0aWNhbGx5IGFkZHMgdGhlIGBub3ZhbGlkYXRlYCBhdHRyaWJ1dGUgb24gYW55IGA8Zm9ybT5gIHdoZW5ldmVyXG4gKiBgRm9ybU1vZHVsZWAgb3IgYFJlYWN0aXZlRm9ybU1vZHVsZWAgYXJlIGltcG9ydGVkIGludG8gdGhlIGFwcGxpY2F0aW9uLlxuICogSWYgeW91IHdhbnQgdG8gZXhwbGljaXRseSBlbmFibGUgbmF0aXZlIERPTSB2YWxpZGF0aW9uIFVJIHdpdGggQW5ndWxhciBmb3JtcywgeW91IGNhbiBhZGQgdGhlXG4gKiBgbmdOYXRpdmVWYWxpZGF0ZWAgYXR0cmlidXRlIHRvIHRoZSBgPGZvcm0+YCBlbGVtZW50OlxuICpcbiAqIGBgYGh0bWxcbiAqIDxmb3JtIG5nTmF0aXZlVmFsaWRhdGU+XG4gKiAgIC4uLlxuICogPC9mb3JtPlxuICogYGBgXG4gKlxuICogQG5nTW9kdWxlIEZvcm1zTW9kdWxlXG4gKiBAcHVibGljQXBpXG4gKi9cbmNsYXNzIE5nRm9ybSBleHRlbmRzIENvbnRyb2xDb250YWluZXIge1xuICAgIGNvbnN0cnVjdG9yKHZhbGlkYXRvcnMsIGFzeW5jVmFsaWRhdG9ycywgY2FsbFNldERpc2FibGVkU3RhdGUpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5jYWxsU2V0RGlzYWJsZWRTdGF0ZSA9IGNhbGxTZXREaXNhYmxlZFN0YXRlO1xuICAgICAgICAvKipcbiAgICAgICAgICogQGRlc2NyaXB0aW9uXG4gICAgICAgICAqIFJldHVybnMgd2hldGhlciB0aGUgZm9ybSBzdWJtaXNzaW9uIGhhcyBiZWVuIHRyaWdnZXJlZC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc3VibWl0dGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2RpcmVjdGl2ZXMgPSBuZXcgU2V0KCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgICAgICogRXZlbnQgZW1pdHRlciBmb3IgdGhlIFwibmdTdWJtaXRcIiBldmVudFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5uZ1N1Ym1pdCA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgdGhpcy5mb3JtID1cbiAgICAgICAgICAgIG5ldyBGb3JtR3JvdXAoe30sIGNvbXBvc2VWYWxpZGF0b3JzKHZhbGlkYXRvcnMpLCBjb21wb3NlQXN5bmNWYWxpZGF0b3JzKGFzeW5jVmFsaWRhdG9ycykpO1xuICAgIH1cbiAgICAvKiogQG5vZG9jICovXG4gICAgbmdBZnRlclZpZXdJbml0KCkge1xuICAgICAgICB0aGlzLl9zZXRVcGRhdGVTdHJhdGVneSgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKiBUaGUgZGlyZWN0aXZlIGluc3RhbmNlLlxuICAgICAqL1xuICAgIGdldCBmb3JtRGlyZWN0aXZlKCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICogVGhlIGludGVybmFsIGBGb3JtR3JvdXBgIGluc3RhbmNlLlxuICAgICAqL1xuICAgIGdldCBjb250cm9sKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5mb3JtO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKiBSZXR1cm5zIGFuIGFycmF5IHJlcHJlc2VudGluZyB0aGUgcGF0aCB0byB0aGlzIGdyb3VwLiBCZWNhdXNlIHRoaXMgZGlyZWN0aXZlXG4gICAgICogYWx3YXlzIGxpdmVzIGF0IHRoZSB0b3AgbGV2ZWwgb2YgYSBmb3JtLCBpdCBpcyBhbHdheXMgYW4gZW1wdHkgYXJyYXkuXG4gICAgICovXG4gICAgZ2V0IHBhdGgoKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICogUmV0dXJucyBhIG1hcCBvZiB0aGUgY29udHJvbHMgaW4gdGhpcyBncm91cC5cbiAgICAgKi9cbiAgICBnZXQgY29udHJvbHMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZvcm0uY29udHJvbHM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqIE1ldGhvZCB0aGF0IHNldHMgdXAgdGhlIGNvbnRyb2wgZGlyZWN0aXZlIGluIHRoaXMgZ3JvdXAsIHJlLWNhbGN1bGF0ZXMgaXRzIHZhbHVlXG4gICAgICogYW5kIHZhbGlkaXR5LCBhbmQgYWRkcyB0aGUgaW5zdGFuY2UgdG8gdGhlIGludGVybmFsIGxpc3Qgb2YgZGlyZWN0aXZlcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBkaXIgVGhlIGBOZ01vZGVsYCBkaXJlY3RpdmUgaW5zdGFuY2UuXG4gICAgICovXG4gICAgYWRkQ29udHJvbChkaXIpIHtcbiAgICAgICAgcmVzb2x2ZWRQcm9taXNlJDEudGhlbigoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBjb250YWluZXIgPSB0aGlzLl9maW5kQ29udGFpbmVyKGRpci5wYXRoKTtcbiAgICAgICAgICAgIGRpci5jb250cm9sID1cbiAgICAgICAgICAgICAgICBjb250YWluZXIucmVnaXN0ZXJDb250cm9sKGRpci5uYW1lLCBkaXIuY29udHJvbCk7XG4gICAgICAgICAgICBzZXRVcENvbnRyb2woZGlyLmNvbnRyb2wsIGRpciwgdGhpcy5jYWxsU2V0RGlzYWJsZWRTdGF0ZSk7XG4gICAgICAgICAgICBkaXIuY29udHJvbC51cGRhdGVWYWx1ZUFuZFZhbGlkaXR5KHsgZW1pdEV2ZW50OiBmYWxzZSB9KTtcbiAgICAgICAgICAgIHRoaXMuX2RpcmVjdGl2ZXMuYWRkKGRpcik7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKiBSZXRyaWV2ZXMgdGhlIGBGb3JtQ29udHJvbGAgaW5zdGFuY2UgZnJvbSB0aGUgcHJvdmlkZWQgYE5nTW9kZWxgIGRpcmVjdGl2ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBkaXIgVGhlIGBOZ01vZGVsYCBkaXJlY3RpdmUgaW5zdGFuY2UuXG4gICAgICovXG4gICAgZ2V0Q29udHJvbChkaXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZm9ybS5nZXQoZGlyLnBhdGgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKiBSZW1vdmVzIHRoZSBgTmdNb2RlbGAgaW5zdGFuY2UgZnJvbSB0aGUgaW50ZXJuYWwgbGlzdCBvZiBkaXJlY3RpdmVzXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZGlyIFRoZSBgTmdNb2RlbGAgZGlyZWN0aXZlIGluc3RhbmNlLlxuICAgICAqL1xuICAgIHJlbW92ZUNvbnRyb2woZGlyKSB7XG4gICAgICAgIHJlc29sdmVkUHJvbWlzZSQxLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgY29udGFpbmVyID0gdGhpcy5fZmluZENvbnRhaW5lcihkaXIucGF0aCk7XG4gICAgICAgICAgICBpZiAoY29udGFpbmVyKSB7XG4gICAgICAgICAgICAgICAgY29udGFpbmVyLnJlbW92ZUNvbnRyb2woZGlyLm5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fZGlyZWN0aXZlcy5kZWxldGUoZGlyKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqIEFkZHMgYSBuZXcgYE5nTW9kZWxHcm91cGAgZGlyZWN0aXZlIGluc3RhbmNlIHRvIHRoZSBmb3JtLlxuICAgICAqXG4gICAgICogQHBhcmFtIGRpciBUaGUgYE5nTW9kZWxHcm91cGAgZGlyZWN0aXZlIGluc3RhbmNlLlxuICAgICAqL1xuICAgIGFkZEZvcm1Hcm91cChkaXIpIHtcbiAgICAgICAgcmVzb2x2ZWRQcm9taXNlJDEudGhlbigoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBjb250YWluZXIgPSB0aGlzLl9maW5kQ29udGFpbmVyKGRpci5wYXRoKTtcbiAgICAgICAgICAgIGNvbnN0IGdyb3VwID0gbmV3IEZvcm1Hcm91cCh7fSk7XG4gICAgICAgICAgICBzZXRVcEZvcm1Db250YWluZXIoZ3JvdXAsIGRpcik7XG4gICAgICAgICAgICBjb250YWluZXIucmVnaXN0ZXJDb250cm9sKGRpci5uYW1lLCBncm91cCk7XG4gICAgICAgICAgICBncm91cC51cGRhdGVWYWx1ZUFuZFZhbGlkaXR5KHsgZW1pdEV2ZW50OiBmYWxzZSB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqIFJlbW92ZXMgdGhlIGBOZ01vZGVsR3JvdXBgIGRpcmVjdGl2ZSBpbnN0YW5jZSBmcm9tIHRoZSBmb3JtLlxuICAgICAqXG4gICAgICogQHBhcmFtIGRpciBUaGUgYE5nTW9kZWxHcm91cGAgZGlyZWN0aXZlIGluc3RhbmNlLlxuICAgICAqL1xuICAgIHJlbW92ZUZvcm1Hcm91cChkaXIpIHtcbiAgICAgICAgcmVzb2x2ZWRQcm9taXNlJDEudGhlbigoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBjb250YWluZXIgPSB0aGlzLl9maW5kQ29udGFpbmVyKGRpci5wYXRoKTtcbiAgICAgICAgICAgIGlmIChjb250YWluZXIpIHtcbiAgICAgICAgICAgICAgICBjb250YWluZXIucmVtb3ZlQ29udHJvbChkaXIubmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKiBSZXRyaWV2ZXMgdGhlIGBGb3JtR3JvdXBgIGZvciBhIHByb3ZpZGVkIGBOZ01vZGVsR3JvdXBgIGRpcmVjdGl2ZSBpbnN0YW5jZVxuICAgICAqXG4gICAgICogQHBhcmFtIGRpciBUaGUgYE5nTW9kZWxHcm91cGAgZGlyZWN0aXZlIGluc3RhbmNlLlxuICAgICAqL1xuICAgIGdldEZvcm1Hcm91cChkaXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZm9ybS5nZXQoZGlyLnBhdGgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBuZXcgdmFsdWUgZm9yIHRoZSBwcm92aWRlZCBgTmdDb250cm9sYCBkaXJlY3RpdmUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZGlyIFRoZSBgTmdDb250cm9sYCBkaXJlY3RpdmUgaW5zdGFuY2UuXG4gICAgICogQHBhcmFtIHZhbHVlIFRoZSBuZXcgdmFsdWUgZm9yIHRoZSBkaXJlY3RpdmUncyBjb250cm9sLlxuICAgICAqL1xuICAgIHVwZGF0ZU1vZGVsKGRpciwgdmFsdWUpIHtcbiAgICAgICAgcmVzb2x2ZWRQcm9taXNlJDEudGhlbigoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBjdHJsID0gdGhpcy5mb3JtLmdldChkaXIucGF0aCk7XG4gICAgICAgICAgICBjdHJsLnNldFZhbHVlKHZhbHVlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqIFNldHMgdGhlIHZhbHVlIGZvciB0aGlzIGBGb3JtR3JvdXBgLlxuICAgICAqXG4gICAgICogQHBhcmFtIHZhbHVlIFRoZSBuZXcgdmFsdWVcbiAgICAgKi9cbiAgICBzZXRWYWx1ZSh2YWx1ZSkge1xuICAgICAgICB0aGlzLmNvbnRyb2wuc2V0VmFsdWUodmFsdWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKiBNZXRob2QgY2FsbGVkIHdoZW4gdGhlIFwic3VibWl0XCIgZXZlbnQgaXMgdHJpZ2dlcmVkIG9uIHRoZSBmb3JtLlxuICAgICAqIFRyaWdnZXJzIHRoZSBgbmdTdWJtaXRgIGVtaXR0ZXIgdG8gZW1pdCB0aGUgXCJzdWJtaXRcIiBldmVudCBhcyBpdHMgcGF5bG9hZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSAkZXZlbnQgVGhlIFwic3VibWl0XCIgZXZlbnQgb2JqZWN0XG4gICAgICovXG4gICAgb25TdWJtaXQoJGV2ZW50KSB7XG4gICAgICAgIHRoaXMuc3VibWl0dGVkID0gdHJ1ZTtcbiAgICAgICAgc3luY1BlbmRpbmdDb250cm9scyh0aGlzLmZvcm0sIHRoaXMuX2RpcmVjdGl2ZXMpO1xuICAgICAgICB0aGlzLm5nU3VibWl0LmVtaXQoJGV2ZW50KTtcbiAgICAgICAgLy8gRm9ybXMgd2l0aCBgbWV0aG9kPVwiZGlhbG9nXCJgIGhhdmUgc29tZSBzcGVjaWFsIGJlaGF2aW9yXG4gICAgICAgIC8vIHRoYXQgd29uJ3QgcmVsb2FkIHRoZSBwYWdlIGFuZCB0aGF0IHNob3VsZG4ndCBiZSBwcmV2ZW50ZWQuXG4gICAgICAgIHJldHVybiAkZXZlbnQ/LnRhcmdldD8ubWV0aG9kID09PSAnZGlhbG9nJztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICogTWV0aG9kIGNhbGxlZCB3aGVuIHRoZSBcInJlc2V0XCIgZXZlbnQgaXMgdHJpZ2dlcmVkIG9uIHRoZSBmb3JtLlxuICAgICAqL1xuICAgIG9uUmVzZXQoKSB7XG4gICAgICAgIHRoaXMucmVzZXRGb3JtKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqIFJlc2V0cyB0aGUgZm9ybSB0byBhbiBpbml0aWFsIHZhbHVlIGFuZCByZXNldHMgaXRzIHN1Ym1pdHRlZCBzdGF0dXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdmFsdWUgVGhlIG5ldyB2YWx1ZSBmb3IgdGhlIGZvcm0uXG4gICAgICovXG4gICAgcmVzZXRGb3JtKHZhbHVlID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMuZm9ybS5yZXNldCh2YWx1ZSk7XG4gICAgICAgIHRoaXMuc3VibWl0dGVkID0gZmFsc2U7XG4gICAgfVxuICAgIF9zZXRVcGRhdGVTdHJhdGVneSgpIHtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucyAmJiB0aGlzLm9wdGlvbnMudXBkYXRlT24gIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5mb3JtLl91cGRhdGVPbiA9IHRoaXMub3B0aW9ucy51cGRhdGVPbjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfZmluZENvbnRhaW5lcihwYXRoKSB7XG4gICAgICAgIHBhdGgucG9wKCk7XG4gICAgICAgIHJldHVybiBwYXRoLmxlbmd0aCA/IHRoaXMuZm9ybS5nZXQocGF0aCkgOiB0aGlzLmZvcm07XG4gICAgfVxuICAgIHN0YXRpYyB7IHRoaXMuybVmYWMgPSBpMC7Jtcm1bmdEZWNsYXJlRmFjdG9yeSh7IG1pblZlcnNpb246IFwiMTIuMC4wXCIsIHZlcnNpb246IFwiMTcuMy4xMlwiLCBuZ0ltcG9ydDogaTAsIHR5cGU6IE5nRm9ybSwgZGVwczogW3sgdG9rZW46IE5HX1ZBTElEQVRPUlMsIG9wdGlvbmFsOiB0cnVlLCBzZWxmOiB0cnVlIH0sIHsgdG9rZW46IE5HX0FTWU5DX1ZBTElEQVRPUlMsIG9wdGlvbmFsOiB0cnVlLCBzZWxmOiB0cnVlIH0sIHsgdG9rZW46IENBTExfU0VUX0RJU0FCTEVEX1NUQVRFLCBvcHRpb25hbDogdHJ1ZSB9XSwgdGFyZ2V0OiBpMC7Jtcm1RmFjdG9yeVRhcmdldC5EaXJlY3RpdmUgfSk7IH1cbiAgICBzdGF0aWMgeyB0aGlzLsm1ZGlyID0gaTAuybXJtW5nRGVjbGFyZURpcmVjdGl2ZSh7IG1pblZlcnNpb246IFwiMTQuMC4wXCIsIHZlcnNpb246IFwiMTcuMy4xMlwiLCB0eXBlOiBOZ0Zvcm0sIHNlbGVjdG9yOiBcImZvcm06bm90KFtuZ05vRm9ybV0pOm5vdChbZm9ybUdyb3VwXSksbmctZm9ybSxbbmdGb3JtXVwiLCBpbnB1dHM6IHsgb3B0aW9uczogW1wibmdGb3JtT3B0aW9uc1wiLCBcIm9wdGlvbnNcIl0gfSwgb3V0cHV0czogeyBuZ1N1Ym1pdDogXCJuZ1N1Ym1pdFwiIH0sIGhvc3Q6IHsgbGlzdGVuZXJzOiB7IFwic3VibWl0XCI6IFwib25TdWJtaXQoJGV2ZW50KVwiLCBcInJlc2V0XCI6IFwib25SZXNldCgpXCIgfSB9LCBwcm92aWRlcnM6IFtmb3JtRGlyZWN0aXZlUHJvdmlkZXIkMV0sIGV4cG9ydEFzOiBbXCJuZ0Zvcm1cIl0sIHVzZXNJbmhlcml0YW5jZTogdHJ1ZSwgbmdJbXBvcnQ6IGkwIH0pOyB9XG59XG5pMC7Jtcm1bmdEZWNsYXJlQ2xhc3NNZXRhZGF0YSh7IG1pblZlcnNpb246IFwiMTIuMC4wXCIsIHZlcnNpb246IFwiMTcuMy4xMlwiLCBuZ0ltcG9ydDogaTAsIHR5cGU6IE5nRm9ybSwgZGVjb3JhdG9yczogW3tcbiAgICAgICAgICAgIHR5cGU6IERpcmVjdGl2ZSxcbiAgICAgICAgICAgIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnZm9ybTpub3QoW25nTm9Gb3JtXSk6bm90KFtmb3JtR3JvdXBdKSxuZy1mb3JtLFtuZ0Zvcm1dJyxcbiAgICAgICAgICAgICAgICAgICAgcHJvdmlkZXJzOiBbZm9ybURpcmVjdGl2ZVByb3ZpZGVyJDFdLFxuICAgICAgICAgICAgICAgICAgICBob3N0OiB7ICcoc3VibWl0KSc6ICdvblN1Ym1pdCgkZXZlbnQpJywgJyhyZXNldCknOiAnb25SZXNldCgpJyB9LFxuICAgICAgICAgICAgICAgICAgICBvdXRwdXRzOiBbJ25nU3VibWl0J10sXG4gICAgICAgICAgICAgICAgICAgIGV4cG9ydEFzOiAnbmdGb3JtJ1xuICAgICAgICAgICAgICAgIH1dXG4gICAgICAgIH1dLCBjdG9yUGFyYW1ldGVyczogKCkgPT4gW3sgdHlwZTogdW5kZWZpbmVkLCBkZWNvcmF0b3JzOiBbe1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBPcHRpb25hbFxuICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogU2VsZlxuICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogSW5qZWN0LFxuICAgICAgICAgICAgICAgICAgICBhcmdzOiBbTkdfVkFMSURBVE9SU11cbiAgICAgICAgICAgICAgICB9XSB9LCB7IHR5cGU6IHVuZGVmaW5lZCwgZGVjb3JhdG9yczogW3tcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogT3B0aW9uYWxcbiAgICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFNlbGZcbiAgICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IEluamVjdCxcbiAgICAgICAgICAgICAgICAgICAgYXJnczogW05HX0FTWU5DX1ZBTElEQVRPUlNdXG4gICAgICAgICAgICAgICAgfV0gfSwgeyB0eXBlOiB1bmRlZmluZWQsIGRlY29yYXRvcnM6IFt7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IE9wdGlvbmFsXG4gICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBJbmplY3QsXG4gICAgICAgICAgICAgICAgICAgIGFyZ3M6IFtDQUxMX1NFVF9ESVNBQkxFRF9TVEFURV1cbiAgICAgICAgICAgICAgICB9XSB9XSwgcHJvcERlY29yYXRvcnM6IHsgb3B0aW9uczogW3tcbiAgICAgICAgICAgICAgICB0eXBlOiBJbnB1dCxcbiAgICAgICAgICAgICAgICBhcmdzOiBbJ25nRm9ybU9wdGlvbnMnXVxuICAgICAgICAgICAgfV0gfSB9KTtcblxuZnVuY3Rpb24gcmVtb3ZlTGlzdEl0ZW0obGlzdCwgZWwpIHtcbiAgICBjb25zdCBpbmRleCA9IGxpc3QuaW5kZXhPZihlbCk7XG4gICAgaWYgKGluZGV4ID4gLTEpXG4gICAgICAgIGxpc3Quc3BsaWNlKGluZGV4LCAxKTtcbn1cblxuZnVuY3Rpb24gaXNGb3JtQ29udHJvbFN0YXRlKGZvcm1TdGF0ZSkge1xuICAgIHJldHVybiB0eXBlb2YgZm9ybVN0YXRlID09PSAnb2JqZWN0JyAmJiBmb3JtU3RhdGUgIT09IG51bGwgJiZcbiAgICAgICAgT2JqZWN0LmtleXMoZm9ybVN0YXRlKS5sZW5ndGggPT09IDIgJiYgJ3ZhbHVlJyBpbiBmb3JtU3RhdGUgJiYgJ2Rpc2FibGVkJyBpbiBmb3JtU3RhdGU7XG59XG5jb25zdCBGb3JtQ29udHJvbCA9IChjbGFzcyBGb3JtQ29udHJvbCBleHRlbmRzIEFic3RyYWN0Q29udHJvbCB7XG4gICAgY29uc3RydWN0b3IoXG4gICAgLy8gZm9ybVN0YXRlIGFuZCBkZWZhdWx0VmFsdWUgd2lsbCBvbmx5IGJlIG51bGwgaWYgVCBpcyBudWxsYWJsZVxuICAgIGZvcm1TdGF0ZSA9IG51bGwsIHZhbGlkYXRvck9yT3B0cywgYXN5bmNWYWxpZGF0b3IpIHtcbiAgICAgICAgc3VwZXIocGlja1ZhbGlkYXRvcnModmFsaWRhdG9yT3JPcHRzKSwgcGlja0FzeW5jVmFsaWRhdG9ycyhhc3luY1ZhbGlkYXRvciwgdmFsaWRhdG9yT3JPcHRzKSk7XG4gICAgICAgIC8qKiBAcHVibGljQXBpICovXG4gICAgICAgIHRoaXMuZGVmYXVsdFZhbHVlID0gbnVsbDtcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICB0aGlzLl9vbkNoYW5nZSA9IFtdO1xuICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgIHRoaXMuX3BlbmRpbmdDaGFuZ2UgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fYXBwbHlGb3JtU3RhdGUoZm9ybVN0YXRlKTtcbiAgICAgICAgdGhpcy5fc2V0VXBkYXRlU3RyYXRlZ3kodmFsaWRhdG9yT3JPcHRzKTtcbiAgICAgICAgdGhpcy5faW5pdE9ic2VydmFibGVzKCk7XG4gICAgICAgIHRoaXMudXBkYXRlVmFsdWVBbmRWYWxpZGl0eSh7XG4gICAgICAgICAgICBvbmx5U2VsZjogdHJ1ZSxcbiAgICAgICAgICAgIC8vIElmIGBhc3luY1ZhbGlkYXRvcmAgaXMgcHJlc2VudCwgaXQgd2lsbCB0cmlnZ2VyIGNvbnRyb2wgc3RhdHVzIGNoYW5nZSBmcm9tIGBQRU5ESU5HYCB0b1xuICAgICAgICAgICAgLy8gYFZBTElEYCBvciBgSU5WQUxJRGAuXG4gICAgICAgICAgICAvLyBUaGUgc3RhdHVzIHNob3VsZCBiZSBicm9hZGNhc3RlZCB2aWEgdGhlIGBzdGF0dXNDaGFuZ2VzYCBvYnNlcnZhYmxlLCBzbyB3ZSBzZXRcbiAgICAgICAgICAgIC8vIGBlbWl0RXZlbnRgIHRvIGB0cnVlYCB0byBhbGxvdyB0aGF0IGR1cmluZyB0aGUgY29udHJvbCBjcmVhdGlvbiBwcm9jZXNzLlxuICAgICAgICAgICAgZW1pdEV2ZW50OiAhIXRoaXMuYXN5bmNWYWxpZGF0b3JcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChpc09wdGlvbnNPYmoodmFsaWRhdG9yT3JPcHRzKSAmJlxuICAgICAgICAgICAgKHZhbGlkYXRvck9yT3B0cy5ub25OdWxsYWJsZSB8fCB2YWxpZGF0b3JPck9wdHMuaW5pdGlhbFZhbHVlSXNEZWZhdWx0KSkge1xuICAgICAgICAgICAgaWYgKGlzRm9ybUNvbnRyb2xTdGF0ZShmb3JtU3RhdGUpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kZWZhdWx0VmFsdWUgPSBmb3JtU3RhdGUudmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRlZmF1bHRWYWx1ZSA9IGZvcm1TdGF0ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBzZXRWYWx1ZSh2YWx1ZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIHRoaXMudmFsdWUgPSB0aGlzLl9wZW5kaW5nVmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgaWYgKHRoaXMuX29uQ2hhbmdlLmxlbmd0aCAmJiBvcHRpb25zLmVtaXRNb2RlbFRvVmlld0NoYW5nZSAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHRoaXMuX29uQ2hhbmdlLmZvckVhY2goKGNoYW5nZUZuKSA9PiBjaGFuZ2VGbih0aGlzLnZhbHVlLCBvcHRpb25zLmVtaXRWaWV3VG9Nb2RlbENoYW5nZSAhPT0gZmFsc2UpKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnVwZGF0ZVZhbHVlQW5kVmFsaWRpdHkob3B0aW9ucyk7XG4gICAgfVxuICAgIHBhdGNoVmFsdWUodmFsdWUsIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICB0aGlzLnNldFZhbHVlKHZhbHVlLCBvcHRpb25zKTtcbiAgICB9XG4gICAgcmVzZXQoZm9ybVN0YXRlID0gdGhpcy5kZWZhdWx0VmFsdWUsIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICB0aGlzLl9hcHBseUZvcm1TdGF0ZShmb3JtU3RhdGUpO1xuICAgICAgICB0aGlzLm1hcmtBc1ByaXN0aW5lKG9wdGlvbnMpO1xuICAgICAgICB0aGlzLm1hcmtBc1VudG91Y2hlZChvcHRpb25zKTtcbiAgICAgICAgdGhpcy5zZXRWYWx1ZSh0aGlzLnZhbHVlLCBvcHRpb25zKTtcbiAgICAgICAgdGhpcy5fcGVuZGluZ0NoYW5nZSA9IGZhbHNlO1xuICAgIH1cbiAgICAvKiogIEBpbnRlcm5hbCAqL1xuICAgIF91cGRhdGVWYWx1ZSgpIHsgfVxuICAgIC8qKiAgQGludGVybmFsICovXG4gICAgX2FueUNvbnRyb2xzKGNvbmRpdGlvbikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8qKiAgQGludGVybmFsICovXG4gICAgX2FsbENvbnRyb2xzRGlzYWJsZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRpc2FibGVkO1xuICAgIH1cbiAgICByZWdpc3Rlck9uQ2hhbmdlKGZuKSB7XG4gICAgICAgIHRoaXMuX29uQ2hhbmdlLnB1c2goZm4pO1xuICAgIH1cbiAgICAvKiogQGludGVybmFsICovXG4gICAgX3VucmVnaXN0ZXJPbkNoYW5nZShmbikge1xuICAgICAgICByZW1vdmVMaXN0SXRlbSh0aGlzLl9vbkNoYW5nZSwgZm4pO1xuICAgIH1cbiAgICByZWdpc3Rlck9uRGlzYWJsZWRDaGFuZ2UoZm4pIHtcbiAgICAgICAgdGhpcy5fb25EaXNhYmxlZENoYW5nZS5wdXNoKGZuKTtcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIF91bnJlZ2lzdGVyT25EaXNhYmxlZENoYW5nZShmbikge1xuICAgICAgICByZW1vdmVMaXN0SXRlbSh0aGlzLl9vbkRpc2FibGVkQ2hhbmdlLCBmbik7XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBfZm9yRWFjaENoaWxkKGNiKSB7IH1cbiAgICAvKiogQGludGVybmFsICovXG4gICAgX3N5bmNQZW5kaW5nQ29udHJvbHMoKSB7XG4gICAgICAgIGlmICh0aGlzLnVwZGF0ZU9uID09PSAnc3VibWl0Jykge1xuICAgICAgICAgICAgaWYgKHRoaXMuX3BlbmRpbmdEaXJ0eSlcbiAgICAgICAgICAgICAgICB0aGlzLm1hcmtBc0RpcnR5KCk7XG4gICAgICAgICAgICBpZiAodGhpcy5fcGVuZGluZ1RvdWNoZWQpXG4gICAgICAgICAgICAgICAgdGhpcy5tYXJrQXNUb3VjaGVkKCk7XG4gICAgICAgICAgICBpZiAodGhpcy5fcGVuZGluZ0NoYW5nZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0VmFsdWUodGhpcy5fcGVuZGluZ1ZhbHVlLCB7IG9ubHlTZWxmOiB0cnVlLCBlbWl0TW9kZWxUb1ZpZXdDaGFuZ2U6IGZhbHNlIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgX2FwcGx5Rm9ybVN0YXRlKGZvcm1TdGF0ZSkge1xuICAgICAgICBpZiAoaXNGb3JtQ29udHJvbFN0YXRlKGZvcm1TdGF0ZSkpIHtcbiAgICAgICAgICAgIHRoaXMudmFsdWUgPSB0aGlzLl9wZW5kaW5nVmFsdWUgPSBmb3JtU3RhdGUudmFsdWU7XG4gICAgICAgICAgICBmb3JtU3RhdGUuZGlzYWJsZWQgPyB0aGlzLmRpc2FibGUoeyBvbmx5U2VsZjogdHJ1ZSwgZW1pdEV2ZW50OiBmYWxzZSB9KSA6XG4gICAgICAgICAgICAgICAgdGhpcy5lbmFibGUoeyBvbmx5U2VsZjogdHJ1ZSwgZW1pdEV2ZW50OiBmYWxzZSB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMudmFsdWUgPSB0aGlzLl9wZW5kaW5nVmFsdWUgPSBmb3JtU3RhdGU7XG4gICAgICAgIH1cbiAgICB9XG59KTtcbmNvbnN0IFVudHlwZWRGb3JtQ29udHJvbCA9IEZvcm1Db250cm9sO1xuLyoqXG4gKiBAZGVzY3JpcHRpb25cbiAqIEFzc2VydHMgdGhhdCB0aGUgZ2l2ZW4gY29udHJvbCBpcyBhbiBpbnN0YW5jZSBvZiBgRm9ybUNvbnRyb2xgXG4gKlxuICogQHB1YmxpY0FwaVxuICovXG5jb25zdCBpc0Zvcm1Db250cm9sID0gKGNvbnRyb2wpID0+IGNvbnRyb2wgaW5zdGFuY2VvZiBGb3JtQ29udHJvbDtcblxuLyoqXG4gKiBAZGVzY3JpcHRpb25cbiAqIEEgYmFzZSBjbGFzcyBmb3IgY29kZSBzaGFyZWQgYmV0d2VlbiB0aGUgYE5nTW9kZWxHcm91cGAgYW5kIGBGb3JtR3JvdXBOYW1lYCBkaXJlY3RpdmVzLlxuICpcbiAqIEBwdWJsaWNBcGlcbiAqL1xuY2xhc3MgQWJzdHJhY3RGb3JtR3JvdXBEaXJlY3RpdmUgZXh0ZW5kcyBDb250cm9sQ29udGFpbmVyIHtcbiAgICAvKiogQG5vZG9jICovXG4gICAgbmdPbkluaXQoKSB7XG4gICAgICAgIHRoaXMuX2NoZWNrUGFyZW50VHlwZSgpO1xuICAgICAgICAvLyBSZWdpc3RlciB0aGUgZ3JvdXAgd2l0aCBpdHMgcGFyZW50IGdyb3VwLlxuICAgICAgICB0aGlzLmZvcm1EaXJlY3RpdmUuYWRkRm9ybUdyb3VwKHRoaXMpO1xuICAgIH1cbiAgICAvKiogQG5vZG9jICovXG4gICAgbmdPbkRlc3Ryb3koKSB7XG4gICAgICAgIGlmICh0aGlzLmZvcm1EaXJlY3RpdmUpIHtcbiAgICAgICAgICAgIC8vIFJlbW92ZSB0aGUgZ3JvdXAgZnJvbSBpdHMgcGFyZW50IGdyb3VwLlxuICAgICAgICAgICAgdGhpcy5mb3JtRGlyZWN0aXZlLnJlbW92ZUZvcm1Hcm91cCh0aGlzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKiBUaGUgYEZvcm1Hcm91cGAgYm91bmQgdG8gdGhpcyBkaXJlY3RpdmUuXG4gICAgICovXG4gICAgZ2V0IGNvbnRyb2woKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZvcm1EaXJlY3RpdmUuZ2V0Rm9ybUdyb3VwKHRoaXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKiBUaGUgcGF0aCB0byB0aGlzIGdyb3VwIGZyb20gdGhlIHRvcC1sZXZlbCBkaXJlY3RpdmUuXG4gICAgICovXG4gICAgZ2V0IHBhdGgoKSB7XG4gICAgICAgIHJldHVybiBjb250cm9sUGF0aCh0aGlzLm5hbWUgPT0gbnVsbCA/IHRoaXMubmFtZSA6IHRoaXMubmFtZS50b1N0cmluZygpLCB0aGlzLl9wYXJlbnQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKiBUaGUgdG9wLWxldmVsIGRpcmVjdGl2ZSBmb3IgdGhpcyBncm91cCBpZiBwcmVzZW50LCBvdGhlcndpc2UgbnVsbC5cbiAgICAgKi9cbiAgICBnZXQgZm9ybURpcmVjdGl2ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BhcmVudCA/IHRoaXMuX3BhcmVudC5mb3JtRGlyZWN0aXZlIDogbnVsbDtcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIF9jaGVja1BhcmVudFR5cGUoKSB7IH1cbiAgICBzdGF0aWMgeyB0aGlzLsm1ZmFjID0gaTAuybXJtW5nRGVjbGFyZUZhY3RvcnkoeyBtaW5WZXJzaW9uOiBcIjEyLjAuMFwiLCB2ZXJzaW9uOiBcIjE3LjMuMTJcIiwgbmdJbXBvcnQ6IGkwLCB0eXBlOiBBYnN0cmFjdEZvcm1Hcm91cERpcmVjdGl2ZSwgZGVwczogbnVsbCwgdGFyZ2V0OiBpMC7Jtcm1RmFjdG9yeVRhcmdldC5EaXJlY3RpdmUgfSk7IH1cbiAgICBzdGF0aWMgeyB0aGlzLsm1ZGlyID0gaTAuybXJtW5nRGVjbGFyZURpcmVjdGl2ZSh7IG1pblZlcnNpb246IFwiMTQuMC4wXCIsIHZlcnNpb246IFwiMTcuMy4xMlwiLCB0eXBlOiBBYnN0cmFjdEZvcm1Hcm91cERpcmVjdGl2ZSwgdXNlc0luaGVyaXRhbmNlOiB0cnVlLCBuZ0ltcG9ydDogaTAgfSk7IH1cbn1cbmkwLsm1ybVuZ0RlY2xhcmVDbGFzc01ldGFkYXRhKHsgbWluVmVyc2lvbjogXCIxMi4wLjBcIiwgdmVyc2lvbjogXCIxNy4zLjEyXCIsIG5nSW1wb3J0OiBpMCwgdHlwZTogQWJzdHJhY3RGb3JtR3JvdXBEaXJlY3RpdmUsIGRlY29yYXRvcnM6IFt7XG4gICAgICAgICAgICB0eXBlOiBEaXJlY3RpdmVcbiAgICAgICAgfV0gfSk7XG5cbmZ1bmN0aW9uIG1vZGVsUGFyZW50RXhjZXB0aW9uKCkge1xuICAgIHJldHVybiBuZXcgybVSdW50aW1lRXJyb3IoMTM1MCAvKiBSdW50aW1lRXJyb3JDb2RlLk5HTU9ERUxfSU5fRk9STV9HUk9VUCAqLywgYFxuICAgIG5nTW9kZWwgY2Fubm90IGJlIHVzZWQgdG8gcmVnaXN0ZXIgZm9ybSBjb250cm9scyB3aXRoIGEgcGFyZW50IGZvcm1Hcm91cCBkaXJlY3RpdmUuICBUcnkgdXNpbmdcbiAgICBmb3JtR3JvdXAncyBwYXJ0bmVyIGRpcmVjdGl2ZSBcImZvcm1Db250cm9sTmFtZVwiIGluc3RlYWQuICBFeGFtcGxlOlxuXG4gICAgJHtmb3JtQ29udHJvbE5hbWVFeGFtcGxlfVxuXG4gICAgT3IsIGlmIHlvdSdkIGxpa2UgdG8gYXZvaWQgcmVnaXN0ZXJpbmcgdGhpcyBmb3JtIGNvbnRyb2wsIGluZGljYXRlIHRoYXQgaXQncyBzdGFuZGFsb25lIGluIG5nTW9kZWxPcHRpb25zOlxuXG4gICAgRXhhbXBsZTpcblxuICAgICR7bmdNb2RlbFdpdGhGb3JtR3JvdXBFeGFtcGxlfWApO1xufVxuZnVuY3Rpb24gZm9ybUdyb3VwTmFtZUV4Y2VwdGlvbigpIHtcbiAgICByZXR1cm4gbmV3IMm1UnVudGltZUVycm9yKDEzNTEgLyogUnVudGltZUVycm9yQ29kZS5OR01PREVMX0lOX0ZPUk1fR1JPVVBfTkFNRSAqLywgYFxuICAgIG5nTW9kZWwgY2Fubm90IGJlIHVzZWQgdG8gcmVnaXN0ZXIgZm9ybSBjb250cm9scyB3aXRoIGEgcGFyZW50IGZvcm1Hcm91cE5hbWUgb3IgZm9ybUFycmF5TmFtZSBkaXJlY3RpdmUuXG5cbiAgICBPcHRpb24gMTogVXNlIGZvcm1Db250cm9sTmFtZSBpbnN0ZWFkIG9mIG5nTW9kZWwgKHJlYWN0aXZlIHN0cmF0ZWd5KTpcblxuICAgICR7Zm9ybUdyb3VwTmFtZUV4YW1wbGV9XG5cbiAgICBPcHRpb24gMjogIFVwZGF0ZSBuZ01vZGVsJ3MgcGFyZW50IGJlIG5nTW9kZWxHcm91cCAodGVtcGxhdGUtZHJpdmVuIHN0cmF0ZWd5KTpcblxuICAgICR7bmdNb2RlbEdyb3VwRXhhbXBsZX1gKTtcbn1cbmZ1bmN0aW9uIG1pc3NpbmdOYW1lRXhjZXB0aW9uKCkge1xuICAgIHJldHVybiBuZXcgybVSdW50aW1lRXJyb3IoMTM1MiAvKiBSdW50aW1lRXJyb3JDb2RlLk5HTU9ERUxfV0lUSE9VVF9OQU1FICovLCBgSWYgbmdNb2RlbCBpcyB1c2VkIHdpdGhpbiBhIGZvcm0gdGFnLCBlaXRoZXIgdGhlIG5hbWUgYXR0cmlidXRlIG11c3QgYmUgc2V0IG9yIHRoZSBmb3JtXG4gICAgY29udHJvbCBtdXN0IGJlIGRlZmluZWQgYXMgJ3N0YW5kYWxvbmUnIGluIG5nTW9kZWxPcHRpb25zLlxuXG4gICAgRXhhbXBsZSAxOiA8aW5wdXQgWyhuZ01vZGVsKV09XCJwZXJzb24uZmlyc3ROYW1lXCIgbmFtZT1cImZpcnN0XCI+XG4gICAgRXhhbXBsZSAyOiA8aW5wdXQgWyhuZ01vZGVsKV09XCJwZXJzb24uZmlyc3ROYW1lXCIgW25nTW9kZWxPcHRpb25zXT1cIntzdGFuZGFsb25lOiB0cnVlfVwiPmApO1xufVxuZnVuY3Rpb24gbW9kZWxHcm91cFBhcmVudEV4Y2VwdGlvbigpIHtcbiAgICByZXR1cm4gbmV3IMm1UnVudGltZUVycm9yKDEzNTMgLyogUnVudGltZUVycm9yQ29kZS5OR01PREVMR1JPVVBfSU5fRk9STV9HUk9VUCAqLywgYFxuICAgIG5nTW9kZWxHcm91cCBjYW5ub3QgYmUgdXNlZCB3aXRoIGEgcGFyZW50IGZvcm1Hcm91cCBkaXJlY3RpdmUuXG5cbiAgICBPcHRpb24gMTogVXNlIGZvcm1Hcm91cE5hbWUgaW5zdGVhZCBvZiBuZ01vZGVsR3JvdXAgKHJlYWN0aXZlIHN0cmF0ZWd5KTpcblxuICAgICR7Zm9ybUdyb3VwTmFtZUV4YW1wbGV9XG5cbiAgICBPcHRpb24gMjogIFVzZSBhIHJlZ3VsYXIgZm9ybSB0YWcgaW5zdGVhZCBvZiB0aGUgZm9ybUdyb3VwIGRpcmVjdGl2ZSAodGVtcGxhdGUtZHJpdmVuIHN0cmF0ZWd5KTpcblxuICAgICR7bmdNb2RlbEdyb3VwRXhhbXBsZX1gKTtcbn1cblxuY29uc3QgbW9kZWxHcm91cFByb3ZpZGVyID0ge1xuICAgIHByb3ZpZGU6IENvbnRyb2xDb250YWluZXIsXG4gICAgdXNlRXhpc3Rpbmc6IGZvcndhcmRSZWYoKCkgPT4gTmdNb2RlbEdyb3VwKVxufTtcbi8qKlxuICogQGRlc2NyaXB0aW9uXG4gKiBDcmVhdGVzIGFuZCBiaW5kcyBhIGBGb3JtR3JvdXBgIGluc3RhbmNlIHRvIGEgRE9NIGVsZW1lbnQuXG4gKlxuICogVGhpcyBkaXJlY3RpdmUgY2FuIG9ubHkgYmUgdXNlZCBhcyBhIGNoaWxkIG9mIGBOZ0Zvcm1gICh3aXRoaW4gYDxmb3JtPmAgdGFncykuXG4gKlxuICogVXNlIHRoaXMgZGlyZWN0aXZlIHRvIHZhbGlkYXRlIGEgc3ViLWdyb3VwIG9mIHlvdXIgZm9ybSBzZXBhcmF0ZWx5IGZyb20gdGhlXG4gKiByZXN0IG9mIHlvdXIgZm9ybSwgb3IgaWYgc29tZSB2YWx1ZXMgaW4geW91ciBkb21haW4gbW9kZWwgbWFrZSBtb3JlIHNlbnNlXG4gKiB0byBjb25zdW1lIHRvZ2V0aGVyIGluIGEgbmVzdGVkIG9iamVjdC5cbiAqXG4gKiBQcm92aWRlIGEgbmFtZSBmb3IgdGhlIHN1Yi1ncm91cCBhbmQgaXQgd2lsbCBiZWNvbWUgdGhlIGtleVxuICogZm9yIHRoZSBzdWItZ3JvdXAgaW4gdGhlIGZvcm0ncyBmdWxsIHZhbHVlLiBJZiB5b3UgbmVlZCBkaXJlY3QgYWNjZXNzLCBleHBvcnQgdGhlIGRpcmVjdGl2ZSBpbnRvXG4gKiBhIGxvY2FsIHRlbXBsYXRlIHZhcmlhYmxlIHVzaW5nIGBuZ01vZGVsR3JvdXBgIChleDogYCNteUdyb3VwPVwibmdNb2RlbEdyb3VwXCJgKS5cbiAqXG4gKiBAdXNhZ2VOb3Rlc1xuICpcbiAqICMjIyBDb25zdW1pbmcgY29udHJvbHMgaW4gYSBncm91cGluZ1xuICpcbiAqIFRoZSBmb2xsb3dpbmcgZXhhbXBsZSBzaG93cyB5b3UgaG93IHRvIGNvbWJpbmUgY29udHJvbHMgdG9nZXRoZXIgaW4gYSBzdWItZ3JvdXBcbiAqIG9mIHRoZSBmb3JtLlxuICpcbiAqIHtAZXhhbXBsZSBmb3Jtcy90cy9uZ01vZGVsR3JvdXAvbmdfbW9kZWxfZ3JvdXBfZXhhbXBsZS50cyByZWdpb249J0NvbXBvbmVudCd9XG4gKlxuICogQG5nTW9kdWxlIEZvcm1zTW9kdWxlXG4gKiBAcHVibGljQXBpXG4gKi9cbmNsYXNzIE5nTW9kZWxHcm91cCBleHRlbmRzIEFic3RyYWN0Rm9ybUdyb3VwRGlyZWN0aXZlIHtcbiAgICBjb25zdHJ1Y3RvcihwYXJlbnQsIHZhbGlkYXRvcnMsIGFzeW5jVmFsaWRhdG9ycykge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICAvKipcbiAgICAgICAgICogQGRlc2NyaXB0aW9uXG4gICAgICAgICAqIFRyYWNrcyB0aGUgbmFtZSBvZiB0aGUgYE5nTW9kZWxHcm91cGAgYm91bmQgdG8gdGhlIGRpcmVjdGl2ZS4gVGhlIG5hbWUgY29ycmVzcG9uZHNcbiAgICAgICAgICogdG8gYSBrZXkgaW4gdGhlIHBhcmVudCBgTmdGb3JtYC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubmFtZSA9ICcnO1xuICAgICAgICB0aGlzLl9wYXJlbnQgPSBwYXJlbnQ7XG4gICAgICAgIHRoaXMuX3NldFZhbGlkYXRvcnModmFsaWRhdG9ycyk7XG4gICAgICAgIHRoaXMuX3NldEFzeW5jVmFsaWRhdG9ycyhhc3luY1ZhbGlkYXRvcnMpO1xuICAgIH1cbiAgICAvKiogQGludGVybmFsICovXG4gICAgX2NoZWNrUGFyZW50VHlwZSgpIHtcbiAgICAgICAgaWYgKCEodGhpcy5fcGFyZW50IGluc3RhbmNlb2YgTmdNb2RlbEdyb3VwKSAmJiAhKHRoaXMuX3BhcmVudCBpbnN0YW5jZW9mIE5nRm9ybSkgJiZcbiAgICAgICAgICAgICh0eXBlb2YgbmdEZXZNb2RlID09PSAndW5kZWZpbmVkJyB8fCBuZ0Rldk1vZGUpKSB7XG4gICAgICAgICAgICB0aHJvdyBtb2RlbEdyb3VwUGFyZW50RXhjZXB0aW9uKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3RhdGljIHsgdGhpcy7JtWZhYyA9IGkwLsm1ybVuZ0RlY2xhcmVGYWN0b3J5KHsgbWluVmVyc2lvbjogXCIxMi4wLjBcIiwgdmVyc2lvbjogXCIxNy4zLjEyXCIsIG5nSW1wb3J0OiBpMCwgdHlwZTogTmdNb2RlbEdyb3VwLCBkZXBzOiBbeyB0b2tlbjogQ29udHJvbENvbnRhaW5lciwgaG9zdDogdHJ1ZSwgc2tpcFNlbGY6IHRydWUgfSwgeyB0b2tlbjogTkdfVkFMSURBVE9SUywgb3B0aW9uYWw6IHRydWUsIHNlbGY6IHRydWUgfSwgeyB0b2tlbjogTkdfQVNZTkNfVkFMSURBVE9SUywgb3B0aW9uYWw6IHRydWUsIHNlbGY6IHRydWUgfV0sIHRhcmdldDogaTAuybXJtUZhY3RvcnlUYXJnZXQuRGlyZWN0aXZlIH0pOyB9XG4gICAgc3RhdGljIHsgdGhpcy7JtWRpciA9IGkwLsm1ybVuZ0RlY2xhcmVEaXJlY3RpdmUoeyBtaW5WZXJzaW9uOiBcIjE0LjAuMFwiLCB2ZXJzaW9uOiBcIjE3LjMuMTJcIiwgdHlwZTogTmdNb2RlbEdyb3VwLCBzZWxlY3RvcjogXCJbbmdNb2RlbEdyb3VwXVwiLCBpbnB1dHM6IHsgbmFtZTogW1wibmdNb2RlbEdyb3VwXCIsIFwibmFtZVwiXSB9LCBwcm92aWRlcnM6IFttb2RlbEdyb3VwUHJvdmlkZXJdLCBleHBvcnRBczogW1wibmdNb2RlbEdyb3VwXCJdLCB1c2VzSW5oZXJpdGFuY2U6IHRydWUsIG5nSW1wb3J0OiBpMCB9KTsgfVxufVxuaTAuybXJtW5nRGVjbGFyZUNsYXNzTWV0YWRhdGEoeyBtaW5WZXJzaW9uOiBcIjEyLjAuMFwiLCB2ZXJzaW9uOiBcIjE3LjMuMTJcIiwgbmdJbXBvcnQ6IGkwLCB0eXBlOiBOZ01vZGVsR3JvdXAsIGRlY29yYXRvcnM6IFt7XG4gICAgICAgICAgICB0eXBlOiBEaXJlY3RpdmUsXG4gICAgICAgICAgICBhcmdzOiBbeyBzZWxlY3RvcjogJ1tuZ01vZGVsR3JvdXBdJywgcHJvdmlkZXJzOiBbbW9kZWxHcm91cFByb3ZpZGVyXSwgZXhwb3J0QXM6ICduZ01vZGVsR3JvdXAnIH1dXG4gICAgICAgIH1dLCBjdG9yUGFyYW1ldGVyczogKCkgPT4gW3sgdHlwZTogQ29udHJvbENvbnRhaW5lciwgZGVjb3JhdG9yczogW3tcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogSG9zdFxuICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogU2tpcFNlbGZcbiAgICAgICAgICAgICAgICB9XSB9LCB7IHR5cGU6IHVuZGVmaW5lZCwgZGVjb3JhdG9yczogW3tcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogT3B0aW9uYWxcbiAgICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFNlbGZcbiAgICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IEluamVjdCxcbiAgICAgICAgICAgICAgICAgICAgYXJnczogW05HX1ZBTElEQVRPUlNdXG4gICAgICAgICAgICAgICAgfV0gfSwgeyB0eXBlOiB1bmRlZmluZWQsIGRlY29yYXRvcnM6IFt7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IE9wdGlvbmFsXG4gICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBTZWxmXG4gICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBJbmplY3QsXG4gICAgICAgICAgICAgICAgICAgIGFyZ3M6IFtOR19BU1lOQ19WQUxJREFUT1JTXVxuICAgICAgICAgICAgICAgIH1dIH1dLCBwcm9wRGVjb3JhdG9yczogeyBuYW1lOiBbe1xuICAgICAgICAgICAgICAgIHR5cGU6IElucHV0LFxuICAgICAgICAgICAgICAgIGFyZ3M6IFsnbmdNb2RlbEdyb3VwJ11cbiAgICAgICAgICAgIH1dIH0gfSk7XG5cbmNvbnN0IGZvcm1Db250cm9sQmluZGluZyQxID0ge1xuICAgIHByb3ZpZGU6IE5nQ29udHJvbCxcbiAgICB1c2VFeGlzdGluZzogZm9yd2FyZFJlZigoKSA9PiBOZ01vZGVsKVxufTtcbi8qKlxuICogYG5nTW9kZWxgIGZvcmNlcyBhbiBhZGRpdGlvbmFsIGNoYW5nZSBkZXRlY3Rpb24gcnVuIHdoZW4gaXRzIGlucHV0cyBjaGFuZ2U6XG4gKiBFLmcuOlxuICogYGBgXG4gKiA8ZGl2Pnt7bXlNb2RlbC52YWxpZH19PC9kaXY+XG4gKiA8aW5wdXQgWyhuZ01vZGVsKV09XCJteVZhbHVlXCIgI215TW9kZWw9XCJuZ01vZGVsXCI+XG4gKiBgYGBcbiAqIEkuZS4gYG5nTW9kZWxgIGNhbiBleHBvcnQgaXRzZWxmIG9uIHRoZSBlbGVtZW50IGFuZCB0aGVuIGJlIHVzZWQgaW4gdGhlIHRlbXBsYXRlLlxuICogTm9ybWFsbHksIHRoaXMgd291bGQgcmVzdWx0IGluIGV4cHJlc3Npb25zIGJlZm9yZSB0aGUgYGlucHV0YCB0aGF0IHVzZSB0aGUgZXhwb3J0ZWQgZGlyZWN0aXZlXG4gKiB0byBoYXZlIGFuIG9sZCB2YWx1ZSBhcyB0aGV5IGhhdmUgYmVlblxuICogZGlydHkgY2hlY2tlZCBiZWZvcmUuIEFzIHRoaXMgaXMgYSB2ZXJ5IGNvbW1vbiBjYXNlIGZvciBgbmdNb2RlbGAsIHdlIGFkZGVkIHRoaXMgc2Vjb25kIGNoYW5nZVxuICogZGV0ZWN0aW9uIHJ1bi5cbiAqXG4gKiBOb3RlczpcbiAqIC0gdGhpcyBpcyBqdXN0IG9uZSBleHRyYSBydW4gbm8gbWF0dGVyIGhvdyBtYW55IGBuZ01vZGVsYHMgaGF2ZSBiZWVuIGNoYW5nZWQuXG4gKiAtIHRoaXMgaXMgYSBnZW5lcmFsIHByb2JsZW0gd2hlbiB1c2luZyBgZXhwb3J0QXNgIGZvciBkaXJlY3RpdmVzIVxuICovXG5jb25zdCByZXNvbHZlZFByb21pc2UgPSAoKCkgPT4gUHJvbWlzZS5yZXNvbHZlKCkpKCk7XG4vKipcbiAqIEBkZXNjcmlwdGlvblxuICogQ3JlYXRlcyBhIGBGb3JtQ29udHJvbGAgaW5zdGFuY2UgZnJvbSBhIFtkb21haW5cbiAqIG1vZGVsXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Eb21haW5fbW9kZWwpIGFuZCBiaW5kcyBpdCB0byBhIGZvcm0gY29udHJvbCBlbGVtZW50LlxuICpcbiAqIFRoZSBgRm9ybUNvbnRyb2xgIGluc3RhbmNlIHRyYWNrcyB0aGUgdmFsdWUsIHVzZXIgaW50ZXJhY3Rpb24sIGFuZFxuICogdmFsaWRhdGlvbiBzdGF0dXMgb2YgdGhlIGNvbnRyb2wgYW5kIGtlZXBzIHRoZSB2aWV3IHN5bmNlZCB3aXRoIHRoZSBtb2RlbC4gSWYgdXNlZFxuICogd2l0aGluIGEgcGFyZW50IGZvcm0sIHRoZSBkaXJlY3RpdmUgYWxzbyByZWdpc3RlcnMgaXRzZWxmIHdpdGggdGhlIGZvcm0gYXMgYSBjaGlsZFxuICogY29udHJvbC5cbiAqXG4gKiBUaGlzIGRpcmVjdGl2ZSBpcyB1c2VkIGJ5IGl0c2VsZiBvciBhcyBwYXJ0IG9mIGEgbGFyZ2VyIGZvcm0uIFVzZSB0aGVcbiAqIGBuZ01vZGVsYCBzZWxlY3RvciB0byBhY3RpdmF0ZSBpdC5cbiAqXG4gKiBJdCBhY2NlcHRzIGEgZG9tYWluIG1vZGVsIGFzIGFuIG9wdGlvbmFsIGBJbnB1dGAuIElmIHlvdSBoYXZlIGEgb25lLXdheSBiaW5kaW5nXG4gKiB0byBgbmdNb2RlbGAgd2l0aCBgW11gIHN5bnRheCwgY2hhbmdpbmcgdGhlIGRvbWFpbiBtb2RlbCdzIHZhbHVlIGluIHRoZSBjb21wb25lbnRcbiAqIGNsYXNzIHNldHMgdGhlIHZhbHVlIGluIHRoZSB2aWV3LiBJZiB5b3UgaGF2ZSBhIHR3by13YXkgYmluZGluZyB3aXRoIGBbKCldYCBzeW50YXhcbiAqIChhbHNvIGtub3duIGFzICdiYW5hbmEtaW4tYS1ib3ggc3ludGF4JyksIHRoZSB2YWx1ZSBpbiB0aGUgVUkgYWx3YXlzIHN5bmNzIGJhY2sgdG9cbiAqIHRoZSBkb21haW4gbW9kZWwgaW4geW91ciBjbGFzcy5cbiAqXG4gKiBUbyBpbnNwZWN0IHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBhc3NvY2lhdGVkIGBGb3JtQ29udHJvbGAgKGxpa2UgdGhlIHZhbGlkaXR5IHN0YXRlKSxcbiAqIGV4cG9ydCB0aGUgZGlyZWN0aXZlIGludG8gYSBsb2NhbCB0ZW1wbGF0ZSB2YXJpYWJsZSB1c2luZyBgbmdNb2RlbGAgYXMgdGhlIGtleSAoZXg6XG4gKiBgI215VmFyPVwibmdNb2RlbFwiYCkuIFlvdSBjYW4gdGhlbiBhY2Nlc3MgdGhlIGNvbnRyb2wgdXNpbmcgdGhlIGRpcmVjdGl2ZSdzIGBjb250cm9sYCBwcm9wZXJ0eS5cbiAqIEhvd2V2ZXIsIHRoZSBtb3N0IGNvbW1vbmx5IHVzZWQgcHJvcGVydGllcyAobGlrZSBgdmFsaWRgIGFuZCBgZGlydHlgKSBhbHNvIGV4aXN0IG9uIHRoZSBjb250cm9sXG4gKiBmb3IgZGlyZWN0IGFjY2Vzcy4gU2VlIGEgZnVsbCBsaXN0IG9mIHByb3BlcnRpZXMgZGlyZWN0bHkgYXZhaWxhYmxlIGluXG4gKiBgQWJzdHJhY3RDb250cm9sRGlyZWN0aXZlYC5cbiAqXG4gKiBAc2VlIHtAbGluayBSYWRpb0NvbnRyb2xWYWx1ZUFjY2Vzc29yfVxuICogQHNlZSB7QGxpbmsgU2VsZWN0Q29udHJvbFZhbHVlQWNjZXNzb3J9XG4gKlxuICogQHVzYWdlTm90ZXNcbiAqXG4gKiAjIyMgVXNpbmcgbmdNb2RlbCBvbiBhIHN0YW5kYWxvbmUgY29udHJvbFxuICpcbiAqIFRoZSBmb2xsb3dpbmcgZXhhbXBsZXMgc2hvdyBhIHNpbXBsZSBzdGFuZGFsb25lIGNvbnRyb2wgdXNpbmcgYG5nTW9kZWxgOlxuICpcbiAqIHtAZXhhbXBsZSBmb3Jtcy90cy9zaW1wbGVOZ01vZGVsL3NpbXBsZV9uZ19tb2RlbF9leGFtcGxlLnRzIHJlZ2lvbj0nQ29tcG9uZW50J31cbiAqXG4gKiBXaGVuIHVzaW5nIHRoZSBgbmdNb2RlbGAgd2l0aGluIGA8Zm9ybT5gIHRhZ3MsIHlvdSdsbCBhbHNvIG5lZWQgdG8gc3VwcGx5IGEgYG5hbWVgIGF0dHJpYnV0ZVxuICogc28gdGhhdCB0aGUgY29udHJvbCBjYW4gYmUgcmVnaXN0ZXJlZCB3aXRoIHRoZSBwYXJlbnQgZm9ybSB1bmRlciB0aGF0IG5hbWUuXG4gKlxuICogSW4gdGhlIGNvbnRleHQgb2YgYSBwYXJlbnQgZm9ybSwgaXQncyBvZnRlbiB1bm5lY2Vzc2FyeSB0byBpbmNsdWRlIG9uZS13YXkgb3IgdHdvLXdheSBiaW5kaW5nLFxuICogYXMgdGhlIHBhcmVudCBmb3JtIHN5bmNzIHRoZSB2YWx1ZSBmb3IgeW91LiBZb3UgYWNjZXNzIGl0cyBwcm9wZXJ0aWVzIGJ5IGV4cG9ydGluZyBpdCBpbnRvIGFcbiAqIGxvY2FsIHRlbXBsYXRlIHZhcmlhYmxlIHVzaW5nIGBuZ0Zvcm1gIHN1Y2ggYXMgKGAjZj1cIm5nRm9ybVwiYCkuIFVzZSB0aGUgdmFyaWFibGUgd2hlcmVcbiAqIG5lZWRlZCBvbiBmb3JtIHN1Ym1pc3Npb24uXG4gKlxuICogSWYgeW91IGRvIG5lZWQgdG8gcG9wdWxhdGUgaW5pdGlhbCB2YWx1ZXMgaW50byB5b3VyIGZvcm0sIHVzaW5nIGEgb25lLXdheSBiaW5kaW5nIGZvclxuICogYG5nTW9kZWxgIHRlbmRzIHRvIGJlIHN1ZmZpY2llbnQgYXMgbG9uZyBhcyB5b3UgdXNlIHRoZSBleHBvcnRlZCBmb3JtJ3MgdmFsdWUgcmF0aGVyXG4gKiB0aGFuIHRoZSBkb21haW4gbW9kZWwncyB2YWx1ZSBvbiBzdWJtaXQuXG4gKlxuICogIyMjIFVzaW5nIG5nTW9kZWwgd2l0aGluIGEgZm9ybVxuICpcbiAqIFRoZSBmb2xsb3dpbmcgZXhhbXBsZSBzaG93cyBjb250cm9scyB1c2luZyBgbmdNb2RlbGAgd2l0aGluIGEgZm9ybTpcbiAqXG4gKiB7QGV4YW1wbGUgZm9ybXMvdHMvc2ltcGxlRm9ybS9zaW1wbGVfZm9ybV9leGFtcGxlLnRzIHJlZ2lvbj0nQ29tcG9uZW50J31cbiAqXG4gKiAjIyMgVXNpbmcgYSBzdGFuZGFsb25lIG5nTW9kZWwgd2l0aGluIGEgZ3JvdXBcbiAqXG4gKiBUaGUgZm9sbG93aW5nIGV4YW1wbGUgc2hvd3MgeW91IGhvdyB0byB1c2UgYSBzdGFuZGFsb25lIG5nTW9kZWwgY29udHJvbFxuICogd2l0aGluIGEgZm9ybS4gVGhpcyBjb250cm9scyB0aGUgZGlzcGxheSBvZiB0aGUgZm9ybSwgYnV0IGRvZXNuJ3QgY29udGFpbiBmb3JtIGRhdGEuXG4gKlxuICogYGBgaHRtbFxuICogPGZvcm0+XG4gKiAgIDxpbnB1dCBuYW1lPVwibG9naW5cIiBuZ01vZGVsIHBsYWNlaG9sZGVyPVwiTG9naW5cIj5cbiAqICAgPGlucHV0IHR5cGU9XCJjaGVja2JveFwiIG5nTW9kZWwgW25nTW9kZWxPcHRpb25zXT1cIntzdGFuZGFsb25lOiB0cnVlfVwiPiBTaG93IG1vcmUgb3B0aW9ucz9cbiAqIDwvZm9ybT5cbiAqIDwhLS0gZm9ybSB2YWx1ZToge2xvZ2luOiAnJ30gLS0+XG4gKiBgYGBcbiAqXG4gKiAjIyMgU2V0dGluZyB0aGUgbmdNb2RlbCBgbmFtZWAgYXR0cmlidXRlIHRocm91Z2ggb3B0aW9uc1xuICpcbiAqIFRoZSBmb2xsb3dpbmcgZXhhbXBsZSBzaG93cyB5b3UgYW4gYWx0ZXJuYXRlIHdheSB0byBzZXQgdGhlIG5hbWUgYXR0cmlidXRlLiBIZXJlLFxuICogYW4gYXR0cmlidXRlIGlkZW50aWZpZWQgYXMgbmFtZSBpcyB1c2VkIHdpdGhpbiBhIGN1c3RvbSBmb3JtIGNvbnRyb2wgY29tcG9uZW50LiBUbyBzdGlsbCBiZSBhYmxlXG4gKiB0byBzcGVjaWZ5IHRoZSBOZ01vZGVsJ3MgbmFtZSwgeW91IG11c3Qgc3BlY2lmeSBpdCB1c2luZyB0aGUgYG5nTW9kZWxPcHRpb25zYCBpbnB1dCBpbnN0ZWFkLlxuICpcbiAqIGBgYGh0bWxcbiAqIDxmb3JtPlxuICogICA8bXktY3VzdG9tLWZvcm0tY29udHJvbCBuYW1lPVwiTmFuY3lcIiBuZ01vZGVsIFtuZ01vZGVsT3B0aW9uc109XCJ7bmFtZTogJ3VzZXInfVwiPlxuICogICA8L215LWN1c3RvbS1mb3JtLWNvbnRyb2w+XG4gKiA8L2Zvcm0+XG4gKiA8IS0tIGZvcm0gdmFsdWU6IHt1c2VyOiAnJ30gLS0+XG4gKiBgYGBcbiAqXG4gKiBAbmdNb2R1bGUgRm9ybXNNb2R1bGVcbiAqIEBwdWJsaWNBcGlcbiAqL1xuY2xhc3MgTmdNb2RlbCBleHRlbmRzIE5nQ29udHJvbCB7XG4gICAgY29uc3RydWN0b3IocGFyZW50LCB2YWxpZGF0b3JzLCBhc3luY1ZhbGlkYXRvcnMsIHZhbHVlQWNjZXNzb3JzLCBfY2hhbmdlRGV0ZWN0b3JSZWYsIGNhbGxTZXREaXNhYmxlZFN0YXRlKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuX2NoYW5nZURldGVjdG9yUmVmID0gX2NoYW5nZURldGVjdG9yUmVmO1xuICAgICAgICB0aGlzLmNhbGxTZXREaXNhYmxlZFN0YXRlID0gY2FsbFNldERpc2FibGVkU3RhdGU7XG4gICAgICAgIHRoaXMuY29udHJvbCA9IG5ldyBGb3JtQ29udHJvbCgpO1xuICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgIHRoaXMuX3JlZ2lzdGVyZWQgPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAgICAgKiBUcmFja3MgdGhlIG5hbWUgYm91bmQgdG8gdGhlIGRpcmVjdGl2ZS4gSWYgYSBwYXJlbnQgZm9ybSBleGlzdHMsIGl0XG4gICAgICAgICAqIHVzZXMgdGhpcyBuYW1lIGFzIGEga2V5IHRvIHJldHJpZXZlIHRoaXMgY29udHJvbCdzIHZhbHVlLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5uYW1lID0gJyc7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgICAgICogRXZlbnQgZW1pdHRlciBmb3IgcHJvZHVjaW5nIHRoZSBgbmdNb2RlbENoYW5nZWAgZXZlbnQgYWZ0ZXJcbiAgICAgICAgICogdGhlIHZpZXcgbW9kZWwgdXBkYXRlcy5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudXBkYXRlID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICB0aGlzLl9wYXJlbnQgPSBwYXJlbnQ7XG4gICAgICAgIHRoaXMuX3NldFZhbGlkYXRvcnModmFsaWRhdG9ycyk7XG4gICAgICAgIHRoaXMuX3NldEFzeW5jVmFsaWRhdG9ycyhhc3luY1ZhbGlkYXRvcnMpO1xuICAgICAgICB0aGlzLnZhbHVlQWNjZXNzb3IgPSBzZWxlY3RWYWx1ZUFjY2Vzc29yKHRoaXMsIHZhbHVlQWNjZXNzb3JzKTtcbiAgICB9XG4gICAgLyoqIEBub2RvYyAqL1xuICAgIG5nT25DaGFuZ2VzKGNoYW5nZXMpIHtcbiAgICAgICAgdGhpcy5fY2hlY2tGb3JFcnJvcnMoKTtcbiAgICAgICAgaWYgKCF0aGlzLl9yZWdpc3RlcmVkIHx8ICduYW1lJyBpbiBjaGFuZ2VzKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fcmVnaXN0ZXJlZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2NoZWNrTmFtZSgpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmZvcm1EaXJlY3RpdmUpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gV2UgY2FuJ3QgY2FsbCBgZm9ybURpcmVjdGl2ZS5yZW1vdmVDb250cm9sKHRoaXMpYCwgYmVjYXVzZSB0aGUgYG5hbWVgIGhhcyBhbHJlYWR5IGJlZW5cbiAgICAgICAgICAgICAgICAgICAgLy8gY2hhbmdlZC4gV2UgYWxzbyBjYW4ndCByZXNldCB0aGUgbmFtZSB0ZW1wb3JhcmlseSBzaW5jZSB0aGUgbG9naWMgaW4gYHJlbW92ZUNvbnRyb2xgXG4gICAgICAgICAgICAgICAgICAgIC8vIGlzIGluc2lkZSBhIHByb21pc2UgYW5kIGl0IHdvbid0IHJ1biBpbW1lZGlhdGVseS4gV2Ugd29yayBhcm91bmQgaXQgYnkgZ2l2aW5nIGl0IGFuXG4gICAgICAgICAgICAgICAgICAgIC8vIG9iamVjdCB3aXRoIHRoZSBzYW1lIHNoYXBlIGluc3RlYWQuXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG9sZE5hbWUgPSBjaGFuZ2VzWyduYW1lJ10ucHJldmlvdXNWYWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5mb3JtRGlyZWN0aXZlLnJlbW92ZUNvbnRyb2woeyBuYW1lOiBvbGROYW1lLCBwYXRoOiB0aGlzLl9nZXRQYXRoKG9sZE5hbWUpIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3NldFVwQ29udHJvbCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICgnaXNEaXNhYmxlZCcgaW4gY2hhbmdlcykge1xuICAgICAgICAgICAgdGhpcy5fdXBkYXRlRGlzYWJsZWQoY2hhbmdlcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzUHJvcGVydHlVcGRhdGVkKGNoYW5nZXMsIHRoaXMudmlld01vZGVsKSkge1xuICAgICAgICAgICAgdGhpcy5fdXBkYXRlVmFsdWUodGhpcy5tb2RlbCk7XG4gICAgICAgICAgICB0aGlzLnZpZXdNb2RlbCA9IHRoaXMubW9kZWw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqIEBub2RvYyAqL1xuICAgIG5nT25EZXN0cm95KCkge1xuICAgICAgICB0aGlzLmZvcm1EaXJlY3RpdmUgJiYgdGhpcy5mb3JtRGlyZWN0aXZlLnJlbW92ZUNvbnRyb2wodGhpcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqIFJldHVybnMgYW4gYXJyYXkgdGhhdCByZXByZXNlbnRzIHRoZSBwYXRoIGZyb20gdGhlIHRvcC1sZXZlbCBmb3JtIHRvIHRoaXMgY29udHJvbC5cbiAgICAgKiBFYWNoIGluZGV4IGlzIHRoZSBzdHJpbmcgbmFtZSBvZiB0aGUgY29udHJvbCBvbiB0aGF0IGxldmVsLlxuICAgICAqL1xuICAgIGdldCBwYXRoKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZ2V0UGF0aCh0aGlzLm5hbWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKiBUaGUgdG9wLWxldmVsIGRpcmVjdGl2ZSBmb3IgdGhpcyBjb250cm9sIGlmIHByZXNlbnQsIG90aGVyd2lzZSBudWxsLlxuICAgICAqL1xuICAgIGdldCBmb3JtRGlyZWN0aXZlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcGFyZW50ID8gdGhpcy5fcGFyZW50LmZvcm1EaXJlY3RpdmUgOiBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKiBTZXRzIHRoZSBuZXcgdmFsdWUgZm9yIHRoZSB2aWV3IG1vZGVsIGFuZCBlbWl0cyBhbiBgbmdNb2RlbENoYW5nZWAgZXZlbnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbmV3VmFsdWUgVGhlIG5ldyB2YWx1ZSBlbWl0dGVkIGJ5IGBuZ01vZGVsQ2hhbmdlYC5cbiAgICAgKi9cbiAgICB2aWV3VG9Nb2RlbFVwZGF0ZShuZXdWYWx1ZSkge1xuICAgICAgICB0aGlzLnZpZXdNb2RlbCA9IG5ld1ZhbHVlO1xuICAgICAgICB0aGlzLnVwZGF0ZS5lbWl0KG5ld1ZhbHVlKTtcbiAgICB9XG4gICAgX3NldFVwQ29udHJvbCgpIHtcbiAgICAgICAgdGhpcy5fc2V0VXBkYXRlU3RyYXRlZ3koKTtcbiAgICAgICAgdGhpcy5faXNTdGFuZGFsb25lKCkgPyB0aGlzLl9zZXRVcFN0YW5kYWxvbmUoKSA6IHRoaXMuZm9ybURpcmVjdGl2ZS5hZGRDb250cm9sKHRoaXMpO1xuICAgICAgICB0aGlzLl9yZWdpc3RlcmVkID0gdHJ1ZTtcbiAgICB9XG4gICAgX3NldFVwZGF0ZVN0cmF0ZWd5KCkge1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zICYmIHRoaXMub3B0aW9ucy51cGRhdGVPbiAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmNvbnRyb2wuX3VwZGF0ZU9uID0gdGhpcy5vcHRpb25zLnVwZGF0ZU9uO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9pc1N0YW5kYWxvbmUoKSB7XG4gICAgICAgIHJldHVybiAhdGhpcy5fcGFyZW50IHx8ICEhKHRoaXMub3B0aW9ucyAmJiB0aGlzLm9wdGlvbnMuc3RhbmRhbG9uZSk7XG4gICAgfVxuICAgIF9zZXRVcFN0YW5kYWxvbmUoKSB7XG4gICAgICAgIHNldFVwQ29udHJvbCh0aGlzLmNvbnRyb2wsIHRoaXMsIHRoaXMuY2FsbFNldERpc2FibGVkU3RhdGUpO1xuICAgICAgICB0aGlzLmNvbnRyb2wudXBkYXRlVmFsdWVBbmRWYWxpZGl0eSh7IGVtaXRFdmVudDogZmFsc2UgfSk7XG4gICAgfVxuICAgIF9jaGVja0ZvckVycm9ycygpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9pc1N0YW5kYWxvbmUoKSkge1xuICAgICAgICAgICAgdGhpcy5fY2hlY2tQYXJlbnRUeXBlKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fY2hlY2tOYW1lKCk7XG4gICAgfVxuICAgIF9jaGVja1BhcmVudFR5cGUoKSB7XG4gICAgICAgIGlmICh0eXBlb2YgbmdEZXZNb2RlID09PSAndW5kZWZpbmVkJyB8fCBuZ0Rldk1vZGUpIHtcbiAgICAgICAgICAgIGlmICghKHRoaXMuX3BhcmVudCBpbnN0YW5jZW9mIE5nTW9kZWxHcm91cCkgJiZcbiAgICAgICAgICAgICAgICB0aGlzLl9wYXJlbnQgaW5zdGFuY2VvZiBBYnN0cmFjdEZvcm1Hcm91cERpcmVjdGl2ZSkge1xuICAgICAgICAgICAgICAgIHRocm93IGZvcm1Hcm91cE5hbWVFeGNlcHRpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCEodGhpcy5fcGFyZW50IGluc3RhbmNlb2YgTmdNb2RlbEdyb3VwKSAmJiAhKHRoaXMuX3BhcmVudCBpbnN0YW5jZW9mIE5nRm9ybSkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBtb2RlbFBhcmVudEV4Y2VwdGlvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIF9jaGVja05hbWUoKSB7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMgJiYgdGhpcy5vcHRpb25zLm5hbWUpXG4gICAgICAgICAgICB0aGlzLm5hbWUgPSB0aGlzLm9wdGlvbnMubmFtZTtcbiAgICAgICAgaWYgKCF0aGlzLl9pc1N0YW5kYWxvbmUoKSAmJiAhdGhpcy5uYW1lICYmICh0eXBlb2YgbmdEZXZNb2RlID09PSAndW5kZWZpbmVkJyB8fCBuZ0Rldk1vZGUpKSB7XG4gICAgICAgICAgICB0aHJvdyBtaXNzaW5nTmFtZUV4Y2VwdGlvbigpO1xuICAgICAgICB9XG4gICAgfVxuICAgIF91cGRhdGVWYWx1ZSh2YWx1ZSkge1xuICAgICAgICByZXNvbHZlZFByb21pc2UudGhlbigoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmNvbnRyb2wuc2V0VmFsdWUodmFsdWUsIHsgZW1pdFZpZXdUb01vZGVsQ2hhbmdlOiBmYWxzZSB9KTtcbiAgICAgICAgICAgIHRoaXMuX2NoYW5nZURldGVjdG9yUmVmPy5tYXJrRm9yQ2hlY2soKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIF91cGRhdGVEaXNhYmxlZChjaGFuZ2VzKSB7XG4gICAgICAgIGNvbnN0IGRpc2FibGVkVmFsdWUgPSBjaGFuZ2VzWydpc0Rpc2FibGVkJ10uY3VycmVudFZhbHVlO1xuICAgICAgICAvLyBjaGVja2luZyBmb3IgMCB0byBhdm9pZCBicmVha2luZyBjaGFuZ2VcbiAgICAgICAgY29uc3QgaXNEaXNhYmxlZCA9IGRpc2FibGVkVmFsdWUgIT09IDAgJiYgYm9vbGVhbkF0dHJpYnV0ZShkaXNhYmxlZFZhbHVlKTtcbiAgICAgICAgcmVzb2x2ZWRQcm9taXNlLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgaWYgKGlzRGlzYWJsZWQgJiYgIXRoaXMuY29udHJvbC5kaXNhYmxlZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuY29udHJvbC5kaXNhYmxlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICghaXNEaXNhYmxlZCAmJiB0aGlzLmNvbnRyb2wuZGlzYWJsZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRyb2wuZW5hYmxlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9jaGFuZ2VEZXRlY3RvclJlZj8ubWFya0ZvckNoZWNrKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBfZ2V0UGF0aChjb250cm9sTmFtZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcGFyZW50ID8gY29udHJvbFBhdGgoY29udHJvbE5hbWUsIHRoaXMuX3BhcmVudCkgOiBbY29udHJvbE5hbWVdO1xuICAgIH1cbiAgICBzdGF0aWMgeyB0aGlzLsm1ZmFjID0gaTAuybXJtW5nRGVjbGFyZUZhY3RvcnkoeyBtaW5WZXJzaW9uOiBcIjEyLjAuMFwiLCB2ZXJzaW9uOiBcIjE3LjMuMTJcIiwgbmdJbXBvcnQ6IGkwLCB0eXBlOiBOZ01vZGVsLCBkZXBzOiBbeyB0b2tlbjogQ29udHJvbENvbnRhaW5lciwgaG9zdDogdHJ1ZSwgb3B0aW9uYWw6IHRydWUgfSwgeyB0b2tlbjogTkdfVkFMSURBVE9SUywgb3B0aW9uYWw6IHRydWUsIHNlbGY6IHRydWUgfSwgeyB0b2tlbjogTkdfQVNZTkNfVkFMSURBVE9SUywgb3B0aW9uYWw6IHRydWUsIHNlbGY6IHRydWUgfSwgeyB0b2tlbjogTkdfVkFMVUVfQUNDRVNTT1IsIG9wdGlvbmFsOiB0cnVlLCBzZWxmOiB0cnVlIH0sIHsgdG9rZW46IENoYW5nZURldGVjdG9yUmVmLCBvcHRpb25hbDogdHJ1ZSB9LCB7IHRva2VuOiBDQUxMX1NFVF9ESVNBQkxFRF9TVEFURSwgb3B0aW9uYWw6IHRydWUgfV0sIHRhcmdldDogaTAuybXJtUZhY3RvcnlUYXJnZXQuRGlyZWN0aXZlIH0pOyB9XG4gICAgc3RhdGljIHsgdGhpcy7JtWRpciA9IGkwLsm1ybVuZ0RlY2xhcmVEaXJlY3RpdmUoeyBtaW5WZXJzaW9uOiBcIjE0LjAuMFwiLCB2ZXJzaW9uOiBcIjE3LjMuMTJcIiwgdHlwZTogTmdNb2RlbCwgc2VsZWN0b3I6IFwiW25nTW9kZWxdOm5vdChbZm9ybUNvbnRyb2xOYW1lXSk6bm90KFtmb3JtQ29udHJvbF0pXCIsIGlucHV0czogeyBuYW1lOiBcIm5hbWVcIiwgaXNEaXNhYmxlZDogW1wiZGlzYWJsZWRcIiwgXCJpc0Rpc2FibGVkXCJdLCBtb2RlbDogW1wibmdNb2RlbFwiLCBcIm1vZGVsXCJdLCBvcHRpb25zOiBbXCJuZ01vZGVsT3B0aW9uc1wiLCBcIm9wdGlvbnNcIl0gfSwgb3V0cHV0czogeyB1cGRhdGU6IFwibmdNb2RlbENoYW5nZVwiIH0sIHByb3ZpZGVyczogW2Zvcm1Db250cm9sQmluZGluZyQxXSwgZXhwb3J0QXM6IFtcIm5nTW9kZWxcIl0sIHVzZXNJbmhlcml0YW5jZTogdHJ1ZSwgdXNlc09uQ2hhbmdlczogdHJ1ZSwgbmdJbXBvcnQ6IGkwIH0pOyB9XG59XG5pMC7Jtcm1bmdEZWNsYXJlQ2xhc3NNZXRhZGF0YSh7IG1pblZlcnNpb246IFwiMTIuMC4wXCIsIHZlcnNpb246IFwiMTcuMy4xMlwiLCBuZ0ltcG9ydDogaTAsIHR5cGU6IE5nTW9kZWwsIGRlY29yYXRvcnM6IFt7XG4gICAgICAgICAgICB0eXBlOiBEaXJlY3RpdmUsXG4gICAgICAgICAgICBhcmdzOiBbe1xuICAgICAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ1tuZ01vZGVsXTpub3QoW2Zvcm1Db250cm9sTmFtZV0pOm5vdChbZm9ybUNvbnRyb2xdKScsXG4gICAgICAgICAgICAgICAgICAgIHByb3ZpZGVyczogW2Zvcm1Db250cm9sQmluZGluZyQxXSxcbiAgICAgICAgICAgICAgICAgICAgZXhwb3J0QXM6ICduZ01vZGVsJ1xuICAgICAgICAgICAgICAgIH1dXG4gICAgICAgIH1dLCBjdG9yUGFyYW1ldGVyczogKCkgPT4gW3sgdHlwZTogQ29udHJvbENvbnRhaW5lciwgZGVjb3JhdG9yczogW3tcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogT3B0aW9uYWxcbiAgICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IEhvc3RcbiAgICAgICAgICAgICAgICB9XSB9LCB7IHR5cGU6IHVuZGVmaW5lZCwgZGVjb3JhdG9yczogW3tcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogT3B0aW9uYWxcbiAgICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFNlbGZcbiAgICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IEluamVjdCxcbiAgICAgICAgICAgICAgICAgICAgYXJnczogW05HX1ZBTElEQVRPUlNdXG4gICAgICAgICAgICAgICAgfV0gfSwgeyB0eXBlOiB1bmRlZmluZWQsIGRlY29yYXRvcnM6IFt7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IE9wdGlvbmFsXG4gICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBTZWxmXG4gICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBJbmplY3QsXG4gICAgICAgICAgICAgICAgICAgIGFyZ3M6IFtOR19BU1lOQ19WQUxJREFUT1JTXVxuICAgICAgICAgICAgICAgIH1dIH0sIHsgdHlwZTogdW5kZWZpbmVkLCBkZWNvcmF0b3JzOiBbe1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBPcHRpb25hbFxuICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogU2VsZlxuICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogSW5qZWN0LFxuICAgICAgICAgICAgICAgICAgICBhcmdzOiBbTkdfVkFMVUVfQUNDRVNTT1JdXG4gICAgICAgICAgICAgICAgfV0gfSwgeyB0eXBlOiBpMC5DaGFuZ2VEZXRlY3RvclJlZiwgZGVjb3JhdG9yczogW3tcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogT3B0aW9uYWxcbiAgICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IEluamVjdCxcbiAgICAgICAgICAgICAgICAgICAgYXJnczogW0NoYW5nZURldGVjdG9yUmVmXVxuICAgICAgICAgICAgICAgIH1dIH0sIHsgdHlwZTogdW5kZWZpbmVkLCBkZWNvcmF0b3JzOiBbe1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBPcHRpb25hbFxuICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogSW5qZWN0LFxuICAgICAgICAgICAgICAgICAgICBhcmdzOiBbQ0FMTF9TRVRfRElTQUJMRURfU1RBVEVdXG4gICAgICAgICAgICAgICAgfV0gfV0sIHByb3BEZWNvcmF0b3JzOiB7IG5hbWU6IFt7XG4gICAgICAgICAgICAgICAgdHlwZTogSW5wdXRcbiAgICAgICAgICAgIH1dLCBpc0Rpc2FibGVkOiBbe1xuICAgICAgICAgICAgICAgIHR5cGU6IElucHV0LFxuICAgICAgICAgICAgICAgIGFyZ3M6IFsnZGlzYWJsZWQnXVxuICAgICAgICAgICAgfV0sIG1vZGVsOiBbe1xuICAgICAgICAgICAgICAgIHR5cGU6IElucHV0LFxuICAgICAgICAgICAgICAgIGFyZ3M6IFsnbmdNb2RlbCddXG4gICAgICAgICAgICB9XSwgb3B0aW9uczogW3tcbiAgICAgICAgICAgICAgICB0eXBlOiBJbnB1dCxcbiAgICAgICAgICAgICAgICBhcmdzOiBbJ25nTW9kZWxPcHRpb25zJ11cbiAgICAgICAgICAgIH1dLCB1cGRhdGU6IFt7XG4gICAgICAgICAgICAgICAgdHlwZTogT3V0cHV0LFxuICAgICAgICAgICAgICAgIGFyZ3M6IFsnbmdNb2RlbENoYW5nZSddXG4gICAgICAgICAgICB9XSB9IH0pO1xuXG4vKipcbiAqIEBkZXNjcmlwdGlvblxuICpcbiAqIEFkZHMgYG5vdmFsaWRhdGVgIGF0dHJpYnV0ZSB0byBhbGwgZm9ybXMgYnkgZGVmYXVsdC5cbiAqXG4gKiBgbm92YWxpZGF0ZWAgaXMgdXNlZCB0byBkaXNhYmxlIGJyb3dzZXIncyBuYXRpdmUgZm9ybSB2YWxpZGF0aW9uLlxuICpcbiAqIElmIHlvdSB3YW50IHRvIHVzZSBuYXRpdmUgdmFsaWRhdGlvbiB3aXRoIEFuZ3VsYXIgZm9ybXMsIGp1c3QgYWRkIGBuZ05hdGl2ZVZhbGlkYXRlYCBhdHRyaWJ1dGU6XG4gKlxuICogYGBgXG4gKiA8Zm9ybSBuZ05hdGl2ZVZhbGlkYXRlPjwvZm9ybT5cbiAqIGBgYFxuICpcbiAqIEBwdWJsaWNBcGlcbiAqIEBuZ01vZHVsZSBSZWFjdGl2ZUZvcm1zTW9kdWxlXG4gKiBAbmdNb2R1bGUgRm9ybXNNb2R1bGVcbiAqL1xuY2xhc3MgybVOZ05vVmFsaWRhdGUge1xuICAgIHN0YXRpYyB7IHRoaXMuybVmYWMgPSBpMC7Jtcm1bmdEZWNsYXJlRmFjdG9yeSh7IG1pblZlcnNpb246IFwiMTIuMC4wXCIsIHZlcnNpb246IFwiMTcuMy4xMlwiLCBuZ0ltcG9ydDogaTAsIHR5cGU6IMm1TmdOb1ZhbGlkYXRlLCBkZXBzOiBbXSwgdGFyZ2V0OiBpMC7Jtcm1RmFjdG9yeVRhcmdldC5EaXJlY3RpdmUgfSk7IH1cbiAgICBzdGF0aWMgeyB0aGlzLsm1ZGlyID0gaTAuybXJtW5nRGVjbGFyZURpcmVjdGl2ZSh7IG1pblZlcnNpb246IFwiMTQuMC4wXCIsIHZlcnNpb246IFwiMTcuMy4xMlwiLCB0eXBlOiDJtU5nTm9WYWxpZGF0ZSwgc2VsZWN0b3I6IFwiZm9ybTpub3QoW25nTm9Gb3JtXSk6bm90KFtuZ05hdGl2ZVZhbGlkYXRlXSlcIiwgaG9zdDogeyBhdHRyaWJ1dGVzOiB7IFwibm92YWxpZGF0ZVwiOiBcIlwiIH0gfSwgbmdJbXBvcnQ6IGkwIH0pOyB9XG59XG5pMC7Jtcm1bmdEZWNsYXJlQ2xhc3NNZXRhZGF0YSh7IG1pblZlcnNpb246IFwiMTIuMC4wXCIsIHZlcnNpb246IFwiMTcuMy4xMlwiLCBuZ0ltcG9ydDogaTAsIHR5cGU6IMm1TmdOb1ZhbGlkYXRlLCBkZWNvcmF0b3JzOiBbe1xuICAgICAgICAgICAgdHlwZTogRGlyZWN0aXZlLFxuICAgICAgICAgICAgYXJnczogW3tcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdmb3JtOm5vdChbbmdOb0Zvcm1dKTpub3QoW25nTmF0aXZlVmFsaWRhdGVdKScsXG4gICAgICAgICAgICAgICAgICAgIGhvc3Q6IHsgJ25vdmFsaWRhdGUnOiAnJyB9LFxuICAgICAgICAgICAgICAgIH1dXG4gICAgICAgIH1dIH0pO1xuXG5jb25zdCBOVU1CRVJfVkFMVUVfQUNDRVNTT1IgPSB7XG4gICAgcHJvdmlkZTogTkdfVkFMVUVfQUNDRVNTT1IsXG4gICAgdXNlRXhpc3Rpbmc6IGZvcndhcmRSZWYoKCkgPT4gTnVtYmVyVmFsdWVBY2Nlc3NvciksXG4gICAgbXVsdGk6IHRydWVcbn07XG4vKipcbiAqIEBkZXNjcmlwdGlvblxuICogVGhlIGBDb250cm9sVmFsdWVBY2Nlc3NvcmAgZm9yIHdyaXRpbmcgYSBudW1iZXIgdmFsdWUgYW5kIGxpc3RlbmluZyB0byBudW1iZXIgaW5wdXQgY2hhbmdlcy5cbiAqIFRoZSB2YWx1ZSBhY2Nlc3NvciBpcyB1c2VkIGJ5IHRoZSBgRm9ybUNvbnRyb2xEaXJlY3RpdmVgLCBgRm9ybUNvbnRyb2xOYW1lYCwgYW5kIGBOZ01vZGVsYFxuICogZGlyZWN0aXZlcy5cbiAqXG4gKiBAdXNhZ2VOb3Rlc1xuICpcbiAqICMjIyBVc2luZyBhIG51bWJlciBpbnB1dCB3aXRoIGEgcmVhY3RpdmUgZm9ybS5cbiAqXG4gKiBUaGUgZm9sbG93aW5nIGV4YW1wbGUgc2hvd3MgaG93IHRvIHVzZSBhIG51bWJlciBpbnB1dCB3aXRoIGEgcmVhY3RpdmUgZm9ybS5cbiAqXG4gKiBgYGB0c1xuICogY29uc3QgdG90YWxDb3VudENvbnRyb2wgPSBuZXcgRm9ybUNvbnRyb2woKTtcbiAqIGBgYFxuICpcbiAqIGBgYFxuICogPGlucHV0IHR5cGU9XCJudW1iZXJcIiBbZm9ybUNvbnRyb2xdPVwidG90YWxDb3VudENvbnRyb2xcIj5cbiAqIGBgYFxuICpcbiAqIEBuZ01vZHVsZSBSZWFjdGl2ZUZvcm1zTW9kdWxlXG4gKiBAbmdNb2R1bGUgRm9ybXNNb2R1bGVcbiAqIEBwdWJsaWNBcGlcbiAqL1xuY2xhc3MgTnVtYmVyVmFsdWVBY2Nlc3NvciBleHRlbmRzIEJ1aWx0SW5Db250cm9sVmFsdWVBY2Nlc3NvciB7XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgXCJ2YWx1ZVwiIHByb3BlcnR5IG9uIHRoZSBpbnB1dCBlbGVtZW50LlxuICAgICAqIEBub2RvY1xuICAgICAqL1xuICAgIHdyaXRlVmFsdWUodmFsdWUpIHtcbiAgICAgICAgLy8gVGhlIHZhbHVlIG5lZWRzIHRvIGJlIG5vcm1hbGl6ZWQgZm9yIElFOSwgb3RoZXJ3aXNlIGl0IGlzIHNldCB0byAnbnVsbCcgd2hlbiBudWxsXG4gICAgICAgIGNvbnN0IG5vcm1hbGl6ZWRWYWx1ZSA9IHZhbHVlID09IG51bGwgPyAnJyA6IHZhbHVlO1xuICAgICAgICB0aGlzLnNldFByb3BlcnR5KCd2YWx1ZScsIG5vcm1hbGl6ZWRWYWx1ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlZ2lzdGVycyBhIGZ1bmN0aW9uIGNhbGxlZCB3aGVuIHRoZSBjb250cm9sIHZhbHVlIGNoYW5nZXMuXG4gICAgICogQG5vZG9jXG4gICAgICovXG4gICAgcmVnaXN0ZXJPbkNoYW5nZShmbikge1xuICAgICAgICB0aGlzLm9uQ2hhbmdlID0gKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICBmbih2YWx1ZSA9PSAnJyA/IG51bGwgOiBwYXJzZUZsb2F0KHZhbHVlKSk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIHN0YXRpYyB7IHRoaXMuybVmYWMgPSBpMC7Jtcm1bmdEZWNsYXJlRmFjdG9yeSh7IG1pblZlcnNpb246IFwiMTIuMC4wXCIsIHZlcnNpb246IFwiMTcuMy4xMlwiLCBuZ0ltcG9ydDogaTAsIHR5cGU6IE51bWJlclZhbHVlQWNjZXNzb3IsIGRlcHM6IG51bGwsIHRhcmdldDogaTAuybXJtUZhY3RvcnlUYXJnZXQuRGlyZWN0aXZlIH0pOyB9XG4gICAgc3RhdGljIHsgdGhpcy7JtWRpciA9IGkwLsm1ybVuZ0RlY2xhcmVEaXJlY3RpdmUoeyBtaW5WZXJzaW9uOiBcIjE0LjAuMFwiLCB2ZXJzaW9uOiBcIjE3LjMuMTJcIiwgdHlwZTogTnVtYmVyVmFsdWVBY2Nlc3Nvciwgc2VsZWN0b3I6IFwiaW5wdXRbdHlwZT1udW1iZXJdW2Zvcm1Db250cm9sTmFtZV0saW5wdXRbdHlwZT1udW1iZXJdW2Zvcm1Db250cm9sXSxpbnB1dFt0eXBlPW51bWJlcl1bbmdNb2RlbF1cIiwgaG9zdDogeyBsaXN0ZW5lcnM6IHsgXCJpbnB1dFwiOiBcIm9uQ2hhbmdlKCRldmVudC50YXJnZXQudmFsdWUpXCIsIFwiYmx1clwiOiBcIm9uVG91Y2hlZCgpXCIgfSB9LCBwcm92aWRlcnM6IFtOVU1CRVJfVkFMVUVfQUNDRVNTT1JdLCB1c2VzSW5oZXJpdGFuY2U6IHRydWUsIG5nSW1wb3J0OiBpMCB9KTsgfVxufVxuaTAuybXJtW5nRGVjbGFyZUNsYXNzTWV0YWRhdGEoeyBtaW5WZXJzaW9uOiBcIjEyLjAuMFwiLCB2ZXJzaW9uOiBcIjE3LjMuMTJcIiwgbmdJbXBvcnQ6IGkwLCB0eXBlOiBOdW1iZXJWYWx1ZUFjY2Vzc29yLCBkZWNvcmF0b3JzOiBbe1xuICAgICAgICAgICAgdHlwZTogRGlyZWN0aXZlLFxuICAgICAgICAgICAgYXJnczogW3tcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdpbnB1dFt0eXBlPW51bWJlcl1bZm9ybUNvbnRyb2xOYW1lXSxpbnB1dFt0eXBlPW51bWJlcl1bZm9ybUNvbnRyb2xdLGlucHV0W3R5cGU9bnVtYmVyXVtuZ01vZGVsXScsXG4gICAgICAgICAgICAgICAgICAgIGhvc3Q6IHsgJyhpbnB1dCknOiAnb25DaGFuZ2UoJGV2ZW50LnRhcmdldC52YWx1ZSknLCAnKGJsdXIpJzogJ29uVG91Y2hlZCgpJyB9LFxuICAgICAgICAgICAgICAgICAgICBwcm92aWRlcnM6IFtOVU1CRVJfVkFMVUVfQUNDRVNTT1JdXG4gICAgICAgICAgICAgICAgfV1cbiAgICAgICAgfV0gfSk7XG5cbmNvbnN0IFJBRElPX1ZBTFVFX0FDQ0VTU09SID0ge1xuICAgIHByb3ZpZGU6IE5HX1ZBTFVFX0FDQ0VTU09SLFxuICAgIHVzZUV4aXN0aW5nOiBmb3J3YXJkUmVmKCgpID0+IFJhZGlvQ29udHJvbFZhbHVlQWNjZXNzb3IpLFxuICAgIG11bHRpOiB0cnVlXG59O1xuZnVuY3Rpb24gdGhyb3dOYW1lRXJyb3IoKSB7XG4gICAgdGhyb3cgbmV3IMm1UnVudGltZUVycm9yKDEyMDIgLyogUnVudGltZUVycm9yQ29kZS5OQU1FX0FORF9GT1JNX0NPTlRST0xfTkFNRV9NVVNUX01BVENIICovLCBgXG4gICAgICBJZiB5b3UgZGVmaW5lIGJvdGggYSBuYW1lIGFuZCBhIGZvcm1Db250cm9sTmFtZSBhdHRyaWJ1dGUgb24geW91ciByYWRpbyBidXR0b24sIHRoZWlyIHZhbHVlc1xuICAgICAgbXVzdCBtYXRjaC4gRXg6IDxpbnB1dCB0eXBlPVwicmFkaW9cIiBmb3JtQ29udHJvbE5hbWU9XCJmb29kXCIgbmFtZT1cImZvb2RcIj5cbiAgICBgKTtcbn1cbi8qKlxuICogQGRlc2NyaXB0aW9uXG4gKiBDbGFzcyB1c2VkIGJ5IEFuZ3VsYXIgdG8gdHJhY2sgcmFkaW8gYnV0dG9ucy4gRm9yIGludGVybmFsIHVzZSBvbmx5LlxuICovXG5jbGFzcyBSYWRpb0NvbnRyb2xSZWdpc3RyeSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuX2FjY2Vzc29ycyA9IFtdO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKiBBZGRzIGEgY29udHJvbCB0byB0aGUgaW50ZXJuYWwgcmVnaXN0cnkuIEZvciBpbnRlcm5hbCB1c2Ugb25seS5cbiAgICAgKi9cbiAgICBhZGQoY29udHJvbCwgYWNjZXNzb3IpIHtcbiAgICAgICAgdGhpcy5fYWNjZXNzb3JzLnB1c2goW2NvbnRyb2wsIGFjY2Vzc29yXSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqIFJlbW92ZXMgYSBjb250cm9sIGZyb20gdGhlIGludGVybmFsIHJlZ2lzdHJ5LiBGb3IgaW50ZXJuYWwgdXNlIG9ubHkuXG4gICAgICovXG4gICAgcmVtb3ZlKGFjY2Vzc29yKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSB0aGlzLl9hY2Nlc3NvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9hY2Nlc3NvcnNbaV1bMV0gPT09IGFjY2Vzc29yKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fYWNjZXNzb3JzLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICogU2VsZWN0cyBhIHJhZGlvIGJ1dHRvbi4gRm9yIGludGVybmFsIHVzZSBvbmx5LlxuICAgICAqL1xuICAgIHNlbGVjdChhY2Nlc3Nvcikge1xuICAgICAgICB0aGlzLl9hY2Nlc3NvcnMuZm9yRWFjaCgoYykgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2lzU2FtZUdyb3VwKGMsIGFjY2Vzc29yKSAmJiBjWzFdICE9PSBhY2Nlc3Nvcikge1xuICAgICAgICAgICAgICAgIGNbMV0uZmlyZVVuY2hlY2soYWNjZXNzb3IudmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgX2lzU2FtZUdyb3VwKGNvbnRyb2xQYWlyLCBhY2Nlc3Nvcikge1xuICAgICAgICBpZiAoIWNvbnRyb2xQYWlyWzBdLmNvbnRyb2wpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHJldHVybiBjb250cm9sUGFpclswXS5fcGFyZW50ID09PSBhY2Nlc3Nvci5fY29udHJvbC5fcGFyZW50ICYmXG4gICAgICAgICAgICBjb250cm9sUGFpclsxXS5uYW1lID09PSBhY2Nlc3Nvci5uYW1lO1xuICAgIH1cbiAgICBzdGF0aWMgeyB0aGlzLsm1ZmFjID0gaTAuybXJtW5nRGVjbGFyZUZhY3RvcnkoeyBtaW5WZXJzaW9uOiBcIjEyLjAuMFwiLCB2ZXJzaW9uOiBcIjE3LjMuMTJcIiwgbmdJbXBvcnQ6IGkwLCB0eXBlOiBSYWRpb0NvbnRyb2xSZWdpc3RyeSwgZGVwczogW10sIHRhcmdldDogaTAuybXJtUZhY3RvcnlUYXJnZXQuSW5qZWN0YWJsZSB9KTsgfVxuICAgIHN0YXRpYyB7IHRoaXMuybVwcm92ID0gaTAuybXJtW5nRGVjbGFyZUluamVjdGFibGUoeyBtaW5WZXJzaW9uOiBcIjEyLjAuMFwiLCB2ZXJzaW9uOiBcIjE3LjMuMTJcIiwgbmdJbXBvcnQ6IGkwLCB0eXBlOiBSYWRpb0NvbnRyb2xSZWdpc3RyeSwgcHJvdmlkZWRJbjogJ3Jvb3QnIH0pOyB9XG59XG5pMC7Jtcm1bmdEZWNsYXJlQ2xhc3NNZXRhZGF0YSh7IG1pblZlcnNpb246IFwiMTIuMC4wXCIsIHZlcnNpb246IFwiMTcuMy4xMlwiLCBuZ0ltcG9ydDogaTAsIHR5cGU6IFJhZGlvQ29udHJvbFJlZ2lzdHJ5LCBkZWNvcmF0b3JzOiBbe1xuICAgICAgICAgICAgdHlwZTogSW5qZWN0YWJsZSxcbiAgICAgICAgICAgIGFyZ3M6IFt7IHByb3ZpZGVkSW46ICdyb290JyB9XVxuICAgICAgICB9XSB9KTtcbi8qKlxuICogQGRlc2NyaXB0aW9uXG4gKiBUaGUgYENvbnRyb2xWYWx1ZUFjY2Vzc29yYCBmb3Igd3JpdGluZyByYWRpbyBjb250cm9sIHZhbHVlcyBhbmQgbGlzdGVuaW5nIHRvIHJhZGlvIGNvbnRyb2xcbiAqIGNoYW5nZXMuIFRoZSB2YWx1ZSBhY2Nlc3NvciBpcyB1c2VkIGJ5IHRoZSBgRm9ybUNvbnRyb2xEaXJlY3RpdmVgLCBgRm9ybUNvbnRyb2xOYW1lYCwgYW5kXG4gKiBgTmdNb2RlbGAgZGlyZWN0aXZlcy5cbiAqXG4gKiBAdXNhZ2VOb3Rlc1xuICpcbiAqICMjIyBVc2luZyByYWRpbyBidXR0b25zIHdpdGggcmVhY3RpdmUgZm9ybSBkaXJlY3RpdmVzXG4gKlxuICogVGhlIGZvbGxvdyBleGFtcGxlIHNob3dzIGhvdyB0byB1c2UgcmFkaW8gYnV0dG9ucyBpbiBhIHJlYWN0aXZlIGZvcm0uIFdoZW4gdXNpbmcgcmFkaW8gYnV0dG9ucyBpblxuICogYSByZWFjdGl2ZSBmb3JtLCByYWRpbyBidXR0b25zIGluIHRoZSBzYW1lIGdyb3VwIHNob3VsZCBoYXZlIHRoZSBzYW1lIGBmb3JtQ29udHJvbE5hbWVgLlxuICogUHJvdmlkaW5nIGEgYG5hbWVgIGF0dHJpYnV0ZSBpcyBvcHRpb25hbC5cbiAqXG4gKiB7QGV4YW1wbGUgZm9ybXMvdHMvcmVhY3RpdmVSYWRpb0J1dHRvbnMvcmVhY3RpdmVfcmFkaW9fYnV0dG9uX2V4YW1wbGUudHMgcmVnaW9uPSdSZWFjdGl2ZSd9XG4gKlxuICogQG5nTW9kdWxlIFJlYWN0aXZlRm9ybXNNb2R1bGVcbiAqIEBuZ01vZHVsZSBGb3Jtc01vZHVsZVxuICogQHB1YmxpY0FwaVxuICovXG5jbGFzcyBSYWRpb0NvbnRyb2xWYWx1ZUFjY2Vzc29yIGV4dGVuZHMgQnVpbHRJbkNvbnRyb2xWYWx1ZUFjY2Vzc29yIHtcbiAgICBjb25zdHJ1Y3RvcihyZW5kZXJlciwgZWxlbWVudFJlZiwgX3JlZ2lzdHJ5LCBfaW5qZWN0b3IpIHtcbiAgICAgICAgc3VwZXIocmVuZGVyZXIsIGVsZW1lbnRSZWYpO1xuICAgICAgICB0aGlzLl9yZWdpc3RyeSA9IF9yZWdpc3RyeTtcbiAgICAgICAgdGhpcy5faW5qZWN0b3IgPSBfaW5qZWN0b3I7XG4gICAgICAgIHRoaXMuc2V0RGlzYWJsZWRTdGF0ZUZpcmVkID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgcmVnaXN0ZXJlZCBjYWxsYmFjayBmdW5jdGlvbiBjYWxsZWQgd2hlbiBhIGNoYW5nZSBldmVudCBvY2N1cnMgb24gdGhlIGlucHV0IGVsZW1lbnQuXG4gICAgICAgICAqIE5vdGU6IHdlIGRlY2xhcmUgYG9uQ2hhbmdlYCBoZXJlIChhbHNvIHVzZWQgYXMgaG9zdCBsaXN0ZW5lcikgYXMgYSBmdW5jdGlvbiB3aXRoIG5vIGFyZ3VtZW50c1xuICAgICAgICAgKiB0byBvdmVycmlkZSB0aGUgYG9uQ2hhbmdlYCBmdW5jdGlvbiAod2hpY2ggZXhwZWN0cyAxIGFyZ3VtZW50KSBpbiB0aGUgcGFyZW50XG4gICAgICAgICAqIGBCYXNlQ29udHJvbFZhbHVlQWNjZXNzb3JgIGNsYXNzLlxuICAgICAgICAgKiBAbm9kb2NcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMub25DaGFuZ2UgPSAoKSA9PiB7IH07XG4gICAgICAgIHRoaXMuY2FsbFNldERpc2FibGVkU3RhdGUgPSBpbmplY3QoQ0FMTF9TRVRfRElTQUJMRURfU1RBVEUsIHsgb3B0aW9uYWw6IHRydWUgfSkgPz8gc2V0RGlzYWJsZWRTdGF0ZURlZmF1bHQ7XG4gICAgfVxuICAgIC8qKiBAbm9kb2MgKi9cbiAgICBuZ09uSW5pdCgpIHtcbiAgICAgICAgdGhpcy5fY29udHJvbCA9IHRoaXMuX2luamVjdG9yLmdldChOZ0NvbnRyb2wpO1xuICAgICAgICB0aGlzLl9jaGVja05hbWUoKTtcbiAgICAgICAgdGhpcy5fcmVnaXN0cnkuYWRkKHRoaXMuX2NvbnRyb2wsIHRoaXMpO1xuICAgIH1cbiAgICAvKiogQG5vZG9jICovXG4gICAgbmdPbkRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuX3JlZ2lzdHJ5LnJlbW92ZSh0aGlzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgXCJjaGVja2VkXCIgcHJvcGVydHkgdmFsdWUgb24gdGhlIHJhZGlvIGlucHV0IGVsZW1lbnQuXG4gICAgICogQG5vZG9jXG4gICAgICovXG4gICAgd3JpdGVWYWx1ZSh2YWx1ZSkge1xuICAgICAgICB0aGlzLl9zdGF0ZSA9IHZhbHVlID09PSB0aGlzLnZhbHVlO1xuICAgICAgICB0aGlzLnNldFByb3BlcnR5KCdjaGVja2VkJywgdGhpcy5fc3RhdGUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWdpc3RlcnMgYSBmdW5jdGlvbiBjYWxsZWQgd2hlbiB0aGUgY29udHJvbCB2YWx1ZSBjaGFuZ2VzLlxuICAgICAqIEBub2RvY1xuICAgICAqL1xuICAgIHJlZ2lzdGVyT25DaGFuZ2UoZm4pIHtcbiAgICAgICAgdGhpcy5fZm4gPSBmbjtcbiAgICAgICAgdGhpcy5vbkNoYW5nZSA9ICgpID0+IHtcbiAgICAgICAgICAgIGZuKHRoaXMudmFsdWUpO1xuICAgICAgICAgICAgdGhpcy5fcmVnaXN0cnkuc2VsZWN0KHRoaXMpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICAvKiogQG5vZG9jICovXG4gICAgc2V0RGlzYWJsZWRTdGF0ZShpc0Rpc2FibGVkKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBgc2V0RGlzYWJsZWRTdGF0ZWAgaXMgc3VwcG9zZWQgdG8gYmUgY2FsbGVkIHdoZW5ldmVyIHRoZSBkaXNhYmxlZCBzdGF0ZSBvZiBhIGNvbnRyb2wgY2hhbmdlcyxcbiAgICAgICAgICogaW5jbHVkaW5nIHVwb24gY29udHJvbCBjcmVhdGlvbi4gSG93ZXZlciwgYSBsb25nc3RhbmRpbmcgYnVnIGNhdXNlZCB0aGUgbWV0aG9kIHRvIG5vdCBmaXJlXG4gICAgICAgICAqIHdoZW4gYW4gKmVuYWJsZWQqIGNvbnRyb2wgd2FzIGF0dGFjaGVkLiBUaGlzIGJ1ZyB3YXMgZml4ZWQgaW4gdjE1IGluICM0NzU3Ni5cbiAgICAgICAgICpcbiAgICAgICAgICogVGhpcyBoYWQgYSBzaWRlIGVmZmVjdDogcHJldmlvdXNseSwgaXQgd2FzIHBvc3NpYmxlIHRvIGluc3RhbnRpYXRlIGEgcmVhY3RpdmUgZm9ybSBjb250cm9sXG4gICAgICAgICAqIHdpdGggYFthdHRyLmRpc2FibGVkXT10cnVlYCwgZXZlbiB0aG91Z2ggdGhlIGNvcnJlc3BvbmRpbmcgY29udHJvbCB3YXMgZW5hYmxlZCBpbiB0aGVcbiAgICAgICAgICogbW9kZWwuIFRoaXMgcmVzdWx0ZWQgaW4gYSBtaXNtYXRjaCBiZXR3ZWVuIHRoZSBtb2RlbCBhbmQgdGhlIERPTS4gTm93LCBiZWNhdXNlXG4gICAgICAgICAqIGBzZXREaXNhYmxlZFN0YXRlYCBpcyBhbHdheXMgY2FsbGVkLCB0aGUgdmFsdWUgaW4gdGhlIERPTSB3aWxsIGJlIGltbWVkaWF0ZWx5IG92ZXJ3cml0dGVuXG4gICAgICAgICAqIHdpdGggdGhlIFwiY29ycmVjdFwiIGVuYWJsZWQgdmFsdWUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEhvd2V2ZXIsIHRoZSBmaXggYWxzbyBjcmVhdGVkIGFuIGV4Y2VwdGlvbmFsIGNhc2U6IHJhZGlvIGJ1dHRvbnMuIEJlY2F1c2UgUmVhY3RpdmUgRm9ybXNcbiAgICAgICAgICogbW9kZWxzIHRoZSBlbnRpcmUgZ3JvdXAgb2YgcmFkaW8gYnV0dG9ucyBhcyBhIHNpbmdsZSBgRm9ybUNvbnRyb2xgLCB0aGVyZSBpcyBubyB3YXkgdG9cbiAgICAgICAgICogY29udHJvbCB0aGUgZGlzYWJsZWQgc3RhdGUgZm9yIGluZGl2aWR1YWwgcmFkaW9zLCBzbyB0aGV5IGNhbiBubyBsb25nZXIgYmUgY29uZmlndXJlZCBhc1xuICAgICAgICAgKiBkaXNhYmxlZC4gVGh1cywgd2Uga2VlcCB0aGUgb2xkIGJlaGF2aW9yIGZvciByYWRpbyBidXR0b25zLCBzbyB0aGF0IGBbYXR0ci5kaXNhYmxlZF1gXG4gICAgICAgICAqIGNvbnRpbnVlcyB0byB3b3JrLiBTcGVjaWZpY2FsbHksIHdlIGRyb3AgdGhlIGZpcnN0IGNhbGwgdG8gYHNldERpc2FibGVkU3RhdGVgIGlmIGBkaXNhYmxlZGBcbiAgICAgICAgICogaXMgYGZhbHNlYCwgYW5kIHdlIGFyZSBub3QgaW4gbGVnYWN5IG1vZGUuXG4gICAgICAgICAqL1xuICAgICAgICBpZiAodGhpcy5zZXREaXNhYmxlZFN0YXRlRmlyZWQgfHwgaXNEaXNhYmxlZCB8fFxuICAgICAgICAgICAgdGhpcy5jYWxsU2V0RGlzYWJsZWRTdGF0ZSA9PT0gJ3doZW5EaXNhYmxlZEZvckxlZ2FjeUNvZGUnKSB7XG4gICAgICAgICAgICB0aGlzLnNldFByb3BlcnR5KCdkaXNhYmxlZCcsIGlzRGlzYWJsZWQpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2V0RGlzYWJsZWRTdGF0ZUZpcmVkID0gdHJ1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgXCJ2YWx1ZVwiIG9uIHRoZSByYWRpbyBpbnB1dCBlbGVtZW50IGFuZCB1bmNoZWNrcyBpdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB2YWx1ZVxuICAgICAqL1xuICAgIGZpcmVVbmNoZWNrKHZhbHVlKSB7XG4gICAgICAgIHRoaXMud3JpdGVWYWx1ZSh2YWx1ZSk7XG4gICAgfVxuICAgIF9jaGVja05hbWUoKSB7XG4gICAgICAgIGlmICh0aGlzLm5hbWUgJiYgdGhpcy5mb3JtQ29udHJvbE5hbWUgJiYgdGhpcy5uYW1lICE9PSB0aGlzLmZvcm1Db250cm9sTmFtZSAmJlxuICAgICAgICAgICAgKHR5cGVvZiBuZ0Rldk1vZGUgPT09ICd1bmRlZmluZWQnIHx8IG5nRGV2TW9kZSkpIHtcbiAgICAgICAgICAgIHRocm93TmFtZUVycm9yKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLm5hbWUgJiYgdGhpcy5mb3JtQ29udHJvbE5hbWUpXG4gICAgICAgICAgICB0aGlzLm5hbWUgPSB0aGlzLmZvcm1Db250cm9sTmFtZTtcbiAgICB9XG4gICAgc3RhdGljIHsgdGhpcy7JtWZhYyA9IGkwLsm1ybVuZ0RlY2xhcmVGYWN0b3J5KHsgbWluVmVyc2lvbjogXCIxMi4wLjBcIiwgdmVyc2lvbjogXCIxNy4zLjEyXCIsIG5nSW1wb3J0OiBpMCwgdHlwZTogUmFkaW9Db250cm9sVmFsdWVBY2Nlc3NvciwgZGVwczogW3sgdG9rZW46IGkwLlJlbmRlcmVyMiB9LCB7IHRva2VuOiBpMC5FbGVtZW50UmVmIH0sIHsgdG9rZW46IFJhZGlvQ29udHJvbFJlZ2lzdHJ5IH0sIHsgdG9rZW46IGkwLkluamVjdG9yIH1dLCB0YXJnZXQ6IGkwLsm1ybVGYWN0b3J5VGFyZ2V0LkRpcmVjdGl2ZSB9KTsgfVxuICAgIHN0YXRpYyB7IHRoaXMuybVkaXIgPSBpMC7Jtcm1bmdEZWNsYXJlRGlyZWN0aXZlKHsgbWluVmVyc2lvbjogXCIxNC4wLjBcIiwgdmVyc2lvbjogXCIxNy4zLjEyXCIsIHR5cGU6IFJhZGlvQ29udHJvbFZhbHVlQWNjZXNzb3IsIHNlbGVjdG9yOiBcImlucHV0W3R5cGU9cmFkaW9dW2Zvcm1Db250cm9sTmFtZV0saW5wdXRbdHlwZT1yYWRpb11bZm9ybUNvbnRyb2xdLGlucHV0W3R5cGU9cmFkaW9dW25nTW9kZWxdXCIsIGlucHV0czogeyBuYW1lOiBcIm5hbWVcIiwgZm9ybUNvbnRyb2xOYW1lOiBcImZvcm1Db250cm9sTmFtZVwiLCB2YWx1ZTogXCJ2YWx1ZVwiIH0sIGhvc3Q6IHsgbGlzdGVuZXJzOiB7IFwiY2hhbmdlXCI6IFwib25DaGFuZ2UoKVwiLCBcImJsdXJcIjogXCJvblRvdWNoZWQoKVwiIH0gfSwgcHJvdmlkZXJzOiBbUkFESU9fVkFMVUVfQUNDRVNTT1JdLCB1c2VzSW5oZXJpdGFuY2U6IHRydWUsIG5nSW1wb3J0OiBpMCB9KTsgfVxufVxuaTAuybXJtW5nRGVjbGFyZUNsYXNzTWV0YWRhdGEoeyBtaW5WZXJzaW9uOiBcIjEyLjAuMFwiLCB2ZXJzaW9uOiBcIjE3LjMuMTJcIiwgbmdJbXBvcnQ6IGkwLCB0eXBlOiBSYWRpb0NvbnRyb2xWYWx1ZUFjY2Vzc29yLCBkZWNvcmF0b3JzOiBbe1xuICAgICAgICAgICAgdHlwZTogRGlyZWN0aXZlLFxuICAgICAgICAgICAgYXJnczogW3tcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdpbnB1dFt0eXBlPXJhZGlvXVtmb3JtQ29udHJvbE5hbWVdLGlucHV0W3R5cGU9cmFkaW9dW2Zvcm1Db250cm9sXSxpbnB1dFt0eXBlPXJhZGlvXVtuZ01vZGVsXScsXG4gICAgICAgICAgICAgICAgICAgIGhvc3Q6IHsgJyhjaGFuZ2UpJzogJ29uQ2hhbmdlKCknLCAnKGJsdXIpJzogJ29uVG91Y2hlZCgpJyB9LFxuICAgICAgICAgICAgICAgICAgICBwcm92aWRlcnM6IFtSQURJT19WQUxVRV9BQ0NFU1NPUl1cbiAgICAgICAgICAgICAgICB9XVxuICAgICAgICB9XSwgY3RvclBhcmFtZXRlcnM6ICgpID0+IFt7IHR5cGU6IGkwLlJlbmRlcmVyMiB9LCB7IHR5cGU6IGkwLkVsZW1lbnRSZWYgfSwgeyB0eXBlOiBSYWRpb0NvbnRyb2xSZWdpc3RyeSB9LCB7IHR5cGU6IGkwLkluamVjdG9yIH1dLCBwcm9wRGVjb3JhdG9yczogeyBuYW1lOiBbe1xuICAgICAgICAgICAgICAgIHR5cGU6IElucHV0XG4gICAgICAgICAgICB9XSwgZm9ybUNvbnRyb2xOYW1lOiBbe1xuICAgICAgICAgICAgICAgIHR5cGU6IElucHV0XG4gICAgICAgICAgICB9XSwgdmFsdWU6IFt7XG4gICAgICAgICAgICAgICAgdHlwZTogSW5wdXRcbiAgICAgICAgICAgIH1dIH0gfSk7XG5cbmNvbnN0IFJBTkdFX1ZBTFVFX0FDQ0VTU09SID0ge1xuICAgIHByb3ZpZGU6IE5HX1ZBTFVFX0FDQ0VTU09SLFxuICAgIHVzZUV4aXN0aW5nOiBmb3J3YXJkUmVmKCgpID0+IFJhbmdlVmFsdWVBY2Nlc3NvciksXG4gICAgbXVsdGk6IHRydWVcbn07XG4vKipcbiAqIEBkZXNjcmlwdGlvblxuICogVGhlIGBDb250cm9sVmFsdWVBY2Nlc3NvcmAgZm9yIHdyaXRpbmcgYSByYW5nZSB2YWx1ZSBhbmQgbGlzdGVuaW5nIHRvIHJhbmdlIGlucHV0IGNoYW5nZXMuXG4gKiBUaGUgdmFsdWUgYWNjZXNzb3IgaXMgdXNlZCBieSB0aGUgYEZvcm1Db250cm9sRGlyZWN0aXZlYCwgYEZvcm1Db250cm9sTmFtZWAsIGFuZCAgYE5nTW9kZWxgXG4gKiBkaXJlY3RpdmVzLlxuICpcbiAqIEB1c2FnZU5vdGVzXG4gKlxuICogIyMjIFVzaW5nIGEgcmFuZ2UgaW5wdXQgd2l0aCBhIHJlYWN0aXZlIGZvcm1cbiAqXG4gKiBUaGUgZm9sbG93aW5nIGV4YW1wbGUgc2hvd3MgaG93IHRvIHVzZSBhIHJhbmdlIGlucHV0IHdpdGggYSByZWFjdGl2ZSBmb3JtLlxuICpcbiAqIGBgYHRzXG4gKiBjb25zdCBhZ2VDb250cm9sID0gbmV3IEZvcm1Db250cm9sKCk7XG4gKiBgYGBcbiAqXG4gKiBgYGBcbiAqIDxpbnB1dCB0eXBlPVwicmFuZ2VcIiBbZm9ybUNvbnRyb2xdPVwiYWdlQ29udHJvbFwiPlxuICogYGBgXG4gKlxuICogQG5nTW9kdWxlIFJlYWN0aXZlRm9ybXNNb2R1bGVcbiAqIEBuZ01vZHVsZSBGb3Jtc01vZHVsZVxuICogQHB1YmxpY0FwaVxuICovXG5jbGFzcyBSYW5nZVZhbHVlQWNjZXNzb3IgZXh0ZW5kcyBCdWlsdEluQ29udHJvbFZhbHVlQWNjZXNzb3Ige1xuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIFwidmFsdWVcIiBwcm9wZXJ0eSBvbiB0aGUgaW5wdXQgZWxlbWVudC5cbiAgICAgKiBAbm9kb2NcbiAgICAgKi9cbiAgICB3cml0ZVZhbHVlKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuc2V0UHJvcGVydHkoJ3ZhbHVlJywgcGFyc2VGbG9hdCh2YWx1ZSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWdpc3RlcnMgYSBmdW5jdGlvbiBjYWxsZWQgd2hlbiB0aGUgY29udHJvbCB2YWx1ZSBjaGFuZ2VzLlxuICAgICAqIEBub2RvY1xuICAgICAqL1xuICAgIHJlZ2lzdGVyT25DaGFuZ2UoZm4pIHtcbiAgICAgICAgdGhpcy5vbkNoYW5nZSA9ICh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgZm4odmFsdWUgPT0gJycgPyBudWxsIDogcGFyc2VGbG9hdCh2YWx1ZSkpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBzdGF0aWMgeyB0aGlzLsm1ZmFjID0gaTAuybXJtW5nRGVjbGFyZUZhY3RvcnkoeyBtaW5WZXJzaW9uOiBcIjEyLjAuMFwiLCB2ZXJzaW9uOiBcIjE3LjMuMTJcIiwgbmdJbXBvcnQ6IGkwLCB0eXBlOiBSYW5nZVZhbHVlQWNjZXNzb3IsIGRlcHM6IG51bGwsIHRhcmdldDogaTAuybXJtUZhY3RvcnlUYXJnZXQuRGlyZWN0aXZlIH0pOyB9XG4gICAgc3RhdGljIHsgdGhpcy7JtWRpciA9IGkwLsm1ybVuZ0RlY2xhcmVEaXJlY3RpdmUoeyBtaW5WZXJzaW9uOiBcIjE0LjAuMFwiLCB2ZXJzaW9uOiBcIjE3LjMuMTJcIiwgdHlwZTogUmFuZ2VWYWx1ZUFjY2Vzc29yLCBzZWxlY3RvcjogXCJpbnB1dFt0eXBlPXJhbmdlXVtmb3JtQ29udHJvbE5hbWVdLGlucHV0W3R5cGU9cmFuZ2VdW2Zvcm1Db250cm9sXSxpbnB1dFt0eXBlPXJhbmdlXVtuZ01vZGVsXVwiLCBob3N0OiB7IGxpc3RlbmVyczogeyBcImNoYW5nZVwiOiBcIm9uQ2hhbmdlKCRldmVudC50YXJnZXQudmFsdWUpXCIsIFwiaW5wdXRcIjogXCJvbkNoYW5nZSgkZXZlbnQudGFyZ2V0LnZhbHVlKVwiLCBcImJsdXJcIjogXCJvblRvdWNoZWQoKVwiIH0gfSwgcHJvdmlkZXJzOiBbUkFOR0VfVkFMVUVfQUNDRVNTT1JdLCB1c2VzSW5oZXJpdGFuY2U6IHRydWUsIG5nSW1wb3J0OiBpMCB9KTsgfVxufVxuaTAuybXJtW5nRGVjbGFyZUNsYXNzTWV0YWRhdGEoeyBtaW5WZXJzaW9uOiBcIjEyLjAuMFwiLCB2ZXJzaW9uOiBcIjE3LjMuMTJcIiwgbmdJbXBvcnQ6IGkwLCB0eXBlOiBSYW5nZVZhbHVlQWNjZXNzb3IsIGRlY29yYXRvcnM6IFt7XG4gICAgICAgICAgICB0eXBlOiBEaXJlY3RpdmUsXG4gICAgICAgICAgICBhcmdzOiBbe1xuICAgICAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ2lucHV0W3R5cGU9cmFuZ2VdW2Zvcm1Db250cm9sTmFtZV0saW5wdXRbdHlwZT1yYW5nZV1bZm9ybUNvbnRyb2xdLGlucHV0W3R5cGU9cmFuZ2VdW25nTW9kZWxdJyxcbiAgICAgICAgICAgICAgICAgICAgaG9zdDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgJyhjaGFuZ2UpJzogJ29uQ2hhbmdlKCRldmVudC50YXJnZXQudmFsdWUpJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICcoaW5wdXQpJzogJ29uQ2hhbmdlKCRldmVudC50YXJnZXQudmFsdWUpJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICcoYmx1ciknOiAnb25Ub3VjaGVkKCknXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHByb3ZpZGVyczogW1JBTkdFX1ZBTFVFX0FDQ0VTU09SXVxuICAgICAgICAgICAgICAgIH1dXG4gICAgICAgIH1dIH0pO1xuXG4vKipcbiAqIFRva2VuIHRvIHByb3ZpZGUgdG8gdHVybiBvZmYgdGhlIG5nTW9kZWwgd2FybmluZyBvbiBmb3JtQ29udHJvbCBhbmQgZm9ybUNvbnRyb2xOYW1lLlxuICovXG5jb25zdCBOR19NT0RFTF9XSVRIX0ZPUk1fQ09OVFJPTF9XQVJOSU5HID0gbmV3IEluamVjdGlvblRva2VuKG5nRGV2TW9kZSA/ICdOZ01vZGVsV2l0aEZvcm1Db250cm9sV2FybmluZycgOiAnJyk7XG5jb25zdCBmb3JtQ29udHJvbEJpbmRpbmcgPSB7XG4gICAgcHJvdmlkZTogTmdDb250cm9sLFxuICAgIHVzZUV4aXN0aW5nOiBmb3J3YXJkUmVmKCgpID0+IEZvcm1Db250cm9sRGlyZWN0aXZlKVxufTtcbi8qKlxuICogQGRlc2NyaXB0aW9uXG4gKiBTeW5jaHJvbml6ZXMgYSBzdGFuZGFsb25lIGBGb3JtQ29udHJvbGAgaW5zdGFuY2UgdG8gYSBmb3JtIGNvbnRyb2wgZWxlbWVudC5cbiAqXG4gKiBOb3RlIHRoYXQgc3VwcG9ydCBmb3IgdXNpbmcgdGhlIGBuZ01vZGVsYCBpbnB1dCBwcm9wZXJ0eSBhbmQgYG5nTW9kZWxDaGFuZ2VgIGV2ZW50IHdpdGggcmVhY3RpdmVcbiAqIGZvcm0gZGlyZWN0aXZlcyB3YXMgZGVwcmVjYXRlZCBpbiBBbmd1bGFyIHY2IGFuZCBpcyBzY2hlZHVsZWQgZm9yIHJlbW92YWwgaW5cbiAqIGEgZnV0dXJlIHZlcnNpb24gb2YgQW5ndWxhci5cbiAqIEZvciBkZXRhaWxzLCBzZWUgW0RlcHJlY2F0ZWQgZmVhdHVyZXNdKGd1aWRlL2RlcHJlY2F0aW9ucyNuZ21vZGVsLXdpdGgtcmVhY3RpdmUtZm9ybXMpLlxuICpcbiAqIEBzZWUgW1JlYWN0aXZlIEZvcm1zIEd1aWRlXShndWlkZS9yZWFjdGl2ZS1mb3JtcylcbiAqIEBzZWUge0BsaW5rIEZvcm1Db250cm9sfVxuICogQHNlZSB7QGxpbmsgQWJzdHJhY3RDb250cm9sfVxuICpcbiAqIEB1c2FnZU5vdGVzXG4gKlxuICogVGhlIGZvbGxvd2luZyBleGFtcGxlIHNob3dzIGhvdyB0byByZWdpc3RlciBhIHN0YW5kYWxvbmUgY29udHJvbCBhbmQgc2V0IGl0cyB2YWx1ZS5cbiAqXG4gKiB7QGV4YW1wbGUgZm9ybXMvdHMvc2ltcGxlRm9ybUNvbnRyb2wvc2ltcGxlX2Zvcm1fY29udHJvbF9leGFtcGxlLnRzIHJlZ2lvbj0nQ29tcG9uZW50J31cbiAqXG4gKiBAbmdNb2R1bGUgUmVhY3RpdmVGb3Jtc01vZHVsZVxuICogQHB1YmxpY0FwaVxuICovXG5jbGFzcyBGb3JtQ29udHJvbERpcmVjdGl2ZSBleHRlbmRzIE5nQ29udHJvbCB7XG4gICAgLyoqXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICogVHJpZ2dlcnMgYSB3YXJuaW5nIGluIGRldiBtb2RlIHRoYXQgdGhpcyBpbnB1dCBzaG91bGQgbm90IGJlIHVzZWQgd2l0aCByZWFjdGl2ZSBmb3Jtcy5cbiAgICAgKi9cbiAgICBzZXQgaXNEaXNhYmxlZChpc0Rpc2FibGVkKSB7XG4gICAgICAgIGlmICh0eXBlb2YgbmdEZXZNb2RlID09PSAndW5kZWZpbmVkJyB8fCBuZ0Rldk1vZGUpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihkaXNhYmxlZEF0dHJXYXJuaW5nKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKiBTdGF0aWMgcHJvcGVydHkgdXNlZCB0byB0cmFjayB3aGV0aGVyIGFueSBuZ01vZGVsIHdhcm5pbmdzIGhhdmUgYmVlbiBzZW50IGFjcm9zc1xuICAgICAqIGFsbCBpbnN0YW5jZXMgb2YgRm9ybUNvbnRyb2xEaXJlY3RpdmUuIFVzZWQgdG8gc3VwcG9ydCB3YXJuaW5nIGNvbmZpZyBvZiBcIm9uY2VcIi5cbiAgICAgKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHN0YXRpYyB7IHRoaXMuX25nTW9kZWxXYXJuaW5nU2VudE9uY2UgPSBmYWxzZTsgfVxuICAgIGNvbnN0cnVjdG9yKHZhbGlkYXRvcnMsIGFzeW5jVmFsaWRhdG9ycywgdmFsdWVBY2Nlc3NvcnMsIF9uZ01vZGVsV2FybmluZ0NvbmZpZywgY2FsbFNldERpc2FibGVkU3RhdGUpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5fbmdNb2RlbFdhcm5pbmdDb25maWcgPSBfbmdNb2RlbFdhcm5pbmdDb25maWc7XG4gICAgICAgIHRoaXMuY2FsbFNldERpc2FibGVkU3RhdGUgPSBjYWxsU2V0RGlzYWJsZWRTdGF0ZTtcbiAgICAgICAgLyoqIEBkZXByZWNhdGVkIGFzIG9mIHY2ICovXG4gICAgICAgIHRoaXMudXBkYXRlID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICAvKipcbiAgICAgICAgICogQGRlc2NyaXB0aW9uXG4gICAgICAgICAqIEluc3RhbmNlIHByb3BlcnR5IHVzZWQgdG8gdHJhY2sgd2hldGhlciBhbiBuZ01vZGVsIHdhcm5pbmcgaGFzIGJlZW4gc2VudCBvdXQgZm9yIHRoaXNcbiAgICAgICAgICogcGFydGljdWxhciBgRm9ybUNvbnRyb2xEaXJlY3RpdmVgIGluc3RhbmNlLiBVc2VkIHRvIHN1cHBvcnQgd2FybmluZyBjb25maWcgb2YgXCJhbHdheXNcIi5cbiAgICAgICAgICpcbiAgICAgICAgICogQGludGVybmFsXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9uZ01vZGVsV2FybmluZ1NlbnQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fc2V0VmFsaWRhdG9ycyh2YWxpZGF0b3JzKTtcbiAgICAgICAgdGhpcy5fc2V0QXN5bmNWYWxpZGF0b3JzKGFzeW5jVmFsaWRhdG9ycyk7XG4gICAgICAgIHRoaXMudmFsdWVBY2Nlc3NvciA9IHNlbGVjdFZhbHVlQWNjZXNzb3IodGhpcywgdmFsdWVBY2Nlc3NvcnMpO1xuICAgIH1cbiAgICAvKiogQG5vZG9jICovXG4gICAgbmdPbkNoYW5nZXMoY2hhbmdlcykge1xuICAgICAgICBpZiAodGhpcy5faXNDb250cm9sQ2hhbmdlZChjaGFuZ2VzKSkge1xuICAgICAgICAgICAgY29uc3QgcHJldmlvdXNGb3JtID0gY2hhbmdlc1snZm9ybSddLnByZXZpb3VzVmFsdWU7XG4gICAgICAgICAgICBpZiAocHJldmlvdXNGb3JtKSB7XG4gICAgICAgICAgICAgICAgY2xlYW5VcENvbnRyb2wocHJldmlvdXNGb3JtLCB0aGlzLCAvKiB2YWxpZGF0ZUNvbnRyb2xQcmVzZW5jZU9uQ2hhbmdlICovIGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNldFVwQ29udHJvbCh0aGlzLmZvcm0sIHRoaXMsIHRoaXMuY2FsbFNldERpc2FibGVkU3RhdGUpO1xuICAgICAgICAgICAgdGhpcy5mb3JtLnVwZGF0ZVZhbHVlQW5kVmFsaWRpdHkoeyBlbWl0RXZlbnQ6IGZhbHNlIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc1Byb3BlcnR5VXBkYXRlZChjaGFuZ2VzLCB0aGlzLnZpZXdNb2RlbCkpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbmdEZXZNb2RlID09PSAndW5kZWZpbmVkJyB8fCBuZ0Rldk1vZGUpIHtcbiAgICAgICAgICAgICAgICBfbmdNb2RlbFdhcm5pbmcoJ2Zvcm1Db250cm9sJywgRm9ybUNvbnRyb2xEaXJlY3RpdmUsIHRoaXMsIHRoaXMuX25nTW9kZWxXYXJuaW5nQ29uZmlnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZm9ybS5zZXRWYWx1ZSh0aGlzLm1vZGVsKTtcbiAgICAgICAgICAgIHRoaXMudmlld01vZGVsID0gdGhpcy5tb2RlbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKiogQG5vZG9jICovXG4gICAgbmdPbkRlc3Ryb3koKSB7XG4gICAgICAgIGlmICh0aGlzLmZvcm0pIHtcbiAgICAgICAgICAgIGNsZWFuVXBDb250cm9sKHRoaXMuZm9ybSwgdGhpcywgLyogdmFsaWRhdGVDb250cm9sUHJlc2VuY2VPbkNoYW5nZSAqLyBmYWxzZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICogUmV0dXJucyBhbiBhcnJheSB0aGF0IHJlcHJlc2VudHMgdGhlIHBhdGggZnJvbSB0aGUgdG9wLWxldmVsIGZvcm0gdG8gdGhpcyBjb250cm9sLlxuICAgICAqIEVhY2ggaW5kZXggaXMgdGhlIHN0cmluZyBuYW1lIG9mIHRoZSBjb250cm9sIG9uIHRoYXQgbGV2ZWwuXG4gICAgICovXG4gICAgZ2V0IHBhdGgoKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICogVGhlIGBGb3JtQ29udHJvbGAgYm91bmQgdG8gdGhpcyBkaXJlY3RpdmUuXG4gICAgICovXG4gICAgZ2V0IGNvbnRyb2woKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZvcm07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqIFNldHMgdGhlIG5ldyB2YWx1ZSBmb3IgdGhlIHZpZXcgbW9kZWwgYW5kIGVtaXRzIGFuIGBuZ01vZGVsQ2hhbmdlYCBldmVudC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBuZXdWYWx1ZSBUaGUgbmV3IHZhbHVlIGZvciB0aGUgdmlldyBtb2RlbC5cbiAgICAgKi9cbiAgICB2aWV3VG9Nb2RlbFVwZGF0ZShuZXdWYWx1ZSkge1xuICAgICAgICB0aGlzLnZpZXdNb2RlbCA9IG5ld1ZhbHVlO1xuICAgICAgICB0aGlzLnVwZGF0ZS5lbWl0KG5ld1ZhbHVlKTtcbiAgICB9XG4gICAgX2lzQ29udHJvbENoYW5nZWQoY2hhbmdlcykge1xuICAgICAgICByZXR1cm4gY2hhbmdlcy5oYXNPd25Qcm9wZXJ0eSgnZm9ybScpO1xuICAgIH1cbiAgICBzdGF0aWMgeyB0aGlzLsm1ZmFjID0gaTAuybXJtW5nRGVjbGFyZUZhY3RvcnkoeyBtaW5WZXJzaW9uOiBcIjEyLjAuMFwiLCB2ZXJzaW9uOiBcIjE3LjMuMTJcIiwgbmdJbXBvcnQ6IGkwLCB0eXBlOiBGb3JtQ29udHJvbERpcmVjdGl2ZSwgZGVwczogW3sgdG9rZW46IE5HX1ZBTElEQVRPUlMsIG9wdGlvbmFsOiB0cnVlLCBzZWxmOiB0cnVlIH0sIHsgdG9rZW46IE5HX0FTWU5DX1ZBTElEQVRPUlMsIG9wdGlvbmFsOiB0cnVlLCBzZWxmOiB0cnVlIH0sIHsgdG9rZW46IE5HX1ZBTFVFX0FDQ0VTU09SLCBvcHRpb25hbDogdHJ1ZSwgc2VsZjogdHJ1ZSB9LCB7IHRva2VuOiBOR19NT0RFTF9XSVRIX0ZPUk1fQ09OVFJPTF9XQVJOSU5HLCBvcHRpb25hbDogdHJ1ZSB9LCB7IHRva2VuOiBDQUxMX1NFVF9ESVNBQkxFRF9TVEFURSwgb3B0aW9uYWw6IHRydWUgfV0sIHRhcmdldDogaTAuybXJtUZhY3RvcnlUYXJnZXQuRGlyZWN0aXZlIH0pOyB9XG4gICAgc3RhdGljIHsgdGhpcy7JtWRpciA9IGkwLsm1ybVuZ0RlY2xhcmVEaXJlY3RpdmUoeyBtaW5WZXJzaW9uOiBcIjE0LjAuMFwiLCB2ZXJzaW9uOiBcIjE3LjMuMTJcIiwgdHlwZTogRm9ybUNvbnRyb2xEaXJlY3RpdmUsIHNlbGVjdG9yOiBcIltmb3JtQ29udHJvbF1cIiwgaW5wdXRzOiB7IGZvcm06IFtcImZvcm1Db250cm9sXCIsIFwiZm9ybVwiXSwgaXNEaXNhYmxlZDogW1wiZGlzYWJsZWRcIiwgXCJpc0Rpc2FibGVkXCJdLCBtb2RlbDogW1wibmdNb2RlbFwiLCBcIm1vZGVsXCJdIH0sIG91dHB1dHM6IHsgdXBkYXRlOiBcIm5nTW9kZWxDaGFuZ2VcIiB9LCBwcm92aWRlcnM6IFtmb3JtQ29udHJvbEJpbmRpbmddLCBleHBvcnRBczogW1wibmdGb3JtXCJdLCB1c2VzSW5oZXJpdGFuY2U6IHRydWUsIHVzZXNPbkNoYW5nZXM6IHRydWUsIG5nSW1wb3J0OiBpMCB9KTsgfVxufVxuaTAuybXJtW5nRGVjbGFyZUNsYXNzTWV0YWRhdGEoeyBtaW5WZXJzaW9uOiBcIjEyLjAuMFwiLCB2ZXJzaW9uOiBcIjE3LjMuMTJcIiwgbmdJbXBvcnQ6IGkwLCB0eXBlOiBGb3JtQ29udHJvbERpcmVjdGl2ZSwgZGVjb3JhdG9yczogW3tcbiAgICAgICAgICAgIHR5cGU6IERpcmVjdGl2ZSxcbiAgICAgICAgICAgIGFyZ3M6IFt7IHNlbGVjdG9yOiAnW2Zvcm1Db250cm9sXScsIHByb3ZpZGVyczogW2Zvcm1Db250cm9sQmluZGluZ10sIGV4cG9ydEFzOiAnbmdGb3JtJyB9XVxuICAgICAgICB9XSwgY3RvclBhcmFtZXRlcnM6ICgpID0+IFt7IHR5cGU6IHVuZGVmaW5lZCwgZGVjb3JhdG9yczogW3tcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogT3B0aW9uYWxcbiAgICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFNlbGZcbiAgICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IEluamVjdCxcbiAgICAgICAgICAgICAgICAgICAgYXJnczogW05HX1ZBTElEQVRPUlNdXG4gICAgICAgICAgICAgICAgfV0gfSwgeyB0eXBlOiB1bmRlZmluZWQsIGRlY29yYXRvcnM6IFt7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IE9wdGlvbmFsXG4gICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBTZWxmXG4gICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBJbmplY3QsXG4gICAgICAgICAgICAgICAgICAgIGFyZ3M6IFtOR19BU1lOQ19WQUxJREFUT1JTXVxuICAgICAgICAgICAgICAgIH1dIH0sIHsgdHlwZTogdW5kZWZpbmVkLCBkZWNvcmF0b3JzOiBbe1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBPcHRpb25hbFxuICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogU2VsZlxuICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogSW5qZWN0LFxuICAgICAgICAgICAgICAgICAgICBhcmdzOiBbTkdfVkFMVUVfQUNDRVNTT1JdXG4gICAgICAgICAgICAgICAgfV0gfSwgeyB0eXBlOiB1bmRlZmluZWQsIGRlY29yYXRvcnM6IFt7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IE9wdGlvbmFsXG4gICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBJbmplY3QsXG4gICAgICAgICAgICAgICAgICAgIGFyZ3M6IFtOR19NT0RFTF9XSVRIX0ZPUk1fQ09OVFJPTF9XQVJOSU5HXVxuICAgICAgICAgICAgICAgIH1dIH0sIHsgdHlwZTogdW5kZWZpbmVkLCBkZWNvcmF0b3JzOiBbe1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBPcHRpb25hbFxuICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogSW5qZWN0LFxuICAgICAgICAgICAgICAgICAgICBhcmdzOiBbQ0FMTF9TRVRfRElTQUJMRURfU1RBVEVdXG4gICAgICAgICAgICAgICAgfV0gfV0sIHByb3BEZWNvcmF0b3JzOiB7IGZvcm06IFt7XG4gICAgICAgICAgICAgICAgdHlwZTogSW5wdXQsXG4gICAgICAgICAgICAgICAgYXJnczogWydmb3JtQ29udHJvbCddXG4gICAgICAgICAgICB9XSwgaXNEaXNhYmxlZDogW3tcbiAgICAgICAgICAgICAgICB0eXBlOiBJbnB1dCxcbiAgICAgICAgICAgICAgICBhcmdzOiBbJ2Rpc2FibGVkJ11cbiAgICAgICAgICAgIH1dLCBtb2RlbDogW3tcbiAgICAgICAgICAgICAgICB0eXBlOiBJbnB1dCxcbiAgICAgICAgICAgICAgICBhcmdzOiBbJ25nTW9kZWwnXVxuICAgICAgICAgICAgfV0sIHVwZGF0ZTogW3tcbiAgICAgICAgICAgICAgICB0eXBlOiBPdXRwdXQsXG4gICAgICAgICAgICAgICAgYXJnczogWyduZ01vZGVsQ2hhbmdlJ11cbiAgICAgICAgICAgIH1dIH0gfSk7XG5cbmNvbnN0IGZvcm1EaXJlY3RpdmVQcm92aWRlciA9IHtcbiAgICBwcm92aWRlOiBDb250cm9sQ29udGFpbmVyLFxuICAgIHVzZUV4aXN0aW5nOiBmb3J3YXJkUmVmKCgpID0+IEZvcm1Hcm91cERpcmVjdGl2ZSlcbn07XG4vKipcbiAqIEBkZXNjcmlwdGlvblxuICpcbiAqIEJpbmRzIGFuIGV4aXN0aW5nIGBGb3JtR3JvdXBgIG9yIGBGb3JtUmVjb3JkYCB0byBhIERPTSBlbGVtZW50LlxuICpcbiAqIFRoaXMgZGlyZWN0aXZlIGFjY2VwdHMgYW4gZXhpc3RpbmcgYEZvcm1Hcm91cGAgaW5zdGFuY2UuIEl0IHdpbGwgdGhlbiB1c2UgdGhpc1xuICogYEZvcm1Hcm91cGAgaW5zdGFuY2UgdG8gbWF0Y2ggYW55IGNoaWxkIGBGb3JtQ29udHJvbGAsIGBGb3JtR3JvdXBgL2BGb3JtUmVjb3JkYCxcbiAqIGFuZCBgRm9ybUFycmF5YCBpbnN0YW5jZXMgdG8gY2hpbGQgYEZvcm1Db250cm9sTmFtZWAsIGBGb3JtR3JvdXBOYW1lYCxcbiAqIGFuZCBgRm9ybUFycmF5TmFtZWAgZGlyZWN0aXZlcy5cbiAqXG4gKiBAc2VlIFtSZWFjdGl2ZSBGb3JtcyBHdWlkZV0oZ3VpZGUvcmVhY3RpdmUtZm9ybXMpXG4gKiBAc2VlIHtAbGluayBBYnN0cmFjdENvbnRyb2x9XG4gKlxuICogQHVzYWdlTm90ZXNcbiAqICMjIyBSZWdpc3RlciBGb3JtIEdyb3VwXG4gKlxuICogVGhlIGZvbGxvd2luZyBleGFtcGxlIHJlZ2lzdGVycyBhIGBGb3JtR3JvdXBgIHdpdGggZmlyc3QgbmFtZSBhbmQgbGFzdCBuYW1lIGNvbnRyb2xzLFxuICogYW5kIGxpc3RlbnMgZm9yIHRoZSAqbmdTdWJtaXQqIGV2ZW50IHdoZW4gdGhlIGJ1dHRvbiBpcyBjbGlja2VkLlxuICpcbiAqIHtAZXhhbXBsZSBmb3Jtcy90cy9zaW1wbGVGb3JtR3JvdXAvc2ltcGxlX2Zvcm1fZ3JvdXBfZXhhbXBsZS50cyByZWdpb249J0NvbXBvbmVudCd9XG4gKlxuICogQG5nTW9kdWxlIFJlYWN0aXZlRm9ybXNNb2R1bGVcbiAqIEBwdWJsaWNBcGlcbiAqL1xuY2xhc3MgRm9ybUdyb3VwRGlyZWN0aXZlIGV4dGVuZHMgQ29udHJvbENvbnRhaW5lciB7XG4gICAgY29uc3RydWN0b3IodmFsaWRhdG9ycywgYXN5bmNWYWxpZGF0b3JzLCBjYWxsU2V0RGlzYWJsZWRTdGF0ZSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmNhbGxTZXREaXNhYmxlZFN0YXRlID0gY2FsbFNldERpc2FibGVkU3RhdGU7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgICAgICogUmVwb3J0cyB3aGV0aGVyIHRoZSBmb3JtIHN1Ym1pc3Npb24gaGFzIGJlZW4gdHJpZ2dlcmVkLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zdWJtaXR0ZWQgPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENhbGxiYWNrIHRoYXQgc2hvdWxkIGJlIGludm9rZWQgd2hlbiBjb250cm9scyBpbiBGb3JtR3JvdXAgb3IgRm9ybUFycmF5IGNvbGxlY3Rpb24gY2hhbmdlXG4gICAgICAgICAqIChhZGRlZCBvciByZW1vdmVkKS4gVGhpcyBjYWxsYmFjayB0cmlnZ2VycyBjb3JyZXNwb25kaW5nIERPTSB1cGRhdGVzLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fb25Db2xsZWN0aW9uQ2hhbmdlID0gKCkgPT4gdGhpcy5fdXBkYXRlRG9tVmFsdWUoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAgICAgKiBUcmFja3MgdGhlIGxpc3Qgb2YgYWRkZWQgYEZvcm1Db250cm9sTmFtZWAgaW5zdGFuY2VzXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmRpcmVjdGl2ZXMgPSBbXTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAgICAgKiBUcmFja3MgdGhlIGBGb3JtR3JvdXBgIGJvdW5kIHRvIHRoaXMgZGlyZWN0aXZlLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5mb3JtID0gbnVsbDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAgICAgKiBFbWl0cyBhbiBldmVudCB3aGVuIHRoZSBmb3JtIHN1Ym1pc3Npb24gaGFzIGJlZW4gdHJpZ2dlcmVkLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5uZ1N1Ym1pdCA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgdGhpcy5fc2V0VmFsaWRhdG9ycyh2YWxpZGF0b3JzKTtcbiAgICAgICAgdGhpcy5fc2V0QXN5bmNWYWxpZGF0b3JzKGFzeW5jVmFsaWRhdG9ycyk7XG4gICAgfVxuICAgIC8qKiBAbm9kb2MgKi9cbiAgICBuZ09uQ2hhbmdlcyhjaGFuZ2VzKSB7XG4gICAgICAgIHRoaXMuX2NoZWNrRm9ybVByZXNlbnQoKTtcbiAgICAgICAgaWYgKGNoYW5nZXMuaGFzT3duUHJvcGVydHkoJ2Zvcm0nKSkge1xuICAgICAgICAgICAgdGhpcy5fdXBkYXRlVmFsaWRhdG9ycygpO1xuICAgICAgICAgICAgdGhpcy5fdXBkYXRlRG9tVmFsdWUoKTtcbiAgICAgICAgICAgIHRoaXMuX3VwZGF0ZVJlZ2lzdHJhdGlvbnMoKTtcbiAgICAgICAgICAgIHRoaXMuX29sZEZvcm0gPSB0aGlzLmZvcm07XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqIEBub2RvYyAqL1xuICAgIG5nT25EZXN0cm95KCkge1xuICAgICAgICBpZiAodGhpcy5mb3JtKSB7XG4gICAgICAgICAgICBjbGVhblVwVmFsaWRhdG9ycyh0aGlzLmZvcm0sIHRoaXMpO1xuICAgICAgICAgICAgLy8gQ3VycmVudGx5IHRoZSBgb25Db2xsZWN0aW9uQ2hhbmdlYCBjYWxsYmFjayBpcyByZXdyaXR0ZW4gZWFjaCB0aW1lIHRoZVxuICAgICAgICAgICAgLy8gYF9yZWdpc3Rlck9uQ29sbGVjdGlvbkNoYW5nZWAgZnVuY3Rpb24gaXMgaW52b2tlZC4gVGhlIGltcGxpY2F0aW9uIGlzIHRoYXQgY2xlYW51cCBzaG91bGRcbiAgICAgICAgICAgIC8vIGhhcHBlbiAqb25seSogd2hlbiB0aGUgYG9uQ29sbGVjdGlvbkNoYW5nZWAgY2FsbGJhY2sgd2FzIHNldCBieSB0aGlzIGRpcmVjdGl2ZSBpbnN0YW5jZS5cbiAgICAgICAgICAgIC8vIE90aGVyd2lzZSBpdCBtaWdodCBjYXVzZSBvdmVycmlkaW5nIGEgY2FsbGJhY2sgb2Ygc29tZSBvdGhlciBkaXJlY3RpdmUgaW5zdGFuY2VzLiBXZSBzaG91bGRcbiAgICAgICAgICAgIC8vIGNvbnNpZGVyIHVwZGF0aW5nIHRoaXMgbG9naWMgbGF0ZXIgdG8gbWFrZSBpdCBzaW1pbGFyIHRvIGhvdyBgb25DaGFuZ2VgIGNhbGxiYWNrcyBhcmVcbiAgICAgICAgICAgIC8vIGhhbmRsZWQsIHNlZSBodHRwczovL2dpdGh1Yi5jb20vYW5ndWxhci9hbmd1bGFyL2lzc3Vlcy8zOTczMiBmb3IgYWRkaXRpb25hbCBpbmZvLlxuICAgICAgICAgICAgaWYgKHRoaXMuZm9ybS5fb25Db2xsZWN0aW9uQ2hhbmdlID09PSB0aGlzLl9vbkNvbGxlY3Rpb25DaGFuZ2UpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmZvcm0uX3JlZ2lzdGVyT25Db2xsZWN0aW9uQ2hhbmdlKCgpID0+IHsgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICogUmV0dXJucyB0aGlzIGRpcmVjdGl2ZSdzIGluc3RhbmNlLlxuICAgICAqL1xuICAgIGdldCBmb3JtRGlyZWN0aXZlKCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICogUmV0dXJucyB0aGUgYEZvcm1Hcm91cGAgYm91bmQgdG8gdGhpcyBkaXJlY3RpdmUuXG4gICAgICovXG4gICAgZ2V0IGNvbnRyb2woKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZvcm07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqIFJldHVybnMgYW4gYXJyYXkgcmVwcmVzZW50aW5nIHRoZSBwYXRoIHRvIHRoaXMgZ3JvdXAuIEJlY2F1c2UgdGhpcyBkaXJlY3RpdmVcbiAgICAgKiBhbHdheXMgbGl2ZXMgYXQgdGhlIHRvcCBsZXZlbCBvZiBhIGZvcm0sIGl0IGFsd2F5cyBhbiBlbXB0eSBhcnJheS5cbiAgICAgKi9cbiAgICBnZXQgcGF0aCgpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKiBNZXRob2QgdGhhdCBzZXRzIHVwIHRoZSBjb250cm9sIGRpcmVjdGl2ZSBpbiB0aGlzIGdyb3VwLCByZS1jYWxjdWxhdGVzIGl0cyB2YWx1ZVxuICAgICAqIGFuZCB2YWxpZGl0eSwgYW5kIGFkZHMgdGhlIGluc3RhbmNlIHRvIHRoZSBpbnRlcm5hbCBsaXN0IG9mIGRpcmVjdGl2ZXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZGlyIFRoZSBgRm9ybUNvbnRyb2xOYW1lYCBkaXJlY3RpdmUgaW5zdGFuY2UuXG4gICAgICovXG4gICAgYWRkQ29udHJvbChkaXIpIHtcbiAgICAgICAgY29uc3QgY3RybCA9IHRoaXMuZm9ybS5nZXQoZGlyLnBhdGgpO1xuICAgICAgICBzZXRVcENvbnRyb2woY3RybCwgZGlyLCB0aGlzLmNhbGxTZXREaXNhYmxlZFN0YXRlKTtcbiAgICAgICAgY3RybC51cGRhdGVWYWx1ZUFuZFZhbGlkaXR5KHsgZW1pdEV2ZW50OiBmYWxzZSB9KTtcbiAgICAgICAgdGhpcy5kaXJlY3RpdmVzLnB1c2goZGlyKTtcbiAgICAgICAgcmV0dXJuIGN0cmw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqIFJldHJpZXZlcyB0aGUgYEZvcm1Db250cm9sYCBpbnN0YW5jZSBmcm9tIHRoZSBwcm92aWRlZCBgRm9ybUNvbnRyb2xOYW1lYCBkaXJlY3RpdmVcbiAgICAgKlxuICAgICAqIEBwYXJhbSBkaXIgVGhlIGBGb3JtQ29udHJvbE5hbWVgIGRpcmVjdGl2ZSBpbnN0YW5jZS5cbiAgICAgKi9cbiAgICBnZXRDb250cm9sKGRpcikge1xuICAgICAgICByZXR1cm4gdGhpcy5mb3JtLmdldChkaXIucGF0aCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqIFJlbW92ZXMgdGhlIGBGb3JtQ29udHJvbE5hbWVgIGluc3RhbmNlIGZyb20gdGhlIGludGVybmFsIGxpc3Qgb2YgZGlyZWN0aXZlc1xuICAgICAqXG4gICAgICogQHBhcmFtIGRpciBUaGUgYEZvcm1Db250cm9sTmFtZWAgZGlyZWN0aXZlIGluc3RhbmNlLlxuICAgICAqL1xuICAgIHJlbW92ZUNvbnRyb2woZGlyKSB7XG4gICAgICAgIGNsZWFuVXBDb250cm9sKGRpci5jb250cm9sIHx8IG51bGwsIGRpciwgLyogdmFsaWRhdGVDb250cm9sUHJlc2VuY2VPbkNoYW5nZSAqLyBmYWxzZSk7XG4gICAgICAgIHJlbW92ZUxpc3RJdGVtJDEodGhpcy5kaXJlY3RpdmVzLCBkaXIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGRzIGEgbmV3IGBGb3JtR3JvdXBOYW1lYCBkaXJlY3RpdmUgaW5zdGFuY2UgdG8gdGhlIGZvcm0uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZGlyIFRoZSBgRm9ybUdyb3VwTmFtZWAgZGlyZWN0aXZlIGluc3RhbmNlLlxuICAgICAqL1xuICAgIGFkZEZvcm1Hcm91cChkaXIpIHtcbiAgICAgICAgdGhpcy5fc2V0VXBGb3JtQ29udGFpbmVyKGRpcik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBlcmZvcm1zIHRoZSBuZWNlc3NhcnkgY2xlYW51cCB3aGVuIGEgYEZvcm1Hcm91cE5hbWVgIGRpcmVjdGl2ZSBpbnN0YW5jZSBpcyByZW1vdmVkIGZyb20gdGhlXG4gICAgICogdmlldy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBkaXIgVGhlIGBGb3JtR3JvdXBOYW1lYCBkaXJlY3RpdmUgaW5zdGFuY2UuXG4gICAgICovXG4gICAgcmVtb3ZlRm9ybUdyb3VwKGRpcikge1xuICAgICAgICB0aGlzLl9jbGVhblVwRm9ybUNvbnRhaW5lcihkaXIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKiBSZXRyaWV2ZXMgdGhlIGBGb3JtR3JvdXBgIGZvciBhIHByb3ZpZGVkIGBGb3JtR3JvdXBOYW1lYCBkaXJlY3RpdmUgaW5zdGFuY2VcbiAgICAgKlxuICAgICAqIEBwYXJhbSBkaXIgVGhlIGBGb3JtR3JvdXBOYW1lYCBkaXJlY3RpdmUgaW5zdGFuY2UuXG4gICAgICovXG4gICAgZ2V0Rm9ybUdyb3VwKGRpcikge1xuICAgICAgICByZXR1cm4gdGhpcy5mb3JtLmdldChkaXIucGF0aCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBlcmZvcm1zIHRoZSBuZWNlc3Nhcnkgc2V0dXAgd2hlbiBhIGBGb3JtQXJyYXlOYW1lYCBkaXJlY3RpdmUgaW5zdGFuY2UgaXMgYWRkZWQgdG8gdGhlIHZpZXcuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZGlyIFRoZSBgRm9ybUFycmF5TmFtZWAgZGlyZWN0aXZlIGluc3RhbmNlLlxuICAgICAqL1xuICAgIGFkZEZvcm1BcnJheShkaXIpIHtcbiAgICAgICAgdGhpcy5fc2V0VXBGb3JtQ29udGFpbmVyKGRpcik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBlcmZvcm1zIHRoZSBuZWNlc3NhcnkgY2xlYW51cCB3aGVuIGEgYEZvcm1BcnJheU5hbWVgIGRpcmVjdGl2ZSBpbnN0YW5jZSBpcyByZW1vdmVkIGZyb20gdGhlXG4gICAgICogdmlldy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBkaXIgVGhlIGBGb3JtQXJyYXlOYW1lYCBkaXJlY3RpdmUgaW5zdGFuY2UuXG4gICAgICovXG4gICAgcmVtb3ZlRm9ybUFycmF5KGRpcikge1xuICAgICAgICB0aGlzLl9jbGVhblVwRm9ybUNvbnRhaW5lcihkaXIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKiBSZXRyaWV2ZXMgdGhlIGBGb3JtQXJyYXlgIGZvciBhIHByb3ZpZGVkIGBGb3JtQXJyYXlOYW1lYCBkaXJlY3RpdmUgaW5zdGFuY2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZGlyIFRoZSBgRm9ybUFycmF5TmFtZWAgZGlyZWN0aXZlIGluc3RhbmNlLlxuICAgICAqL1xuICAgIGdldEZvcm1BcnJheShkaXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZm9ybS5nZXQoZGlyLnBhdGgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBuZXcgdmFsdWUgZm9yIHRoZSBwcm92aWRlZCBgRm9ybUNvbnRyb2xOYW1lYCBkaXJlY3RpdmUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZGlyIFRoZSBgRm9ybUNvbnRyb2xOYW1lYCBkaXJlY3RpdmUgaW5zdGFuY2UuXG4gICAgICogQHBhcmFtIHZhbHVlIFRoZSBuZXcgdmFsdWUgZm9yIHRoZSBkaXJlY3RpdmUncyBjb250cm9sLlxuICAgICAqL1xuICAgIHVwZGF0ZU1vZGVsKGRpciwgdmFsdWUpIHtcbiAgICAgICAgY29uc3QgY3RybCA9IHRoaXMuZm9ybS5nZXQoZGlyLnBhdGgpO1xuICAgICAgICBjdHJsLnNldFZhbHVlKHZhbHVlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICogTWV0aG9kIGNhbGxlZCB3aXRoIHRoZSBcInN1Ym1pdFwiIGV2ZW50IGlzIHRyaWdnZXJlZCBvbiB0aGUgZm9ybS5cbiAgICAgKiBUcmlnZ2VycyB0aGUgYG5nU3VibWl0YCBlbWl0dGVyIHRvIGVtaXQgdGhlIFwic3VibWl0XCIgZXZlbnQgYXMgaXRzIHBheWxvYWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gJGV2ZW50IFRoZSBcInN1Ym1pdFwiIGV2ZW50IG9iamVjdFxuICAgICAqL1xuICAgIG9uU3VibWl0KCRldmVudCkge1xuICAgICAgICB0aGlzLnN1Ym1pdHRlZCA9IHRydWU7XG4gICAgICAgIHN5bmNQZW5kaW5nQ29udHJvbHModGhpcy5mb3JtLCB0aGlzLmRpcmVjdGl2ZXMpO1xuICAgICAgICB0aGlzLm5nU3VibWl0LmVtaXQoJGV2ZW50KTtcbiAgICAgICAgLy8gRm9ybXMgd2l0aCBgbWV0aG9kPVwiZGlhbG9nXCJgIGhhdmUgc29tZSBzcGVjaWFsIGJlaGF2aW9yIHRoYXQgd29uJ3QgcmVsb2FkIHRoZSBwYWdlIGFuZCB0aGF0XG4gICAgICAgIC8vIHNob3VsZG4ndCBiZSBwcmV2ZW50ZWQuIE5vdGUgdGhhdCB3ZSBuZWVkIHRvIG51bGwgY2hlY2sgdGhlIGBldmVudGAgYW5kIHRoZSBgdGFyZ2V0YCwgYmVjYXVzZVxuICAgICAgICAvLyBzb21lIGludGVybmFsIGFwcHMgY2FsbCB0aGlzIG1ldGhvZCBkaXJlY3RseSB3aXRoIHRoZSB3cm9uZyBhcmd1bWVudHMuXG4gICAgICAgIHJldHVybiAkZXZlbnQ/LnRhcmdldD8ubWV0aG9kID09PSAnZGlhbG9nJztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICogTWV0aG9kIGNhbGxlZCB3aGVuIHRoZSBcInJlc2V0XCIgZXZlbnQgaXMgdHJpZ2dlcmVkIG9uIHRoZSBmb3JtLlxuICAgICAqL1xuICAgIG9uUmVzZXQoKSB7XG4gICAgICAgIHRoaXMucmVzZXRGb3JtKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqIFJlc2V0cyB0aGUgZm9ybSB0byBhbiBpbml0aWFsIHZhbHVlIGFuZCByZXNldHMgaXRzIHN1Ym1pdHRlZCBzdGF0dXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdmFsdWUgVGhlIG5ldyB2YWx1ZSBmb3IgdGhlIGZvcm0uXG4gICAgICovXG4gICAgcmVzZXRGb3JtKHZhbHVlID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMuZm9ybS5yZXNldCh2YWx1ZSk7XG4gICAgICAgIHRoaXMuc3VibWl0dGVkID0gZmFsc2U7XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBfdXBkYXRlRG9tVmFsdWUoKSB7XG4gICAgICAgIHRoaXMuZGlyZWN0aXZlcy5mb3JFYWNoKGRpciA9PiB7XG4gICAgICAgICAgICBjb25zdCBvbGRDdHJsID0gZGlyLmNvbnRyb2w7XG4gICAgICAgICAgICBjb25zdCBuZXdDdHJsID0gdGhpcy5mb3JtLmdldChkaXIucGF0aCk7XG4gICAgICAgICAgICBpZiAob2xkQ3RybCAhPT0gbmV3Q3RybCkge1xuICAgICAgICAgICAgICAgIC8vIE5vdGU6IHRoZSB2YWx1ZSBvZiB0aGUgYGRpci5jb250cm9sYCBtYXkgbm90IGJlIGRlZmluZWQsIGZvciBleGFtcGxlIHdoZW4gaXQncyBhIGZpcnN0XG4gICAgICAgICAgICAgICAgLy8gYEZvcm1Db250cm9sYCB0aGF0IGlzIGFkZGVkIHRvIGEgYEZvcm1Hcm91cGAgaW5zdGFuY2UgKHZpYSBgYWRkQ29udHJvbGAgY2FsbCkuXG4gICAgICAgICAgICAgICAgY2xlYW5VcENvbnRyb2wob2xkQ3RybCB8fCBudWxsLCBkaXIpO1xuICAgICAgICAgICAgICAgIC8vIENoZWNrIHdoZXRoZXIgbmV3IGNvbnRyb2wgYXQgdGhlIHNhbWUgbG9jYXRpb24gaW5zaWRlIHRoZSBjb3JyZXNwb25kaW5nIGBGb3JtR3JvdXBgIGlzIGFuXG4gICAgICAgICAgICAgICAgLy8gaW5zdGFuY2Ugb2YgYEZvcm1Db250cm9sYCBhbmQgcGVyZm9ybSBjb250cm9sIHNldHVwIG9ubHkgaWYgdGhhdCdzIHRoZSBjYXNlLlxuICAgICAgICAgICAgICAgIC8vIE5vdGU6IHdlIGRvbid0IG5lZWQgdG8gY2xlYXIgdGhlIGxpc3Qgb2YgZGlyZWN0aXZlcyAoYHRoaXMuZGlyZWN0aXZlc2ApIGhlcmUsIGl0IHdvdWxkIGJlXG4gICAgICAgICAgICAgICAgLy8gdGFrZW4gY2FyZSBvZiBpbiB0aGUgYHJlbW92ZUNvbnRyb2xgIG1ldGhvZCBpbnZva2VkIHdoZW4gY29ycmVzcG9uZGluZyBgZm9ybUNvbnRyb2xOYW1lYFxuICAgICAgICAgICAgICAgIC8vIGRpcmVjdGl2ZSBpbnN0YW5jZSBpcyBiZWluZyByZW1vdmVkIChpbnZva2VkIGZyb20gYEZvcm1Db250cm9sTmFtZS5uZ09uRGVzdHJveWApLlxuICAgICAgICAgICAgICAgIGlmIChpc0Zvcm1Db250cm9sKG5ld0N0cmwpKSB7XG4gICAgICAgICAgICAgICAgICAgIHNldFVwQ29udHJvbChuZXdDdHJsLCBkaXIsIHRoaXMuY2FsbFNldERpc2FibGVkU3RhdGUpO1xuICAgICAgICAgICAgICAgICAgICBkaXIuY29udHJvbCA9IG5ld0N0cmw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5mb3JtLl91cGRhdGVUcmVlVmFsaWRpdHkoeyBlbWl0RXZlbnQ6IGZhbHNlIH0pO1xuICAgIH1cbiAgICBfc2V0VXBGb3JtQ29udGFpbmVyKGRpcikge1xuICAgICAgICBjb25zdCBjdHJsID0gdGhpcy5mb3JtLmdldChkaXIucGF0aCk7XG4gICAgICAgIHNldFVwRm9ybUNvbnRhaW5lcihjdHJsLCBkaXIpO1xuICAgICAgICAvLyBOT1RFOiB0aGlzIG9wZXJhdGlvbiBsb29rcyB1bm5lY2Vzc2FyeSBpbiBjYXNlIG5vIG5ldyB2YWxpZGF0b3JzIHdlcmUgYWRkZWQgaW5cbiAgICAgICAgLy8gYHNldFVwRm9ybUNvbnRhaW5lcmAgY2FsbC4gQ29uc2lkZXIgdXBkYXRpbmcgdGhpcyBjb2RlIHRvIG1hdGNoIHRoZSBsb2dpYyBpblxuICAgICAgICAvLyBgX2NsZWFuVXBGb3JtQ29udGFpbmVyYCBmdW5jdGlvbi5cbiAgICAgICAgY3RybC51cGRhdGVWYWx1ZUFuZFZhbGlkaXR5KHsgZW1pdEV2ZW50OiBmYWxzZSB9KTtcbiAgICB9XG4gICAgX2NsZWFuVXBGb3JtQ29udGFpbmVyKGRpcikge1xuICAgICAgICBpZiAodGhpcy5mb3JtKSB7XG4gICAgICAgICAgICBjb25zdCBjdHJsID0gdGhpcy5mb3JtLmdldChkaXIucGF0aCk7XG4gICAgICAgICAgICBpZiAoY3RybCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGlzQ29udHJvbFVwZGF0ZWQgPSBjbGVhblVwRm9ybUNvbnRhaW5lcihjdHJsLCBkaXIpO1xuICAgICAgICAgICAgICAgIGlmIChpc0NvbnRyb2xVcGRhdGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFJ1biB2YWxpZGl0eSBjaGVjayBvbmx5IGluIGNhc2UgYSBjb250cm9sIHdhcyB1cGRhdGVkIChpLmUuIHZpZXcgdmFsaWRhdG9ycyB3ZXJlXG4gICAgICAgICAgICAgICAgICAgIC8vIHJlbW92ZWQpIGFzIHJlbW92aW5nIHZpZXcgdmFsaWRhdG9ycyBtaWdodCBjYXVzZSB2YWxpZGl0eSB0byBjaGFuZ2UuXG4gICAgICAgICAgICAgICAgICAgIGN0cmwudXBkYXRlVmFsdWVBbmRWYWxpZGl0eSh7IGVtaXRFdmVudDogZmFsc2UgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIF91cGRhdGVSZWdpc3RyYXRpb25zKCkge1xuICAgICAgICB0aGlzLmZvcm0uX3JlZ2lzdGVyT25Db2xsZWN0aW9uQ2hhbmdlKHRoaXMuX29uQ29sbGVjdGlvbkNoYW5nZSk7XG4gICAgICAgIGlmICh0aGlzLl9vbGRGb3JtKSB7XG4gICAgICAgICAgICB0aGlzLl9vbGRGb3JtLl9yZWdpc3Rlck9uQ29sbGVjdGlvbkNoYW5nZSgoKSA9PiB7IH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIF91cGRhdGVWYWxpZGF0b3JzKCkge1xuICAgICAgICBzZXRVcFZhbGlkYXRvcnModGhpcy5mb3JtLCB0aGlzKTtcbiAgICAgICAgaWYgKHRoaXMuX29sZEZvcm0pIHtcbiAgICAgICAgICAgIGNsZWFuVXBWYWxpZGF0b3JzKHRoaXMuX29sZEZvcm0sIHRoaXMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9jaGVja0Zvcm1QcmVzZW50KCkge1xuICAgICAgICBpZiAoIXRoaXMuZm9ybSAmJiAodHlwZW9mIG5nRGV2TW9kZSA9PT0gJ3VuZGVmaW5lZCcgfHwgbmdEZXZNb2RlKSkge1xuICAgICAgICAgICAgdGhyb3cgbWlzc2luZ0Zvcm1FeGNlcHRpb24oKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzdGF0aWMgeyB0aGlzLsm1ZmFjID0gaTAuybXJtW5nRGVjbGFyZUZhY3RvcnkoeyBtaW5WZXJzaW9uOiBcIjEyLjAuMFwiLCB2ZXJzaW9uOiBcIjE3LjMuMTJcIiwgbmdJbXBvcnQ6IGkwLCB0eXBlOiBGb3JtR3JvdXBEaXJlY3RpdmUsIGRlcHM6IFt7IHRva2VuOiBOR19WQUxJREFUT1JTLCBvcHRpb25hbDogdHJ1ZSwgc2VsZjogdHJ1ZSB9LCB7IHRva2VuOiBOR19BU1lOQ19WQUxJREFUT1JTLCBvcHRpb25hbDogdHJ1ZSwgc2VsZjogdHJ1ZSB9LCB7IHRva2VuOiBDQUxMX1NFVF9ESVNBQkxFRF9TVEFURSwgb3B0aW9uYWw6IHRydWUgfV0sIHRhcmdldDogaTAuybXJtUZhY3RvcnlUYXJnZXQuRGlyZWN0aXZlIH0pOyB9XG4gICAgc3RhdGljIHsgdGhpcy7JtWRpciA9IGkwLsm1ybVuZ0RlY2xhcmVEaXJlY3RpdmUoeyBtaW5WZXJzaW9uOiBcIjE0LjAuMFwiLCB2ZXJzaW9uOiBcIjE3LjMuMTJcIiwgdHlwZTogRm9ybUdyb3VwRGlyZWN0aXZlLCBzZWxlY3RvcjogXCJbZm9ybUdyb3VwXVwiLCBpbnB1dHM6IHsgZm9ybTogW1wiZm9ybUdyb3VwXCIsIFwiZm9ybVwiXSB9LCBvdXRwdXRzOiB7IG5nU3VibWl0OiBcIm5nU3VibWl0XCIgfSwgaG9zdDogeyBsaXN0ZW5lcnM6IHsgXCJzdWJtaXRcIjogXCJvblN1Ym1pdCgkZXZlbnQpXCIsIFwicmVzZXRcIjogXCJvblJlc2V0KClcIiB9IH0sIHByb3ZpZGVyczogW2Zvcm1EaXJlY3RpdmVQcm92aWRlcl0sIGV4cG9ydEFzOiBbXCJuZ0Zvcm1cIl0sIHVzZXNJbmhlcml0YW5jZTogdHJ1ZSwgdXNlc09uQ2hhbmdlczogdHJ1ZSwgbmdJbXBvcnQ6IGkwIH0pOyB9XG59XG5pMC7Jtcm1bmdEZWNsYXJlQ2xhc3NNZXRhZGF0YSh7IG1pblZlcnNpb246IFwiMTIuMC4wXCIsIHZlcnNpb246IFwiMTcuMy4xMlwiLCBuZ0ltcG9ydDogaTAsIHR5cGU6IEZvcm1Hcm91cERpcmVjdGl2ZSwgZGVjb3JhdG9yczogW3tcbiAgICAgICAgICAgIHR5cGU6IERpcmVjdGl2ZSxcbiAgICAgICAgICAgIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnW2Zvcm1Hcm91cF0nLFxuICAgICAgICAgICAgICAgICAgICBwcm92aWRlcnM6IFtmb3JtRGlyZWN0aXZlUHJvdmlkZXJdLFxuICAgICAgICAgICAgICAgICAgICBob3N0OiB7ICcoc3VibWl0KSc6ICdvblN1Ym1pdCgkZXZlbnQpJywgJyhyZXNldCknOiAnb25SZXNldCgpJyB9LFxuICAgICAgICAgICAgICAgICAgICBleHBvcnRBczogJ25nRm9ybSdcbiAgICAgICAgICAgICAgICB9XVxuICAgICAgICB9XSwgY3RvclBhcmFtZXRlcnM6ICgpID0+IFt7IHR5cGU6IHVuZGVmaW5lZCwgZGVjb3JhdG9yczogW3tcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogT3B0aW9uYWxcbiAgICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFNlbGZcbiAgICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IEluamVjdCxcbiAgICAgICAgICAgICAgICAgICAgYXJnczogW05HX1ZBTElEQVRPUlNdXG4gICAgICAgICAgICAgICAgfV0gfSwgeyB0eXBlOiB1bmRlZmluZWQsIGRlY29yYXRvcnM6IFt7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IE9wdGlvbmFsXG4gICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBTZWxmXG4gICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBJbmplY3QsXG4gICAgICAgICAgICAgICAgICAgIGFyZ3M6IFtOR19BU1lOQ19WQUxJREFUT1JTXVxuICAgICAgICAgICAgICAgIH1dIH0sIHsgdHlwZTogdW5kZWZpbmVkLCBkZWNvcmF0b3JzOiBbe1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBPcHRpb25hbFxuICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogSW5qZWN0LFxuICAgICAgICAgICAgICAgICAgICBhcmdzOiBbQ0FMTF9TRVRfRElTQUJMRURfU1RBVEVdXG4gICAgICAgICAgICAgICAgfV0gfV0sIHByb3BEZWNvcmF0b3JzOiB7IGZvcm06IFt7XG4gICAgICAgICAgICAgICAgdHlwZTogSW5wdXQsXG4gICAgICAgICAgICAgICAgYXJnczogWydmb3JtR3JvdXAnXVxuICAgICAgICAgICAgfV0sIG5nU3VibWl0OiBbe1xuICAgICAgICAgICAgICAgIHR5cGU6IE91dHB1dFxuICAgICAgICAgICAgfV0gfSB9KTtcblxuY29uc3QgZm9ybUdyb3VwTmFtZVByb3ZpZGVyID0ge1xuICAgIHByb3ZpZGU6IENvbnRyb2xDb250YWluZXIsXG4gICAgdXNlRXhpc3Rpbmc6IGZvcndhcmRSZWYoKCkgPT4gRm9ybUdyb3VwTmFtZSlcbn07XG4vKipcbiAqIEBkZXNjcmlwdGlvblxuICpcbiAqIFN5bmNzIGEgbmVzdGVkIGBGb3JtR3JvdXBgIG9yIGBGb3JtUmVjb3JkYCB0byBhIERPTSBlbGVtZW50LlxuICpcbiAqIFRoaXMgZGlyZWN0aXZlIGNhbiBvbmx5IGJlIHVzZWQgd2l0aCBhIHBhcmVudCBgRm9ybUdyb3VwRGlyZWN0aXZlYC5cbiAqXG4gKiBJdCBhY2NlcHRzIHRoZSBzdHJpbmcgbmFtZSBvZiB0aGUgbmVzdGVkIGBGb3JtR3JvdXBgIG9yIGBGb3JtUmVjb3JkYCB0byBsaW5rLCBhbmRcbiAqIGxvb2tzIGZvciBhIGBGb3JtR3JvdXBgIG9yIGBGb3JtUmVjb3JkYCByZWdpc3RlcmVkIHdpdGggdGhhdCBuYW1lIGluIHRoZSBwYXJlbnRcbiAqIGBGb3JtR3JvdXBgIGluc3RhbmNlIHlvdSBwYXNzZWQgaW50byBgRm9ybUdyb3VwRGlyZWN0aXZlYC5cbiAqXG4gKiBVc2UgbmVzdGVkIGZvcm0gZ3JvdXBzIHRvIHZhbGlkYXRlIGEgc3ViLWdyb3VwIG9mIGFcbiAqIGZvcm0gc2VwYXJhdGVseSBmcm9tIHRoZSByZXN0IG9yIHRvIGdyb3VwIHRoZSB2YWx1ZXMgb2YgY2VydGFpblxuICogY29udHJvbHMgaW50byB0aGVpciBvd24gbmVzdGVkIG9iamVjdC5cbiAqXG4gKiBAc2VlIFtSZWFjdGl2ZSBGb3JtcyBHdWlkZV0oZ3VpZGUvcmVhY3RpdmUtZm9ybXMpXG4gKlxuICogQHVzYWdlTm90ZXNcbiAqXG4gKiAjIyMgQWNjZXNzIHRoZSBncm91cCBieSBuYW1lXG4gKlxuICogVGhlIGZvbGxvd2luZyBleGFtcGxlIHVzZXMgdGhlIGBBYnN0cmFjdENvbnRyb2wuZ2V0YCBtZXRob2QgdG8gYWNjZXNzIHRoZVxuICogYXNzb2NpYXRlZCBgRm9ybUdyb3VwYFxuICpcbiAqIGBgYHRzXG4gKiAgIHRoaXMuZm9ybS5nZXQoJ25hbWUnKTtcbiAqIGBgYFxuICpcbiAqICMjIyBBY2Nlc3MgaW5kaXZpZHVhbCBjb250cm9scyBpbiB0aGUgZ3JvdXBcbiAqXG4gKiBUaGUgZm9sbG93aW5nIGV4YW1wbGUgdXNlcyB0aGUgYEFic3RyYWN0Q29udHJvbC5nZXRgIG1ldGhvZCB0byBhY2Nlc3NcbiAqIGluZGl2aWR1YWwgY29udHJvbHMgd2l0aGluIHRoZSBncm91cCB1c2luZyBkb3Qgc3ludGF4LlxuICpcbiAqIGBgYHRzXG4gKiAgIHRoaXMuZm9ybS5nZXQoJ25hbWUuZmlyc3QnKTtcbiAqIGBgYFxuICpcbiAqICMjIyBSZWdpc3RlciBhIG5lc3RlZCBgRm9ybUdyb3VwYC5cbiAqXG4gKiBUaGUgZm9sbG93aW5nIGV4YW1wbGUgcmVnaXN0ZXJzIGEgbmVzdGVkICpuYW1lKiBgRm9ybUdyb3VwYCB3aXRoaW4gYW4gZXhpc3RpbmcgYEZvcm1Hcm91cGAsXG4gKiBhbmQgcHJvdmlkZXMgbWV0aG9kcyB0byByZXRyaWV2ZSB0aGUgbmVzdGVkIGBGb3JtR3JvdXBgIGFuZCBpbmRpdmlkdWFsIGNvbnRyb2xzLlxuICpcbiAqIHtAZXhhbXBsZSBmb3Jtcy90cy9uZXN0ZWRGb3JtR3JvdXAvbmVzdGVkX2Zvcm1fZ3JvdXBfZXhhbXBsZS50cyByZWdpb249J0NvbXBvbmVudCd9XG4gKlxuICogQG5nTW9kdWxlIFJlYWN0aXZlRm9ybXNNb2R1bGVcbiAqIEBwdWJsaWNBcGlcbiAqL1xuY2xhc3MgRm9ybUdyb3VwTmFtZSBleHRlbmRzIEFic3RyYWN0Rm9ybUdyb3VwRGlyZWN0aXZlIHtcbiAgICBjb25zdHJ1Y3RvcihwYXJlbnQsIHZhbGlkYXRvcnMsIGFzeW5jVmFsaWRhdG9ycykge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICAvKipcbiAgICAgICAgICogQGRlc2NyaXB0aW9uXG4gICAgICAgICAqIFRyYWNrcyB0aGUgbmFtZSBvZiB0aGUgYEZvcm1Hcm91cGAgYm91bmQgdG8gdGhlIGRpcmVjdGl2ZS4gVGhlIG5hbWUgY29ycmVzcG9uZHNcbiAgICAgICAgICogdG8gYSBrZXkgaW4gdGhlIHBhcmVudCBgRm9ybUdyb3VwYCBvciBgRm9ybUFycmF5YC5cbiAgICAgICAgICogQWNjZXB0cyBhIG5hbWUgYXMgYSBzdHJpbmcgb3IgYSBudW1iZXIuXG4gICAgICAgICAqIFRoZSBuYW1lIGluIHRoZSBmb3JtIG9mIGEgc3RyaW5nIGlzIHVzZWZ1bCBmb3IgaW5kaXZpZHVhbCBmb3JtcyxcbiAgICAgICAgICogd2hpbGUgdGhlIG51bWVyaWNhbCBmb3JtIGFsbG93cyBmb3IgZm9ybSBncm91cHMgdG8gYmUgYm91bmRcbiAgICAgICAgICogdG8gaW5kaWNlcyB3aGVuIGl0ZXJhdGluZyBvdmVyIGdyb3VwcyBpbiBhIGBGb3JtQXJyYXlgLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5uYW1lID0gbnVsbDtcbiAgICAgICAgdGhpcy5fcGFyZW50ID0gcGFyZW50O1xuICAgICAgICB0aGlzLl9zZXRWYWxpZGF0b3JzKHZhbGlkYXRvcnMpO1xuICAgICAgICB0aGlzLl9zZXRBc3luY1ZhbGlkYXRvcnMoYXN5bmNWYWxpZGF0b3JzKTtcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIF9jaGVja1BhcmVudFR5cGUoKSB7XG4gICAgICAgIGlmIChfaGFzSW52YWxpZFBhcmVudCh0aGlzLl9wYXJlbnQpICYmICh0eXBlb2YgbmdEZXZNb2RlID09PSAndW5kZWZpbmVkJyB8fCBuZ0Rldk1vZGUpKSB7XG4gICAgICAgICAgICB0aHJvdyBncm91cFBhcmVudEV4Y2VwdGlvbigpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHN0YXRpYyB7IHRoaXMuybVmYWMgPSBpMC7Jtcm1bmdEZWNsYXJlRmFjdG9yeSh7IG1pblZlcnNpb246IFwiMTIuMC4wXCIsIHZlcnNpb246IFwiMTcuMy4xMlwiLCBuZ0ltcG9ydDogaTAsIHR5cGU6IEZvcm1Hcm91cE5hbWUsIGRlcHM6IFt7IHRva2VuOiBDb250cm9sQ29udGFpbmVyLCBob3N0OiB0cnVlLCBvcHRpb25hbDogdHJ1ZSwgc2tpcFNlbGY6IHRydWUgfSwgeyB0b2tlbjogTkdfVkFMSURBVE9SUywgb3B0aW9uYWw6IHRydWUsIHNlbGY6IHRydWUgfSwgeyB0b2tlbjogTkdfQVNZTkNfVkFMSURBVE9SUywgb3B0aW9uYWw6IHRydWUsIHNlbGY6IHRydWUgfV0sIHRhcmdldDogaTAuybXJtUZhY3RvcnlUYXJnZXQuRGlyZWN0aXZlIH0pOyB9XG4gICAgc3RhdGljIHsgdGhpcy7JtWRpciA9IGkwLsm1ybVuZ0RlY2xhcmVEaXJlY3RpdmUoeyBtaW5WZXJzaW9uOiBcIjE0LjAuMFwiLCB2ZXJzaW9uOiBcIjE3LjMuMTJcIiwgdHlwZTogRm9ybUdyb3VwTmFtZSwgc2VsZWN0b3I6IFwiW2Zvcm1Hcm91cE5hbWVdXCIsIGlucHV0czogeyBuYW1lOiBbXCJmb3JtR3JvdXBOYW1lXCIsIFwibmFtZVwiXSB9LCBwcm92aWRlcnM6IFtmb3JtR3JvdXBOYW1lUHJvdmlkZXJdLCB1c2VzSW5oZXJpdGFuY2U6IHRydWUsIG5nSW1wb3J0OiBpMCB9KTsgfVxufVxuaTAuybXJtW5nRGVjbGFyZUNsYXNzTWV0YWRhdGEoeyBtaW5WZXJzaW9uOiBcIjEyLjAuMFwiLCB2ZXJzaW9uOiBcIjE3LjMuMTJcIiwgbmdJbXBvcnQ6IGkwLCB0eXBlOiBGb3JtR3JvdXBOYW1lLCBkZWNvcmF0b3JzOiBbe1xuICAgICAgICAgICAgdHlwZTogRGlyZWN0aXZlLFxuICAgICAgICAgICAgYXJnczogW3sgc2VsZWN0b3I6ICdbZm9ybUdyb3VwTmFtZV0nLCBwcm92aWRlcnM6IFtmb3JtR3JvdXBOYW1lUHJvdmlkZXJdIH1dXG4gICAgICAgIH1dLCBjdG9yUGFyYW1ldGVyczogKCkgPT4gW3sgdHlwZTogQ29udHJvbENvbnRhaW5lciwgZGVjb3JhdG9yczogW3tcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogT3B0aW9uYWxcbiAgICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IEhvc3RcbiAgICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFNraXBTZWxmXG4gICAgICAgICAgICAgICAgfV0gfSwgeyB0eXBlOiB1bmRlZmluZWQsIGRlY29yYXRvcnM6IFt7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IE9wdGlvbmFsXG4gICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBTZWxmXG4gICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBJbmplY3QsXG4gICAgICAgICAgICAgICAgICAgIGFyZ3M6IFtOR19WQUxJREFUT1JTXVxuICAgICAgICAgICAgICAgIH1dIH0sIHsgdHlwZTogdW5kZWZpbmVkLCBkZWNvcmF0b3JzOiBbe1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBPcHRpb25hbFxuICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogU2VsZlxuICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogSW5qZWN0LFxuICAgICAgICAgICAgICAgICAgICBhcmdzOiBbTkdfQVNZTkNfVkFMSURBVE9SU11cbiAgICAgICAgICAgICAgICB9XSB9XSwgcHJvcERlY29yYXRvcnM6IHsgbmFtZTogW3tcbiAgICAgICAgICAgICAgICB0eXBlOiBJbnB1dCxcbiAgICAgICAgICAgICAgICBhcmdzOiBbJ2Zvcm1Hcm91cE5hbWUnXVxuICAgICAgICAgICAgfV0gfSB9KTtcbmNvbnN0IGZvcm1BcnJheU5hbWVQcm92aWRlciA9IHtcbiAgICBwcm92aWRlOiBDb250cm9sQ29udGFpbmVyLFxuICAgIHVzZUV4aXN0aW5nOiBmb3J3YXJkUmVmKCgpID0+IEZvcm1BcnJheU5hbWUpXG59O1xuLyoqXG4gKiBAZGVzY3JpcHRpb25cbiAqXG4gKiBTeW5jcyBhIG5lc3RlZCBgRm9ybUFycmF5YCB0byBhIERPTSBlbGVtZW50LlxuICpcbiAqIFRoaXMgZGlyZWN0aXZlIGlzIGRlc2lnbmVkIHRvIGJlIHVzZWQgd2l0aCBhIHBhcmVudCBgRm9ybUdyb3VwRGlyZWN0aXZlYCAoc2VsZWN0b3I6XG4gKiBgW2Zvcm1Hcm91cF1gKS5cbiAqXG4gKiBJdCBhY2NlcHRzIHRoZSBzdHJpbmcgbmFtZSBvZiB0aGUgbmVzdGVkIGBGb3JtQXJyYXlgIHlvdSB3YW50IHRvIGxpbmssIGFuZFxuICogd2lsbCBsb29rIGZvciBhIGBGb3JtQXJyYXlgIHJlZ2lzdGVyZWQgd2l0aCB0aGF0IG5hbWUgaW4gdGhlIHBhcmVudFxuICogYEZvcm1Hcm91cGAgaW5zdGFuY2UgeW91IHBhc3NlZCBpbnRvIGBGb3JtR3JvdXBEaXJlY3RpdmVgLlxuICpcbiAqIEBzZWUgW1JlYWN0aXZlIEZvcm1zIEd1aWRlXShndWlkZS9yZWFjdGl2ZS1mb3JtcylcbiAqIEBzZWUge0BsaW5rIEFic3RyYWN0Q29udHJvbH1cbiAqXG4gKiBAdXNhZ2VOb3Rlc1xuICpcbiAqICMjIyBFeGFtcGxlXG4gKlxuICoge0BleGFtcGxlIGZvcm1zL3RzL25lc3RlZEZvcm1BcnJheS9uZXN0ZWRfZm9ybV9hcnJheV9leGFtcGxlLnRzIHJlZ2lvbj0nQ29tcG9uZW50J31cbiAqXG4gKiBAbmdNb2R1bGUgUmVhY3RpdmVGb3Jtc01vZHVsZVxuICogQHB1YmxpY0FwaVxuICovXG5jbGFzcyBGb3JtQXJyYXlOYW1lIGV4dGVuZHMgQ29udHJvbENvbnRhaW5lciB7XG4gICAgY29uc3RydWN0b3IocGFyZW50LCB2YWxpZGF0b3JzLCBhc3luY1ZhbGlkYXRvcnMpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAgICAgKiBUcmFja3MgdGhlIG5hbWUgb2YgdGhlIGBGb3JtQXJyYXlgIGJvdW5kIHRvIHRoZSBkaXJlY3RpdmUuIFRoZSBuYW1lIGNvcnJlc3BvbmRzXG4gICAgICAgICAqIHRvIGEga2V5IGluIHRoZSBwYXJlbnQgYEZvcm1Hcm91cGAgb3IgYEZvcm1BcnJheWAuXG4gICAgICAgICAqIEFjY2VwdHMgYSBuYW1lIGFzIGEgc3RyaW5nIG9yIGEgbnVtYmVyLlxuICAgICAgICAgKiBUaGUgbmFtZSBpbiB0aGUgZm9ybSBvZiBhIHN0cmluZyBpcyB1c2VmdWwgZm9yIGluZGl2aWR1YWwgZm9ybXMsXG4gICAgICAgICAqIHdoaWxlIHRoZSBudW1lcmljYWwgZm9ybSBhbGxvd3MgZm9yIGZvcm0gYXJyYXlzIHRvIGJlIGJvdW5kXG4gICAgICAgICAqIHRvIGluZGljZXMgd2hlbiBpdGVyYXRpbmcgb3ZlciBhcnJheXMgaW4gYSBgRm9ybUFycmF5YC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubmFtZSA9IG51bGw7XG4gICAgICAgIHRoaXMuX3BhcmVudCA9IHBhcmVudDtcbiAgICAgICAgdGhpcy5fc2V0VmFsaWRhdG9ycyh2YWxpZGF0b3JzKTtcbiAgICAgICAgdGhpcy5fc2V0QXN5bmNWYWxpZGF0b3JzKGFzeW5jVmFsaWRhdG9ycyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEEgbGlmZWN5Y2xlIG1ldGhvZCBjYWxsZWQgd2hlbiB0aGUgZGlyZWN0aXZlJ3MgaW5wdXRzIGFyZSBpbml0aWFsaXplZC4gRm9yIGludGVybmFsIHVzZSBvbmx5LlxuICAgICAqIEB0aHJvd3MgSWYgdGhlIGRpcmVjdGl2ZSBkb2VzIG5vdCBoYXZlIGEgdmFsaWQgcGFyZW50LlxuICAgICAqIEBub2RvY1xuICAgICAqL1xuICAgIG5nT25Jbml0KCkge1xuICAgICAgICB0aGlzLl9jaGVja1BhcmVudFR5cGUoKTtcbiAgICAgICAgdGhpcy5mb3JtRGlyZWN0aXZlLmFkZEZvcm1BcnJheSh0aGlzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQSBsaWZlY3ljbGUgbWV0aG9kIGNhbGxlZCBiZWZvcmUgdGhlIGRpcmVjdGl2ZSdzIGluc3RhbmNlIGlzIGRlc3Ryb3llZC4gRm9yIGludGVybmFsIHVzZSBvbmx5LlxuICAgICAqIEBub2RvY1xuICAgICAqL1xuICAgIG5nT25EZXN0cm95KCkge1xuICAgICAgICBpZiAodGhpcy5mb3JtRGlyZWN0aXZlKSB7XG4gICAgICAgICAgICB0aGlzLmZvcm1EaXJlY3RpdmUucmVtb3ZlRm9ybUFycmF5KHRoaXMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqIFRoZSBgRm9ybUFycmF5YCBib3VuZCB0byB0aGlzIGRpcmVjdGl2ZS5cbiAgICAgKi9cbiAgICBnZXQgY29udHJvbCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZm9ybURpcmVjdGl2ZS5nZXRGb3JtQXJyYXkodGhpcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqIFRoZSB0b3AtbGV2ZWwgZGlyZWN0aXZlIGZvciB0aGlzIGdyb3VwIGlmIHByZXNlbnQsIG90aGVyd2lzZSBudWxsLlxuICAgICAqL1xuICAgIGdldCBmb3JtRGlyZWN0aXZlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcGFyZW50ID8gdGhpcy5fcGFyZW50LmZvcm1EaXJlY3RpdmUgOiBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKiBSZXR1cm5zIGFuIGFycmF5IHRoYXQgcmVwcmVzZW50cyB0aGUgcGF0aCBmcm9tIHRoZSB0b3AtbGV2ZWwgZm9ybSB0byB0aGlzIGNvbnRyb2wuXG4gICAgICogRWFjaCBpbmRleCBpcyB0aGUgc3RyaW5nIG5hbWUgb2YgdGhlIGNvbnRyb2wgb24gdGhhdCBsZXZlbC5cbiAgICAgKi9cbiAgICBnZXQgcGF0aCgpIHtcbiAgICAgICAgcmV0dXJuIGNvbnRyb2xQYXRoKHRoaXMubmFtZSA9PSBudWxsID8gdGhpcy5uYW1lIDogdGhpcy5uYW1lLnRvU3RyaW5nKCksIHRoaXMuX3BhcmVudCk7XG4gICAgfVxuICAgIF9jaGVja1BhcmVudFR5cGUoKSB7XG4gICAgICAgIGlmIChfaGFzSW52YWxpZFBhcmVudCh0aGlzLl9wYXJlbnQpICYmICh0eXBlb2YgbmdEZXZNb2RlID09PSAndW5kZWZpbmVkJyB8fCBuZ0Rldk1vZGUpKSB7XG4gICAgICAgICAgICB0aHJvdyBhcnJheVBhcmVudEV4Y2VwdGlvbigpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHN0YXRpYyB7IHRoaXMuybVmYWMgPSBpMC7Jtcm1bmdEZWNsYXJlRmFjdG9yeSh7IG1pblZlcnNpb246IFwiMTIuMC4wXCIsIHZlcnNpb246IFwiMTcuMy4xMlwiLCBuZ0ltcG9ydDogaTAsIHR5cGU6IEZvcm1BcnJheU5hbWUsIGRlcHM6IFt7IHRva2VuOiBDb250cm9sQ29udGFpbmVyLCBob3N0OiB0cnVlLCBvcHRpb25hbDogdHJ1ZSwgc2tpcFNlbGY6IHRydWUgfSwgeyB0b2tlbjogTkdfVkFMSURBVE9SUywgb3B0aW9uYWw6IHRydWUsIHNlbGY6IHRydWUgfSwgeyB0b2tlbjogTkdfQVNZTkNfVkFMSURBVE9SUywgb3B0aW9uYWw6IHRydWUsIHNlbGY6IHRydWUgfV0sIHRhcmdldDogaTAuybXJtUZhY3RvcnlUYXJnZXQuRGlyZWN0aXZlIH0pOyB9XG4gICAgc3RhdGljIHsgdGhpcy7JtWRpciA9IGkwLsm1ybVuZ0RlY2xhcmVEaXJlY3RpdmUoeyBtaW5WZXJzaW9uOiBcIjE0LjAuMFwiLCB2ZXJzaW9uOiBcIjE3LjMuMTJcIiwgdHlwZTogRm9ybUFycmF5TmFtZSwgc2VsZWN0b3I6IFwiW2Zvcm1BcnJheU5hbWVdXCIsIGlucHV0czogeyBuYW1lOiBbXCJmb3JtQXJyYXlOYW1lXCIsIFwibmFtZVwiXSB9LCBwcm92aWRlcnM6IFtmb3JtQXJyYXlOYW1lUHJvdmlkZXJdLCB1c2VzSW5oZXJpdGFuY2U6IHRydWUsIG5nSW1wb3J0OiBpMCB9KTsgfVxufVxuaTAuybXJtW5nRGVjbGFyZUNsYXNzTWV0YWRhdGEoeyBtaW5WZXJzaW9uOiBcIjEyLjAuMFwiLCB2ZXJzaW9uOiBcIjE3LjMuMTJcIiwgbmdJbXBvcnQ6IGkwLCB0eXBlOiBGb3JtQXJyYXlOYW1lLCBkZWNvcmF0b3JzOiBbe1xuICAgICAgICAgICAgdHlwZTogRGlyZWN0aXZlLFxuICAgICAgICAgICAgYXJnczogW3sgc2VsZWN0b3I6ICdbZm9ybUFycmF5TmFtZV0nLCBwcm92aWRlcnM6IFtmb3JtQXJyYXlOYW1lUHJvdmlkZXJdIH1dXG4gICAgICAgIH1dLCBjdG9yUGFyYW1ldGVyczogKCkgPT4gW3sgdHlwZTogQ29udHJvbENvbnRhaW5lciwgZGVjb3JhdG9yczogW3tcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogT3B0aW9uYWxcbiAgICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IEhvc3RcbiAgICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFNraXBTZWxmXG4gICAgICAgICAgICAgICAgfV0gfSwgeyB0eXBlOiB1bmRlZmluZWQsIGRlY29yYXRvcnM6IFt7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IE9wdGlvbmFsXG4gICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBTZWxmXG4gICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBJbmplY3QsXG4gICAgICAgICAgICAgICAgICAgIGFyZ3M6IFtOR19WQUxJREFUT1JTXVxuICAgICAgICAgICAgICAgIH1dIH0sIHsgdHlwZTogdW5kZWZpbmVkLCBkZWNvcmF0b3JzOiBbe1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBPcHRpb25hbFxuICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogU2VsZlxuICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogSW5qZWN0LFxuICAgICAgICAgICAgICAgICAgICBhcmdzOiBbTkdfQVNZTkNfVkFMSURBVE9SU11cbiAgICAgICAgICAgICAgICB9XSB9XSwgcHJvcERlY29yYXRvcnM6IHsgbmFtZTogW3tcbiAgICAgICAgICAgICAgICB0eXBlOiBJbnB1dCxcbiAgICAgICAgICAgICAgICBhcmdzOiBbJ2Zvcm1BcnJheU5hbWUnXVxuICAgICAgICAgICAgfV0gfSB9KTtcbmZ1bmN0aW9uIF9oYXNJbnZhbGlkUGFyZW50KHBhcmVudCkge1xuICAgIHJldHVybiAhKHBhcmVudCBpbnN0YW5jZW9mIEZvcm1Hcm91cE5hbWUpICYmICEocGFyZW50IGluc3RhbmNlb2YgRm9ybUdyb3VwRGlyZWN0aXZlKSAmJlxuICAgICAgICAhKHBhcmVudCBpbnN0YW5jZW9mIEZvcm1BcnJheU5hbWUpO1xufVxuXG5jb25zdCBjb250cm9sTmFtZUJpbmRpbmcgPSB7XG4gICAgcHJvdmlkZTogTmdDb250cm9sLFxuICAgIHVzZUV4aXN0aW5nOiBmb3J3YXJkUmVmKCgpID0+IEZvcm1Db250cm9sTmFtZSlcbn07XG4vKipcbiAqIEBkZXNjcmlwdGlvblxuICogU3luY3MgYSBgRm9ybUNvbnRyb2xgIGluIGFuIGV4aXN0aW5nIGBGb3JtR3JvdXBgIHRvIGEgZm9ybSBjb250cm9sXG4gKiBlbGVtZW50IGJ5IG5hbWUuXG4gKlxuICogQHNlZSBbUmVhY3RpdmUgRm9ybXMgR3VpZGVdKGd1aWRlL3JlYWN0aXZlLWZvcm1zKVxuICogQHNlZSB7QGxpbmsgRm9ybUNvbnRyb2x9XG4gKiBAc2VlIHtAbGluayBBYnN0cmFjdENvbnRyb2x9XG4gKlxuICogQHVzYWdlTm90ZXNcbiAqXG4gKiAjIyMgUmVnaXN0ZXIgYEZvcm1Db250cm9sYCB3aXRoaW4gYSBncm91cFxuICpcbiAqIFRoZSBmb2xsb3dpbmcgZXhhbXBsZSBzaG93cyBob3cgdG8gcmVnaXN0ZXIgbXVsdGlwbGUgZm9ybSBjb250cm9scyB3aXRoaW4gYSBmb3JtIGdyb3VwXG4gKiBhbmQgc2V0IHRoZWlyIHZhbHVlLlxuICpcbiAqIHtAZXhhbXBsZSBmb3Jtcy90cy9zaW1wbGVGb3JtR3JvdXAvc2ltcGxlX2Zvcm1fZ3JvdXBfZXhhbXBsZS50cyByZWdpb249J0NvbXBvbmVudCd9XG4gKlxuICogVG8gc2VlIGBmb3JtQ29udHJvbE5hbWVgIGV4YW1wbGVzIHdpdGggZGlmZmVyZW50IGZvcm0gY29udHJvbCB0eXBlcywgc2VlOlxuICpcbiAqICogUmFkaW8gYnV0dG9uczogYFJhZGlvQ29udHJvbFZhbHVlQWNjZXNzb3JgXG4gKiAqIFNlbGVjdHM6IGBTZWxlY3RDb250cm9sVmFsdWVBY2Nlc3NvcmBcbiAqXG4gKiAjIyMgVXNlIHdpdGggbmdNb2RlbCBpcyBkZXByZWNhdGVkXG4gKlxuICogU3VwcG9ydCBmb3IgdXNpbmcgdGhlIGBuZ01vZGVsYCBpbnB1dCBwcm9wZXJ0eSBhbmQgYG5nTW9kZWxDaGFuZ2VgIGV2ZW50IHdpdGggcmVhY3RpdmVcbiAqIGZvcm0gZGlyZWN0aXZlcyBoYXMgYmVlbiBkZXByZWNhdGVkIGluIEFuZ3VsYXIgdjYgYW5kIGlzIHNjaGVkdWxlZCBmb3IgcmVtb3ZhbCBpblxuICogYSBmdXR1cmUgdmVyc2lvbiBvZiBBbmd1bGFyLlxuICpcbiAqIEZvciBkZXRhaWxzLCBzZWUgW0RlcHJlY2F0ZWQgZmVhdHVyZXNdKGd1aWRlL2RlcHJlY2F0aW9ucyNuZ21vZGVsLXdpdGgtcmVhY3RpdmUtZm9ybXMpLlxuICpcbiAqIEBuZ01vZHVsZSBSZWFjdGl2ZUZvcm1zTW9kdWxlXG4gKiBAcHVibGljQXBpXG4gKi9cbmNsYXNzIEZvcm1Db250cm9sTmFtZSBleHRlbmRzIE5nQ29udHJvbCB7XG4gICAgLyoqXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICogVHJpZ2dlcnMgYSB3YXJuaW5nIGluIGRldiBtb2RlIHRoYXQgdGhpcyBpbnB1dCBzaG91bGQgbm90IGJlIHVzZWQgd2l0aCByZWFjdGl2ZSBmb3Jtcy5cbiAgICAgKi9cbiAgICBzZXQgaXNEaXNhYmxlZChpc0Rpc2FibGVkKSB7XG4gICAgICAgIGlmICh0eXBlb2YgbmdEZXZNb2RlID09PSAndW5kZWZpbmVkJyB8fCBuZ0Rldk1vZGUpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihkaXNhYmxlZEF0dHJXYXJuaW5nKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKiBTdGF0aWMgcHJvcGVydHkgdXNlZCB0byB0cmFjayB3aGV0aGVyIGFueSBuZ01vZGVsIHdhcm5pbmdzIGhhdmUgYmVlbiBzZW50IGFjcm9zc1xuICAgICAqIGFsbCBpbnN0YW5jZXMgb2YgRm9ybUNvbnRyb2xOYW1lLiBVc2VkIHRvIHN1cHBvcnQgd2FybmluZyBjb25maWcgb2YgXCJvbmNlXCIuXG4gICAgICpcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBzdGF0aWMgeyB0aGlzLl9uZ01vZGVsV2FybmluZ1NlbnRPbmNlID0gZmFsc2U7IH1cbiAgICBjb25zdHJ1Y3RvcihwYXJlbnQsIHZhbGlkYXRvcnMsIGFzeW5jVmFsaWRhdG9ycywgdmFsdWVBY2Nlc3NvcnMsIF9uZ01vZGVsV2FybmluZ0NvbmZpZykge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLl9uZ01vZGVsV2FybmluZ0NvbmZpZyA9IF9uZ01vZGVsV2FybmluZ0NvbmZpZztcbiAgICAgICAgdGhpcy5fYWRkZWQgPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAgICAgKiBUcmFja3MgdGhlIG5hbWUgb2YgdGhlIGBGb3JtQ29udHJvbGAgYm91bmQgdG8gdGhlIGRpcmVjdGl2ZS4gVGhlIG5hbWUgY29ycmVzcG9uZHNcbiAgICAgICAgICogdG8gYSBrZXkgaW4gdGhlIHBhcmVudCBgRm9ybUdyb3VwYCBvciBgRm9ybUFycmF5YC5cbiAgICAgICAgICogQWNjZXB0cyBhIG5hbWUgYXMgYSBzdHJpbmcgb3IgYSBudW1iZXIuXG4gICAgICAgICAqIFRoZSBuYW1lIGluIHRoZSBmb3JtIG9mIGEgc3RyaW5nIGlzIHVzZWZ1bCBmb3IgaW5kaXZpZHVhbCBmb3JtcyxcbiAgICAgICAgICogd2hpbGUgdGhlIG51bWVyaWNhbCBmb3JtIGFsbG93cyBmb3IgZm9ybSBjb250cm9scyB0byBiZSBib3VuZFxuICAgICAgICAgKiB0byBpbmRpY2VzIHdoZW4gaXRlcmF0aW5nIG92ZXIgY29udHJvbHMgaW4gYSBgRm9ybUFycmF5YC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubmFtZSA9IG51bGw7XG4gICAgICAgIC8qKiBAZGVwcmVjYXRlZCBhcyBvZiB2NiAqL1xuICAgICAgICB0aGlzLnVwZGF0ZSA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAgICAgKiBJbnN0YW5jZSBwcm9wZXJ0eSB1c2VkIHRvIHRyYWNrIHdoZXRoZXIgYW4gbmdNb2RlbCB3YXJuaW5nIGhhcyBiZWVuIHNlbnQgb3V0IGZvciB0aGlzXG4gICAgICAgICAqIHBhcnRpY3VsYXIgRm9ybUNvbnRyb2xOYW1lIGluc3RhbmNlLiBVc2VkIHRvIHN1cHBvcnQgd2FybmluZyBjb25maWcgb2YgXCJhbHdheXNcIi5cbiAgICAgICAgICpcbiAgICAgICAgICogQGludGVybmFsXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9uZ01vZGVsV2FybmluZ1NlbnQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fcGFyZW50ID0gcGFyZW50O1xuICAgICAgICB0aGlzLl9zZXRWYWxpZGF0b3JzKHZhbGlkYXRvcnMpO1xuICAgICAgICB0aGlzLl9zZXRBc3luY1ZhbGlkYXRvcnMoYXN5bmNWYWxpZGF0b3JzKTtcbiAgICAgICAgdGhpcy52YWx1ZUFjY2Vzc29yID0gc2VsZWN0VmFsdWVBY2Nlc3Nvcih0aGlzLCB2YWx1ZUFjY2Vzc29ycyk7XG4gICAgfVxuICAgIC8qKiBAbm9kb2MgKi9cbiAgICBuZ09uQ2hhbmdlcyhjaGFuZ2VzKSB7XG4gICAgICAgIGlmICghdGhpcy5fYWRkZWQpXG4gICAgICAgICAgICB0aGlzLl9zZXRVcENvbnRyb2woKTtcbiAgICAgICAgaWYgKGlzUHJvcGVydHlVcGRhdGVkKGNoYW5nZXMsIHRoaXMudmlld01vZGVsKSkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBuZ0Rldk1vZGUgPT09ICd1bmRlZmluZWQnIHx8IG5nRGV2TW9kZSkge1xuICAgICAgICAgICAgICAgIF9uZ01vZGVsV2FybmluZygnZm9ybUNvbnRyb2xOYW1lJywgRm9ybUNvbnRyb2xOYW1lLCB0aGlzLCB0aGlzLl9uZ01vZGVsV2FybmluZ0NvbmZpZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnZpZXdNb2RlbCA9IHRoaXMubW9kZWw7XG4gICAgICAgICAgICB0aGlzLmZvcm1EaXJlY3RpdmUudXBkYXRlTW9kZWwodGhpcywgdGhpcy5tb2RlbCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqIEBub2RvYyAqL1xuICAgIG5nT25EZXN0cm95KCkge1xuICAgICAgICBpZiAodGhpcy5mb3JtRGlyZWN0aXZlKSB7XG4gICAgICAgICAgICB0aGlzLmZvcm1EaXJlY3RpdmUucmVtb3ZlQ29udHJvbCh0aGlzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKiBTZXRzIHRoZSBuZXcgdmFsdWUgZm9yIHRoZSB2aWV3IG1vZGVsIGFuZCBlbWl0cyBhbiBgbmdNb2RlbENoYW5nZWAgZXZlbnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbmV3VmFsdWUgVGhlIG5ldyB2YWx1ZSBmb3IgdGhlIHZpZXcgbW9kZWwuXG4gICAgICovXG4gICAgdmlld1RvTW9kZWxVcGRhdGUobmV3VmFsdWUpIHtcbiAgICAgICAgdGhpcy52aWV3TW9kZWwgPSBuZXdWYWx1ZTtcbiAgICAgICAgdGhpcy51cGRhdGUuZW1pdChuZXdWYWx1ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqIFJldHVybnMgYW4gYXJyYXkgdGhhdCByZXByZXNlbnRzIHRoZSBwYXRoIGZyb20gdGhlIHRvcC1sZXZlbCBmb3JtIHRvIHRoaXMgY29udHJvbC5cbiAgICAgKiBFYWNoIGluZGV4IGlzIHRoZSBzdHJpbmcgbmFtZSBvZiB0aGUgY29udHJvbCBvbiB0aGF0IGxldmVsLlxuICAgICAqL1xuICAgIGdldCBwYXRoKCkge1xuICAgICAgICByZXR1cm4gY29udHJvbFBhdGgodGhpcy5uYW1lID09IG51bGwgPyB0aGlzLm5hbWUgOiB0aGlzLm5hbWUudG9TdHJpbmcoKSwgdGhpcy5fcGFyZW50KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICogVGhlIHRvcC1sZXZlbCBkaXJlY3RpdmUgZm9yIHRoaXMgZ3JvdXAgaWYgcHJlc2VudCwgb3RoZXJ3aXNlIG51bGwuXG4gICAgICovXG4gICAgZ2V0IGZvcm1EaXJlY3RpdmUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wYXJlbnQgPyB0aGlzLl9wYXJlbnQuZm9ybURpcmVjdGl2ZSA6IG51bGw7XG4gICAgfVxuICAgIF9jaGVja1BhcmVudFR5cGUoKSB7XG4gICAgICAgIGlmICh0eXBlb2YgbmdEZXZNb2RlID09PSAndW5kZWZpbmVkJyB8fCBuZ0Rldk1vZGUpIHtcbiAgICAgICAgICAgIGlmICghKHRoaXMuX3BhcmVudCBpbnN0YW5jZW9mIEZvcm1Hcm91cE5hbWUpICYmXG4gICAgICAgICAgICAgICAgdGhpcy5fcGFyZW50IGluc3RhbmNlb2YgQWJzdHJhY3RGb3JtR3JvdXBEaXJlY3RpdmUpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZ01vZGVsR3JvdXBFeGNlcHRpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCEodGhpcy5fcGFyZW50IGluc3RhbmNlb2YgRm9ybUdyb3VwTmFtZSkgJiZcbiAgICAgICAgICAgICAgICAhKHRoaXMuX3BhcmVudCBpbnN0YW5jZW9mIEZvcm1Hcm91cERpcmVjdGl2ZSkgJiZcbiAgICAgICAgICAgICAgICAhKHRoaXMuX3BhcmVudCBpbnN0YW5jZW9mIEZvcm1BcnJheU5hbWUpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgY29udHJvbFBhcmVudEV4Y2VwdGlvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIF9zZXRVcENvbnRyb2woKSB7XG4gICAgICAgIHRoaXMuX2NoZWNrUGFyZW50VHlwZSgpO1xuICAgICAgICB0aGlzLmNvbnRyb2wgPSB0aGlzLmZvcm1EaXJlY3RpdmUuYWRkQ29udHJvbCh0aGlzKTtcbiAgICAgICAgdGhpcy5fYWRkZWQgPSB0cnVlO1xuICAgIH1cbiAgICBzdGF0aWMgeyB0aGlzLsm1ZmFjID0gaTAuybXJtW5nRGVjbGFyZUZhY3RvcnkoeyBtaW5WZXJzaW9uOiBcIjEyLjAuMFwiLCB2ZXJzaW9uOiBcIjE3LjMuMTJcIiwgbmdJbXBvcnQ6IGkwLCB0eXBlOiBGb3JtQ29udHJvbE5hbWUsIGRlcHM6IFt7IHRva2VuOiBDb250cm9sQ29udGFpbmVyLCBob3N0OiB0cnVlLCBvcHRpb25hbDogdHJ1ZSwgc2tpcFNlbGY6IHRydWUgfSwgeyB0b2tlbjogTkdfVkFMSURBVE9SUywgb3B0aW9uYWw6IHRydWUsIHNlbGY6IHRydWUgfSwgeyB0b2tlbjogTkdfQVNZTkNfVkFMSURBVE9SUywgb3B0aW9uYWw6IHRydWUsIHNlbGY6IHRydWUgfSwgeyB0b2tlbjogTkdfVkFMVUVfQUNDRVNTT1IsIG9wdGlvbmFsOiB0cnVlLCBzZWxmOiB0cnVlIH0sIHsgdG9rZW46IE5HX01PREVMX1dJVEhfRk9STV9DT05UUk9MX1dBUk5JTkcsIG9wdGlvbmFsOiB0cnVlIH1dLCB0YXJnZXQ6IGkwLsm1ybVGYWN0b3J5VGFyZ2V0LkRpcmVjdGl2ZSB9KTsgfVxuICAgIHN0YXRpYyB7IHRoaXMuybVkaXIgPSBpMC7Jtcm1bmdEZWNsYXJlRGlyZWN0aXZlKHsgbWluVmVyc2lvbjogXCIxNC4wLjBcIiwgdmVyc2lvbjogXCIxNy4zLjEyXCIsIHR5cGU6IEZvcm1Db250cm9sTmFtZSwgc2VsZWN0b3I6IFwiW2Zvcm1Db250cm9sTmFtZV1cIiwgaW5wdXRzOiB7IG5hbWU6IFtcImZvcm1Db250cm9sTmFtZVwiLCBcIm5hbWVcIl0sIGlzRGlzYWJsZWQ6IFtcImRpc2FibGVkXCIsIFwiaXNEaXNhYmxlZFwiXSwgbW9kZWw6IFtcIm5nTW9kZWxcIiwgXCJtb2RlbFwiXSB9LCBvdXRwdXRzOiB7IHVwZGF0ZTogXCJuZ01vZGVsQ2hhbmdlXCIgfSwgcHJvdmlkZXJzOiBbY29udHJvbE5hbWVCaW5kaW5nXSwgdXNlc0luaGVyaXRhbmNlOiB0cnVlLCB1c2VzT25DaGFuZ2VzOiB0cnVlLCBuZ0ltcG9ydDogaTAgfSk7IH1cbn1cbmkwLsm1ybVuZ0RlY2xhcmVDbGFzc01ldGFkYXRhKHsgbWluVmVyc2lvbjogXCIxMi4wLjBcIiwgdmVyc2lvbjogXCIxNy4zLjEyXCIsIG5nSW1wb3J0OiBpMCwgdHlwZTogRm9ybUNvbnRyb2xOYW1lLCBkZWNvcmF0b3JzOiBbe1xuICAgICAgICAgICAgdHlwZTogRGlyZWN0aXZlLFxuICAgICAgICAgICAgYXJnczogW3sgc2VsZWN0b3I6ICdbZm9ybUNvbnRyb2xOYW1lXScsIHByb3ZpZGVyczogW2NvbnRyb2xOYW1lQmluZGluZ10gfV1cbiAgICAgICAgfV0sIGN0b3JQYXJhbWV0ZXJzOiAoKSA9PiBbeyB0eXBlOiBDb250cm9sQ29udGFpbmVyLCBkZWNvcmF0b3JzOiBbe1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBPcHRpb25hbFxuICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogSG9zdFxuICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogU2tpcFNlbGZcbiAgICAgICAgICAgICAgICB9XSB9LCB7IHR5cGU6IHVuZGVmaW5lZCwgZGVjb3JhdG9yczogW3tcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogT3B0aW9uYWxcbiAgICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFNlbGZcbiAgICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IEluamVjdCxcbiAgICAgICAgICAgICAgICAgICAgYXJnczogW05HX1ZBTElEQVRPUlNdXG4gICAgICAgICAgICAgICAgfV0gfSwgeyB0eXBlOiB1bmRlZmluZWQsIGRlY29yYXRvcnM6IFt7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IE9wdGlvbmFsXG4gICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBTZWxmXG4gICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBJbmplY3QsXG4gICAgICAgICAgICAgICAgICAgIGFyZ3M6IFtOR19BU1lOQ19WQUxJREFUT1JTXVxuICAgICAgICAgICAgICAgIH1dIH0sIHsgdHlwZTogdW5kZWZpbmVkLCBkZWNvcmF0b3JzOiBbe1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBPcHRpb25hbFxuICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogU2VsZlxuICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogSW5qZWN0LFxuICAgICAgICAgICAgICAgICAgICBhcmdzOiBbTkdfVkFMVUVfQUNDRVNTT1JdXG4gICAgICAgICAgICAgICAgfV0gfSwgeyB0eXBlOiB1bmRlZmluZWQsIGRlY29yYXRvcnM6IFt7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IE9wdGlvbmFsXG4gICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBJbmplY3QsXG4gICAgICAgICAgICAgICAgICAgIGFyZ3M6IFtOR19NT0RFTF9XSVRIX0ZPUk1fQ09OVFJPTF9XQVJOSU5HXVxuICAgICAgICAgICAgICAgIH1dIH1dLCBwcm9wRGVjb3JhdG9yczogeyBuYW1lOiBbe1xuICAgICAgICAgICAgICAgIHR5cGU6IElucHV0LFxuICAgICAgICAgICAgICAgIGFyZ3M6IFsnZm9ybUNvbnRyb2xOYW1lJ11cbiAgICAgICAgICAgIH1dLCBpc0Rpc2FibGVkOiBbe1xuICAgICAgICAgICAgICAgIHR5cGU6IElucHV0LFxuICAgICAgICAgICAgICAgIGFyZ3M6IFsnZGlzYWJsZWQnXVxuICAgICAgICAgICAgfV0sIG1vZGVsOiBbe1xuICAgICAgICAgICAgICAgIHR5cGU6IElucHV0LFxuICAgICAgICAgICAgICAgIGFyZ3M6IFsnbmdNb2RlbCddXG4gICAgICAgICAgICB9XSwgdXBkYXRlOiBbe1xuICAgICAgICAgICAgICAgIHR5cGU6IE91dHB1dCxcbiAgICAgICAgICAgICAgICBhcmdzOiBbJ25nTW9kZWxDaGFuZ2UnXVxuICAgICAgICAgICAgfV0gfSB9KTtcblxuY29uc3QgU0VMRUNUX1ZBTFVFX0FDQ0VTU09SID0ge1xuICAgIHByb3ZpZGU6IE5HX1ZBTFVFX0FDQ0VTU09SLFxuICAgIHVzZUV4aXN0aW5nOiBmb3J3YXJkUmVmKCgpID0+IFNlbGVjdENvbnRyb2xWYWx1ZUFjY2Vzc29yKSxcbiAgICBtdWx0aTogdHJ1ZVxufTtcbmZ1bmN0aW9uIF9idWlsZFZhbHVlU3RyaW5nJDEoaWQsIHZhbHVlKSB7XG4gICAgaWYgKGlkID09IG51bGwpXG4gICAgICAgIHJldHVybiBgJHt2YWx1ZX1gO1xuICAgIGlmICh2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnKVxuICAgICAgICB2YWx1ZSA9ICdPYmplY3QnO1xuICAgIHJldHVybiBgJHtpZH06ICR7dmFsdWV9YC5zbGljZSgwLCA1MCk7XG59XG5mdW5jdGlvbiBfZXh0cmFjdElkJDEodmFsdWVTdHJpbmcpIHtcbiAgICByZXR1cm4gdmFsdWVTdHJpbmcuc3BsaXQoJzonKVswXTtcbn1cbi8qKlxuICogQGRlc2NyaXB0aW9uXG4gKiBUaGUgYENvbnRyb2xWYWx1ZUFjY2Vzc29yYCBmb3Igd3JpdGluZyBzZWxlY3QgY29udHJvbCB2YWx1ZXMgYW5kIGxpc3RlbmluZyB0byBzZWxlY3QgY29udHJvbFxuICogY2hhbmdlcy4gVGhlIHZhbHVlIGFjY2Vzc29yIGlzIHVzZWQgYnkgdGhlIGBGb3JtQ29udHJvbERpcmVjdGl2ZWAsIGBGb3JtQ29udHJvbE5hbWVgLCBhbmRcbiAqIGBOZ01vZGVsYCBkaXJlY3RpdmVzLlxuICpcbiAqIEB1c2FnZU5vdGVzXG4gKlxuICogIyMjIFVzaW5nIHNlbGVjdCBjb250cm9scyBpbiBhIHJlYWN0aXZlIGZvcm1cbiAqXG4gKiBUaGUgZm9sbG93aW5nIGV4YW1wbGVzIHNob3cgaG93IHRvIHVzZSBhIHNlbGVjdCBjb250cm9sIGluIGEgcmVhY3RpdmUgZm9ybS5cbiAqXG4gKiB7QGV4YW1wbGUgZm9ybXMvdHMvcmVhY3RpdmVTZWxlY3RDb250cm9sL3JlYWN0aXZlX3NlbGVjdF9jb250cm9sX2V4YW1wbGUudHMgcmVnaW9uPSdDb21wb25lbnQnfVxuICpcbiAqICMjIyBVc2luZyBzZWxlY3QgY29udHJvbHMgaW4gYSB0ZW1wbGF0ZS1kcml2ZW4gZm9ybVxuICpcbiAqIFRvIHVzZSBhIHNlbGVjdCBpbiBhIHRlbXBsYXRlLWRyaXZlbiBmb3JtLCBzaW1wbHkgYWRkIGFuIGBuZ01vZGVsYCBhbmQgYSBgbmFtZWBcbiAqIGF0dHJpYnV0ZSB0byB0aGUgbWFpbiBgPHNlbGVjdD5gIHRhZy5cbiAqXG4gKiB7QGV4YW1wbGUgZm9ybXMvdHMvc2VsZWN0Q29udHJvbC9zZWxlY3RfY29udHJvbF9leGFtcGxlLnRzIHJlZ2lvbj0nQ29tcG9uZW50J31cbiAqXG4gKiAjIyMgQ3VzdG9taXppbmcgb3B0aW9uIHNlbGVjdGlvblxuICpcbiAqIEFuZ3VsYXIgdXNlcyBvYmplY3QgaWRlbnRpdHkgdG8gc2VsZWN0IG9wdGlvbi4gSXQncyBwb3NzaWJsZSBmb3IgdGhlIGlkZW50aXRpZXMgb2YgaXRlbXNcbiAqIHRvIGNoYW5nZSB3aGlsZSB0aGUgZGF0YSBkb2VzIG5vdC4gVGhpcyBjYW4gaGFwcGVuLCBmb3IgZXhhbXBsZSwgaWYgdGhlIGl0ZW1zIGFyZSBwcm9kdWNlZFxuICogZnJvbSBhbiBSUEMgdG8gdGhlIHNlcnZlciwgYW5kIHRoYXQgUlBDIGlzIHJlLXJ1bi4gRXZlbiBpZiB0aGUgZGF0YSBoYXNuJ3QgY2hhbmdlZCwgdGhlXG4gKiBzZWNvbmQgcmVzcG9uc2Ugd2lsbCBwcm9kdWNlIG9iamVjdHMgd2l0aCBkaWZmZXJlbnQgaWRlbnRpdGllcy5cbiAqXG4gKiBUbyBjdXN0b21pemUgdGhlIGRlZmF1bHQgb3B0aW9uIGNvbXBhcmlzb24gYWxnb3JpdGhtLCBgPHNlbGVjdD5gIHN1cHBvcnRzIGBjb21wYXJlV2l0aGAgaW5wdXQuXG4gKiBgY29tcGFyZVdpdGhgIHRha2VzIGEgKipmdW5jdGlvbioqIHdoaWNoIGhhcyB0d28gYXJndW1lbnRzOiBgb3B0aW9uMWAgYW5kIGBvcHRpb24yYC5cbiAqIElmIGBjb21wYXJlV2l0aGAgaXMgZ2l2ZW4sIEFuZ3VsYXIgc2VsZWN0cyBvcHRpb24gYnkgdGhlIHJldHVybiB2YWx1ZSBvZiB0aGUgZnVuY3Rpb24uXG4gKlxuICogYGBgdHNcbiAqIGNvbnN0IHNlbGVjdGVkQ291bnRyaWVzQ29udHJvbCA9IG5ldyBGb3JtQ29udHJvbCgpO1xuICogYGBgXG4gKlxuICogYGBgXG4gKiA8c2VsZWN0IFtjb21wYXJlV2l0aF09XCJjb21wYXJlRm5cIiAgW2Zvcm1Db250cm9sXT1cInNlbGVjdGVkQ291bnRyaWVzQ29udHJvbFwiPlxuICogICAgIDxvcHRpb24gKm5nRm9yPVwibGV0IGNvdW50cnkgb2YgY291bnRyaWVzXCIgW25nVmFsdWVdPVwiY291bnRyeVwiPlxuICogICAgICAgICB7e2NvdW50cnkubmFtZX19XG4gKiAgICAgPC9vcHRpb24+XG4gKiA8L3NlbGVjdD5cbiAqXG4gKiBjb21wYXJlRm4oYzE6IENvdW50cnksIGMyOiBDb3VudHJ5KTogYm9vbGVhbiB7XG4gKiAgICAgcmV0dXJuIGMxICYmIGMyID8gYzEuaWQgPT09IGMyLmlkIDogYzEgPT09IGMyO1xuICogfVxuICogYGBgXG4gKlxuICogKipOb3RlOioqIFdlIGxpc3RlbiB0byB0aGUgJ2NoYW5nZScgZXZlbnQgYmVjYXVzZSAnaW5wdXQnIGV2ZW50cyBhcmVuJ3QgZmlyZWRcbiAqIGZvciBzZWxlY3RzIGluIElFLCBzZWU6XG4gKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvSFRNTEVsZW1lbnQvaW5wdXRfZXZlbnQjYnJvd3Nlcl9jb21wYXRpYmlsaXR5XG4gKlxuICogQG5nTW9kdWxlIFJlYWN0aXZlRm9ybXNNb2R1bGVcbiAqIEBuZ01vZHVsZSBGb3Jtc01vZHVsZVxuICogQHB1YmxpY0FwaVxuICovXG5jbGFzcyBTZWxlY3RDb250cm9sVmFsdWVBY2Nlc3NvciBleHRlbmRzIEJ1aWx0SW5Db250cm9sVmFsdWVBY2Nlc3NvciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgdGhpcy5fb3B0aW9uTWFwID0gbmV3IE1hcCgpO1xuICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgIHRoaXMuX2lkQ291bnRlciA9IDA7XG4gICAgICAgIHRoaXMuX2NvbXBhcmVXaXRoID0gT2JqZWN0LmlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKiBUcmFja3MgdGhlIG9wdGlvbiBjb21wYXJpc29uIGFsZ29yaXRobSBmb3IgdHJhY2tpbmcgaWRlbnRpdGllcyB3aGVuXG4gICAgICogY2hlY2tpbmcgZm9yIGNoYW5nZXMuXG4gICAgICovXG4gICAgc2V0IGNvbXBhcmVXaXRoKGZuKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicgJiYgKHR5cGVvZiBuZ0Rldk1vZGUgPT09ICd1bmRlZmluZWQnIHx8IG5nRGV2TW9kZSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyDJtVJ1bnRpbWVFcnJvcigxMjAxIC8qIFJ1bnRpbWVFcnJvckNvZGUuQ09NUEFSRVdJVEhfTk9UX0FfRk4gKi8sIGBjb21wYXJlV2l0aCBtdXN0IGJlIGEgZnVuY3Rpb24sIGJ1dCByZWNlaXZlZCAke0pTT04uc3RyaW5naWZ5KGZuKX1gKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9jb21wYXJlV2l0aCA9IGZuO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBcInZhbHVlXCIgcHJvcGVydHkgb24gdGhlIHNlbGVjdCBlbGVtZW50LlxuICAgICAqIEBub2RvY1xuICAgICAqL1xuICAgIHdyaXRlVmFsdWUodmFsdWUpIHtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICBjb25zdCBpZCA9IHRoaXMuX2dldE9wdGlvbklkKHZhbHVlKTtcbiAgICAgICAgY29uc3QgdmFsdWVTdHJpbmcgPSBfYnVpbGRWYWx1ZVN0cmluZyQxKGlkLCB2YWx1ZSk7XG4gICAgICAgIHRoaXMuc2V0UHJvcGVydHkoJ3ZhbHVlJywgdmFsdWVTdHJpbmcpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWdpc3RlcnMgYSBmdW5jdGlvbiBjYWxsZWQgd2hlbiB0aGUgY29udHJvbCB2YWx1ZSBjaGFuZ2VzLlxuICAgICAqIEBub2RvY1xuICAgICAqL1xuICAgIHJlZ2lzdGVyT25DaGFuZ2UoZm4pIHtcbiAgICAgICAgdGhpcy5vbkNoYW5nZSA9ICh2YWx1ZVN0cmluZykgPT4ge1xuICAgICAgICAgICAgdGhpcy52YWx1ZSA9IHRoaXMuX2dldE9wdGlvblZhbHVlKHZhbHVlU3RyaW5nKTtcbiAgICAgICAgICAgIGZuKHRoaXMudmFsdWUpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICAvKiogQGludGVybmFsICovXG4gICAgX3JlZ2lzdGVyT3B0aW9uKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMuX2lkQ291bnRlcisrKS50b1N0cmluZygpO1xuICAgIH1cbiAgICAvKiogQGludGVybmFsICovXG4gICAgX2dldE9wdGlvbklkKHZhbHVlKSB7XG4gICAgICAgIGZvciAoY29uc3QgaWQgb2YgdGhpcy5fb3B0aW9uTWFwLmtleXMoKSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2NvbXBhcmVXaXRoKHRoaXMuX29wdGlvbk1hcC5nZXQoaWQpLCB2YWx1ZSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGlkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICAvKiogQGludGVybmFsICovXG4gICAgX2dldE9wdGlvblZhbHVlKHZhbHVlU3RyaW5nKSB7XG4gICAgICAgIGNvbnN0IGlkID0gX2V4dHJhY3RJZCQxKHZhbHVlU3RyaW5nKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX29wdGlvbk1hcC5oYXMoaWQpID8gdGhpcy5fb3B0aW9uTWFwLmdldChpZCkgOiB2YWx1ZVN0cmluZztcbiAgICB9XG4gICAgc3RhdGljIHsgdGhpcy7JtWZhYyA9IGkwLsm1ybVuZ0RlY2xhcmVGYWN0b3J5KHsgbWluVmVyc2lvbjogXCIxMi4wLjBcIiwgdmVyc2lvbjogXCIxNy4zLjEyXCIsIG5nSW1wb3J0OiBpMCwgdHlwZTogU2VsZWN0Q29udHJvbFZhbHVlQWNjZXNzb3IsIGRlcHM6IG51bGwsIHRhcmdldDogaTAuybXJtUZhY3RvcnlUYXJnZXQuRGlyZWN0aXZlIH0pOyB9XG4gICAgc3RhdGljIHsgdGhpcy7JtWRpciA9IGkwLsm1ybVuZ0RlY2xhcmVEaXJlY3RpdmUoeyBtaW5WZXJzaW9uOiBcIjE0LjAuMFwiLCB2ZXJzaW9uOiBcIjE3LjMuMTJcIiwgdHlwZTogU2VsZWN0Q29udHJvbFZhbHVlQWNjZXNzb3IsIHNlbGVjdG9yOiBcInNlbGVjdDpub3QoW211bHRpcGxlXSlbZm9ybUNvbnRyb2xOYW1lXSxzZWxlY3Q6bm90KFttdWx0aXBsZV0pW2Zvcm1Db250cm9sXSxzZWxlY3Q6bm90KFttdWx0aXBsZV0pW25nTW9kZWxdXCIsIGlucHV0czogeyBjb21wYXJlV2l0aDogXCJjb21wYXJlV2l0aFwiIH0sIGhvc3Q6IHsgbGlzdGVuZXJzOiB7IFwiY2hhbmdlXCI6IFwib25DaGFuZ2UoJGV2ZW50LnRhcmdldC52YWx1ZSlcIiwgXCJibHVyXCI6IFwib25Ub3VjaGVkKClcIiB9IH0sIHByb3ZpZGVyczogW1NFTEVDVF9WQUxVRV9BQ0NFU1NPUl0sIHVzZXNJbmhlcml0YW5jZTogdHJ1ZSwgbmdJbXBvcnQ6IGkwIH0pOyB9XG59XG5pMC7Jtcm1bmdEZWNsYXJlQ2xhc3NNZXRhZGF0YSh7IG1pblZlcnNpb246IFwiMTIuMC4wXCIsIHZlcnNpb246IFwiMTcuMy4xMlwiLCBuZ0ltcG9ydDogaTAsIHR5cGU6IFNlbGVjdENvbnRyb2xWYWx1ZUFjY2Vzc29yLCBkZWNvcmF0b3JzOiBbe1xuICAgICAgICAgICAgdHlwZTogRGlyZWN0aXZlLFxuICAgICAgICAgICAgYXJnczogW3tcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdzZWxlY3Q6bm90KFttdWx0aXBsZV0pW2Zvcm1Db250cm9sTmFtZV0sc2VsZWN0Om5vdChbbXVsdGlwbGVdKVtmb3JtQ29udHJvbF0sc2VsZWN0Om5vdChbbXVsdGlwbGVdKVtuZ01vZGVsXScsXG4gICAgICAgICAgICAgICAgICAgIGhvc3Q6IHsgJyhjaGFuZ2UpJzogJ29uQ2hhbmdlKCRldmVudC50YXJnZXQudmFsdWUpJywgJyhibHVyKSc6ICdvblRvdWNoZWQoKScgfSxcbiAgICAgICAgICAgICAgICAgICAgcHJvdmlkZXJzOiBbU0VMRUNUX1ZBTFVFX0FDQ0VTU09SXVxuICAgICAgICAgICAgICAgIH1dXG4gICAgICAgIH1dLCBwcm9wRGVjb3JhdG9yczogeyBjb21wYXJlV2l0aDogW3tcbiAgICAgICAgICAgICAgICB0eXBlOiBJbnB1dFxuICAgICAgICAgICAgfV0gfSB9KTtcbi8qKlxuICogQGRlc2NyaXB0aW9uXG4gKiBNYXJrcyBgPG9wdGlvbj5gIGFzIGR5bmFtaWMsIHNvIEFuZ3VsYXIgY2FuIGJlIG5vdGlmaWVkIHdoZW4gb3B0aW9ucyBjaGFuZ2UuXG4gKlxuICogQHNlZSB7QGxpbmsgU2VsZWN0Q29udHJvbFZhbHVlQWNjZXNzb3J9XG4gKlxuICogQG5nTW9kdWxlIFJlYWN0aXZlRm9ybXNNb2R1bGVcbiAqIEBuZ01vZHVsZSBGb3Jtc01vZHVsZVxuICogQHB1YmxpY0FwaVxuICovXG5jbGFzcyBOZ1NlbGVjdE9wdGlvbiB7XG4gICAgY29uc3RydWN0b3IoX2VsZW1lbnQsIF9yZW5kZXJlciwgX3NlbGVjdCkge1xuICAgICAgICB0aGlzLl9lbGVtZW50ID0gX2VsZW1lbnQ7XG4gICAgICAgIHRoaXMuX3JlbmRlcmVyID0gX3JlbmRlcmVyO1xuICAgICAgICB0aGlzLl9zZWxlY3QgPSBfc2VsZWN0O1xuICAgICAgICBpZiAodGhpcy5fc2VsZWN0KVxuICAgICAgICAgICAgdGhpcy5pZCA9IHRoaXMuX3NlbGVjdC5fcmVnaXN0ZXJPcHRpb24oKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICogVHJhY2tzIHRoZSB2YWx1ZSBib3VuZCB0byB0aGUgb3B0aW9uIGVsZW1lbnQuIFVubGlrZSB0aGUgdmFsdWUgYmluZGluZyxcbiAgICAgKiBuZ1ZhbHVlIHN1cHBvcnRzIGJpbmRpbmcgdG8gb2JqZWN0cy5cbiAgICAgKi9cbiAgICBzZXQgbmdWYWx1ZSh2YWx1ZSkge1xuICAgICAgICBpZiAodGhpcy5fc2VsZWN0ID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRoaXMuX3NlbGVjdC5fb3B0aW9uTWFwLnNldCh0aGlzLmlkLCB2YWx1ZSk7XG4gICAgICAgIHRoaXMuX3NldEVsZW1lbnRWYWx1ZShfYnVpbGRWYWx1ZVN0cmluZyQxKHRoaXMuaWQsIHZhbHVlKSk7XG4gICAgICAgIHRoaXMuX3NlbGVjdC53cml0ZVZhbHVlKHRoaXMuX3NlbGVjdC52YWx1ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqIFRyYWNrcyBzaW1wbGUgc3RyaW5nIHZhbHVlcyBib3VuZCB0byB0aGUgb3B0aW9uIGVsZW1lbnQuXG4gICAgICogRm9yIG9iamVjdHMsIHVzZSB0aGUgYG5nVmFsdWVgIGlucHV0IGJpbmRpbmcuXG4gICAgICovXG4gICAgc2V0IHZhbHVlKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuX3NldEVsZW1lbnRWYWx1ZSh2YWx1ZSk7XG4gICAgICAgIGlmICh0aGlzLl9zZWxlY3QpXG4gICAgICAgICAgICB0aGlzLl9zZWxlY3Qud3JpdGVWYWx1ZSh0aGlzLl9zZWxlY3QudmFsdWUpO1xuICAgIH1cbiAgICAvKiogQGludGVybmFsICovXG4gICAgX3NldEVsZW1lbnRWYWx1ZSh2YWx1ZSkge1xuICAgICAgICB0aGlzLl9yZW5kZXJlci5zZXRQcm9wZXJ0eSh0aGlzLl9lbGVtZW50Lm5hdGl2ZUVsZW1lbnQsICd2YWx1ZScsIHZhbHVlKTtcbiAgICB9XG4gICAgLyoqIEBub2RvYyAqL1xuICAgIG5nT25EZXN0cm95KCkge1xuICAgICAgICBpZiAodGhpcy5fc2VsZWN0KSB7XG4gICAgICAgICAgICB0aGlzLl9zZWxlY3QuX29wdGlvbk1hcC5kZWxldGUodGhpcy5pZCk7XG4gICAgICAgICAgICB0aGlzLl9zZWxlY3Qud3JpdGVWYWx1ZSh0aGlzLl9zZWxlY3QudmFsdWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHN0YXRpYyB7IHRoaXMuybVmYWMgPSBpMC7Jtcm1bmdEZWNsYXJlRmFjdG9yeSh7IG1pblZlcnNpb246IFwiMTIuMC4wXCIsIHZlcnNpb246IFwiMTcuMy4xMlwiLCBuZ0ltcG9ydDogaTAsIHR5cGU6IE5nU2VsZWN0T3B0aW9uLCBkZXBzOiBbeyB0b2tlbjogaTAuRWxlbWVudFJlZiB9LCB7IHRva2VuOiBpMC5SZW5kZXJlcjIgfSwgeyB0b2tlbjogU2VsZWN0Q29udHJvbFZhbHVlQWNjZXNzb3IsIGhvc3Q6IHRydWUsIG9wdGlvbmFsOiB0cnVlIH1dLCB0YXJnZXQ6IGkwLsm1ybVGYWN0b3J5VGFyZ2V0LkRpcmVjdGl2ZSB9KTsgfVxuICAgIHN0YXRpYyB7IHRoaXMuybVkaXIgPSBpMC7Jtcm1bmdEZWNsYXJlRGlyZWN0aXZlKHsgbWluVmVyc2lvbjogXCIxNC4wLjBcIiwgdmVyc2lvbjogXCIxNy4zLjEyXCIsIHR5cGU6IE5nU2VsZWN0T3B0aW9uLCBzZWxlY3RvcjogXCJvcHRpb25cIiwgaW5wdXRzOiB7IG5nVmFsdWU6IFwibmdWYWx1ZVwiLCB2YWx1ZTogXCJ2YWx1ZVwiIH0sIG5nSW1wb3J0OiBpMCB9KTsgfVxufVxuaTAuybXJtW5nRGVjbGFyZUNsYXNzTWV0YWRhdGEoeyBtaW5WZXJzaW9uOiBcIjEyLjAuMFwiLCB2ZXJzaW9uOiBcIjE3LjMuMTJcIiwgbmdJbXBvcnQ6IGkwLCB0eXBlOiBOZ1NlbGVjdE9wdGlvbiwgZGVjb3JhdG9yczogW3tcbiAgICAgICAgICAgIHR5cGU6IERpcmVjdGl2ZSxcbiAgICAgICAgICAgIGFyZ3M6IFt7IHNlbGVjdG9yOiAnb3B0aW9uJyB9XVxuICAgICAgICB9XSwgY3RvclBhcmFtZXRlcnM6ICgpID0+IFt7IHR5cGU6IGkwLkVsZW1lbnRSZWYgfSwgeyB0eXBlOiBpMC5SZW5kZXJlcjIgfSwgeyB0eXBlOiBTZWxlY3RDb250cm9sVmFsdWVBY2Nlc3NvciwgZGVjb3JhdG9yczogW3tcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogT3B0aW9uYWxcbiAgICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IEhvc3RcbiAgICAgICAgICAgICAgICB9XSB9XSwgcHJvcERlY29yYXRvcnM6IHsgbmdWYWx1ZTogW3tcbiAgICAgICAgICAgICAgICB0eXBlOiBJbnB1dCxcbiAgICAgICAgICAgICAgICBhcmdzOiBbJ25nVmFsdWUnXVxuICAgICAgICAgICAgfV0sIHZhbHVlOiBbe1xuICAgICAgICAgICAgICAgIHR5cGU6IElucHV0LFxuICAgICAgICAgICAgICAgIGFyZ3M6IFsndmFsdWUnXVxuICAgICAgICAgICAgfV0gfSB9KTtcblxuY29uc3QgU0VMRUNUX01VTFRJUExFX1ZBTFVFX0FDQ0VTU09SID0ge1xuICAgIHByb3ZpZGU6IE5HX1ZBTFVFX0FDQ0VTU09SLFxuICAgIHVzZUV4aXN0aW5nOiBmb3J3YXJkUmVmKCgpID0+IFNlbGVjdE11bHRpcGxlQ29udHJvbFZhbHVlQWNjZXNzb3IpLFxuICAgIG11bHRpOiB0cnVlXG59O1xuZnVuY3Rpb24gX2J1aWxkVmFsdWVTdHJpbmcoaWQsIHZhbHVlKSB7XG4gICAgaWYgKGlkID09IG51bGwpXG4gICAgICAgIHJldHVybiBgJHt2YWx1ZX1gO1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKVxuICAgICAgICB2YWx1ZSA9IGAnJHt2YWx1ZX0nYDtcbiAgICBpZiAodmFsdWUgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JylcbiAgICAgICAgdmFsdWUgPSAnT2JqZWN0JztcbiAgICByZXR1cm4gYCR7aWR9OiAke3ZhbHVlfWAuc2xpY2UoMCwgNTApO1xufVxuZnVuY3Rpb24gX2V4dHJhY3RJZCh2YWx1ZVN0cmluZykge1xuICAgIHJldHVybiB2YWx1ZVN0cmluZy5zcGxpdCgnOicpWzBdO1xufVxuLyoqIE1vY2sgaW50ZXJmYWNlIGZvciBIVE1MQ29sbGVjdGlvbiAqL1xuY2xhc3MgSFRNTENvbGxlY3Rpb24ge1xufVxuLyoqXG4gKiBAZGVzY3JpcHRpb25cbiAqIFRoZSBgQ29udHJvbFZhbHVlQWNjZXNzb3JgIGZvciB3cml0aW5nIG11bHRpLXNlbGVjdCBjb250cm9sIHZhbHVlcyBhbmQgbGlzdGVuaW5nIHRvIG11bHRpLXNlbGVjdFxuICogY29udHJvbCBjaGFuZ2VzLiBUaGUgdmFsdWUgYWNjZXNzb3IgaXMgdXNlZCBieSB0aGUgYEZvcm1Db250cm9sRGlyZWN0aXZlYCwgYEZvcm1Db250cm9sTmFtZWAsIGFuZFxuICogYE5nTW9kZWxgIGRpcmVjdGl2ZXMuXG4gKlxuICogQHNlZSB7QGxpbmsgU2VsZWN0Q29udHJvbFZhbHVlQWNjZXNzb3J9XG4gKlxuICogQHVzYWdlTm90ZXNcbiAqXG4gKiAjIyMgVXNpbmcgYSBtdWx0aS1zZWxlY3QgY29udHJvbFxuICpcbiAqIFRoZSBmb2xsb3cgZXhhbXBsZSBzaG93cyB5b3UgaG93IHRvIHVzZSBhIG11bHRpLXNlbGVjdCBjb250cm9sIHdpdGggYSByZWFjdGl2ZSBmb3JtLlxuICpcbiAqIGBgYHRzXG4gKiBjb25zdCBjb3VudHJ5Q29udHJvbCA9IG5ldyBGb3JtQ29udHJvbCgpO1xuICogYGBgXG4gKlxuICogYGBgXG4gKiA8c2VsZWN0IG11bHRpcGxlIG5hbWU9XCJjb3VudHJpZXNcIiBbZm9ybUNvbnRyb2xdPVwiY291bnRyeUNvbnRyb2xcIj5cbiAqICAgPG9wdGlvbiAqbmdGb3I9XCJsZXQgY291bnRyeSBvZiBjb3VudHJpZXNcIiBbbmdWYWx1ZV09XCJjb3VudHJ5XCI+XG4gKiAgICAge3sgY291bnRyeS5uYW1lIH19XG4gKiAgIDwvb3B0aW9uPlxuICogPC9zZWxlY3Q+XG4gKiBgYGBcbiAqXG4gKiAjIyMgQ3VzdG9taXppbmcgb3B0aW9uIHNlbGVjdGlvblxuICpcbiAqIFRvIGN1c3RvbWl6ZSB0aGUgZGVmYXVsdCBvcHRpb24gY29tcGFyaXNvbiBhbGdvcml0aG0sIGA8c2VsZWN0PmAgc3VwcG9ydHMgYGNvbXBhcmVXaXRoYCBpbnB1dC5cbiAqIFNlZSB0aGUgYFNlbGVjdENvbnRyb2xWYWx1ZUFjY2Vzc29yYCBmb3IgdXNhZ2UuXG4gKlxuICogQG5nTW9kdWxlIFJlYWN0aXZlRm9ybXNNb2R1bGVcbiAqIEBuZ01vZHVsZSBGb3Jtc01vZHVsZVxuICogQHB1YmxpY0FwaVxuICovXG5jbGFzcyBTZWxlY3RNdWx0aXBsZUNvbnRyb2xWYWx1ZUFjY2Vzc29yIGV4dGVuZHMgQnVpbHRJbkNvbnRyb2xWYWx1ZUFjY2Vzc29yIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICB0aGlzLl9vcHRpb25NYXAgPSBuZXcgTWFwKCk7XG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgdGhpcy5faWRDb3VudGVyID0gMDtcbiAgICAgICAgdGhpcy5fY29tcGFyZVdpdGggPSBPYmplY3QuaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqIFRyYWNrcyB0aGUgb3B0aW9uIGNvbXBhcmlzb24gYWxnb3JpdGhtIGZvciB0cmFja2luZyBpZGVudGl0aWVzIHdoZW5cbiAgICAgKiBjaGVja2luZyBmb3IgY2hhbmdlcy5cbiAgICAgKi9cbiAgICBzZXQgY29tcGFyZVdpdGgoZm4pIHtcbiAgICAgICAgaWYgKHR5cGVvZiBmbiAhPT0gJ2Z1bmN0aW9uJyAmJiAodHlwZW9mIG5nRGV2TW9kZSA9PT0gJ3VuZGVmaW5lZCcgfHwgbmdEZXZNb2RlKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IMm1UnVudGltZUVycm9yKDEyMDEgLyogUnVudGltZUVycm9yQ29kZS5DT01QQVJFV0lUSF9OT1RfQV9GTiAqLywgYGNvbXBhcmVXaXRoIG11c3QgYmUgYSBmdW5jdGlvbiwgYnV0IHJlY2VpdmVkICR7SlNPTi5zdHJpbmdpZnkoZm4pfWApO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2NvbXBhcmVXaXRoID0gZm47XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIFwidmFsdWVcIiBwcm9wZXJ0eSBvbiBvbmUgb3Igb2YgbW9yZSBvZiB0aGUgc2VsZWN0J3Mgb3B0aW9ucy5cbiAgICAgKiBAbm9kb2NcbiAgICAgKi9cbiAgICB3cml0ZVZhbHVlKHZhbHVlKSB7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgbGV0IG9wdGlvblNlbGVjdGVkU3RhdGVTZXR0ZXI7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgLy8gY29udmVydCB2YWx1ZXMgdG8gaWRzXG4gICAgICAgICAgICBjb25zdCBpZHMgPSB2YWx1ZS5tYXAoKHYpID0+IHRoaXMuX2dldE9wdGlvbklkKHYpKTtcbiAgICAgICAgICAgIG9wdGlvblNlbGVjdGVkU3RhdGVTZXR0ZXIgPSAob3B0LCBvKSA9PiB7XG4gICAgICAgICAgICAgICAgb3B0Ll9zZXRTZWxlY3RlZChpZHMuaW5kZXhPZihvLnRvU3RyaW5nKCkpID4gLTEpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG9wdGlvblNlbGVjdGVkU3RhdGVTZXR0ZXIgPSAob3B0LCBvKSA9PiB7XG4gICAgICAgICAgICAgICAgb3B0Ll9zZXRTZWxlY3RlZChmYWxzZSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX29wdGlvbk1hcC5mb3JFYWNoKG9wdGlvblNlbGVjdGVkU3RhdGVTZXR0ZXIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWdpc3RlcnMgYSBmdW5jdGlvbiBjYWxsZWQgd2hlbiB0aGUgY29udHJvbCB2YWx1ZSBjaGFuZ2VzXG4gICAgICogYW5kIHdyaXRlcyBhbiBhcnJheSBvZiB0aGUgc2VsZWN0ZWQgb3B0aW9ucy5cbiAgICAgKiBAbm9kb2NcbiAgICAgKi9cbiAgICByZWdpc3Rlck9uQ2hhbmdlKGZuKSB7XG4gICAgICAgIHRoaXMub25DaGFuZ2UgPSAoZWxlbWVudCkgPT4ge1xuICAgICAgICAgICAgY29uc3Qgc2VsZWN0ZWQgPSBbXTtcbiAgICAgICAgICAgIGNvbnN0IHNlbGVjdGVkT3B0aW9ucyA9IGVsZW1lbnQuc2VsZWN0ZWRPcHRpb25zO1xuICAgICAgICAgICAgaWYgKHNlbGVjdGVkT3B0aW9ucyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHNlbGVjdGVkT3B0aW9ucztcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG9wdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgb3B0ID0gb3B0aW9uc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdmFsID0gdGhpcy5fZ2V0T3B0aW9uVmFsdWUob3B0LnZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0ZWQucHVzaCh2YWwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIERlZ3JhZGUgdG8gdXNlIGBvcHRpb25zYCB3aGVuIGBzZWxlY3RlZE9wdGlvbnNgIHByb3BlcnR5IGlzIG5vdCBhdmFpbGFibGUuXG4gICAgICAgICAgICAvLyBOb3RlOiB0aGUgYHNlbGVjdGVkT3B0aW9uc2AgaXMgYXZhaWxhYmxlIGluIGFsbCBzdXBwb3J0ZWQgYnJvd3NlcnMsIGJ1dCB0aGUgRG9taW5vIGxpYlxuICAgICAgICAgICAgLy8gZG9lc24ndCBoYXZlIGl0IGN1cnJlbnRseSwgc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9mZ25hc3MvZG9taW5vL2lzc3Vlcy8xNzcuXG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCBvcHRpb25zID0gZWxlbWVudC5vcHRpb25zO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb3B0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBvcHQgPSBvcHRpb25zW2ldO1xuICAgICAgICAgICAgICAgICAgICBpZiAob3B0LnNlbGVjdGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB2YWwgPSB0aGlzLl9nZXRPcHRpb25WYWx1ZShvcHQudmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0ZWQucHVzaCh2YWwpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy52YWx1ZSA9IHNlbGVjdGVkO1xuICAgICAgICAgICAgZm4oc2VsZWN0ZWQpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICAvKiogQGludGVybmFsICovXG4gICAgX3JlZ2lzdGVyT3B0aW9uKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGlkID0gKHRoaXMuX2lkQ291bnRlcisrKS50b1N0cmluZygpO1xuICAgICAgICB0aGlzLl9vcHRpb25NYXAuc2V0KGlkLCB2YWx1ZSk7XG4gICAgICAgIHJldHVybiBpZDtcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIF9nZXRPcHRpb25JZCh2YWx1ZSkge1xuICAgICAgICBmb3IgKGNvbnN0IGlkIG9mIHRoaXMuX29wdGlvbk1hcC5rZXlzKCkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9jb21wYXJlV2l0aCh0aGlzLl9vcHRpb25NYXAuZ2V0KGlkKS5fdmFsdWUsIHZhbHVlKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gaWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBfZ2V0T3B0aW9uVmFsdWUodmFsdWVTdHJpbmcpIHtcbiAgICAgICAgY29uc3QgaWQgPSBfZXh0cmFjdElkKHZhbHVlU3RyaW5nKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX29wdGlvbk1hcC5oYXMoaWQpID8gdGhpcy5fb3B0aW9uTWFwLmdldChpZCkuX3ZhbHVlIDogdmFsdWVTdHJpbmc7XG4gICAgfVxuICAgIHN0YXRpYyB7IHRoaXMuybVmYWMgPSBpMC7Jtcm1bmdEZWNsYXJlRmFjdG9yeSh7IG1pblZlcnNpb246IFwiMTIuMC4wXCIsIHZlcnNpb246IFwiMTcuMy4xMlwiLCBuZ0ltcG9ydDogaTAsIHR5cGU6IFNlbGVjdE11bHRpcGxlQ29udHJvbFZhbHVlQWNjZXNzb3IsIGRlcHM6IG51bGwsIHRhcmdldDogaTAuybXJtUZhY3RvcnlUYXJnZXQuRGlyZWN0aXZlIH0pOyB9XG4gICAgc3RhdGljIHsgdGhpcy7JtWRpciA9IGkwLsm1ybVuZ0RlY2xhcmVEaXJlY3RpdmUoeyBtaW5WZXJzaW9uOiBcIjE0LjAuMFwiLCB2ZXJzaW9uOiBcIjE3LjMuMTJcIiwgdHlwZTogU2VsZWN0TXVsdGlwbGVDb250cm9sVmFsdWVBY2Nlc3Nvciwgc2VsZWN0b3I6IFwic2VsZWN0W211bHRpcGxlXVtmb3JtQ29udHJvbE5hbWVdLHNlbGVjdFttdWx0aXBsZV1bZm9ybUNvbnRyb2xdLHNlbGVjdFttdWx0aXBsZV1bbmdNb2RlbF1cIiwgaW5wdXRzOiB7IGNvbXBhcmVXaXRoOiBcImNvbXBhcmVXaXRoXCIgfSwgaG9zdDogeyBsaXN0ZW5lcnM6IHsgXCJjaGFuZ2VcIjogXCJvbkNoYW5nZSgkZXZlbnQudGFyZ2V0KVwiLCBcImJsdXJcIjogXCJvblRvdWNoZWQoKVwiIH0gfSwgcHJvdmlkZXJzOiBbU0VMRUNUX01VTFRJUExFX1ZBTFVFX0FDQ0VTU09SXSwgdXNlc0luaGVyaXRhbmNlOiB0cnVlLCBuZ0ltcG9ydDogaTAgfSk7IH1cbn1cbmkwLsm1ybVuZ0RlY2xhcmVDbGFzc01ldGFkYXRhKHsgbWluVmVyc2lvbjogXCIxMi4wLjBcIiwgdmVyc2lvbjogXCIxNy4zLjEyXCIsIG5nSW1wb3J0OiBpMCwgdHlwZTogU2VsZWN0TXVsdGlwbGVDb250cm9sVmFsdWVBY2Nlc3NvciwgZGVjb3JhdG9yczogW3tcbiAgICAgICAgICAgIHR5cGU6IERpcmVjdGl2ZSxcbiAgICAgICAgICAgIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnc2VsZWN0W211bHRpcGxlXVtmb3JtQ29udHJvbE5hbWVdLHNlbGVjdFttdWx0aXBsZV1bZm9ybUNvbnRyb2xdLHNlbGVjdFttdWx0aXBsZV1bbmdNb2RlbF0nLFxuICAgICAgICAgICAgICAgICAgICBob3N0OiB7ICcoY2hhbmdlKSc6ICdvbkNoYW5nZSgkZXZlbnQudGFyZ2V0KScsICcoYmx1ciknOiAnb25Ub3VjaGVkKCknIH0sXG4gICAgICAgICAgICAgICAgICAgIHByb3ZpZGVyczogW1NFTEVDVF9NVUxUSVBMRV9WQUxVRV9BQ0NFU1NPUl1cbiAgICAgICAgICAgICAgICB9XVxuICAgICAgICB9XSwgcHJvcERlY29yYXRvcnM6IHsgY29tcGFyZVdpdGg6IFt7XG4gICAgICAgICAgICAgICAgdHlwZTogSW5wdXRcbiAgICAgICAgICAgIH1dIH0gfSk7XG4vKipcbiAqIEBkZXNjcmlwdGlvblxuICogTWFya3MgYDxvcHRpb24+YCBhcyBkeW5hbWljLCBzbyBBbmd1bGFyIGNhbiBiZSBub3RpZmllZCB3aGVuIG9wdGlvbnMgY2hhbmdlLlxuICpcbiAqIEBzZWUge0BsaW5rIFNlbGVjdE11bHRpcGxlQ29udHJvbFZhbHVlQWNjZXNzb3J9XG4gKlxuICogQG5nTW9kdWxlIFJlYWN0aXZlRm9ybXNNb2R1bGVcbiAqIEBuZ01vZHVsZSBGb3Jtc01vZHVsZVxuICogQHB1YmxpY0FwaVxuICovXG5jbGFzcyDJtU5nU2VsZWN0TXVsdGlwbGVPcHRpb24ge1xuICAgIGNvbnN0cnVjdG9yKF9lbGVtZW50LCBfcmVuZGVyZXIsIF9zZWxlY3QpIHtcbiAgICAgICAgdGhpcy5fZWxlbWVudCA9IF9lbGVtZW50O1xuICAgICAgICB0aGlzLl9yZW5kZXJlciA9IF9yZW5kZXJlcjtcbiAgICAgICAgdGhpcy5fc2VsZWN0ID0gX3NlbGVjdDtcbiAgICAgICAgaWYgKHRoaXMuX3NlbGVjdCkge1xuICAgICAgICAgICAgdGhpcy5pZCA9IHRoaXMuX3NlbGVjdC5fcmVnaXN0ZXJPcHRpb24odGhpcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICogVHJhY2tzIHRoZSB2YWx1ZSBib3VuZCB0byB0aGUgb3B0aW9uIGVsZW1lbnQuIFVubGlrZSB0aGUgdmFsdWUgYmluZGluZyxcbiAgICAgKiBuZ1ZhbHVlIHN1cHBvcnRzIGJpbmRpbmcgdG8gb2JqZWN0cy5cbiAgICAgKi9cbiAgICBzZXQgbmdWYWx1ZSh2YWx1ZSkge1xuICAgICAgICBpZiAodGhpcy5fc2VsZWN0ID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRoaXMuX3ZhbHVlID0gdmFsdWU7XG4gICAgICAgIHRoaXMuX3NldEVsZW1lbnRWYWx1ZShfYnVpbGRWYWx1ZVN0cmluZyh0aGlzLmlkLCB2YWx1ZSkpO1xuICAgICAgICB0aGlzLl9zZWxlY3Qud3JpdGVWYWx1ZSh0aGlzLl9zZWxlY3QudmFsdWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKiBUcmFja3Mgc2ltcGxlIHN0cmluZyB2YWx1ZXMgYm91bmQgdG8gdGhlIG9wdGlvbiBlbGVtZW50LlxuICAgICAqIEZvciBvYmplY3RzLCB1c2UgdGhlIGBuZ1ZhbHVlYCBpbnB1dCBiaW5kaW5nLlxuICAgICAqL1xuICAgIHNldCB2YWx1ZSh2YWx1ZSkge1xuICAgICAgICBpZiAodGhpcy5fc2VsZWN0KSB7XG4gICAgICAgICAgICB0aGlzLl92YWx1ZSA9IHZhbHVlO1xuICAgICAgICAgICAgdGhpcy5fc2V0RWxlbWVudFZhbHVlKF9idWlsZFZhbHVlU3RyaW5nKHRoaXMuaWQsIHZhbHVlKSk7XG4gICAgICAgICAgICB0aGlzLl9zZWxlY3Qud3JpdGVWYWx1ZSh0aGlzLl9zZWxlY3QudmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fc2V0RWxlbWVudFZhbHVlKHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKiogQGludGVybmFsICovXG4gICAgX3NldEVsZW1lbnRWYWx1ZSh2YWx1ZSkge1xuICAgICAgICB0aGlzLl9yZW5kZXJlci5zZXRQcm9wZXJ0eSh0aGlzLl9lbGVtZW50Lm5hdGl2ZUVsZW1lbnQsICd2YWx1ZScsIHZhbHVlKTtcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIF9zZXRTZWxlY3RlZChzZWxlY3RlZCkge1xuICAgICAgICB0aGlzLl9yZW5kZXJlci5zZXRQcm9wZXJ0eSh0aGlzLl9lbGVtZW50Lm5hdGl2ZUVsZW1lbnQsICdzZWxlY3RlZCcsIHNlbGVjdGVkKTtcbiAgICB9XG4gICAgLyoqIEBub2RvYyAqL1xuICAgIG5nT25EZXN0cm95KCkge1xuICAgICAgICBpZiAodGhpcy5fc2VsZWN0KSB7XG4gICAgICAgICAgICB0aGlzLl9zZWxlY3QuX29wdGlvbk1hcC5kZWxldGUodGhpcy5pZCk7XG4gICAgICAgICAgICB0aGlzLl9zZWxlY3Qud3JpdGVWYWx1ZSh0aGlzLl9zZWxlY3QudmFsdWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHN0YXRpYyB7IHRoaXMuybVmYWMgPSBpMC7Jtcm1bmdEZWNsYXJlRmFjdG9yeSh7IG1pblZlcnNpb246IFwiMTIuMC4wXCIsIHZlcnNpb246IFwiMTcuMy4xMlwiLCBuZ0ltcG9ydDogaTAsIHR5cGU6IMm1TmdTZWxlY3RNdWx0aXBsZU9wdGlvbiwgZGVwczogW3sgdG9rZW46IGkwLkVsZW1lbnRSZWYgfSwgeyB0b2tlbjogaTAuUmVuZGVyZXIyIH0sIHsgdG9rZW46IFNlbGVjdE11bHRpcGxlQ29udHJvbFZhbHVlQWNjZXNzb3IsIGhvc3Q6IHRydWUsIG9wdGlvbmFsOiB0cnVlIH1dLCB0YXJnZXQ6IGkwLsm1ybVGYWN0b3J5VGFyZ2V0LkRpcmVjdGl2ZSB9KTsgfVxuICAgIHN0YXRpYyB7IHRoaXMuybVkaXIgPSBpMC7Jtcm1bmdEZWNsYXJlRGlyZWN0aXZlKHsgbWluVmVyc2lvbjogXCIxNC4wLjBcIiwgdmVyc2lvbjogXCIxNy4zLjEyXCIsIHR5cGU6IMm1TmdTZWxlY3RNdWx0aXBsZU9wdGlvbiwgc2VsZWN0b3I6IFwib3B0aW9uXCIsIGlucHV0czogeyBuZ1ZhbHVlOiBcIm5nVmFsdWVcIiwgdmFsdWU6IFwidmFsdWVcIiB9LCBuZ0ltcG9ydDogaTAgfSk7IH1cbn1cbmkwLsm1ybVuZ0RlY2xhcmVDbGFzc01ldGFkYXRhKHsgbWluVmVyc2lvbjogXCIxMi4wLjBcIiwgdmVyc2lvbjogXCIxNy4zLjEyXCIsIG5nSW1wb3J0OiBpMCwgdHlwZTogybVOZ1NlbGVjdE11bHRpcGxlT3B0aW9uLCBkZWNvcmF0b3JzOiBbe1xuICAgICAgICAgICAgdHlwZTogRGlyZWN0aXZlLFxuICAgICAgICAgICAgYXJnczogW3sgc2VsZWN0b3I6ICdvcHRpb24nIH1dXG4gICAgICAgIH1dLCBjdG9yUGFyYW1ldGVyczogKCkgPT4gW3sgdHlwZTogaTAuRWxlbWVudFJlZiB9LCB7IHR5cGU6IGkwLlJlbmRlcmVyMiB9LCB7IHR5cGU6IFNlbGVjdE11bHRpcGxlQ29udHJvbFZhbHVlQWNjZXNzb3IsIGRlY29yYXRvcnM6IFt7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IE9wdGlvbmFsXG4gICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBIb3N0XG4gICAgICAgICAgICAgICAgfV0gfV0sIHByb3BEZWNvcmF0b3JzOiB7IG5nVmFsdWU6IFt7XG4gICAgICAgICAgICAgICAgdHlwZTogSW5wdXQsXG4gICAgICAgICAgICAgICAgYXJnczogWyduZ1ZhbHVlJ11cbiAgICAgICAgICAgIH1dLCB2YWx1ZTogW3tcbiAgICAgICAgICAgICAgICB0eXBlOiBJbnB1dCxcbiAgICAgICAgICAgICAgICBhcmdzOiBbJ3ZhbHVlJ11cbiAgICAgICAgICAgIH1dIH0gfSk7XG5cbi8qKlxuICogTWV0aG9kIHRoYXQgdXBkYXRlcyBzdHJpbmcgdG8gaW50ZWdlciBpZiBub3QgYWxyZWFkeSBhIG51bWJlclxuICpcbiAqIEBwYXJhbSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29udmVydCB0byBpbnRlZ2VyLlxuICogQHJldHVybnMgdmFsdWUgb2YgcGFyYW1ldGVyIGNvbnZlcnRlZCB0byBudW1iZXIgb3IgaW50ZWdlci5cbiAqL1xuZnVuY3Rpb24gdG9JbnRlZ2VyKHZhbHVlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgPyB2YWx1ZSA6IHBhcnNlSW50KHZhbHVlLCAxMCk7XG59XG4vKipcbiAqIE1ldGhvZCB0aGF0IGVuc3VyZXMgdGhhdCBwcm92aWRlZCB2YWx1ZSBpcyBhIGZsb2F0IChhbmQgY29udmVydHMgaXQgdG8gZmxvYXQgaWYgbmVlZGVkKS5cbiAqXG4gKiBAcGFyYW0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQgdG8gZmxvYXQuXG4gKiBAcmV0dXJucyB2YWx1ZSBvZiBwYXJhbWV0ZXIgY29udmVydGVkIHRvIG51bWJlciBvciBmbG9hdC5cbiAqL1xuZnVuY3Rpb24gdG9GbG9hdCh2YWx1ZSkge1xuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInID8gdmFsdWUgOiBwYXJzZUZsb2F0KHZhbHVlKTtcbn1cbi8qKlxuICogQSBiYXNlIGNsYXNzIGZvciBWYWxpZGF0b3ItYmFzZWQgRGlyZWN0aXZlcy4gVGhlIGNsYXNzIGNvbnRhaW5zIGNvbW1vbiBsb2dpYyBzaGFyZWQgYWNyb3NzIHN1Y2hcbiAqIERpcmVjdGl2ZXMuXG4gKlxuICogRm9yIGludGVybmFsIHVzZSBvbmx5LCB0aGlzIGNsYXNzIGlzIG5vdCBpbnRlbmRlZCBmb3IgdXNlIG91dHNpZGUgb2YgdGhlIEZvcm1zIHBhY2thZ2UuXG4gKi9cbmNsYXNzIEFic3RyYWN0VmFsaWRhdG9yRGlyZWN0aXZlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5fdmFsaWRhdG9yID0gbnVsbFZhbGlkYXRvcjtcbiAgICB9XG4gICAgLyoqIEBub2RvYyAqL1xuICAgIG5nT25DaGFuZ2VzKGNoYW5nZXMpIHtcbiAgICAgICAgaWYgKHRoaXMuaW5wdXROYW1lIGluIGNoYW5nZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IGlucHV0ID0gdGhpcy5ub3JtYWxpemVJbnB1dChjaGFuZ2VzW3RoaXMuaW5wdXROYW1lXS5jdXJyZW50VmFsdWUpO1xuICAgICAgICAgICAgdGhpcy5fZW5hYmxlZCA9IHRoaXMuZW5hYmxlZChpbnB1dCk7XG4gICAgICAgICAgICB0aGlzLl92YWxpZGF0b3IgPSB0aGlzLl9lbmFibGVkID8gdGhpcy5jcmVhdGVWYWxpZGF0b3IoaW5wdXQpIDogbnVsbFZhbGlkYXRvcjtcbiAgICAgICAgICAgIGlmICh0aGlzLl9vbkNoYW5nZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX29uQ2hhbmdlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqIEBub2RvYyAqL1xuICAgIHZhbGlkYXRlKGNvbnRyb2wpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ZhbGlkYXRvcihjb250cm9sKTtcbiAgICB9XG4gICAgLyoqIEBub2RvYyAqL1xuICAgIHJlZ2lzdGVyT25WYWxpZGF0b3JDaGFuZ2UoZm4pIHtcbiAgICAgICAgdGhpcy5fb25DaGFuZ2UgPSBmbjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICogRGV0ZXJtaW5lcyB3aGV0aGVyIHRoaXMgdmFsaWRhdG9yIHNob3VsZCBiZSBhY3RpdmUgb3Igbm90IGJhc2VkIG9uIGFuIGlucHV0LlxuICAgICAqIEJhc2UgY2xhc3MgaW1wbGVtZW50YXRpb24gY2hlY2tzIHdoZXRoZXIgYW4gaW5wdXQgaXMgZGVmaW5lZCAoaWYgdGhlIHZhbHVlIGlzIGRpZmZlcmVudCBmcm9tXG4gICAgICogYG51bGxgIGFuZCBgdW5kZWZpbmVkYCkuIFZhbGlkYXRvciBjbGFzc2VzIHRoYXQgZXh0ZW5kIHRoaXMgYmFzZSBjbGFzcyBjYW4gb3ZlcnJpZGUgdGhpc1xuICAgICAqIGZ1bmN0aW9uIHdpdGggdGhlIGxvZ2ljIHNwZWNpZmljIHRvIGEgcGFydGljdWxhciB2YWxpZGF0b3IgZGlyZWN0aXZlLlxuICAgICAqL1xuICAgIGVuYWJsZWQoaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIGlucHV0ICE9IG51bGwgLyogYm90aCBgbnVsbGAgYW5kIGB1bmRlZmluZWRgICovO1xuICAgIH1cbiAgICBzdGF0aWMgeyB0aGlzLsm1ZmFjID0gaTAuybXJtW5nRGVjbGFyZUZhY3RvcnkoeyBtaW5WZXJzaW9uOiBcIjEyLjAuMFwiLCB2ZXJzaW9uOiBcIjE3LjMuMTJcIiwgbmdJbXBvcnQ6IGkwLCB0eXBlOiBBYnN0cmFjdFZhbGlkYXRvckRpcmVjdGl2ZSwgZGVwczogW10sIHRhcmdldDogaTAuybXJtUZhY3RvcnlUYXJnZXQuRGlyZWN0aXZlIH0pOyB9XG4gICAgc3RhdGljIHsgdGhpcy7JtWRpciA9IGkwLsm1ybVuZ0RlY2xhcmVEaXJlY3RpdmUoeyBtaW5WZXJzaW9uOiBcIjE0LjAuMFwiLCB2ZXJzaW9uOiBcIjE3LjMuMTJcIiwgdHlwZTogQWJzdHJhY3RWYWxpZGF0b3JEaXJlY3RpdmUsIHVzZXNPbkNoYW5nZXM6IHRydWUsIG5nSW1wb3J0OiBpMCB9KTsgfVxufVxuaTAuybXJtW5nRGVjbGFyZUNsYXNzTWV0YWRhdGEoeyBtaW5WZXJzaW9uOiBcIjEyLjAuMFwiLCB2ZXJzaW9uOiBcIjE3LjMuMTJcIiwgbmdJbXBvcnQ6IGkwLCB0eXBlOiBBYnN0cmFjdFZhbGlkYXRvckRpcmVjdGl2ZSwgZGVjb3JhdG9yczogW3tcbiAgICAgICAgICAgIHR5cGU6IERpcmVjdGl2ZVxuICAgICAgICB9XSB9KTtcbi8qKlxuICogQGRlc2NyaXB0aW9uXG4gKiBQcm92aWRlciB3aGljaCBhZGRzIGBNYXhWYWxpZGF0b3JgIHRvIHRoZSBgTkdfVkFMSURBVE9SU2AgbXVsdGktcHJvdmlkZXIgbGlzdC5cbiAqL1xuY29uc3QgTUFYX1ZBTElEQVRPUiA9IHtcbiAgICBwcm92aWRlOiBOR19WQUxJREFUT1JTLFxuICAgIHVzZUV4aXN0aW5nOiBmb3J3YXJkUmVmKCgpID0+IE1heFZhbGlkYXRvciksXG4gICAgbXVsdGk6IHRydWVcbn07XG4vKipcbiAqIEEgZGlyZWN0aXZlIHdoaWNoIGluc3RhbGxzIHRoZSB7QGxpbmsgTWF4VmFsaWRhdG9yfSBmb3IgYW55IGBmb3JtQ29udHJvbE5hbWVgLFxuICogYGZvcm1Db250cm9sYCwgb3IgY29udHJvbCB3aXRoIGBuZ01vZGVsYCB0aGF0IGFsc28gaGFzIGEgYG1heGAgYXR0cmlidXRlLlxuICpcbiAqIEBzZWUgW0Zvcm0gVmFsaWRhdGlvbl0oZ3VpZGUvZm9ybS12YWxpZGF0aW9uKVxuICpcbiAqIEB1c2FnZU5vdGVzXG4gKlxuICogIyMjIEFkZGluZyBhIG1heCB2YWxpZGF0b3JcbiAqXG4gKiBUaGUgZm9sbG93aW5nIGV4YW1wbGUgc2hvd3MgaG93IHRvIGFkZCBhIG1heCB2YWxpZGF0b3IgdG8gYW4gaW5wdXQgYXR0YWNoZWQgdG8gYW5cbiAqIG5nTW9kZWwgYmluZGluZy5cbiAqXG4gKiBgYGBodG1sXG4gKiA8aW5wdXQgdHlwZT1cIm51bWJlclwiIG5nTW9kZWwgbWF4PVwiNFwiPlxuICogYGBgXG4gKlxuICogQG5nTW9kdWxlIFJlYWN0aXZlRm9ybXNNb2R1bGVcbiAqIEBuZ01vZHVsZSBGb3Jtc01vZHVsZVxuICogQHB1YmxpY0FwaVxuICovXG5jbGFzcyBNYXhWYWxpZGF0b3IgZXh0ZW5kcyBBYnN0cmFjdFZhbGlkYXRvckRpcmVjdGl2ZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgdGhpcy5pbnB1dE5hbWUgPSAnbWF4JztcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICB0aGlzLm5vcm1hbGl6ZUlucHV0ID0gKGlucHV0KSA9PiB0b0Zsb2F0KGlucHV0KTtcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICB0aGlzLmNyZWF0ZVZhbGlkYXRvciA9IChtYXgpID0+IG1heFZhbGlkYXRvcihtYXgpO1xuICAgIH1cbiAgICBzdGF0aWMgeyB0aGlzLsm1ZmFjID0gaTAuybXJtW5nRGVjbGFyZUZhY3RvcnkoeyBtaW5WZXJzaW9uOiBcIjEyLjAuMFwiLCB2ZXJzaW9uOiBcIjE3LjMuMTJcIiwgbmdJbXBvcnQ6IGkwLCB0eXBlOiBNYXhWYWxpZGF0b3IsIGRlcHM6IG51bGwsIHRhcmdldDogaTAuybXJtUZhY3RvcnlUYXJnZXQuRGlyZWN0aXZlIH0pOyB9XG4gICAgc3RhdGljIHsgdGhpcy7JtWRpciA9IGkwLsm1ybVuZ0RlY2xhcmVEaXJlY3RpdmUoeyBtaW5WZXJzaW9uOiBcIjE0LjAuMFwiLCB2ZXJzaW9uOiBcIjE3LjMuMTJcIiwgdHlwZTogTWF4VmFsaWRhdG9yLCBzZWxlY3RvcjogXCJpbnB1dFt0eXBlPW51bWJlcl1bbWF4XVtmb3JtQ29udHJvbE5hbWVdLGlucHV0W3R5cGU9bnVtYmVyXVttYXhdW2Zvcm1Db250cm9sXSxpbnB1dFt0eXBlPW51bWJlcl1bbWF4XVtuZ01vZGVsXVwiLCBpbnB1dHM6IHsgbWF4OiBcIm1heFwiIH0sIGhvc3Q6IHsgcHJvcGVydGllczogeyBcImF0dHIubWF4XCI6IFwiX2VuYWJsZWQgPyBtYXggOiBudWxsXCIgfSB9LCBwcm92aWRlcnM6IFtNQVhfVkFMSURBVE9SXSwgdXNlc0luaGVyaXRhbmNlOiB0cnVlLCBuZ0ltcG9ydDogaTAgfSk7IH1cbn1cbmkwLsm1ybVuZ0RlY2xhcmVDbGFzc01ldGFkYXRhKHsgbWluVmVyc2lvbjogXCIxMi4wLjBcIiwgdmVyc2lvbjogXCIxNy4zLjEyXCIsIG5nSW1wb3J0OiBpMCwgdHlwZTogTWF4VmFsaWRhdG9yLCBkZWNvcmF0b3JzOiBbe1xuICAgICAgICAgICAgdHlwZTogRGlyZWN0aXZlLFxuICAgICAgICAgICAgYXJnczogW3tcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdpbnB1dFt0eXBlPW51bWJlcl1bbWF4XVtmb3JtQ29udHJvbE5hbWVdLGlucHV0W3R5cGU9bnVtYmVyXVttYXhdW2Zvcm1Db250cm9sXSxpbnB1dFt0eXBlPW51bWJlcl1bbWF4XVtuZ01vZGVsXScsXG4gICAgICAgICAgICAgICAgICAgIHByb3ZpZGVyczogW01BWF9WQUxJREFUT1JdLFxuICAgICAgICAgICAgICAgICAgICBob3N0OiB7ICdbYXR0ci5tYXhdJzogJ19lbmFibGVkID8gbWF4IDogbnVsbCcgfVxuICAgICAgICAgICAgICAgIH1dXG4gICAgICAgIH1dLCBwcm9wRGVjb3JhdG9yczogeyBtYXg6IFt7XG4gICAgICAgICAgICAgICAgdHlwZTogSW5wdXRcbiAgICAgICAgICAgIH1dIH0gfSk7XG4vKipcbiAqIEBkZXNjcmlwdGlvblxuICogUHJvdmlkZXIgd2hpY2ggYWRkcyBgTWluVmFsaWRhdG9yYCB0byB0aGUgYE5HX1ZBTElEQVRPUlNgIG11bHRpLXByb3ZpZGVyIGxpc3QuXG4gKi9cbmNvbnN0IE1JTl9WQUxJREFUT1IgPSB7XG4gICAgcHJvdmlkZTogTkdfVkFMSURBVE9SUyxcbiAgICB1c2VFeGlzdGluZzogZm9yd2FyZFJlZigoKSA9PiBNaW5WYWxpZGF0b3IpLFxuICAgIG11bHRpOiB0cnVlXG59O1xuLyoqXG4gKiBBIGRpcmVjdGl2ZSB3aGljaCBpbnN0YWxscyB0aGUge0BsaW5rIE1pblZhbGlkYXRvcn0gZm9yIGFueSBgZm9ybUNvbnRyb2xOYW1lYCxcbiAqIGBmb3JtQ29udHJvbGAsIG9yIGNvbnRyb2wgd2l0aCBgbmdNb2RlbGAgdGhhdCBhbHNvIGhhcyBhIGBtaW5gIGF0dHJpYnV0ZS5cbiAqXG4gKiBAc2VlIFtGb3JtIFZhbGlkYXRpb25dKGd1aWRlL2Zvcm0tdmFsaWRhdGlvbilcbiAqXG4gKiBAdXNhZ2VOb3Rlc1xuICpcbiAqICMjIyBBZGRpbmcgYSBtaW4gdmFsaWRhdG9yXG4gKlxuICogVGhlIGZvbGxvd2luZyBleGFtcGxlIHNob3dzIGhvdyB0byBhZGQgYSBtaW4gdmFsaWRhdG9yIHRvIGFuIGlucHV0IGF0dGFjaGVkIHRvIGFuXG4gKiBuZ01vZGVsIGJpbmRpbmcuXG4gKlxuICogYGBgaHRtbFxuICogPGlucHV0IHR5cGU9XCJudW1iZXJcIiBuZ01vZGVsIG1pbj1cIjRcIj5cbiAqIGBgYFxuICpcbiAqIEBuZ01vZHVsZSBSZWFjdGl2ZUZvcm1zTW9kdWxlXG4gKiBAbmdNb2R1bGUgRm9ybXNNb2R1bGVcbiAqIEBwdWJsaWNBcGlcbiAqL1xuY2xhc3MgTWluVmFsaWRhdG9yIGV4dGVuZHMgQWJzdHJhY3RWYWxpZGF0b3JEaXJlY3RpdmUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgIHRoaXMuaW5wdXROYW1lID0gJ21pbic7XG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgdGhpcy5ub3JtYWxpemVJbnB1dCA9IChpbnB1dCkgPT4gdG9GbG9hdChpbnB1dCk7XG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgdGhpcy5jcmVhdGVWYWxpZGF0b3IgPSAobWluKSA9PiBtaW5WYWxpZGF0b3IobWluKTtcbiAgICB9XG4gICAgc3RhdGljIHsgdGhpcy7JtWZhYyA9IGkwLsm1ybVuZ0RlY2xhcmVGYWN0b3J5KHsgbWluVmVyc2lvbjogXCIxMi4wLjBcIiwgdmVyc2lvbjogXCIxNy4zLjEyXCIsIG5nSW1wb3J0OiBpMCwgdHlwZTogTWluVmFsaWRhdG9yLCBkZXBzOiBudWxsLCB0YXJnZXQ6IGkwLsm1ybVGYWN0b3J5VGFyZ2V0LkRpcmVjdGl2ZSB9KTsgfVxuICAgIHN0YXRpYyB7IHRoaXMuybVkaXIgPSBpMC7Jtcm1bmdEZWNsYXJlRGlyZWN0aXZlKHsgbWluVmVyc2lvbjogXCIxNC4wLjBcIiwgdmVyc2lvbjogXCIxNy4zLjEyXCIsIHR5cGU6IE1pblZhbGlkYXRvciwgc2VsZWN0b3I6IFwiaW5wdXRbdHlwZT1udW1iZXJdW21pbl1bZm9ybUNvbnRyb2xOYW1lXSxpbnB1dFt0eXBlPW51bWJlcl1bbWluXVtmb3JtQ29udHJvbF0saW5wdXRbdHlwZT1udW1iZXJdW21pbl1bbmdNb2RlbF1cIiwgaW5wdXRzOiB7IG1pbjogXCJtaW5cIiB9LCBob3N0OiB7IHByb3BlcnRpZXM6IHsgXCJhdHRyLm1pblwiOiBcIl9lbmFibGVkID8gbWluIDogbnVsbFwiIH0gfSwgcHJvdmlkZXJzOiBbTUlOX1ZBTElEQVRPUl0sIHVzZXNJbmhlcml0YW5jZTogdHJ1ZSwgbmdJbXBvcnQ6IGkwIH0pOyB9XG59XG5pMC7Jtcm1bmdEZWNsYXJlQ2xhc3NNZXRhZGF0YSh7IG1pblZlcnNpb246IFwiMTIuMC4wXCIsIHZlcnNpb246IFwiMTcuMy4xMlwiLCBuZ0ltcG9ydDogaTAsIHR5cGU6IE1pblZhbGlkYXRvciwgZGVjb3JhdG9yczogW3tcbiAgICAgICAgICAgIHR5cGU6IERpcmVjdGl2ZSxcbiAgICAgICAgICAgIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnaW5wdXRbdHlwZT1udW1iZXJdW21pbl1bZm9ybUNvbnRyb2xOYW1lXSxpbnB1dFt0eXBlPW51bWJlcl1bbWluXVtmb3JtQ29udHJvbF0saW5wdXRbdHlwZT1udW1iZXJdW21pbl1bbmdNb2RlbF0nLFxuICAgICAgICAgICAgICAgICAgICBwcm92aWRlcnM6IFtNSU5fVkFMSURBVE9SXSxcbiAgICAgICAgICAgICAgICAgICAgaG9zdDogeyAnW2F0dHIubWluXSc6ICdfZW5hYmxlZCA/IG1pbiA6IG51bGwnIH1cbiAgICAgICAgICAgICAgICB9XVxuICAgICAgICB9XSwgcHJvcERlY29yYXRvcnM6IHsgbWluOiBbe1xuICAgICAgICAgICAgICAgIHR5cGU6IElucHV0XG4gICAgICAgICAgICB9XSB9IH0pO1xuLyoqXG4gKiBAZGVzY3JpcHRpb25cbiAqIFByb3ZpZGVyIHdoaWNoIGFkZHMgYFJlcXVpcmVkVmFsaWRhdG9yYCB0byB0aGUgYE5HX1ZBTElEQVRPUlNgIG11bHRpLXByb3ZpZGVyIGxpc3QuXG4gKi9cbmNvbnN0IFJFUVVJUkVEX1ZBTElEQVRPUiA9IHtcbiAgICBwcm92aWRlOiBOR19WQUxJREFUT1JTLFxuICAgIHVzZUV4aXN0aW5nOiBmb3J3YXJkUmVmKCgpID0+IFJlcXVpcmVkVmFsaWRhdG9yKSxcbiAgICBtdWx0aTogdHJ1ZVxufTtcbi8qKlxuICogQGRlc2NyaXB0aW9uXG4gKiBQcm92aWRlciB3aGljaCBhZGRzIGBDaGVja2JveFJlcXVpcmVkVmFsaWRhdG9yYCB0byB0aGUgYE5HX1ZBTElEQVRPUlNgIG11bHRpLXByb3ZpZGVyIGxpc3QuXG4gKi9cbmNvbnN0IENIRUNLQk9YX1JFUVVJUkVEX1ZBTElEQVRPUiA9IHtcbiAgICBwcm92aWRlOiBOR19WQUxJREFUT1JTLFxuICAgIHVzZUV4aXN0aW5nOiBmb3J3YXJkUmVmKCgpID0+IENoZWNrYm94UmVxdWlyZWRWYWxpZGF0b3IpLFxuICAgIG11bHRpOiB0cnVlXG59O1xuLyoqXG4gKiBAZGVzY3JpcHRpb25cbiAqIEEgZGlyZWN0aXZlIHRoYXQgYWRkcyB0aGUgYHJlcXVpcmVkYCB2YWxpZGF0b3IgdG8gYW55IGNvbnRyb2xzIG1hcmtlZCB3aXRoIHRoZVxuICogYHJlcXVpcmVkYCBhdHRyaWJ1dGUuIFRoZSBkaXJlY3RpdmUgaXMgcHJvdmlkZWQgd2l0aCB0aGUgYE5HX1ZBTElEQVRPUlNgIG11bHRpLXByb3ZpZGVyIGxpc3QuXG4gKlxuICogQHNlZSBbRm9ybSBWYWxpZGF0aW9uXShndWlkZS9mb3JtLXZhbGlkYXRpb24pXG4gKlxuICogQHVzYWdlTm90ZXNcbiAqXG4gKiAjIyMgQWRkaW5nIGEgcmVxdWlyZWQgdmFsaWRhdG9yIHVzaW5nIHRlbXBsYXRlLWRyaXZlbiBmb3Jtc1xuICpcbiAqIGBgYFxuICogPGlucHV0IG5hbWU9XCJmdWxsTmFtZVwiIG5nTW9kZWwgcmVxdWlyZWQ+XG4gKiBgYGBcbiAqXG4gKiBAbmdNb2R1bGUgRm9ybXNNb2R1bGVcbiAqIEBuZ01vZHVsZSBSZWFjdGl2ZUZvcm1zTW9kdWxlXG4gKiBAcHVibGljQXBpXG4gKi9cbmNsYXNzIFJlcXVpcmVkVmFsaWRhdG9yIGV4dGVuZHMgQWJzdHJhY3RWYWxpZGF0b3JEaXJlY3RpdmUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgIHRoaXMuaW5wdXROYW1lID0gJ3JlcXVpcmVkJztcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICB0aGlzLm5vcm1hbGl6ZUlucHV0ID0gYm9vbGVhbkF0dHJpYnV0ZTtcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICB0aGlzLmNyZWF0ZVZhbGlkYXRvciA9IChpbnB1dCkgPT4gcmVxdWlyZWRWYWxpZGF0b3I7XG4gICAgfVxuICAgIC8qKiBAbm9kb2MgKi9cbiAgICBlbmFibGVkKGlucHV0KSB7XG4gICAgICAgIHJldHVybiBpbnB1dDtcbiAgICB9XG4gICAgc3RhdGljIHsgdGhpcy7JtWZhYyA9IGkwLsm1ybVuZ0RlY2xhcmVGYWN0b3J5KHsgbWluVmVyc2lvbjogXCIxMi4wLjBcIiwgdmVyc2lvbjogXCIxNy4zLjEyXCIsIG5nSW1wb3J0OiBpMCwgdHlwZTogUmVxdWlyZWRWYWxpZGF0b3IsIGRlcHM6IG51bGwsIHRhcmdldDogaTAuybXJtUZhY3RvcnlUYXJnZXQuRGlyZWN0aXZlIH0pOyB9XG4gICAgc3RhdGljIHsgdGhpcy7JtWRpciA9IGkwLsm1ybVuZ0RlY2xhcmVEaXJlY3RpdmUoeyBtaW5WZXJzaW9uOiBcIjE0LjAuMFwiLCB2ZXJzaW9uOiBcIjE3LjMuMTJcIiwgdHlwZTogUmVxdWlyZWRWYWxpZGF0b3IsIHNlbGVjdG9yOiBcIjpub3QoW3R5cGU9Y2hlY2tib3hdKVtyZXF1aXJlZF1bZm9ybUNvbnRyb2xOYW1lXSw6bm90KFt0eXBlPWNoZWNrYm94XSlbcmVxdWlyZWRdW2Zvcm1Db250cm9sXSw6bm90KFt0eXBlPWNoZWNrYm94XSlbcmVxdWlyZWRdW25nTW9kZWxdXCIsIGlucHV0czogeyByZXF1aXJlZDogXCJyZXF1aXJlZFwiIH0sIGhvc3Q6IHsgcHJvcGVydGllczogeyBcImF0dHIucmVxdWlyZWRcIjogXCJfZW5hYmxlZCA/IFxcXCJcXFwiIDogbnVsbFwiIH0gfSwgcHJvdmlkZXJzOiBbUkVRVUlSRURfVkFMSURBVE9SXSwgdXNlc0luaGVyaXRhbmNlOiB0cnVlLCBuZ0ltcG9ydDogaTAgfSk7IH1cbn1cbmkwLsm1ybVuZ0RlY2xhcmVDbGFzc01ldGFkYXRhKHsgbWluVmVyc2lvbjogXCIxMi4wLjBcIiwgdmVyc2lvbjogXCIxNy4zLjEyXCIsIG5nSW1wb3J0OiBpMCwgdHlwZTogUmVxdWlyZWRWYWxpZGF0b3IsIGRlY29yYXRvcnM6IFt7XG4gICAgICAgICAgICB0eXBlOiBEaXJlY3RpdmUsXG4gICAgICAgICAgICBhcmdzOiBbe1xuICAgICAgICAgICAgICAgICAgICBzZWxlY3RvcjogJzpub3QoW3R5cGU9Y2hlY2tib3hdKVtyZXF1aXJlZF1bZm9ybUNvbnRyb2xOYW1lXSw6bm90KFt0eXBlPWNoZWNrYm94XSlbcmVxdWlyZWRdW2Zvcm1Db250cm9sXSw6bm90KFt0eXBlPWNoZWNrYm94XSlbcmVxdWlyZWRdW25nTW9kZWxdJyxcbiAgICAgICAgICAgICAgICAgICAgcHJvdmlkZXJzOiBbUkVRVUlSRURfVkFMSURBVE9SXSxcbiAgICAgICAgICAgICAgICAgICAgaG9zdDogeyAnW2F0dHIucmVxdWlyZWRdJzogJ19lbmFibGVkID8gXCJcIiA6IG51bGwnIH1cbiAgICAgICAgICAgICAgICB9XVxuICAgICAgICB9XSwgcHJvcERlY29yYXRvcnM6IHsgcmVxdWlyZWQ6IFt7XG4gICAgICAgICAgICAgICAgdHlwZTogSW5wdXRcbiAgICAgICAgICAgIH1dIH0gfSk7XG4vKipcbiAqIEEgRGlyZWN0aXZlIHRoYXQgYWRkcyB0aGUgYHJlcXVpcmVkYCB2YWxpZGF0b3IgdG8gY2hlY2tib3ggY29udHJvbHMgbWFya2VkIHdpdGggdGhlXG4gKiBgcmVxdWlyZWRgIGF0dHJpYnV0ZS4gVGhlIGRpcmVjdGl2ZSBpcyBwcm92aWRlZCB3aXRoIHRoZSBgTkdfVkFMSURBVE9SU2AgbXVsdGktcHJvdmlkZXIgbGlzdC5cbiAqXG4gKiBAc2VlIFtGb3JtIFZhbGlkYXRpb25dKGd1aWRlL2Zvcm0tdmFsaWRhdGlvbilcbiAqXG4gKiBAdXNhZ2VOb3Rlc1xuICpcbiAqICMjIyBBZGRpbmcgYSByZXF1aXJlZCBjaGVja2JveCB2YWxpZGF0b3IgdXNpbmcgdGVtcGxhdGUtZHJpdmVuIGZvcm1zXG4gKlxuICogVGhlIGZvbGxvd2luZyBleGFtcGxlIHNob3dzIGhvdyB0byBhZGQgYSBjaGVja2JveCByZXF1aXJlZCB2YWxpZGF0b3IgdG8gYW4gaW5wdXQgYXR0YWNoZWQgdG8gYW5cbiAqIG5nTW9kZWwgYmluZGluZy5cbiAqXG4gKiBgYGBcbiAqIDxpbnB1dCB0eXBlPVwiY2hlY2tib3hcIiBuYW1lPVwiYWN0aXZlXCIgbmdNb2RlbCByZXF1aXJlZD5cbiAqIGBgYFxuICpcbiAqIEBwdWJsaWNBcGlcbiAqIEBuZ01vZHVsZSBGb3Jtc01vZHVsZVxuICogQG5nTW9kdWxlIFJlYWN0aXZlRm9ybXNNb2R1bGVcbiAqL1xuY2xhc3MgQ2hlY2tib3hSZXF1aXJlZFZhbGlkYXRvciBleHRlbmRzIFJlcXVpcmVkVmFsaWRhdG9yIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICB0aGlzLmNyZWF0ZVZhbGlkYXRvciA9IChpbnB1dCkgPT4gcmVxdWlyZWRUcnVlVmFsaWRhdG9yO1xuICAgIH1cbiAgICBzdGF0aWMgeyB0aGlzLsm1ZmFjID0gaTAuybXJtW5nRGVjbGFyZUZhY3RvcnkoeyBtaW5WZXJzaW9uOiBcIjEyLjAuMFwiLCB2ZXJzaW9uOiBcIjE3LjMuMTJcIiwgbmdJbXBvcnQ6IGkwLCB0eXBlOiBDaGVja2JveFJlcXVpcmVkVmFsaWRhdG9yLCBkZXBzOiBudWxsLCB0YXJnZXQ6IGkwLsm1ybVGYWN0b3J5VGFyZ2V0LkRpcmVjdGl2ZSB9KTsgfVxuICAgIHN0YXRpYyB7IHRoaXMuybVkaXIgPSBpMC7Jtcm1bmdEZWNsYXJlRGlyZWN0aXZlKHsgbWluVmVyc2lvbjogXCIxNC4wLjBcIiwgdmVyc2lvbjogXCIxNy4zLjEyXCIsIHR5cGU6IENoZWNrYm94UmVxdWlyZWRWYWxpZGF0b3IsIHNlbGVjdG9yOiBcImlucHV0W3R5cGU9Y2hlY2tib3hdW3JlcXVpcmVkXVtmb3JtQ29udHJvbE5hbWVdLGlucHV0W3R5cGU9Y2hlY2tib3hdW3JlcXVpcmVkXVtmb3JtQ29udHJvbF0saW5wdXRbdHlwZT1jaGVja2JveF1bcmVxdWlyZWRdW25nTW9kZWxdXCIsIGhvc3Q6IHsgcHJvcGVydGllczogeyBcImF0dHIucmVxdWlyZWRcIjogXCJfZW5hYmxlZCA/IFxcXCJcXFwiIDogbnVsbFwiIH0gfSwgcHJvdmlkZXJzOiBbQ0hFQ0tCT1hfUkVRVUlSRURfVkFMSURBVE9SXSwgdXNlc0luaGVyaXRhbmNlOiB0cnVlLCBuZ0ltcG9ydDogaTAgfSk7IH1cbn1cbmkwLsm1ybVuZ0RlY2xhcmVDbGFzc01ldGFkYXRhKHsgbWluVmVyc2lvbjogXCIxMi4wLjBcIiwgdmVyc2lvbjogXCIxNy4zLjEyXCIsIG5nSW1wb3J0OiBpMCwgdHlwZTogQ2hlY2tib3hSZXF1aXJlZFZhbGlkYXRvciwgZGVjb3JhdG9yczogW3tcbiAgICAgICAgICAgIHR5cGU6IERpcmVjdGl2ZSxcbiAgICAgICAgICAgIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnaW5wdXRbdHlwZT1jaGVja2JveF1bcmVxdWlyZWRdW2Zvcm1Db250cm9sTmFtZV0saW5wdXRbdHlwZT1jaGVja2JveF1bcmVxdWlyZWRdW2Zvcm1Db250cm9sXSxpbnB1dFt0eXBlPWNoZWNrYm94XVtyZXF1aXJlZF1bbmdNb2RlbF0nLFxuICAgICAgICAgICAgICAgICAgICBwcm92aWRlcnM6IFtDSEVDS0JPWF9SRVFVSVJFRF9WQUxJREFUT1JdLFxuICAgICAgICAgICAgICAgICAgICBob3N0OiB7ICdbYXR0ci5yZXF1aXJlZF0nOiAnX2VuYWJsZWQgPyBcIlwiIDogbnVsbCcgfVxuICAgICAgICAgICAgICAgIH1dXG4gICAgICAgIH1dIH0pO1xuLyoqXG4gKiBAZGVzY3JpcHRpb25cbiAqIFByb3ZpZGVyIHdoaWNoIGFkZHMgYEVtYWlsVmFsaWRhdG9yYCB0byB0aGUgYE5HX1ZBTElEQVRPUlNgIG11bHRpLXByb3ZpZGVyIGxpc3QuXG4gKi9cbmNvbnN0IEVNQUlMX1ZBTElEQVRPUiA9IHtcbiAgICBwcm92aWRlOiBOR19WQUxJREFUT1JTLFxuICAgIHVzZUV4aXN0aW5nOiBmb3J3YXJkUmVmKCgpID0+IEVtYWlsVmFsaWRhdG9yKSxcbiAgICBtdWx0aTogdHJ1ZVxufTtcbi8qKlxuICogQSBkaXJlY3RpdmUgdGhhdCBhZGRzIHRoZSBgZW1haWxgIHZhbGlkYXRvciB0byBjb250cm9scyBtYXJrZWQgd2l0aCB0aGVcbiAqIGBlbWFpbGAgYXR0cmlidXRlLiBUaGUgZGlyZWN0aXZlIGlzIHByb3ZpZGVkIHdpdGggdGhlIGBOR19WQUxJREFUT1JTYCBtdWx0aS1wcm92aWRlciBsaXN0LlxuICpcbiAqIFRoZSBlbWFpbCB2YWxpZGF0aW9uIGlzIGJhc2VkIG9uIHRoZSBXSEFUV0cgSFRNTCBzcGVjaWZpY2F0aW9uIHdpdGggc29tZSBlbmhhbmNlbWVudHMgdG9cbiAqIGluY29ycG9yYXRlIG1vcmUgUkZDIHJ1bGVzLiBNb3JlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBvbiB0aGUgW1ZhbGlkYXRvcnMuZW1haWxcbiAqIHBhZ2VdKGFwaS9mb3Jtcy9WYWxpZGF0b3JzI2VtYWlsKS5cbiAqXG4gKiBAc2VlIFtGb3JtIFZhbGlkYXRpb25dKGd1aWRlL2Zvcm0tdmFsaWRhdGlvbilcbiAqXG4gKiBAdXNhZ2VOb3Rlc1xuICpcbiAqICMjIyBBZGRpbmcgYW4gZW1haWwgdmFsaWRhdG9yXG4gKlxuICogVGhlIGZvbGxvd2luZyBleGFtcGxlIHNob3dzIGhvdyB0byBhZGQgYW4gZW1haWwgdmFsaWRhdG9yIHRvIGFuIGlucHV0IGF0dGFjaGVkIHRvIGFuIG5nTW9kZWxcbiAqIGJpbmRpbmcuXG4gKlxuICogYGBgXG4gKiA8aW5wdXQgdHlwZT1cImVtYWlsXCIgbmFtZT1cImVtYWlsXCIgbmdNb2RlbCBlbWFpbD5cbiAqIDxpbnB1dCB0eXBlPVwiZW1haWxcIiBuYW1lPVwiZW1haWxcIiBuZ01vZGVsIGVtYWlsPVwidHJ1ZVwiPlxuICogPGlucHV0IHR5cGU9XCJlbWFpbFwiIG5hbWU9XCJlbWFpbFwiIG5nTW9kZWwgW2VtYWlsXT1cInRydWVcIj5cbiAqIGBgYFxuICpcbiAqIEBwdWJsaWNBcGlcbiAqIEBuZ01vZHVsZSBGb3Jtc01vZHVsZVxuICogQG5nTW9kdWxlIFJlYWN0aXZlRm9ybXNNb2R1bGVcbiAqL1xuY2xhc3MgRW1haWxWYWxpZGF0b3IgZXh0ZW5kcyBBYnN0cmFjdFZhbGlkYXRvckRpcmVjdGl2ZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgdGhpcy5pbnB1dE5hbWUgPSAnZW1haWwnO1xuICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgIHRoaXMubm9ybWFsaXplSW5wdXQgPSBib29sZWFuQXR0cmlidXRlO1xuICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgIHRoaXMuY3JlYXRlVmFsaWRhdG9yID0gKGlucHV0KSA9PiBlbWFpbFZhbGlkYXRvcjtcbiAgICB9XG4gICAgLyoqIEBub2RvYyAqL1xuICAgIGVuYWJsZWQoaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIGlucHV0O1xuICAgIH1cbiAgICBzdGF0aWMgeyB0aGlzLsm1ZmFjID0gaTAuybXJtW5nRGVjbGFyZUZhY3RvcnkoeyBtaW5WZXJzaW9uOiBcIjEyLjAuMFwiLCB2ZXJzaW9uOiBcIjE3LjMuMTJcIiwgbmdJbXBvcnQ6IGkwLCB0eXBlOiBFbWFpbFZhbGlkYXRvciwgZGVwczogbnVsbCwgdGFyZ2V0OiBpMC7Jtcm1RmFjdG9yeVRhcmdldC5EaXJlY3RpdmUgfSk7IH1cbiAgICBzdGF0aWMgeyB0aGlzLsm1ZGlyID0gaTAuybXJtW5nRGVjbGFyZURpcmVjdGl2ZSh7IG1pblZlcnNpb246IFwiMTQuMC4wXCIsIHZlcnNpb246IFwiMTcuMy4xMlwiLCB0eXBlOiBFbWFpbFZhbGlkYXRvciwgc2VsZWN0b3I6IFwiW2VtYWlsXVtmb3JtQ29udHJvbE5hbWVdLFtlbWFpbF1bZm9ybUNvbnRyb2xdLFtlbWFpbF1bbmdNb2RlbF1cIiwgaW5wdXRzOiB7IGVtYWlsOiBcImVtYWlsXCIgfSwgcHJvdmlkZXJzOiBbRU1BSUxfVkFMSURBVE9SXSwgdXNlc0luaGVyaXRhbmNlOiB0cnVlLCBuZ0ltcG9ydDogaTAgfSk7IH1cbn1cbmkwLsm1ybVuZ0RlY2xhcmVDbGFzc01ldGFkYXRhKHsgbWluVmVyc2lvbjogXCIxMi4wLjBcIiwgdmVyc2lvbjogXCIxNy4zLjEyXCIsIG5nSW1wb3J0OiBpMCwgdHlwZTogRW1haWxWYWxpZGF0b3IsIGRlY29yYXRvcnM6IFt7XG4gICAgICAgICAgICB0eXBlOiBEaXJlY3RpdmUsXG4gICAgICAgICAgICBhcmdzOiBbe1xuICAgICAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ1tlbWFpbF1bZm9ybUNvbnRyb2xOYW1lXSxbZW1haWxdW2Zvcm1Db250cm9sXSxbZW1haWxdW25nTW9kZWxdJyxcbiAgICAgICAgICAgICAgICAgICAgcHJvdmlkZXJzOiBbRU1BSUxfVkFMSURBVE9SXVxuICAgICAgICAgICAgICAgIH1dXG4gICAgICAgIH1dLCBwcm9wRGVjb3JhdG9yczogeyBlbWFpbDogW3tcbiAgICAgICAgICAgICAgICB0eXBlOiBJbnB1dFxuICAgICAgICAgICAgfV0gfSB9KTtcbi8qKlxuICogQGRlc2NyaXB0aW9uXG4gKiBQcm92aWRlciB3aGljaCBhZGRzIGBNaW5MZW5ndGhWYWxpZGF0b3JgIHRvIHRoZSBgTkdfVkFMSURBVE9SU2AgbXVsdGktcHJvdmlkZXIgbGlzdC5cbiAqL1xuY29uc3QgTUlOX0xFTkdUSF9WQUxJREFUT1IgPSB7XG4gICAgcHJvdmlkZTogTkdfVkFMSURBVE9SUyxcbiAgICB1c2VFeGlzdGluZzogZm9yd2FyZFJlZigoKSA9PiBNaW5MZW5ndGhWYWxpZGF0b3IpLFxuICAgIG11bHRpOiB0cnVlXG59O1xuLyoqXG4gKiBBIGRpcmVjdGl2ZSB0aGF0IGFkZHMgbWluaW11bSBsZW5ndGggdmFsaWRhdGlvbiB0byBjb250cm9scyBtYXJrZWQgd2l0aCB0aGVcbiAqIGBtaW5sZW5ndGhgIGF0dHJpYnV0ZS4gVGhlIGRpcmVjdGl2ZSBpcyBwcm92aWRlZCB3aXRoIHRoZSBgTkdfVkFMSURBVE9SU2AgbXVsdGktcHJvdmlkZXIgbGlzdC5cbiAqXG4gKiBAc2VlIFtGb3JtIFZhbGlkYXRpb25dKGd1aWRlL2Zvcm0tdmFsaWRhdGlvbilcbiAqXG4gKiBAdXNhZ2VOb3Rlc1xuICpcbiAqICMjIyBBZGRpbmcgYSBtaW5pbXVtIGxlbmd0aCB2YWxpZGF0b3JcbiAqXG4gKiBUaGUgZm9sbG93aW5nIGV4YW1wbGUgc2hvd3MgaG93IHRvIGFkZCBhIG1pbmltdW0gbGVuZ3RoIHZhbGlkYXRvciB0byBhbiBpbnB1dCBhdHRhY2hlZCB0byBhblxuICogbmdNb2RlbCBiaW5kaW5nLlxuICpcbiAqIGBgYGh0bWxcbiAqIDxpbnB1dCBuYW1lPVwiZmlyc3ROYW1lXCIgbmdNb2RlbCBtaW5sZW5ndGg9XCI0XCI+XG4gKiBgYGBcbiAqXG4gKiBAbmdNb2R1bGUgUmVhY3RpdmVGb3Jtc01vZHVsZVxuICogQG5nTW9kdWxlIEZvcm1zTW9kdWxlXG4gKiBAcHVibGljQXBpXG4gKi9cbmNsYXNzIE1pbkxlbmd0aFZhbGlkYXRvciBleHRlbmRzIEFic3RyYWN0VmFsaWRhdG9yRGlyZWN0aXZlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICB0aGlzLmlucHV0TmFtZSA9ICdtaW5sZW5ndGgnO1xuICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgIHRoaXMubm9ybWFsaXplSW5wdXQgPSAoaW5wdXQpID0+IHRvSW50ZWdlcihpbnB1dCk7XG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgdGhpcy5jcmVhdGVWYWxpZGF0b3IgPSAobWlubGVuZ3RoKSA9PiBtaW5MZW5ndGhWYWxpZGF0b3IobWlubGVuZ3RoKTtcbiAgICB9XG4gICAgc3RhdGljIHsgdGhpcy7JtWZhYyA9IGkwLsm1ybVuZ0RlY2xhcmVGYWN0b3J5KHsgbWluVmVyc2lvbjogXCIxMi4wLjBcIiwgdmVyc2lvbjogXCIxNy4zLjEyXCIsIG5nSW1wb3J0OiBpMCwgdHlwZTogTWluTGVuZ3RoVmFsaWRhdG9yLCBkZXBzOiBudWxsLCB0YXJnZXQ6IGkwLsm1ybVGYWN0b3J5VGFyZ2V0LkRpcmVjdGl2ZSB9KTsgfVxuICAgIHN0YXRpYyB7IHRoaXMuybVkaXIgPSBpMC7Jtcm1bmdEZWNsYXJlRGlyZWN0aXZlKHsgbWluVmVyc2lvbjogXCIxNC4wLjBcIiwgdmVyc2lvbjogXCIxNy4zLjEyXCIsIHR5cGU6IE1pbkxlbmd0aFZhbGlkYXRvciwgc2VsZWN0b3I6IFwiW21pbmxlbmd0aF1bZm9ybUNvbnRyb2xOYW1lXSxbbWlubGVuZ3RoXVtmb3JtQ29udHJvbF0sW21pbmxlbmd0aF1bbmdNb2RlbF1cIiwgaW5wdXRzOiB7IG1pbmxlbmd0aDogXCJtaW5sZW5ndGhcIiB9LCBob3N0OiB7IHByb3BlcnRpZXM6IHsgXCJhdHRyLm1pbmxlbmd0aFwiOiBcIl9lbmFibGVkID8gbWlubGVuZ3RoIDogbnVsbFwiIH0gfSwgcHJvdmlkZXJzOiBbTUlOX0xFTkdUSF9WQUxJREFUT1JdLCB1c2VzSW5oZXJpdGFuY2U6IHRydWUsIG5nSW1wb3J0OiBpMCB9KTsgfVxufVxuaTAuybXJtW5nRGVjbGFyZUNsYXNzTWV0YWRhdGEoeyBtaW5WZXJzaW9uOiBcIjEyLjAuMFwiLCB2ZXJzaW9uOiBcIjE3LjMuMTJcIiwgbmdJbXBvcnQ6IGkwLCB0eXBlOiBNaW5MZW5ndGhWYWxpZGF0b3IsIGRlY29yYXRvcnM6IFt7XG4gICAgICAgICAgICB0eXBlOiBEaXJlY3RpdmUsXG4gICAgICAgICAgICBhcmdzOiBbe1xuICAgICAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ1ttaW5sZW5ndGhdW2Zvcm1Db250cm9sTmFtZV0sW21pbmxlbmd0aF1bZm9ybUNvbnRyb2xdLFttaW5sZW5ndGhdW25nTW9kZWxdJyxcbiAgICAgICAgICAgICAgICAgICAgcHJvdmlkZXJzOiBbTUlOX0xFTkdUSF9WQUxJREFUT1JdLFxuICAgICAgICAgICAgICAgICAgICBob3N0OiB7ICdbYXR0ci5taW5sZW5ndGhdJzogJ19lbmFibGVkID8gbWlubGVuZ3RoIDogbnVsbCcgfVxuICAgICAgICAgICAgICAgIH1dXG4gICAgICAgIH1dLCBwcm9wRGVjb3JhdG9yczogeyBtaW5sZW5ndGg6IFt7XG4gICAgICAgICAgICAgICAgdHlwZTogSW5wdXRcbiAgICAgICAgICAgIH1dIH0gfSk7XG4vKipcbiAqIEBkZXNjcmlwdGlvblxuICogUHJvdmlkZXIgd2hpY2ggYWRkcyBgTWF4TGVuZ3RoVmFsaWRhdG9yYCB0byB0aGUgYE5HX1ZBTElEQVRPUlNgIG11bHRpLXByb3ZpZGVyIGxpc3QuXG4gKi9cbmNvbnN0IE1BWF9MRU5HVEhfVkFMSURBVE9SID0ge1xuICAgIHByb3ZpZGU6IE5HX1ZBTElEQVRPUlMsXG4gICAgdXNlRXhpc3Rpbmc6IGZvcndhcmRSZWYoKCkgPT4gTWF4TGVuZ3RoVmFsaWRhdG9yKSxcbiAgICBtdWx0aTogdHJ1ZVxufTtcbi8qKlxuICogQSBkaXJlY3RpdmUgdGhhdCBhZGRzIG1heGltdW0gbGVuZ3RoIHZhbGlkYXRpb24gdG8gY29udHJvbHMgbWFya2VkIHdpdGggdGhlXG4gKiBgbWF4bGVuZ3RoYCBhdHRyaWJ1dGUuIFRoZSBkaXJlY3RpdmUgaXMgcHJvdmlkZWQgd2l0aCB0aGUgYE5HX1ZBTElEQVRPUlNgIG11bHRpLXByb3ZpZGVyIGxpc3QuXG4gKlxuICogQHNlZSBbRm9ybSBWYWxpZGF0aW9uXShndWlkZS9mb3JtLXZhbGlkYXRpb24pXG4gKlxuICogQHVzYWdlTm90ZXNcbiAqXG4gKiAjIyMgQWRkaW5nIGEgbWF4aW11bSBsZW5ndGggdmFsaWRhdG9yXG4gKlxuICogVGhlIGZvbGxvd2luZyBleGFtcGxlIHNob3dzIGhvdyB0byBhZGQgYSBtYXhpbXVtIGxlbmd0aCB2YWxpZGF0b3IgdG8gYW4gaW5wdXQgYXR0YWNoZWQgdG8gYW5cbiAqIG5nTW9kZWwgYmluZGluZy5cbiAqXG4gKiBgYGBodG1sXG4gKiA8aW5wdXQgbmFtZT1cImZpcnN0TmFtZVwiIG5nTW9kZWwgbWF4bGVuZ3RoPVwiMjVcIj5cbiAqIGBgYFxuICpcbiAqIEBuZ01vZHVsZSBSZWFjdGl2ZUZvcm1zTW9kdWxlXG4gKiBAbmdNb2R1bGUgRm9ybXNNb2R1bGVcbiAqIEBwdWJsaWNBcGlcbiAqL1xuY2xhc3MgTWF4TGVuZ3RoVmFsaWRhdG9yIGV4dGVuZHMgQWJzdHJhY3RWYWxpZGF0b3JEaXJlY3RpdmUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgIHRoaXMuaW5wdXROYW1lID0gJ21heGxlbmd0aCc7XG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgdGhpcy5ub3JtYWxpemVJbnB1dCA9IChpbnB1dCkgPT4gdG9JbnRlZ2VyKGlucHV0KTtcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICB0aGlzLmNyZWF0ZVZhbGlkYXRvciA9IChtYXhsZW5ndGgpID0+IG1heExlbmd0aFZhbGlkYXRvcihtYXhsZW5ndGgpO1xuICAgIH1cbiAgICBzdGF0aWMgeyB0aGlzLsm1ZmFjID0gaTAuybXJtW5nRGVjbGFyZUZhY3RvcnkoeyBtaW5WZXJzaW9uOiBcIjEyLjAuMFwiLCB2ZXJzaW9uOiBcIjE3LjMuMTJcIiwgbmdJbXBvcnQ6IGkwLCB0eXBlOiBNYXhMZW5ndGhWYWxpZGF0b3IsIGRlcHM6IG51bGwsIHRhcmdldDogaTAuybXJtUZhY3RvcnlUYXJnZXQuRGlyZWN0aXZlIH0pOyB9XG4gICAgc3RhdGljIHsgdGhpcy7JtWRpciA9IGkwLsm1ybVuZ0RlY2xhcmVEaXJlY3RpdmUoeyBtaW5WZXJzaW9uOiBcIjE0LjAuMFwiLCB2ZXJzaW9uOiBcIjE3LjMuMTJcIiwgdHlwZTogTWF4TGVuZ3RoVmFsaWRhdG9yLCBzZWxlY3RvcjogXCJbbWF4bGVuZ3RoXVtmb3JtQ29udHJvbE5hbWVdLFttYXhsZW5ndGhdW2Zvcm1Db250cm9sXSxbbWF4bGVuZ3RoXVtuZ01vZGVsXVwiLCBpbnB1dHM6IHsgbWF4bGVuZ3RoOiBcIm1heGxlbmd0aFwiIH0sIGhvc3Q6IHsgcHJvcGVydGllczogeyBcImF0dHIubWF4bGVuZ3RoXCI6IFwiX2VuYWJsZWQgPyBtYXhsZW5ndGggOiBudWxsXCIgfSB9LCBwcm92aWRlcnM6IFtNQVhfTEVOR1RIX1ZBTElEQVRPUl0sIHVzZXNJbmhlcml0YW5jZTogdHJ1ZSwgbmdJbXBvcnQ6IGkwIH0pOyB9XG59XG5pMC7Jtcm1bmdEZWNsYXJlQ2xhc3NNZXRhZGF0YSh7IG1pblZlcnNpb246IFwiMTIuMC4wXCIsIHZlcnNpb246IFwiMTcuMy4xMlwiLCBuZ0ltcG9ydDogaTAsIHR5cGU6IE1heExlbmd0aFZhbGlkYXRvciwgZGVjb3JhdG9yczogW3tcbiAgICAgICAgICAgIHR5cGU6IERpcmVjdGl2ZSxcbiAgICAgICAgICAgIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnW21heGxlbmd0aF1bZm9ybUNvbnRyb2xOYW1lXSxbbWF4bGVuZ3RoXVtmb3JtQ29udHJvbF0sW21heGxlbmd0aF1bbmdNb2RlbF0nLFxuICAgICAgICAgICAgICAgICAgICBwcm92aWRlcnM6IFtNQVhfTEVOR1RIX1ZBTElEQVRPUl0sXG4gICAgICAgICAgICAgICAgICAgIGhvc3Q6IHsgJ1thdHRyLm1heGxlbmd0aF0nOiAnX2VuYWJsZWQgPyBtYXhsZW5ndGggOiBudWxsJyB9XG4gICAgICAgICAgICAgICAgfV1cbiAgICAgICAgfV0sIHByb3BEZWNvcmF0b3JzOiB7IG1heGxlbmd0aDogW3tcbiAgICAgICAgICAgICAgICB0eXBlOiBJbnB1dFxuICAgICAgICAgICAgfV0gfSB9KTtcbi8qKlxuICogQGRlc2NyaXB0aW9uXG4gKiBQcm92aWRlciB3aGljaCBhZGRzIGBQYXR0ZXJuVmFsaWRhdG9yYCB0byB0aGUgYE5HX1ZBTElEQVRPUlNgIG11bHRpLXByb3ZpZGVyIGxpc3QuXG4gKi9cbmNvbnN0IFBBVFRFUk5fVkFMSURBVE9SID0ge1xuICAgIHByb3ZpZGU6IE5HX1ZBTElEQVRPUlMsXG4gICAgdXNlRXhpc3Rpbmc6IGZvcndhcmRSZWYoKCkgPT4gUGF0dGVyblZhbGlkYXRvciksXG4gICAgbXVsdGk6IHRydWVcbn07XG4vKipcbiAqIEBkZXNjcmlwdGlvblxuICogQSBkaXJlY3RpdmUgdGhhdCBhZGRzIHJlZ2V4IHBhdHRlcm4gdmFsaWRhdGlvbiB0byBjb250cm9scyBtYXJrZWQgd2l0aCB0aGVcbiAqIGBwYXR0ZXJuYCBhdHRyaWJ1dGUuIFRoZSByZWdleCBtdXN0IG1hdGNoIHRoZSBlbnRpcmUgY29udHJvbCB2YWx1ZS5cbiAqIFRoZSBkaXJlY3RpdmUgaXMgcHJvdmlkZWQgd2l0aCB0aGUgYE5HX1ZBTElEQVRPUlNgIG11bHRpLXByb3ZpZGVyIGxpc3QuXG4gKlxuICogQHNlZSBbRm9ybSBWYWxpZGF0aW9uXShndWlkZS9mb3JtLXZhbGlkYXRpb24pXG4gKlxuICogQHVzYWdlTm90ZXNcbiAqXG4gKiAjIyMgQWRkaW5nIGEgcGF0dGVybiB2YWxpZGF0b3JcbiAqXG4gKiBUaGUgZm9sbG93aW5nIGV4YW1wbGUgc2hvd3MgaG93IHRvIGFkZCBhIHBhdHRlcm4gdmFsaWRhdG9yIHRvIGFuIGlucHV0IGF0dGFjaGVkIHRvIGFuXG4gKiBuZ01vZGVsIGJpbmRpbmcuXG4gKlxuICogYGBgaHRtbFxuICogPGlucHV0IG5hbWU9XCJmaXJzdE5hbWVcIiBuZ01vZGVsIHBhdHRlcm49XCJbYS16QS1aIF0qXCI+XG4gKiBgYGBcbiAqXG4gKiBAbmdNb2R1bGUgUmVhY3RpdmVGb3Jtc01vZHVsZVxuICogQG5nTW9kdWxlIEZvcm1zTW9kdWxlXG4gKiBAcHVibGljQXBpXG4gKi9cbmNsYXNzIFBhdHRlcm5WYWxpZGF0b3IgZXh0ZW5kcyBBYnN0cmFjdFZhbGlkYXRvckRpcmVjdGl2ZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgdGhpcy5pbnB1dE5hbWUgPSAncGF0dGVybic7XG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgdGhpcy5ub3JtYWxpemVJbnB1dCA9IChpbnB1dCkgPT4gaW5wdXQ7XG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgdGhpcy5jcmVhdGVWYWxpZGF0b3IgPSAoaW5wdXQpID0+IHBhdHRlcm5WYWxpZGF0b3IoaW5wdXQpO1xuICAgIH1cbiAgICBzdGF0aWMgeyB0aGlzLsm1ZmFjID0gaTAuybXJtW5nRGVjbGFyZUZhY3RvcnkoeyBtaW5WZXJzaW9uOiBcIjEyLjAuMFwiLCB2ZXJzaW9uOiBcIjE3LjMuMTJcIiwgbmdJbXBvcnQ6IGkwLCB0eXBlOiBQYXR0ZXJuVmFsaWRhdG9yLCBkZXBzOiBudWxsLCB0YXJnZXQ6IGkwLsm1ybVGYWN0b3J5VGFyZ2V0LkRpcmVjdGl2ZSB9KTsgfVxuICAgIHN0YXRpYyB7IHRoaXMuybVkaXIgPSBpMC7Jtcm1bmdEZWNsYXJlRGlyZWN0aXZlKHsgbWluVmVyc2lvbjogXCIxNC4wLjBcIiwgdmVyc2lvbjogXCIxNy4zLjEyXCIsIHR5cGU6IFBhdHRlcm5WYWxpZGF0b3IsIHNlbGVjdG9yOiBcIltwYXR0ZXJuXVtmb3JtQ29udHJvbE5hbWVdLFtwYXR0ZXJuXVtmb3JtQ29udHJvbF0sW3BhdHRlcm5dW25nTW9kZWxdXCIsIGlucHV0czogeyBwYXR0ZXJuOiBcInBhdHRlcm5cIiB9LCBob3N0OiB7IHByb3BlcnRpZXM6IHsgXCJhdHRyLnBhdHRlcm5cIjogXCJfZW5hYmxlZCA/IHBhdHRlcm4gOiBudWxsXCIgfSB9LCBwcm92aWRlcnM6IFtQQVRURVJOX1ZBTElEQVRPUl0sIHVzZXNJbmhlcml0YW5jZTogdHJ1ZSwgbmdJbXBvcnQ6IGkwIH0pOyB9XG59XG5pMC7Jtcm1bmdEZWNsYXJlQ2xhc3NNZXRhZGF0YSh7IG1pblZlcnNpb246IFwiMTIuMC4wXCIsIHZlcnNpb246IFwiMTcuMy4xMlwiLCBuZ0ltcG9ydDogaTAsIHR5cGU6IFBhdHRlcm5WYWxpZGF0b3IsIGRlY29yYXRvcnM6IFt7XG4gICAgICAgICAgICB0eXBlOiBEaXJlY3RpdmUsXG4gICAgICAgICAgICBhcmdzOiBbe1xuICAgICAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ1twYXR0ZXJuXVtmb3JtQ29udHJvbE5hbWVdLFtwYXR0ZXJuXVtmb3JtQ29udHJvbF0sW3BhdHRlcm5dW25nTW9kZWxdJyxcbiAgICAgICAgICAgICAgICAgICAgcHJvdmlkZXJzOiBbUEFUVEVSTl9WQUxJREFUT1JdLFxuICAgICAgICAgICAgICAgICAgICBob3N0OiB7ICdbYXR0ci5wYXR0ZXJuXSc6ICdfZW5hYmxlZCA/IHBhdHRlcm4gOiBudWxsJyB9XG4gICAgICAgICAgICAgICAgfV1cbiAgICAgICAgfV0sIHByb3BEZWNvcmF0b3JzOiB7IHBhdHRlcm46IFt7XG4gICAgICAgICAgICAgICAgdHlwZTogSW5wdXRcbiAgICAgICAgICAgIH1dIH0gfSk7XG5cbmNvbnN0IFNIQVJFRF9GT1JNX0RJUkVDVElWRVMgPSBbXG4gICAgybVOZ05vVmFsaWRhdGUsXG4gICAgTmdTZWxlY3RPcHRpb24sXG4gICAgybVOZ1NlbGVjdE11bHRpcGxlT3B0aW9uLFxuICAgIERlZmF1bHRWYWx1ZUFjY2Vzc29yLFxuICAgIE51bWJlclZhbHVlQWNjZXNzb3IsXG4gICAgUmFuZ2VWYWx1ZUFjY2Vzc29yLFxuICAgIENoZWNrYm94Q29udHJvbFZhbHVlQWNjZXNzb3IsXG4gICAgU2VsZWN0Q29udHJvbFZhbHVlQWNjZXNzb3IsXG4gICAgU2VsZWN0TXVsdGlwbGVDb250cm9sVmFsdWVBY2Nlc3NvcixcbiAgICBSYWRpb0NvbnRyb2xWYWx1ZUFjY2Vzc29yLFxuICAgIE5nQ29udHJvbFN0YXR1cyxcbiAgICBOZ0NvbnRyb2xTdGF0dXNHcm91cCxcbiAgICBSZXF1aXJlZFZhbGlkYXRvcixcbiAgICBNaW5MZW5ndGhWYWxpZGF0b3IsXG4gICAgTWF4TGVuZ3RoVmFsaWRhdG9yLFxuICAgIFBhdHRlcm5WYWxpZGF0b3IsXG4gICAgQ2hlY2tib3hSZXF1aXJlZFZhbGlkYXRvcixcbiAgICBFbWFpbFZhbGlkYXRvcixcbiAgICBNaW5WYWxpZGF0b3IsXG4gICAgTWF4VmFsaWRhdG9yLFxuXTtcbmNvbnN0IFRFTVBMQVRFX0RSSVZFTl9ESVJFQ1RJVkVTID0gW05nTW9kZWwsIE5nTW9kZWxHcm91cCwgTmdGb3JtXTtcbmNvbnN0IFJFQUNUSVZFX0RSSVZFTl9ESVJFQ1RJVkVTID0gW0Zvcm1Db250cm9sRGlyZWN0aXZlLCBGb3JtR3JvdXBEaXJlY3RpdmUsIEZvcm1Db250cm9sTmFtZSwgRm9ybUdyb3VwTmFtZSwgRm9ybUFycmF5TmFtZV07XG4vKipcbiAqIEludGVybmFsIG1vZHVsZSB1c2VkIGZvciBzaGFyaW5nIGRpcmVjdGl2ZXMgYmV0d2VlbiBGb3Jtc01vZHVsZSBhbmQgUmVhY3RpdmVGb3Jtc01vZHVsZVxuICovXG5jbGFzcyDJtUludGVybmFsRm9ybXNTaGFyZWRNb2R1bGUge1xuICAgIHN0YXRpYyB7IHRoaXMuybVmYWMgPSBpMC7Jtcm1bmdEZWNsYXJlRmFjdG9yeSh7IG1pblZlcnNpb246IFwiMTIuMC4wXCIsIHZlcnNpb246IFwiMTcuMy4xMlwiLCBuZ0ltcG9ydDogaTAsIHR5cGU6IMm1SW50ZXJuYWxGb3Jtc1NoYXJlZE1vZHVsZSwgZGVwczogW10sIHRhcmdldDogaTAuybXJtUZhY3RvcnlUYXJnZXQuTmdNb2R1bGUgfSk7IH1cbiAgICBzdGF0aWMgeyB0aGlzLsm1bW9kID0gaTAuybXJtW5nRGVjbGFyZU5nTW9kdWxlKHsgbWluVmVyc2lvbjogXCIxNC4wLjBcIiwgdmVyc2lvbjogXCIxNy4zLjEyXCIsIG5nSW1wb3J0OiBpMCwgdHlwZTogybVJbnRlcm5hbEZvcm1zU2hhcmVkTW9kdWxlLCBkZWNsYXJhdGlvbnM6IFvJtU5nTm9WYWxpZGF0ZSxcbiAgICAgICAgICAgIE5nU2VsZWN0T3B0aW9uLFxuICAgICAgICAgICAgybVOZ1NlbGVjdE11bHRpcGxlT3B0aW9uLFxuICAgICAgICAgICAgRGVmYXVsdFZhbHVlQWNjZXNzb3IsXG4gICAgICAgICAgICBOdW1iZXJWYWx1ZUFjY2Vzc29yLFxuICAgICAgICAgICAgUmFuZ2VWYWx1ZUFjY2Vzc29yLFxuICAgICAgICAgICAgQ2hlY2tib3hDb250cm9sVmFsdWVBY2Nlc3NvcixcbiAgICAgICAgICAgIFNlbGVjdENvbnRyb2xWYWx1ZUFjY2Vzc29yLFxuICAgICAgICAgICAgU2VsZWN0TXVsdGlwbGVDb250cm9sVmFsdWVBY2Nlc3NvcixcbiAgICAgICAgICAgIFJhZGlvQ29udHJvbFZhbHVlQWNjZXNzb3IsXG4gICAgICAgICAgICBOZ0NvbnRyb2xTdGF0dXMsXG4gICAgICAgICAgICBOZ0NvbnRyb2xTdGF0dXNHcm91cCxcbiAgICAgICAgICAgIFJlcXVpcmVkVmFsaWRhdG9yLFxuICAgICAgICAgICAgTWluTGVuZ3RoVmFsaWRhdG9yLFxuICAgICAgICAgICAgTWF4TGVuZ3RoVmFsaWRhdG9yLFxuICAgICAgICAgICAgUGF0dGVyblZhbGlkYXRvcixcbiAgICAgICAgICAgIENoZWNrYm94UmVxdWlyZWRWYWxpZGF0b3IsXG4gICAgICAgICAgICBFbWFpbFZhbGlkYXRvcixcbiAgICAgICAgICAgIE1pblZhbGlkYXRvcixcbiAgICAgICAgICAgIE1heFZhbGlkYXRvcl0sIGV4cG9ydHM6IFvJtU5nTm9WYWxpZGF0ZSxcbiAgICAgICAgICAgIE5nU2VsZWN0T3B0aW9uLFxuICAgICAgICAgICAgybVOZ1NlbGVjdE11bHRpcGxlT3B0aW9uLFxuICAgICAgICAgICAgRGVmYXVsdFZhbHVlQWNjZXNzb3IsXG4gICAgICAgICAgICBOdW1iZXJWYWx1ZUFjY2Vzc29yLFxuICAgICAgICAgICAgUmFuZ2VWYWx1ZUFjY2Vzc29yLFxuICAgICAgICAgICAgQ2hlY2tib3hDb250cm9sVmFsdWVBY2Nlc3NvcixcbiAgICAgICAgICAgIFNlbGVjdENvbnRyb2xWYWx1ZUFjY2Vzc29yLFxuICAgICAgICAgICAgU2VsZWN0TXVsdGlwbGVDb250cm9sVmFsdWVBY2Nlc3NvcixcbiAgICAgICAgICAgIFJhZGlvQ29udHJvbFZhbHVlQWNjZXNzb3IsXG4gICAgICAgICAgICBOZ0NvbnRyb2xTdGF0dXMsXG4gICAgICAgICAgICBOZ0NvbnRyb2xTdGF0dXNHcm91cCxcbiAgICAgICAgICAgIFJlcXVpcmVkVmFsaWRhdG9yLFxuICAgICAgICAgICAgTWluTGVuZ3RoVmFsaWRhdG9yLFxuICAgICAgICAgICAgTWF4TGVuZ3RoVmFsaWRhdG9yLFxuICAgICAgICAgICAgUGF0dGVyblZhbGlkYXRvcixcbiAgICAgICAgICAgIENoZWNrYm94UmVxdWlyZWRWYWxpZGF0b3IsXG4gICAgICAgICAgICBFbWFpbFZhbGlkYXRvcixcbiAgICAgICAgICAgIE1pblZhbGlkYXRvcixcbiAgICAgICAgICAgIE1heFZhbGlkYXRvcl0gfSk7IH1cbiAgICBzdGF0aWMgeyB0aGlzLsm1aW5qID0gaTAuybXJtW5nRGVjbGFyZUluamVjdG9yKHsgbWluVmVyc2lvbjogXCIxMi4wLjBcIiwgdmVyc2lvbjogXCIxNy4zLjEyXCIsIG5nSW1wb3J0OiBpMCwgdHlwZTogybVJbnRlcm5hbEZvcm1zU2hhcmVkTW9kdWxlIH0pOyB9XG59XG5pMC7Jtcm1bmdEZWNsYXJlQ2xhc3NNZXRhZGF0YSh7IG1pblZlcnNpb246IFwiMTIuMC4wXCIsIHZlcnNpb246IFwiMTcuMy4xMlwiLCBuZ0ltcG9ydDogaTAsIHR5cGU6IMm1SW50ZXJuYWxGb3Jtc1NoYXJlZE1vZHVsZSwgZGVjb3JhdG9yczogW3tcbiAgICAgICAgICAgIHR5cGU6IE5nTW9kdWxlLFxuICAgICAgICAgICAgYXJnczogW3tcbiAgICAgICAgICAgICAgICAgICAgZGVjbGFyYXRpb25zOiBTSEFSRURfRk9STV9ESVJFQ1RJVkVTLFxuICAgICAgICAgICAgICAgICAgICBleHBvcnRzOiBTSEFSRURfRk9STV9ESVJFQ1RJVkVTLFxuICAgICAgICAgICAgICAgIH1dXG4gICAgICAgIH1dIH0pO1xuXG4vKipcbiAqIFRyYWNrcyB0aGUgdmFsdWUgYW5kIHZhbGlkaXR5IHN0YXRlIG9mIGFuIGFycmF5IG9mIGBGb3JtQ29udHJvbGAsXG4gKiBgRm9ybUdyb3VwYCBvciBgRm9ybUFycmF5YCBpbnN0YW5jZXMuXG4gKlxuICogQSBgRm9ybUFycmF5YCBhZ2dyZWdhdGVzIHRoZSB2YWx1ZXMgb2YgZWFjaCBjaGlsZCBgRm9ybUNvbnRyb2xgIGludG8gYW4gYXJyYXkuXG4gKiBJdCBjYWxjdWxhdGVzIGl0cyBzdGF0dXMgYnkgcmVkdWNpbmcgdGhlIHN0YXR1cyB2YWx1ZXMgb2YgaXRzIGNoaWxkcmVuLiBGb3IgZXhhbXBsZSwgaWYgb25lIG9mXG4gKiB0aGUgY29udHJvbHMgaW4gYSBgRm9ybUFycmF5YCBpcyBpbnZhbGlkLCB0aGUgZW50aXJlIGFycmF5IGJlY29tZXMgaW52YWxpZC5cbiAqXG4gKiBgRm9ybUFycmF5YCBhY2NlcHRzIG9uZSBnZW5lcmljIGFyZ3VtZW50LCB3aGljaCBpcyB0aGUgdHlwZSBvZiB0aGUgY29udHJvbHMgaW5zaWRlLlxuICogSWYgeW91IG5lZWQgYSBoZXRlcm9nZW5vdXMgYXJyYXksIHVzZSB7QGxpbmsgVW50eXBlZEZvcm1BcnJheX0uXG4gKlxuICogYEZvcm1BcnJheWAgaXMgb25lIG9mIHRoZSBmb3VyIGZ1bmRhbWVudGFsIGJ1aWxkaW5nIGJsb2NrcyB1c2VkIHRvIGRlZmluZSBmb3JtcyBpbiBBbmd1bGFyLFxuICogYWxvbmcgd2l0aCBgRm9ybUNvbnRyb2xgLCBgRm9ybUdyb3VwYCwgYW5kIGBGb3JtUmVjb3JkYC5cbiAqXG4gKiBAdXNhZ2VOb3Rlc1xuICpcbiAqICMjIyBDcmVhdGUgYW4gYXJyYXkgb2YgZm9ybSBjb250cm9sc1xuICpcbiAqIGBgYFxuICogY29uc3QgYXJyID0gbmV3IEZvcm1BcnJheShbXG4gKiAgIG5ldyBGb3JtQ29udHJvbCgnTmFuY3knLCBWYWxpZGF0b3JzLm1pbkxlbmd0aCgyKSksXG4gKiAgIG5ldyBGb3JtQ29udHJvbCgnRHJldycpLFxuICogXSk7XG4gKlxuICogY29uc29sZS5sb2coYXJyLnZhbHVlKTsgICAvLyBbJ05hbmN5JywgJ0RyZXcnXVxuICogY29uc29sZS5sb2coYXJyLnN0YXR1cyk7ICAvLyAnVkFMSUQnXG4gKiBgYGBcbiAqXG4gKiAjIyMgQ3JlYXRlIGEgZm9ybSBhcnJheSB3aXRoIGFycmF5LWxldmVsIHZhbGlkYXRvcnNcbiAqXG4gKiBZb3UgaW5jbHVkZSBhcnJheS1sZXZlbCB2YWxpZGF0b3JzIGFuZCBhc3luYyB2YWxpZGF0b3JzLiBUaGVzZSBjb21lIGluIGhhbmR5XG4gKiB3aGVuIHlvdSB3YW50IHRvIHBlcmZvcm0gdmFsaWRhdGlvbiB0aGF0IGNvbnNpZGVycyB0aGUgdmFsdWUgb2YgbW9yZSB0aGFuIG9uZSBjaGlsZFxuICogY29udHJvbC5cbiAqXG4gKiBUaGUgdHdvIHR5cGVzIG9mIHZhbGlkYXRvcnMgYXJlIHBhc3NlZCBpbiBzZXBhcmF0ZWx5IGFzIHRoZSBzZWNvbmQgYW5kIHRoaXJkIGFyZ1xuICogcmVzcGVjdGl2ZWx5LCBvciB0b2dldGhlciBhcyBwYXJ0IG9mIGFuIG9wdGlvbnMgb2JqZWN0LlxuICpcbiAqIGBgYFxuICogY29uc3QgYXJyID0gbmV3IEZvcm1BcnJheShbXG4gKiAgIG5ldyBGb3JtQ29udHJvbCgnTmFuY3knKSxcbiAqICAgbmV3IEZvcm1Db250cm9sKCdEcmV3JylcbiAqIF0sIHt2YWxpZGF0b3JzOiBteVZhbGlkYXRvciwgYXN5bmNWYWxpZGF0b3JzOiBteUFzeW5jVmFsaWRhdG9yfSk7XG4gKiBgYGBcbiAqXG4gKiAjIyMgU2V0IHRoZSB1cGRhdGVPbiBwcm9wZXJ0eSBmb3IgYWxsIGNvbnRyb2xzIGluIGEgZm9ybSBhcnJheVxuICpcbiAqIFRoZSBvcHRpb25zIG9iamVjdCBpcyB1c2VkIHRvIHNldCBhIGRlZmF1bHQgdmFsdWUgZm9yIGVhY2ggY2hpbGRcbiAqIGNvbnRyb2wncyBgdXBkYXRlT25gIHByb3BlcnR5LiBJZiB5b3Ugc2V0IGB1cGRhdGVPbmAgdG8gYCdibHVyJ2AgYXQgdGhlXG4gKiBhcnJheSBsZXZlbCwgYWxsIGNoaWxkIGNvbnRyb2xzIGRlZmF1bHQgdG8gJ2JsdXInLCB1bmxlc3MgdGhlIGNoaWxkXG4gKiBoYXMgZXhwbGljaXRseSBzcGVjaWZpZWQgYSBkaWZmZXJlbnQgYHVwZGF0ZU9uYCB2YWx1ZS5cbiAqXG4gKiBgYGB0c1xuICogY29uc3QgYXJyID0gbmV3IEZvcm1BcnJheShbXG4gKiAgICBuZXcgRm9ybUNvbnRyb2woKVxuICogXSwge3VwZGF0ZU9uOiAnYmx1cid9KTtcbiAqIGBgYFxuICpcbiAqICMjIyBBZGRpbmcgb3IgcmVtb3ZpbmcgY29udHJvbHMgZnJvbSBhIGZvcm0gYXJyYXlcbiAqXG4gKiBUbyBjaGFuZ2UgdGhlIGNvbnRyb2xzIGluIHRoZSBhcnJheSwgdXNlIHRoZSBgcHVzaGAsIGBpbnNlcnRgLCBgcmVtb3ZlQXRgIG9yIGBjbGVhcmAgbWV0aG9kc1xuICogaW4gYEZvcm1BcnJheWAgaXRzZWxmLiBUaGVzZSBtZXRob2RzIGVuc3VyZSB0aGUgY29udHJvbHMgYXJlIHByb3Blcmx5IHRyYWNrZWQgaW4gdGhlXG4gKiBmb3JtJ3MgaGllcmFyY2h5LiBEbyBub3QgbW9kaWZ5IHRoZSBhcnJheSBvZiBgQWJzdHJhY3RDb250cm9sYHMgdXNlZCB0byBpbnN0YW50aWF0ZVxuICogdGhlIGBGb3JtQXJyYXlgIGRpcmVjdGx5LCBhcyB0aGF0IHJlc3VsdCBpbiBzdHJhbmdlIGFuZCB1bmV4cGVjdGVkIGJlaGF2aW9yIHN1Y2hcbiAqIGFzIGJyb2tlbiBjaGFuZ2UgZGV0ZWN0aW9uLlxuICpcbiAqIEBwdWJsaWNBcGlcbiAqL1xuY2xhc3MgRm9ybUFycmF5IGV4dGVuZHMgQWJzdHJhY3RDb250cm9sIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGBGb3JtQXJyYXlgIGluc3RhbmNlLlxuICAgICAqXG4gICAgICogQHBhcmFtIGNvbnRyb2xzIEFuIGFycmF5IG9mIGNoaWxkIGNvbnRyb2xzLiBFYWNoIGNoaWxkIGNvbnRyb2wgaXMgZ2l2ZW4gYW4gaW5kZXhcbiAgICAgKiB3aGVyZSBpdCBpcyByZWdpc3RlcmVkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHZhbGlkYXRvck9yT3B0cyBBIHN5bmNocm9ub3VzIHZhbGlkYXRvciBmdW5jdGlvbiwgb3IgYW4gYXJyYXkgb2ZcbiAgICAgKiBzdWNoIGZ1bmN0aW9ucywgb3IgYW4gYEFic3RyYWN0Q29udHJvbE9wdGlvbnNgIG9iamVjdCB0aGF0IGNvbnRhaW5zIHZhbGlkYXRpb24gZnVuY3Rpb25zXG4gICAgICogYW5kIGEgdmFsaWRhdGlvbiB0cmlnZ2VyLlxuICAgICAqXG4gICAgICogQHBhcmFtIGFzeW5jVmFsaWRhdG9yIEEgc2luZ2xlIGFzeW5jIHZhbGlkYXRvciBvciBhcnJheSBvZiBhc3luYyB2YWxpZGF0b3IgZnVuY3Rpb25zXG4gICAgICpcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihjb250cm9scywgdmFsaWRhdG9yT3JPcHRzLCBhc3luY1ZhbGlkYXRvcikge1xuICAgICAgICBzdXBlcihwaWNrVmFsaWRhdG9ycyh2YWxpZGF0b3JPck9wdHMpLCBwaWNrQXN5bmNWYWxpZGF0b3JzKGFzeW5jVmFsaWRhdG9yLCB2YWxpZGF0b3JPck9wdHMpKTtcbiAgICAgICAgdGhpcy5jb250cm9scyA9IGNvbnRyb2xzO1xuICAgICAgICB0aGlzLl9pbml0T2JzZXJ2YWJsZXMoKTtcbiAgICAgICAgdGhpcy5fc2V0VXBkYXRlU3RyYXRlZ3kodmFsaWRhdG9yT3JPcHRzKTtcbiAgICAgICAgdGhpcy5fc2V0VXBDb250cm9scygpO1xuICAgICAgICB0aGlzLnVwZGF0ZVZhbHVlQW5kVmFsaWRpdHkoe1xuICAgICAgICAgICAgb25seVNlbGY6IHRydWUsXG4gICAgICAgICAgICAvLyBJZiBgYXN5bmNWYWxpZGF0b3JgIGlzIHByZXNlbnQsIGl0IHdpbGwgdHJpZ2dlciBjb250cm9sIHN0YXR1cyBjaGFuZ2UgZnJvbSBgUEVORElOR2AgdG9cbiAgICAgICAgICAgIC8vIGBWQUxJRGAgb3IgYElOVkFMSURgLlxuICAgICAgICAgICAgLy8gVGhlIHN0YXR1cyBzaG91bGQgYmUgYnJvYWRjYXN0ZWQgdmlhIHRoZSBgc3RhdHVzQ2hhbmdlc2Agb2JzZXJ2YWJsZSwgc28gd2Ugc2V0IGBlbWl0RXZlbnRgXG4gICAgICAgICAgICAvLyB0byBgdHJ1ZWAgdG8gYWxsb3cgdGhhdCBkdXJpbmcgdGhlIGNvbnRyb2wgY3JlYXRpb24gcHJvY2Vzcy5cbiAgICAgICAgICAgIGVtaXRFdmVudDogISF0aGlzLmFzeW5jVmFsaWRhdG9yXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGBBYnN0cmFjdENvbnRyb2xgIGF0IHRoZSBnaXZlbiBgaW5kZXhgIGluIHRoZSBhcnJheS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBpbmRleCBJbmRleCBpbiB0aGUgYXJyYXkgdG8gcmV0cmlldmUgdGhlIGNvbnRyb2wuIElmIGBpbmRleGAgaXMgbmVnYXRpdmUsIGl0IHdpbGwgd3JhcFxuICAgICAqICAgICBhcm91bmQgZnJvbSB0aGUgYmFjaywgYW5kIGlmIGluZGV4IGlzIGdyZWF0bHkgbmVnYXRpdmUgKGxlc3MgdGhhbiBgLWxlbmd0aGApLCB0aGUgcmVzdWx0IGlzXG4gICAgICogdW5kZWZpbmVkLiBUaGlzIGJlaGF2aW9yIGlzIHRoZSBzYW1lIGFzIGBBcnJheS5hdChpbmRleClgLlxuICAgICAqL1xuICAgIGF0KGluZGV4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnRyb2xzW3RoaXMuX2FkanVzdEluZGV4KGluZGV4KV07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEluc2VydCBhIG5ldyBgQWJzdHJhY3RDb250cm9sYCBhdCB0aGUgZW5kIG9mIHRoZSBhcnJheS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBjb250cm9sIEZvcm0gY29udHJvbCB0byBiZSBpbnNlcnRlZFxuICAgICAqIEBwYXJhbSBvcHRpb25zIFNwZWNpZmllcyB3aGV0aGVyIHRoaXMgRm9ybUFycmF5IGluc3RhbmNlIHNob3VsZCBlbWl0IGV2ZW50cyBhZnRlciBhIG5ld1xuICAgICAqICAgICBjb250cm9sIGlzIGFkZGVkLlxuICAgICAqICogYGVtaXRFdmVudGA6IFdoZW4gdHJ1ZSBvciBub3Qgc3VwcGxpZWQgKHRoZSBkZWZhdWx0KSwgYm90aCB0aGUgYHN0YXR1c0NoYW5nZXNgIGFuZFxuICAgICAqIGB2YWx1ZUNoYW5nZXNgIG9ic2VydmFibGVzIGVtaXQgZXZlbnRzIHdpdGggdGhlIGxhdGVzdCBzdGF0dXMgYW5kIHZhbHVlIHdoZW4gdGhlIGNvbnRyb2wgaXNcbiAgICAgKiBpbnNlcnRlZC4gV2hlbiBmYWxzZSwgbm8gZXZlbnRzIGFyZSBlbWl0dGVkLlxuICAgICAqL1xuICAgIHB1c2goY29udHJvbCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIHRoaXMuY29udHJvbHMucHVzaChjb250cm9sKTtcbiAgICAgICAgdGhpcy5fcmVnaXN0ZXJDb250cm9sKGNvbnRyb2wpO1xuICAgICAgICB0aGlzLnVwZGF0ZVZhbHVlQW5kVmFsaWRpdHkoeyBlbWl0RXZlbnQ6IG9wdGlvbnMuZW1pdEV2ZW50IH0pO1xuICAgICAgICB0aGlzLl9vbkNvbGxlY3Rpb25DaGFuZ2UoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSW5zZXJ0IGEgbmV3IGBBYnN0cmFjdENvbnRyb2xgIGF0IHRoZSBnaXZlbiBgaW5kZXhgIGluIHRoZSBhcnJheS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBpbmRleCBJbmRleCBpbiB0aGUgYXJyYXkgdG8gaW5zZXJ0IHRoZSBjb250cm9sLiBJZiBgaW5kZXhgIGlzIG5lZ2F0aXZlLCB3cmFwcyBhcm91bmRcbiAgICAgKiAgICAgZnJvbSB0aGUgYmFjay4gSWYgYGluZGV4YCBpcyBncmVhdGx5IG5lZ2F0aXZlIChsZXNzIHRoYW4gYC1sZW5ndGhgKSwgcHJlcGVuZHMgdG8gdGhlIGFycmF5LlxuICAgICAqIFRoaXMgYmVoYXZpb3IgaXMgdGhlIHNhbWUgYXMgYEFycmF5LnNwbGljZShpbmRleCwgMCwgY29udHJvbClgLlxuICAgICAqIEBwYXJhbSBjb250cm9sIEZvcm0gY29udHJvbCB0byBiZSBpbnNlcnRlZFxuICAgICAqIEBwYXJhbSBvcHRpb25zIFNwZWNpZmllcyB3aGV0aGVyIHRoaXMgRm9ybUFycmF5IGluc3RhbmNlIHNob3VsZCBlbWl0IGV2ZW50cyBhZnRlciBhIG5ld1xuICAgICAqICAgICBjb250cm9sIGlzIGluc2VydGVkLlxuICAgICAqICogYGVtaXRFdmVudGA6IFdoZW4gdHJ1ZSBvciBub3Qgc3VwcGxpZWQgKHRoZSBkZWZhdWx0KSwgYm90aCB0aGUgYHN0YXR1c0NoYW5nZXNgIGFuZFxuICAgICAqIGB2YWx1ZUNoYW5nZXNgIG9ic2VydmFibGVzIGVtaXQgZXZlbnRzIHdpdGggdGhlIGxhdGVzdCBzdGF0dXMgYW5kIHZhbHVlIHdoZW4gdGhlIGNvbnRyb2wgaXNcbiAgICAgKiBpbnNlcnRlZC4gV2hlbiBmYWxzZSwgbm8gZXZlbnRzIGFyZSBlbWl0dGVkLlxuICAgICAqL1xuICAgIGluc2VydChpbmRleCwgY29udHJvbCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIHRoaXMuY29udHJvbHMuc3BsaWNlKGluZGV4LCAwLCBjb250cm9sKTtcbiAgICAgICAgdGhpcy5fcmVnaXN0ZXJDb250cm9sKGNvbnRyb2wpO1xuICAgICAgICB0aGlzLnVwZGF0ZVZhbHVlQW5kVmFsaWRpdHkoeyBlbWl0RXZlbnQ6IG9wdGlvbnMuZW1pdEV2ZW50IH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZW1vdmUgdGhlIGNvbnRyb2wgYXQgdGhlIGdpdmVuIGBpbmRleGAgaW4gdGhlIGFycmF5LlxuICAgICAqXG4gICAgICogQHBhcmFtIGluZGV4IEluZGV4IGluIHRoZSBhcnJheSB0byByZW1vdmUgdGhlIGNvbnRyb2wuICBJZiBgaW5kZXhgIGlzIG5lZ2F0aXZlLCB3cmFwcyBhcm91bmRcbiAgICAgKiAgICAgZnJvbSB0aGUgYmFjay4gSWYgYGluZGV4YCBpcyBncmVhdGx5IG5lZ2F0aXZlIChsZXNzIHRoYW4gYC1sZW5ndGhgKSwgcmVtb3ZlcyB0aGUgZmlyc3RcbiAgICAgKiAgICAgZWxlbWVudC4gVGhpcyBiZWhhdmlvciBpcyB0aGUgc2FtZSBhcyBgQXJyYXkuc3BsaWNlKGluZGV4LCAxKWAuXG4gICAgICogQHBhcmFtIG9wdGlvbnMgU3BlY2lmaWVzIHdoZXRoZXIgdGhpcyBGb3JtQXJyYXkgaW5zdGFuY2Ugc2hvdWxkIGVtaXQgZXZlbnRzIGFmdGVyIGFcbiAgICAgKiAgICAgY29udHJvbCBpcyByZW1vdmVkLlxuICAgICAqICogYGVtaXRFdmVudGA6IFdoZW4gdHJ1ZSBvciBub3Qgc3VwcGxpZWQgKHRoZSBkZWZhdWx0KSwgYm90aCB0aGUgYHN0YXR1c0NoYW5nZXNgIGFuZFxuICAgICAqIGB2YWx1ZUNoYW5nZXNgIG9ic2VydmFibGVzIGVtaXQgZXZlbnRzIHdpdGggdGhlIGxhdGVzdCBzdGF0dXMgYW5kIHZhbHVlIHdoZW4gdGhlIGNvbnRyb2wgaXNcbiAgICAgKiByZW1vdmVkLiBXaGVuIGZhbHNlLCBubyBldmVudHMgYXJlIGVtaXR0ZWQuXG4gICAgICovXG4gICAgcmVtb3ZlQXQoaW5kZXgsIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICAvLyBBZGp1c3QgdGhlIGluZGV4LCB0aGVuIGNsYW1wIGl0IGF0IG5vIGxlc3MgdGhhbiAwIHRvIHByZXZlbnQgdW5kZXNpcmVkIHVuZGVyZmxvd3MuXG4gICAgICAgIGxldCBhZGp1c3RlZEluZGV4ID0gdGhpcy5fYWRqdXN0SW5kZXgoaW5kZXgpO1xuICAgICAgICBpZiAoYWRqdXN0ZWRJbmRleCA8IDApXG4gICAgICAgICAgICBhZGp1c3RlZEluZGV4ID0gMDtcbiAgICAgICAgaWYgKHRoaXMuY29udHJvbHNbYWRqdXN0ZWRJbmRleF0pXG4gICAgICAgICAgICB0aGlzLmNvbnRyb2xzW2FkanVzdGVkSW5kZXhdLl9yZWdpc3Rlck9uQ29sbGVjdGlvbkNoYW5nZSgoKSA9PiB7IH0pO1xuICAgICAgICB0aGlzLmNvbnRyb2xzLnNwbGljZShhZGp1c3RlZEluZGV4LCAxKTtcbiAgICAgICAgdGhpcy51cGRhdGVWYWx1ZUFuZFZhbGlkaXR5KHsgZW1pdEV2ZW50OiBvcHRpb25zLmVtaXRFdmVudCB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVwbGFjZSBhbiBleGlzdGluZyBjb250cm9sLlxuICAgICAqXG4gICAgICogQHBhcmFtIGluZGV4IEluZGV4IGluIHRoZSBhcnJheSB0byByZXBsYWNlIHRoZSBjb250cm9sLiBJZiBgaW5kZXhgIGlzIG5lZ2F0aXZlLCB3cmFwcyBhcm91bmRcbiAgICAgKiAgICAgZnJvbSB0aGUgYmFjay4gSWYgYGluZGV4YCBpcyBncmVhdGx5IG5lZ2F0aXZlIChsZXNzIHRoYW4gYC1sZW5ndGhgKSwgcmVwbGFjZXMgdGhlIGZpcnN0XG4gICAgICogICAgIGVsZW1lbnQuIFRoaXMgYmVoYXZpb3IgaXMgdGhlIHNhbWUgYXMgYEFycmF5LnNwbGljZShpbmRleCwgMSwgY29udHJvbClgLlxuICAgICAqIEBwYXJhbSBjb250cm9sIFRoZSBgQWJzdHJhY3RDb250cm9sYCBjb250cm9sIHRvIHJlcGxhY2UgdGhlIGV4aXN0aW5nIGNvbnRyb2xcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBTcGVjaWZpZXMgd2hldGhlciB0aGlzIEZvcm1BcnJheSBpbnN0YW5jZSBzaG91bGQgZW1pdCBldmVudHMgYWZ0ZXIgYW5cbiAgICAgKiAgICAgZXhpc3RpbmcgY29udHJvbCBpcyByZXBsYWNlZCB3aXRoIGEgbmV3IG9uZS5cbiAgICAgKiAqIGBlbWl0RXZlbnRgOiBXaGVuIHRydWUgb3Igbm90IHN1cHBsaWVkICh0aGUgZGVmYXVsdCksIGJvdGggdGhlIGBzdGF0dXNDaGFuZ2VzYCBhbmRcbiAgICAgKiBgdmFsdWVDaGFuZ2VzYCBvYnNlcnZhYmxlcyBlbWl0IGV2ZW50cyB3aXRoIHRoZSBsYXRlc3Qgc3RhdHVzIGFuZCB2YWx1ZSB3aGVuIHRoZSBjb250cm9sIGlzXG4gICAgICogcmVwbGFjZWQgd2l0aCBhIG5ldyBvbmUuIFdoZW4gZmFsc2UsIG5vIGV2ZW50cyBhcmUgZW1pdHRlZC5cbiAgICAgKi9cbiAgICBzZXRDb250cm9sKGluZGV4LCBjb250cm9sLCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgLy8gQWRqdXN0IHRoZSBpbmRleCwgdGhlbiBjbGFtcCBpdCBhdCBubyBsZXNzIHRoYW4gMCB0byBwcmV2ZW50IHVuZGVzaXJlZCB1bmRlcmZsb3dzLlxuICAgICAgICBsZXQgYWRqdXN0ZWRJbmRleCA9IHRoaXMuX2FkanVzdEluZGV4KGluZGV4KTtcbiAgICAgICAgaWYgKGFkanVzdGVkSW5kZXggPCAwKVxuICAgICAgICAgICAgYWRqdXN0ZWRJbmRleCA9IDA7XG4gICAgICAgIGlmICh0aGlzLmNvbnRyb2xzW2FkanVzdGVkSW5kZXhdKVxuICAgICAgICAgICAgdGhpcy5jb250cm9sc1thZGp1c3RlZEluZGV4XS5fcmVnaXN0ZXJPbkNvbGxlY3Rpb25DaGFuZ2UoKCkgPT4geyB9KTtcbiAgICAgICAgdGhpcy5jb250cm9scy5zcGxpY2UoYWRqdXN0ZWRJbmRleCwgMSk7XG4gICAgICAgIGlmIChjb250cm9sKSB7XG4gICAgICAgICAgICB0aGlzLmNvbnRyb2xzLnNwbGljZShhZGp1c3RlZEluZGV4LCAwLCBjb250cm9sKTtcbiAgICAgICAgICAgIHRoaXMuX3JlZ2lzdGVyQ29udHJvbChjb250cm9sKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnVwZGF0ZVZhbHVlQW5kVmFsaWRpdHkoeyBlbWl0RXZlbnQ6IG9wdGlvbnMuZW1pdEV2ZW50IH0pO1xuICAgICAgICB0aGlzLl9vbkNvbGxlY3Rpb25DaGFuZ2UoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTGVuZ3RoIG9mIHRoZSBjb250cm9sIGFycmF5LlxuICAgICAqL1xuICAgIGdldCBsZW5ndGgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnRyb2xzLmxlbmd0aDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgdmFsdWUgb2YgdGhlIGBGb3JtQXJyYXlgLiBJdCBhY2NlcHRzIGFuIGFycmF5IHRoYXQgbWF0Y2hlc1xuICAgICAqIHRoZSBzdHJ1Y3R1cmUgb2YgdGhlIGNvbnRyb2wuXG4gICAgICpcbiAgICAgKiBUaGlzIG1ldGhvZCBwZXJmb3JtcyBzdHJpY3QgY2hlY2tzLCBhbmQgdGhyb3dzIGFuIGVycm9yIGlmIHlvdSB0cnlcbiAgICAgKiB0byBzZXQgdGhlIHZhbHVlIG9mIGEgY29udHJvbCB0aGF0IGRvZXNuJ3QgZXhpc3Qgb3IgaWYgeW91IGV4Y2x1ZGUgdGhlXG4gICAgICogdmFsdWUgb2YgYSBjb250cm9sLlxuICAgICAqXG4gICAgICogQHVzYWdlTm90ZXNcbiAgICAgKiAjIyMgU2V0IHRoZSB2YWx1ZXMgZm9yIHRoZSBjb250cm9scyBpbiB0aGUgZm9ybSBhcnJheVxuICAgICAqXG4gICAgICogYGBgXG4gICAgICogY29uc3QgYXJyID0gbmV3IEZvcm1BcnJheShbXG4gICAgICogICBuZXcgRm9ybUNvbnRyb2woKSxcbiAgICAgKiAgIG5ldyBGb3JtQ29udHJvbCgpXG4gICAgICogXSk7XG4gICAgICogY29uc29sZS5sb2coYXJyLnZhbHVlKTsgICAvLyBbbnVsbCwgbnVsbF1cbiAgICAgKlxuICAgICAqIGFyci5zZXRWYWx1ZShbJ05hbmN5JywgJ0RyZXcnXSk7XG4gICAgICogY29uc29sZS5sb2coYXJyLnZhbHVlKTsgICAvLyBbJ05hbmN5JywgJ0RyZXcnXVxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQHBhcmFtIHZhbHVlIEFycmF5IG9mIHZhbHVlcyBmb3IgdGhlIGNvbnRyb2xzXG4gICAgICogQHBhcmFtIG9wdGlvbnMgQ29uZmlndXJlIG9wdGlvbnMgdGhhdCBkZXRlcm1pbmUgaG93IHRoZSBjb250cm9sIHByb3BhZ2F0ZXMgY2hhbmdlcyBhbmRcbiAgICAgKiBlbWl0cyBldmVudHMgYWZ0ZXIgdGhlIHZhbHVlIGNoYW5nZXNcbiAgICAgKlxuICAgICAqICogYG9ubHlTZWxmYDogV2hlbiB0cnVlLCBlYWNoIGNoYW5nZSBvbmx5IGFmZmVjdHMgdGhpcyBjb250cm9sLCBhbmQgbm90IGl0cyBwYXJlbnQuIERlZmF1bHRcbiAgICAgKiBpcyBmYWxzZS5cbiAgICAgKiAqIGBlbWl0RXZlbnRgOiBXaGVuIHRydWUgb3Igbm90IHN1cHBsaWVkICh0aGUgZGVmYXVsdCksIGJvdGggdGhlIGBzdGF0dXNDaGFuZ2VzYCBhbmRcbiAgICAgKiBgdmFsdWVDaGFuZ2VzYFxuICAgICAqIG9ic2VydmFibGVzIGVtaXQgZXZlbnRzIHdpdGggdGhlIGxhdGVzdCBzdGF0dXMgYW5kIHZhbHVlIHdoZW4gdGhlIGNvbnRyb2wgdmFsdWUgaXMgdXBkYXRlZC5cbiAgICAgKiBXaGVuIGZhbHNlLCBubyBldmVudHMgYXJlIGVtaXR0ZWQuXG4gICAgICogVGhlIGNvbmZpZ3VyYXRpb24gb3B0aW9ucyBhcmUgcGFzc2VkIHRvIHRoZSB7QGxpbmsgQWJzdHJhY3RDb250cm9sI3VwZGF0ZVZhbHVlQW5kVmFsaWRpdHlcbiAgICAgKiB1cGRhdGVWYWx1ZUFuZFZhbGlkaXR5fSBtZXRob2QuXG4gICAgICovXG4gICAgc2V0VmFsdWUodmFsdWUsIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICBhc3NlcnRBbGxWYWx1ZXNQcmVzZW50KHRoaXMsIGZhbHNlLCB2YWx1ZSk7XG4gICAgICAgIHZhbHVlLmZvckVhY2goKG5ld1ZhbHVlLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgYXNzZXJ0Q29udHJvbFByZXNlbnQodGhpcywgZmFsc2UsIGluZGV4KTtcbiAgICAgICAgICAgIHRoaXMuYXQoaW5kZXgpLnNldFZhbHVlKG5ld1ZhbHVlLCB7IG9ubHlTZWxmOiB0cnVlLCBlbWl0RXZlbnQ6IG9wdGlvbnMuZW1pdEV2ZW50IH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy51cGRhdGVWYWx1ZUFuZFZhbGlkaXR5KG9wdGlvbnMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQYXRjaGVzIHRoZSB2YWx1ZSBvZiB0aGUgYEZvcm1BcnJheWAuIEl0IGFjY2VwdHMgYW4gYXJyYXkgdGhhdCBtYXRjaGVzIHRoZVxuICAgICAqIHN0cnVjdHVyZSBvZiB0aGUgY29udHJvbCwgYW5kIGRvZXMgaXRzIGJlc3QgdG8gbWF0Y2ggdGhlIHZhbHVlcyB0byB0aGUgY29ycmVjdFxuICAgICAqIGNvbnRyb2xzIGluIHRoZSBncm91cC5cbiAgICAgKlxuICAgICAqIEl0IGFjY2VwdHMgYm90aCBzdXBlci1zZXRzIGFuZCBzdWItc2V0cyBvZiB0aGUgYXJyYXkgd2l0aG91dCB0aHJvd2luZyBhbiBlcnJvci5cbiAgICAgKlxuICAgICAqIEB1c2FnZU5vdGVzXG4gICAgICogIyMjIFBhdGNoIHRoZSB2YWx1ZXMgZm9yIGNvbnRyb2xzIGluIGEgZm9ybSBhcnJheVxuICAgICAqXG4gICAgICogYGBgXG4gICAgICogY29uc3QgYXJyID0gbmV3IEZvcm1BcnJheShbXG4gICAgICogICAgbmV3IEZvcm1Db250cm9sKCksXG4gICAgICogICAgbmV3IEZvcm1Db250cm9sKClcbiAgICAgKiBdKTtcbiAgICAgKiBjb25zb2xlLmxvZyhhcnIudmFsdWUpOyAgIC8vIFtudWxsLCBudWxsXVxuICAgICAqXG4gICAgICogYXJyLnBhdGNoVmFsdWUoWydOYW5jeSddKTtcbiAgICAgKiBjb25zb2xlLmxvZyhhcnIudmFsdWUpOyAgIC8vIFsnTmFuY3knLCBudWxsXVxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQHBhcmFtIHZhbHVlIEFycmF5IG9mIGxhdGVzdCB2YWx1ZXMgZm9yIHRoZSBjb250cm9sc1xuICAgICAqIEBwYXJhbSBvcHRpb25zIENvbmZpZ3VyZSBvcHRpb25zIHRoYXQgZGV0ZXJtaW5lIGhvdyB0aGUgY29udHJvbCBwcm9wYWdhdGVzIGNoYW5nZXMgYW5kXG4gICAgICogZW1pdHMgZXZlbnRzIGFmdGVyIHRoZSB2YWx1ZSBjaGFuZ2VzXG4gICAgICpcbiAgICAgKiAqIGBvbmx5U2VsZmA6IFdoZW4gdHJ1ZSwgZWFjaCBjaGFuZ2Ugb25seSBhZmZlY3RzIHRoaXMgY29udHJvbCwgYW5kIG5vdCBpdHMgcGFyZW50LiBEZWZhdWx0XG4gICAgICogaXMgZmFsc2UuXG4gICAgICogKiBgZW1pdEV2ZW50YDogV2hlbiB0cnVlIG9yIG5vdCBzdXBwbGllZCAodGhlIGRlZmF1bHQpLCBib3RoIHRoZSBgc3RhdHVzQ2hhbmdlc2AgYW5kXG4gICAgICogYHZhbHVlQ2hhbmdlc2Agb2JzZXJ2YWJsZXMgZW1pdCBldmVudHMgd2l0aCB0aGUgbGF0ZXN0IHN0YXR1cyBhbmQgdmFsdWUgd2hlbiB0aGUgY29udHJvbFxuICAgICAqIHZhbHVlIGlzIHVwZGF0ZWQuIFdoZW4gZmFsc2UsIG5vIGV2ZW50cyBhcmUgZW1pdHRlZC4gVGhlIGNvbmZpZ3VyYXRpb24gb3B0aW9ucyBhcmUgcGFzc2VkIHRvXG4gICAgICogdGhlIHtAbGluayBBYnN0cmFjdENvbnRyb2wjdXBkYXRlVmFsdWVBbmRWYWxpZGl0eSB1cGRhdGVWYWx1ZUFuZFZhbGlkaXR5fSBtZXRob2QuXG4gICAgICovXG4gICAgcGF0Y2hWYWx1ZSh2YWx1ZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIC8vIEV2ZW4gdGhvdWdoIHRoZSBgdmFsdWVgIGFyZ3VtZW50IHR5cGUgZG9lc24ndCBhbGxvdyBgbnVsbGAgYW5kIGB1bmRlZmluZWRgIHZhbHVlcywgdGhlXG4gICAgICAgIC8vIGBwYXRjaFZhbHVlYCBjYW4gYmUgY2FsbGVkIHJlY3Vyc2l2ZWx5IGFuZCBpbm5lciBkYXRhIHN0cnVjdHVyZXMgbWlnaHQgaGF2ZSB0aGVzZSB2YWx1ZXMsXG4gICAgICAgIC8vIHNvIHdlIGp1c3QgaWdub3JlIHN1Y2ggY2FzZXMgd2hlbiBhIGZpZWxkIGNvbnRhaW5pbmcgRm9ybUFycmF5IGluc3RhbmNlIHJlY2VpdmVzIGBudWxsYCBvclxuICAgICAgICAvLyBgdW5kZWZpbmVkYCBhcyBhIHZhbHVlLlxuICAgICAgICBpZiAodmFsdWUgPT0gbnVsbCAvKiBib3RoIGBudWxsYCBhbmQgYHVuZGVmaW5lZGAgKi8pXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHZhbHVlLmZvckVhY2goKG5ld1ZhbHVlLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuYXQoaW5kZXgpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hdChpbmRleCkucGF0Y2hWYWx1ZShuZXdWYWx1ZSwgeyBvbmx5U2VsZjogdHJ1ZSwgZW1pdEV2ZW50OiBvcHRpb25zLmVtaXRFdmVudCB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMudXBkYXRlVmFsdWVBbmRWYWxpZGl0eShvcHRpb25zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVzZXRzIHRoZSBgRm9ybUFycmF5YCBhbmQgYWxsIGRlc2NlbmRhbnRzIGFyZSBtYXJrZWQgYHByaXN0aW5lYCBhbmQgYHVudG91Y2hlZGAsIGFuZCB0aGVcbiAgICAgKiB2YWx1ZSBvZiBhbGwgZGVzY2VuZGFudHMgdG8gbnVsbCBvciBudWxsIG1hcHMuXG4gICAgICpcbiAgICAgKiBZb3UgcmVzZXQgdG8gYSBzcGVjaWZpYyBmb3JtIHN0YXRlIGJ5IHBhc3NpbmcgaW4gYW4gYXJyYXkgb2Ygc3RhdGVzXG4gICAgICogdGhhdCBtYXRjaGVzIHRoZSBzdHJ1Y3R1cmUgb2YgdGhlIGNvbnRyb2wuIFRoZSBzdGF0ZSBpcyBhIHN0YW5kYWxvbmUgdmFsdWVcbiAgICAgKiBvciBhIGZvcm0gc3RhdGUgb2JqZWN0IHdpdGggYm90aCBhIHZhbHVlIGFuZCBhIGRpc2FibGVkIHN0YXR1cy5cbiAgICAgKlxuICAgICAqIEB1c2FnZU5vdGVzXG4gICAgICogIyMjIFJlc2V0IHRoZSB2YWx1ZXMgaW4gYSBmb3JtIGFycmF5XG4gICAgICpcbiAgICAgKiBgYGB0c1xuICAgICAqIGNvbnN0IGFyciA9IG5ldyBGb3JtQXJyYXkoW1xuICAgICAqICAgIG5ldyBGb3JtQ29udHJvbCgpLFxuICAgICAqICAgIG5ldyBGb3JtQ29udHJvbCgpXG4gICAgICogXSk7XG4gICAgICogYXJyLnJlc2V0KFsnbmFtZScsICdsYXN0IG5hbWUnXSk7XG4gICAgICpcbiAgICAgKiBjb25zb2xlLmxvZyhhcnIudmFsdWUpOyAgLy8gWyduYW1lJywgJ2xhc3QgbmFtZSddXG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiAjIyMgUmVzZXQgdGhlIHZhbHVlcyBpbiBhIGZvcm0gYXJyYXkgYW5kIHRoZSBkaXNhYmxlZCBzdGF0dXMgZm9yIHRoZSBmaXJzdCBjb250cm9sXG4gICAgICpcbiAgICAgKiBgYGBcbiAgICAgKiBhcnIucmVzZXQoW1xuICAgICAqICAge3ZhbHVlOiAnbmFtZScsIGRpc2FibGVkOiB0cnVlfSxcbiAgICAgKiAgICdsYXN0J1xuICAgICAqIF0pO1xuICAgICAqXG4gICAgICogY29uc29sZS5sb2coYXJyLnZhbHVlKTsgIC8vIFsnbGFzdCddXG4gICAgICogY29uc29sZS5sb2coYXJyLmF0KDApLnN0YXR1cyk7ICAvLyAnRElTQUJMRUQnXG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdmFsdWUgQXJyYXkgb2YgdmFsdWVzIGZvciB0aGUgY29udHJvbHNcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBDb25maWd1cmUgb3B0aW9ucyB0aGF0IGRldGVybWluZSBob3cgdGhlIGNvbnRyb2wgcHJvcGFnYXRlcyBjaGFuZ2VzIGFuZFxuICAgICAqIGVtaXRzIGV2ZW50cyBhZnRlciB0aGUgdmFsdWUgY2hhbmdlc1xuICAgICAqXG4gICAgICogKiBgb25seVNlbGZgOiBXaGVuIHRydWUsIGVhY2ggY2hhbmdlIG9ubHkgYWZmZWN0cyB0aGlzIGNvbnRyb2wsIGFuZCBub3QgaXRzIHBhcmVudC4gRGVmYXVsdFxuICAgICAqIGlzIGZhbHNlLlxuICAgICAqICogYGVtaXRFdmVudGA6IFdoZW4gdHJ1ZSBvciBub3Qgc3VwcGxpZWQgKHRoZSBkZWZhdWx0KSwgYm90aCB0aGUgYHN0YXR1c0NoYW5nZXNgIGFuZFxuICAgICAqIGB2YWx1ZUNoYW5nZXNgXG4gICAgICogb2JzZXJ2YWJsZXMgZW1pdCBldmVudHMgd2l0aCB0aGUgbGF0ZXN0IHN0YXR1cyBhbmQgdmFsdWUgd2hlbiB0aGUgY29udHJvbCBpcyByZXNldC5cbiAgICAgKiBXaGVuIGZhbHNlLCBubyBldmVudHMgYXJlIGVtaXR0ZWQuXG4gICAgICogVGhlIGNvbmZpZ3VyYXRpb24gb3B0aW9ucyBhcmUgcGFzc2VkIHRvIHRoZSB7QGxpbmsgQWJzdHJhY3RDb250cm9sI3VwZGF0ZVZhbHVlQW5kVmFsaWRpdHlcbiAgICAgKiB1cGRhdGVWYWx1ZUFuZFZhbGlkaXR5fSBtZXRob2QuXG4gICAgICovXG4gICAgcmVzZXQodmFsdWUgPSBbXSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIHRoaXMuX2ZvckVhY2hDaGlsZCgoY29udHJvbCwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgIGNvbnRyb2wucmVzZXQodmFsdWVbaW5kZXhdLCB7IG9ubHlTZWxmOiB0cnVlLCBlbWl0RXZlbnQ6IG9wdGlvbnMuZW1pdEV2ZW50IH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5fdXBkYXRlUHJpc3RpbmUob3B0aW9ucyk7XG4gICAgICAgIHRoaXMuX3VwZGF0ZVRvdWNoZWQob3B0aW9ucyk7XG4gICAgICAgIHRoaXMudXBkYXRlVmFsdWVBbmRWYWxpZGl0eShvcHRpb25zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIGFnZ3JlZ2F0ZSB2YWx1ZSBvZiB0aGUgYXJyYXksIGluY2x1ZGluZyBhbnkgZGlzYWJsZWQgY29udHJvbHMuXG4gICAgICpcbiAgICAgKiBSZXBvcnRzIGFsbCB2YWx1ZXMgcmVnYXJkbGVzcyBvZiBkaXNhYmxlZCBzdGF0dXMuXG4gICAgICovXG4gICAgZ2V0UmF3VmFsdWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnRyb2xzLm1hcCgoY29udHJvbCkgPT4gY29udHJvbC5nZXRSYXdWYWx1ZSgpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVtb3ZlIGFsbCBjb250cm9scyBpbiB0aGUgYEZvcm1BcnJheWAuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBTcGVjaWZpZXMgd2hldGhlciB0aGlzIEZvcm1BcnJheSBpbnN0YW5jZSBzaG91bGQgZW1pdCBldmVudHMgYWZ0ZXIgYWxsXG4gICAgICogICAgIGNvbnRyb2xzIGFyZSByZW1vdmVkLlxuICAgICAqICogYGVtaXRFdmVudGA6IFdoZW4gdHJ1ZSBvciBub3Qgc3VwcGxpZWQgKHRoZSBkZWZhdWx0KSwgYm90aCB0aGUgYHN0YXR1c0NoYW5nZXNgIGFuZFxuICAgICAqIGB2YWx1ZUNoYW5nZXNgIG9ic2VydmFibGVzIGVtaXQgZXZlbnRzIHdpdGggdGhlIGxhdGVzdCBzdGF0dXMgYW5kIHZhbHVlIHdoZW4gYWxsIGNvbnRyb2xzXG4gICAgICogaW4gdGhpcyBGb3JtQXJyYXkgaW5zdGFuY2UgYXJlIHJlbW92ZWQuIFdoZW4gZmFsc2UsIG5vIGV2ZW50cyBhcmUgZW1pdHRlZC5cbiAgICAgKlxuICAgICAqIEB1c2FnZU5vdGVzXG4gICAgICogIyMjIFJlbW92ZSBhbGwgZWxlbWVudHMgZnJvbSBhIEZvcm1BcnJheVxuICAgICAqXG4gICAgICogYGBgdHNcbiAgICAgKiBjb25zdCBhcnIgPSBuZXcgRm9ybUFycmF5KFtcbiAgICAgKiAgICBuZXcgRm9ybUNvbnRyb2woKSxcbiAgICAgKiAgICBuZXcgRm9ybUNvbnRyb2woKVxuICAgICAqIF0pO1xuICAgICAqIGNvbnNvbGUubG9nKGFyci5sZW5ndGgpOyAgLy8gMlxuICAgICAqXG4gICAgICogYXJyLmNsZWFyKCk7XG4gICAgICogY29uc29sZS5sb2coYXJyLmxlbmd0aCk7ICAvLyAwXG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBJdCdzIGEgc2ltcGxlciBhbmQgbW9yZSBlZmZpY2llbnQgYWx0ZXJuYXRpdmUgdG8gcmVtb3ZpbmcgYWxsIGVsZW1lbnRzIG9uZSBieSBvbmU6XG4gICAgICpcbiAgICAgKiBgYGB0c1xuICAgICAqIGNvbnN0IGFyciA9IG5ldyBGb3JtQXJyYXkoW1xuICAgICAqICAgIG5ldyBGb3JtQ29udHJvbCgpLFxuICAgICAqICAgIG5ldyBGb3JtQ29udHJvbCgpXG4gICAgICogXSk7XG4gICAgICpcbiAgICAgKiB3aGlsZSAoYXJyLmxlbmd0aCkge1xuICAgICAqICAgIGFyci5yZW1vdmVBdCgwKTtcbiAgICAgKiB9XG4gICAgICogYGBgXG4gICAgICovXG4gICAgY2xlYXIob3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIGlmICh0aGlzLmNvbnRyb2xzLmxlbmd0aCA8IDEpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRoaXMuX2ZvckVhY2hDaGlsZCgoY29udHJvbCkgPT4gY29udHJvbC5fcmVnaXN0ZXJPbkNvbGxlY3Rpb25DaGFuZ2UoKCkgPT4geyB9KSk7XG4gICAgICAgIHRoaXMuY29udHJvbHMuc3BsaWNlKDApO1xuICAgICAgICB0aGlzLnVwZGF0ZVZhbHVlQW5kVmFsaWRpdHkoeyBlbWl0RXZlbnQ6IG9wdGlvbnMuZW1pdEV2ZW50IH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGp1c3RzIGEgbmVnYXRpdmUgaW5kZXggYnkgc3VtbWluZyBpdCB3aXRoIHRoZSBsZW5ndGggb2YgdGhlIGFycmF5LiBGb3IgdmVyeSBuZWdhdGl2ZVxuICAgICAqIGluZGljZXMsIHRoZSByZXN1bHQgbWF5IHJlbWFpbiBuZWdhdGl2ZS5cbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBfYWRqdXN0SW5kZXgoaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIGluZGV4IDwgMCA/IGluZGV4ICsgdGhpcy5sZW5ndGggOiBpbmRleDtcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIF9zeW5jUGVuZGluZ0NvbnRyb2xzKCkge1xuICAgICAgICBsZXQgc3VidHJlZVVwZGF0ZWQgPSB0aGlzLmNvbnRyb2xzLnJlZHVjZSgodXBkYXRlZCwgY2hpbGQpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBjaGlsZC5fc3luY1BlbmRpbmdDb250cm9scygpID8gdHJ1ZSA6IHVwZGF0ZWQ7XG4gICAgICAgIH0sIGZhbHNlKTtcbiAgICAgICAgaWYgKHN1YnRyZWVVcGRhdGVkKVxuICAgICAgICAgICAgdGhpcy51cGRhdGVWYWx1ZUFuZFZhbGlkaXR5KHsgb25seVNlbGY6IHRydWUgfSk7XG4gICAgICAgIHJldHVybiBzdWJ0cmVlVXBkYXRlZDtcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIF9mb3JFYWNoQ2hpbGQoY2IpIHtcbiAgICAgICAgdGhpcy5jb250cm9scy5mb3JFYWNoKChjb250cm9sLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgY2IoY29udHJvbCwgaW5kZXgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIF91cGRhdGVWYWx1ZSgpIHtcbiAgICAgICAgdGhpcy52YWx1ZSA9XG4gICAgICAgICAgICB0aGlzLmNvbnRyb2xzLmZpbHRlcigoY29udHJvbCkgPT4gY29udHJvbC5lbmFibGVkIHx8IHRoaXMuZGlzYWJsZWQpXG4gICAgICAgICAgICAgICAgLm1hcCgoY29udHJvbCkgPT4gY29udHJvbC52YWx1ZSk7XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBfYW55Q29udHJvbHMoY29uZGl0aW9uKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnRyb2xzLnNvbWUoKGNvbnRyb2wpID0+IGNvbnRyb2wuZW5hYmxlZCAmJiBjb25kaXRpb24oY29udHJvbCkpO1xuICAgIH1cbiAgICAvKiogQGludGVybmFsICovXG4gICAgX3NldFVwQ29udHJvbHMoKSB7XG4gICAgICAgIHRoaXMuX2ZvckVhY2hDaGlsZCgoY29udHJvbCkgPT4gdGhpcy5fcmVnaXN0ZXJDb250cm9sKGNvbnRyb2wpKTtcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIF9hbGxDb250cm9sc0Rpc2FibGVkKCkge1xuICAgICAgICBmb3IgKGNvbnN0IGNvbnRyb2wgb2YgdGhpcy5jb250cm9scykge1xuICAgICAgICAgICAgaWYgKGNvbnRyb2wuZW5hYmxlZClcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuY29udHJvbHMubGVuZ3RoID4gMCB8fCB0aGlzLmRpc2FibGVkO1xuICAgIH1cbiAgICBfcmVnaXN0ZXJDb250cm9sKGNvbnRyb2wpIHtcbiAgICAgICAgY29udHJvbC5zZXRQYXJlbnQodGhpcyk7XG4gICAgICAgIGNvbnRyb2wuX3JlZ2lzdGVyT25Db2xsZWN0aW9uQ2hhbmdlKHRoaXMuX29uQ29sbGVjdGlvbkNoYW5nZSk7XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBfZmluZChuYW1lKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmF0KG5hbWUpID8/IG51bGw7XG4gICAgfVxufVxuY29uc3QgVW50eXBlZEZvcm1BcnJheSA9IEZvcm1BcnJheTtcbi8qKlxuICogQGRlc2NyaXB0aW9uXG4gKiBBc3NlcnRzIHRoYXQgdGhlIGdpdmVuIGNvbnRyb2wgaXMgYW4gaW5zdGFuY2Ugb2YgYEZvcm1BcnJheWBcbiAqXG4gKiBAcHVibGljQXBpXG4gKi9cbmNvbnN0IGlzRm9ybUFycmF5ID0gKGNvbnRyb2wpID0+IGNvbnRyb2wgaW5zdGFuY2VvZiBGb3JtQXJyYXk7XG5cbmZ1bmN0aW9uIGlzQWJzdHJhY3RDb250cm9sT3B0aW9ucyhvcHRpb25zKSB7XG4gICAgcmV0dXJuICEhb3B0aW9ucyAmJlxuICAgICAgICAob3B0aW9ucy5hc3luY1ZhbGlkYXRvcnMgIT09IHVuZGVmaW5lZCB8fFxuICAgICAgICAgICAgb3B0aW9ucy52YWxpZGF0b3JzICE9PSB1bmRlZmluZWQgfHxcbiAgICAgICAgICAgIG9wdGlvbnMudXBkYXRlT24gIT09IHVuZGVmaW5lZCk7XG59XG4vLyBjbGFuZy1mb3JtYXQgb25cbi8qKlxuICogQGRlc2NyaXB0aW9uXG4gKiBDcmVhdGVzIGFuIGBBYnN0cmFjdENvbnRyb2xgIGZyb20gYSB1c2VyLXNwZWNpZmllZCBjb25maWd1cmF0aW9uLlxuICpcbiAqIFRoZSBgRm9ybUJ1aWxkZXJgIHByb3ZpZGVzIHN5bnRhY3RpYyBzdWdhciB0aGF0IHNob3J0ZW5zIGNyZWF0aW5nIGluc3RhbmNlcyBvZiBhXG4gKiBgRm9ybUNvbnRyb2xgLCBgRm9ybUdyb3VwYCwgb3IgYEZvcm1BcnJheWAuIEl0IHJlZHVjZXMgdGhlIGFtb3VudCBvZiBib2lsZXJwbGF0ZSBuZWVkZWQgdG9cbiAqIGJ1aWxkIGNvbXBsZXggZm9ybXMuXG4gKlxuICogQHNlZSBbUmVhY3RpdmUgRm9ybXMgR3VpZGVdKGd1aWRlL3JlYWN0aXZlLWZvcm1zKVxuICpcbiAqIEBwdWJsaWNBcGlcbiAqL1xuY2xhc3MgRm9ybUJ1aWxkZXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLnVzZU5vbk51bGxhYmxlID0gZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqIFJldHVybnMgYSBGb3JtQnVpbGRlciBpbiB3aGljaCBhdXRvbWF0aWNhbGx5IGNvbnN0cnVjdGVkIGBGb3JtQ29udHJvbGAgZWxlbWVudHNcbiAgICAgKiBoYXZlIGB7bm9uTnVsbGFibGU6IHRydWV9YCBhbmQgYXJlIG5vbi1udWxsYWJsZS5cbiAgICAgKlxuICAgICAqICoqQ29uc3RydWN0aW5nIG5vbi1udWxsYWJsZSBjb250cm9scyoqXG4gICAgICpcbiAgICAgKiBXaGVuIGNvbnN0cnVjdGluZyBhIGNvbnRyb2wsIGl0IHdpbGwgYmUgbm9uLW51bGxhYmxlLCBhbmQgd2lsbCByZXNldCB0byBpdHMgaW5pdGlhbCB2YWx1ZS5cbiAgICAgKlxuICAgICAqIGBgYHRzXG4gICAgICogbGV0IG5uZmIgPSBuZXcgRm9ybUJ1aWxkZXIoKS5ub25OdWxsYWJsZTtcbiAgICAgKiBsZXQgbmFtZSA9IG5uZmIuY29udHJvbCgnQWxleCcpOyAvLyBGb3JtQ29udHJvbDxzdHJpbmc+XG4gICAgICogbmFtZS5yZXNldCgpO1xuICAgICAqIGNvbnNvbGUubG9nKG5hbWUpOyAvLyAnQWxleCdcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqICoqQ29uc3RydWN0aW5nIG5vbi1udWxsYWJsZSBncm91cHMgb3IgYXJyYXlzKipcbiAgICAgKlxuICAgICAqIFdoZW4gY29uc3RydWN0aW5nIGEgZ3JvdXAgb3IgYXJyYXksIGFsbCBhdXRvbWF0aWNhbGx5IGNyZWF0ZWQgaW5uZXIgY29udHJvbHMgd2lsbCBiZVxuICAgICAqIG5vbi1udWxsYWJsZSwgYW5kIHdpbGwgcmVzZXQgdG8gdGhlaXIgaW5pdGlhbCB2YWx1ZXMuXG4gICAgICpcbiAgICAgKiBgYGB0c1xuICAgICAqIGxldCBubmZiID0gbmV3IEZvcm1CdWlsZGVyKCkubm9uTnVsbGFibGU7XG4gICAgICogbGV0IG5hbWUgPSBubmZiLmdyb3VwKHt3aG86ICdBbGV4J30pOyAvLyBGb3JtR3JvdXA8e3dobzogRm9ybUNvbnRyb2w8c3RyaW5nPn0+XG4gICAgICogbmFtZS5yZXNldCgpO1xuICAgICAqIGNvbnNvbGUubG9nKG5hbWUpOyAvLyB7d2hvOiAnQWxleCd9XG4gICAgICogYGBgXG4gICAgICogKipDb25zdHJ1Y3RpbmcgKm51bGxhYmxlKiBmaWVsZHMgb24gZ3JvdXBzIG9yIGFycmF5cyoqXG4gICAgICpcbiAgICAgKiBJdCBpcyBzdGlsbCBwb3NzaWJsZSB0byBoYXZlIGEgbnVsbGFibGUgZmllbGQuIEluIHBhcnRpY3VsYXIsIGFueSBgRm9ybUNvbnRyb2xgIHdoaWNoIGlzXG4gICAgICogKmFscmVhZHkqIGNvbnN0cnVjdGVkIHdpbGwgbm90IGJlIGFsdGVyZWQuIEZvciBleGFtcGxlOlxuICAgICAqXG4gICAgICogYGBgdHNcbiAgICAgKiBsZXQgbm5mYiA9IG5ldyBGb3JtQnVpbGRlcigpLm5vbk51bGxhYmxlO1xuICAgICAqIC8vIEZvcm1Hcm91cDx7d2hvOiBGb3JtQ29udHJvbDxzdHJpbmd8bnVsbD59PlxuICAgICAqIGxldCBuYW1lID0gbm5mYi5ncm91cCh7d2hvOiBuZXcgRm9ybUNvbnRyb2woJ0FsZXgnKX0pO1xuICAgICAqIG5hbWUucmVzZXQoKTsgY29uc29sZS5sb2cobmFtZSk7IC8vIHt3aG86IG51bGx9XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBCZWNhdXNlIHRoZSBpbm5lciBjb250cm9sIGlzIGNvbnN0cnVjdGVkIGV4cGxpY2l0bHkgYnkgdGhlIGNhbGxlciwgdGhlIGJ1aWxkZXIgaGFzXG4gICAgICogbm8gY29udHJvbCBvdmVyIGhvdyBpdCBpcyBjcmVhdGVkLCBhbmQgY2Fubm90IGV4Y2x1ZGUgdGhlIGBudWxsYC5cbiAgICAgKi9cbiAgICBnZXQgbm9uTnVsbGFibGUoKSB7XG4gICAgICAgIGNvbnN0IG5uZmIgPSBuZXcgRm9ybUJ1aWxkZXIoKTtcbiAgICAgICAgbm5mYi51c2VOb25OdWxsYWJsZSA9IHRydWU7XG4gICAgICAgIHJldHVybiBubmZiO1xuICAgIH1cbiAgICBncm91cChjb250cm9scywgb3B0aW9ucyA9IG51bGwpIHtcbiAgICAgICAgY29uc3QgcmVkdWNlZENvbnRyb2xzID0gdGhpcy5fcmVkdWNlQ29udHJvbHMoY29udHJvbHMpO1xuICAgICAgICBsZXQgbmV3T3B0aW9ucyA9IHt9O1xuICAgICAgICBpZiAoaXNBYnN0cmFjdENvbnRyb2xPcHRpb25zKG9wdGlvbnMpKSB7XG4gICAgICAgICAgICAvLyBgb3B0aW9uc2AgYXJlIGBBYnN0cmFjdENvbnRyb2xPcHRpb25zYFxuICAgICAgICAgICAgbmV3T3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAob3B0aW9ucyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gYG9wdGlvbnNgIGFyZSBsZWdhY3kgZm9ybSBncm91cCBvcHRpb25zXG4gICAgICAgICAgICBuZXdPcHRpb25zLnZhbGlkYXRvcnMgPSBvcHRpb25zLnZhbGlkYXRvcjtcbiAgICAgICAgICAgIG5ld09wdGlvbnMuYXN5bmNWYWxpZGF0b3JzID0gb3B0aW9ucy5hc3luY1ZhbGlkYXRvcjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IEZvcm1Hcm91cChyZWR1Y2VkQ29udHJvbHMsIG5ld09wdGlvbnMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKiBDb25zdHJ1Y3RzIGEgbmV3IGBGb3JtUmVjb3JkYCBpbnN0YW5jZS4gQWNjZXB0cyBhIHNpbmdsZSBnZW5lcmljIGFyZ3VtZW50LCB3aGljaCBpcyBhbiBvYmplY3RcbiAgICAgKiBjb250YWluaW5nIGFsbCB0aGUga2V5cyBhbmQgY29ycmVzcG9uZGluZyBpbm5lciBjb250cm9sIHR5cGVzLlxuICAgICAqXG4gICAgICogQHBhcmFtIGNvbnRyb2xzIEEgY29sbGVjdGlvbiBvZiBjaGlsZCBjb250cm9scy4gVGhlIGtleSBmb3IgZWFjaCBjaGlsZCBpcyB0aGUgbmFtZVxuICAgICAqIHVuZGVyIHdoaWNoIGl0IGlzIHJlZ2lzdGVyZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBDb25maWd1cmF0aW9uIG9wdGlvbnMgb2JqZWN0IGZvciB0aGUgYEZvcm1SZWNvcmRgLiBUaGUgb2JqZWN0IHNob3VsZCBoYXZlIHRoZVxuICAgICAqIGBBYnN0cmFjdENvbnRyb2xPcHRpb25zYCB0eXBlIGFuZCBtaWdodCBjb250YWluIHRoZSBmb2xsb3dpbmcgZmllbGRzOlxuICAgICAqICogYHZhbGlkYXRvcnNgOiBBIHN5bmNocm9ub3VzIHZhbGlkYXRvciBmdW5jdGlvbiwgb3IgYW4gYXJyYXkgb2YgdmFsaWRhdG9yIGZ1bmN0aW9ucy5cbiAgICAgKiAqIGBhc3luY1ZhbGlkYXRvcnNgOiBBIHNpbmdsZSBhc3luYyB2YWxpZGF0b3Igb3IgYXJyYXkgb2YgYXN5bmMgdmFsaWRhdG9yIGZ1bmN0aW9ucy5cbiAgICAgKiAqIGB1cGRhdGVPbmA6IFRoZSBldmVudCB1cG9uIHdoaWNoIHRoZSBjb250cm9sIHNob3VsZCBiZSB1cGRhdGVkIChvcHRpb25zOiAnY2hhbmdlJyB8ICdibHVyJ1xuICAgICAqIHwgc3VibWl0JykuXG4gICAgICovXG4gICAgcmVjb3JkKGNvbnRyb2xzLCBvcHRpb25zID0gbnVsbCkge1xuICAgICAgICBjb25zdCByZWR1Y2VkQ29udHJvbHMgPSB0aGlzLl9yZWR1Y2VDb250cm9scyhjb250cm9scyk7XG4gICAgICAgIC8vIENhc3QgdG8gYGFueWAgYmVjYXVzZSB0aGUgaW5mZXJyZWQgdHlwZXMgYXJlIG5vdCBhcyBzcGVjaWZpYyBhcyBFbGVtZW50LlxuICAgICAgICByZXR1cm4gbmV3IEZvcm1SZWNvcmQocmVkdWNlZENvbnRyb2xzLCBvcHRpb25zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICogQ29uc3RydWN0cyBhIG5ldyBgRm9ybUNvbnRyb2xgIHdpdGggdGhlIGdpdmVuIHN0YXRlLCB2YWxpZGF0b3JzIGFuZCBvcHRpb25zLiBTZXRzXG4gICAgICogYHtub25OdWxsYWJsZTogdHJ1ZX1gIGluIHRoZSBvcHRpb25zIHRvIGdldCBhIG5vbi1udWxsYWJsZSBjb250cm9sLiBPdGhlcndpc2UsIHRoZVxuICAgICAqIGNvbnRyb2wgd2lsbCBiZSBudWxsYWJsZS4gQWNjZXB0cyBhIHNpbmdsZSBnZW5lcmljIGFyZ3VtZW50LCB3aGljaCBpcyB0aGUgdHlwZSAgb2YgdGhlXG4gICAgICogY29udHJvbCdzIHZhbHVlLlxuICAgICAqXG4gICAgICogQHBhcmFtIGZvcm1TdGF0ZSBJbml0aWFsaXplcyB0aGUgY29udHJvbCB3aXRoIGFuIGluaXRpYWwgc3RhdGUgdmFsdWUsIG9yXG4gICAgICogd2l0aCBhbiBvYmplY3QgdGhhdCBjb250YWlucyBib3RoIGEgdmFsdWUgYW5kIGEgZGlzYWJsZWQgc3RhdHVzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHZhbGlkYXRvck9yT3B0cyBBIHN5bmNocm9ub3VzIHZhbGlkYXRvciBmdW5jdGlvbiwgb3IgYW4gYXJyYXkgb2ZcbiAgICAgKiBzdWNoIGZ1bmN0aW9ucywgb3IgYSBgRm9ybUNvbnRyb2xPcHRpb25zYCBvYmplY3QgdGhhdCBjb250YWluc1xuICAgICAqIHZhbGlkYXRpb24gZnVuY3Rpb25zIGFuZCBhIHZhbGlkYXRpb24gdHJpZ2dlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBhc3luY1ZhbGlkYXRvciBBIHNpbmdsZSBhc3luYyB2YWxpZGF0b3Igb3IgYXJyYXkgb2YgYXN5bmMgdmFsaWRhdG9yXG4gICAgICogZnVuY3Rpb25zLlxuICAgICAqXG4gICAgICogQHVzYWdlTm90ZXNcbiAgICAgKlxuICAgICAqICMjIyBJbml0aWFsaXplIGEgY29udHJvbCBhcyBkaXNhYmxlZFxuICAgICAqXG4gICAgICogVGhlIGZvbGxvd2luZyBleGFtcGxlIHJldHVybnMgYSBjb250cm9sIHdpdGggYW4gaW5pdGlhbCB2YWx1ZSBpbiBhIGRpc2FibGVkIHN0YXRlLlxuICAgICAqXG4gICAgICogPGNvZGUtZXhhbXBsZSBwYXRoPVwiZm9ybXMvdHMvZm9ybUJ1aWxkZXIvZm9ybV9idWlsZGVyX2V4YW1wbGUudHNcIiByZWdpb249XCJkaXNhYmxlZC1jb250cm9sXCI+XG4gICAgICogPC9jb2RlLWV4YW1wbGU+XG4gICAgICovXG4gICAgY29udHJvbChmb3JtU3RhdGUsIHZhbGlkYXRvck9yT3B0cywgYXN5bmNWYWxpZGF0b3IpIHtcbiAgICAgICAgbGV0IG5ld09wdGlvbnMgPSB7fTtcbiAgICAgICAgaWYgKCF0aGlzLnVzZU5vbk51bGxhYmxlKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEZvcm1Db250cm9sKGZvcm1TdGF0ZSwgdmFsaWRhdG9yT3JPcHRzLCBhc3luY1ZhbGlkYXRvcik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzQWJzdHJhY3RDb250cm9sT3B0aW9ucyh2YWxpZGF0b3JPck9wdHMpKSB7XG4gICAgICAgICAgICAvLyBJZiB0aGUgc2Vjb25kIGFyZ3VtZW50IGlzIG9wdGlvbnMsIHRoZW4gdGhleSBhcmUgY29waWVkLlxuICAgICAgICAgICAgbmV3T3B0aW9ucyA9IHZhbGlkYXRvck9yT3B0cztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIElmIHRoZSBvdGhlciBhcmd1bWVudHMgYXJlIHZhbGlkYXRvcnMsIHRoZXkgYXJlIGNvcGllZCBpbnRvIGFuIG9wdGlvbnMgb2JqZWN0LlxuICAgICAgICAgICAgbmV3T3B0aW9ucy52YWxpZGF0b3JzID0gdmFsaWRhdG9yT3JPcHRzO1xuICAgICAgICAgICAgbmV3T3B0aW9ucy5hc3luY1ZhbGlkYXRvcnMgPSBhc3luY1ZhbGlkYXRvcjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IEZvcm1Db250cm9sKGZvcm1TdGF0ZSwgeyAuLi5uZXdPcHRpb25zLCBub25OdWxsYWJsZTogdHJ1ZSB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0cyBhIG5ldyBgRm9ybUFycmF5YCBmcm9tIHRoZSBnaXZlbiBhcnJheSBvZiBjb25maWd1cmF0aW9ucyxcbiAgICAgKiB2YWxpZGF0b3JzIGFuZCBvcHRpb25zLiBBY2NlcHRzIGEgc2luZ2xlIGdlbmVyaWMgYXJndW1lbnQsIHdoaWNoIGlzIHRoZSB0eXBlIG9mIGVhY2ggY29udHJvbFxuICAgICAqIGluc2lkZSB0aGUgYXJyYXkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY29udHJvbHMgQW4gYXJyYXkgb2YgY2hpbGQgY29udHJvbHMgb3IgY29udHJvbCBjb25maWdzLiBFYWNoIGNoaWxkIGNvbnRyb2wgaXMgZ2l2ZW4gYW5cbiAgICAgKiAgICAgaW5kZXggd2hlbiBpdCBpcyByZWdpc3RlcmVkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHZhbGlkYXRvck9yT3B0cyBBIHN5bmNocm9ub3VzIHZhbGlkYXRvciBmdW5jdGlvbiwgb3IgYW4gYXJyYXkgb2Ygc3VjaCBmdW5jdGlvbnMsIG9yIGFuXG4gICAgICogICAgIGBBYnN0cmFjdENvbnRyb2xPcHRpb25zYCBvYmplY3QgdGhhdCBjb250YWluc1xuICAgICAqIHZhbGlkYXRpb24gZnVuY3Rpb25zIGFuZCBhIHZhbGlkYXRpb24gdHJpZ2dlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBhc3luY1ZhbGlkYXRvciBBIHNpbmdsZSBhc3luYyB2YWxpZGF0b3Igb3IgYXJyYXkgb2YgYXN5bmMgdmFsaWRhdG9yIGZ1bmN0aW9ucy5cbiAgICAgKi9cbiAgICBhcnJheShjb250cm9scywgdmFsaWRhdG9yT3JPcHRzLCBhc3luY1ZhbGlkYXRvcikge1xuICAgICAgICBjb25zdCBjcmVhdGVkQ29udHJvbHMgPSBjb250cm9scy5tYXAoYyA9PiB0aGlzLl9jcmVhdGVDb250cm9sKGMpKTtcbiAgICAgICAgLy8gQ2FzdCB0byBgYW55YCBiZWNhdXNlIHRoZSBpbmZlcnJlZCB0eXBlcyBhcmUgbm90IGFzIHNwZWNpZmljIGFzIEVsZW1lbnQuXG4gICAgICAgIHJldHVybiBuZXcgRm9ybUFycmF5KGNyZWF0ZWRDb250cm9scywgdmFsaWRhdG9yT3JPcHRzLCBhc3luY1ZhbGlkYXRvcik7XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBfcmVkdWNlQ29udHJvbHMoY29udHJvbHMpIHtcbiAgICAgICAgY29uc3QgY3JlYXRlZENvbnRyb2xzID0ge307XG4gICAgICAgIE9iamVjdC5rZXlzKGNvbnRyb2xzKS5mb3JFYWNoKGNvbnRyb2xOYW1lID0+IHtcbiAgICAgICAgICAgIGNyZWF0ZWRDb250cm9sc1tjb250cm9sTmFtZV0gPSB0aGlzLl9jcmVhdGVDb250cm9sKGNvbnRyb2xzW2NvbnRyb2xOYW1lXSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gY3JlYXRlZENvbnRyb2xzO1xuICAgIH1cbiAgICAvKiogQGludGVybmFsICovXG4gICAgX2NyZWF0ZUNvbnRyb2woY29udHJvbHMpIHtcbiAgICAgICAgaWYgKGNvbnRyb2xzIGluc3RhbmNlb2YgRm9ybUNvbnRyb2wpIHtcbiAgICAgICAgICAgIHJldHVybiBjb250cm9scztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjb250cm9scyBpbnN0YW5jZW9mIEFic3RyYWN0Q29udHJvbCkgeyAvLyBBIGNvbnRyb2w7IGp1c3QgcmV0dXJuIGl0XG4gICAgICAgICAgICByZXR1cm4gY29udHJvbHM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheShjb250cm9scykpIHsgLy8gQ29udHJvbENvbmZpZyBUdXBsZVxuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBjb250cm9sc1swXTtcbiAgICAgICAgICAgIGNvbnN0IHZhbGlkYXRvciA9IGNvbnRyb2xzLmxlbmd0aCA+IDEgPyBjb250cm9sc1sxXSA6IG51bGw7XG4gICAgICAgICAgICBjb25zdCBhc3luY1ZhbGlkYXRvciA9IGNvbnRyb2xzLmxlbmd0aCA+IDIgPyBjb250cm9sc1syXSA6IG51bGw7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb250cm9sKHZhbHVlLCB2YWxpZGF0b3IsIGFzeW5jVmFsaWRhdG9yKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHsgLy8gVCBvciBGb3JtQ29udHJvbFN0YXRlPFQ+XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb250cm9sKGNvbnRyb2xzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzdGF0aWMgeyB0aGlzLsm1ZmFjID0gaTAuybXJtW5nRGVjbGFyZUZhY3RvcnkoeyBtaW5WZXJzaW9uOiBcIjEyLjAuMFwiLCB2ZXJzaW9uOiBcIjE3LjMuMTJcIiwgbmdJbXBvcnQ6IGkwLCB0eXBlOiBGb3JtQnVpbGRlciwgZGVwczogW10sIHRhcmdldDogaTAuybXJtUZhY3RvcnlUYXJnZXQuSW5qZWN0YWJsZSB9KTsgfVxuICAgIHN0YXRpYyB7IHRoaXMuybVwcm92ID0gaTAuybXJtW5nRGVjbGFyZUluamVjdGFibGUoeyBtaW5WZXJzaW9uOiBcIjEyLjAuMFwiLCB2ZXJzaW9uOiBcIjE3LjMuMTJcIiwgbmdJbXBvcnQ6IGkwLCB0eXBlOiBGb3JtQnVpbGRlciwgcHJvdmlkZWRJbjogJ3Jvb3QnIH0pOyB9XG59XG5pMC7Jtcm1bmdEZWNsYXJlQ2xhc3NNZXRhZGF0YSh7IG1pblZlcnNpb246IFwiMTIuMC4wXCIsIHZlcnNpb246IFwiMTcuMy4xMlwiLCBuZ0ltcG9ydDogaTAsIHR5cGU6IEZvcm1CdWlsZGVyLCBkZWNvcmF0b3JzOiBbe1xuICAgICAgICAgICAgdHlwZTogSW5qZWN0YWJsZSxcbiAgICAgICAgICAgIGFyZ3M6IFt7IHByb3ZpZGVkSW46ICdyb290JyB9XVxuICAgICAgICB9XSB9KTtcbi8qKlxuICogQGRlc2NyaXB0aW9uXG4gKiBgTm9uTnVsbGFibGVGb3JtQnVpbGRlcmAgaXMgc2ltaWxhciB0byB7QGxpbmsgRm9ybUJ1aWxkZXJ9LCBidXQgYXV0b21hdGljYWxseSBjb25zdHJ1Y3RlZFxuICoge0BsaW5rIEZvcm1Db250cm9sfSBlbGVtZW50cyBoYXZlIGB7bm9uTnVsbGFibGU6IHRydWV9YCBhbmQgYXJlIG5vbi1udWxsYWJsZS5cbiAqXG4gKiBAcHVibGljQXBpXG4gKi9cbmNsYXNzIE5vbk51bGxhYmxlRm9ybUJ1aWxkZXIge1xuICAgIHN0YXRpYyB7IHRoaXMuybVmYWMgPSBpMC7Jtcm1bmdEZWNsYXJlRmFjdG9yeSh7IG1pblZlcnNpb246IFwiMTIuMC4wXCIsIHZlcnNpb246IFwiMTcuMy4xMlwiLCBuZ0ltcG9ydDogaTAsIHR5cGU6IE5vbk51bGxhYmxlRm9ybUJ1aWxkZXIsIGRlcHM6IFtdLCB0YXJnZXQ6IGkwLsm1ybVGYWN0b3J5VGFyZ2V0LkluamVjdGFibGUgfSk7IH1cbiAgICBzdGF0aWMgeyB0aGlzLsm1cHJvdiA9IGkwLsm1ybVuZ0RlY2xhcmVJbmplY3RhYmxlKHsgbWluVmVyc2lvbjogXCIxMi4wLjBcIiwgdmVyc2lvbjogXCIxNy4zLjEyXCIsIG5nSW1wb3J0OiBpMCwgdHlwZTogTm9uTnVsbGFibGVGb3JtQnVpbGRlciwgcHJvdmlkZWRJbjogJ3Jvb3QnLCB1c2VGYWN0b3J5OiAoKSA9PiBpbmplY3QoRm9ybUJ1aWxkZXIpLm5vbk51bGxhYmxlIH0pOyB9XG59XG5pMC7Jtcm1bmdEZWNsYXJlQ2xhc3NNZXRhZGF0YSh7IG1pblZlcnNpb246IFwiMTIuMC4wXCIsIHZlcnNpb246IFwiMTcuMy4xMlwiLCBuZ0ltcG9ydDogaTAsIHR5cGU6IE5vbk51bGxhYmxlRm9ybUJ1aWxkZXIsIGRlY29yYXRvcnM6IFt7XG4gICAgICAgICAgICB0eXBlOiBJbmplY3RhYmxlLFxuICAgICAgICAgICAgYXJnczogW3tcbiAgICAgICAgICAgICAgICAgICAgcHJvdmlkZWRJbjogJ3Jvb3QnLFxuICAgICAgICAgICAgICAgICAgICB1c2VGYWN0b3J5OiAoKSA9PiBpbmplY3QoRm9ybUJ1aWxkZXIpLm5vbk51bGxhYmxlLFxuICAgICAgICAgICAgICAgIH1dXG4gICAgICAgIH1dIH0pO1xuLyoqXG4gKiBVbnR5cGVkRm9ybUJ1aWxkZXIgaXMgdGhlIHNhbWUgYXMgYEZvcm1CdWlsZGVyYCwgYnV0IGl0IHByb3ZpZGVzIHVudHlwZWQgY29udHJvbHMuXG4gKi9cbmNsYXNzIFVudHlwZWRGb3JtQnVpbGRlciBleHRlbmRzIEZvcm1CdWlsZGVyIHtcbiAgICBncm91cChjb250cm9sc0NvbmZpZywgb3B0aW9ucyA9IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHN1cGVyLmdyb3VwKGNvbnRyb2xzQ29uZmlnLCBvcHRpb25zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTGlrZSBgRm9ybUJ1aWxkZXIjY29udHJvbGAsIGV4Y2VwdCB0aGUgcmVzdWx0aW5nIGNvbnRyb2wgaXMgdW50eXBlZC5cbiAgICAgKi9cbiAgICBjb250cm9sKGZvcm1TdGF0ZSwgdmFsaWRhdG9yT3JPcHRzLCBhc3luY1ZhbGlkYXRvcikge1xuICAgICAgICByZXR1cm4gc3VwZXIuY29udHJvbChmb3JtU3RhdGUsIHZhbGlkYXRvck9yT3B0cywgYXN5bmNWYWxpZGF0b3IpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBMaWtlIGBGb3JtQnVpbGRlciNhcnJheWAsIGV4Y2VwdCB0aGUgcmVzdWx0aW5nIGFycmF5IGlzIHVudHlwZWQuXG4gICAgICovXG4gICAgYXJyYXkoY29udHJvbHNDb25maWcsIHZhbGlkYXRvck9yT3B0cywgYXN5bmNWYWxpZGF0b3IpIHtcbiAgICAgICAgcmV0dXJuIHN1cGVyLmFycmF5KGNvbnRyb2xzQ29uZmlnLCB2YWxpZGF0b3JPck9wdHMsIGFzeW5jVmFsaWRhdG9yKTtcbiAgICB9XG4gICAgc3RhdGljIHsgdGhpcy7JtWZhYyA9IGkwLsm1ybVuZ0RlY2xhcmVGYWN0b3J5KHsgbWluVmVyc2lvbjogXCIxMi4wLjBcIiwgdmVyc2lvbjogXCIxNy4zLjEyXCIsIG5nSW1wb3J0OiBpMCwgdHlwZTogVW50eXBlZEZvcm1CdWlsZGVyLCBkZXBzOiBudWxsLCB0YXJnZXQ6IGkwLsm1ybVGYWN0b3J5VGFyZ2V0LkluamVjdGFibGUgfSk7IH1cbiAgICBzdGF0aWMgeyB0aGlzLsm1cHJvdiA9IGkwLsm1ybVuZ0RlY2xhcmVJbmplY3RhYmxlKHsgbWluVmVyc2lvbjogXCIxMi4wLjBcIiwgdmVyc2lvbjogXCIxNy4zLjEyXCIsIG5nSW1wb3J0OiBpMCwgdHlwZTogVW50eXBlZEZvcm1CdWlsZGVyLCBwcm92aWRlZEluOiAncm9vdCcgfSk7IH1cbn1cbmkwLsm1ybVuZ0RlY2xhcmVDbGFzc01ldGFkYXRhKHsgbWluVmVyc2lvbjogXCIxMi4wLjBcIiwgdmVyc2lvbjogXCIxNy4zLjEyXCIsIG5nSW1wb3J0OiBpMCwgdHlwZTogVW50eXBlZEZvcm1CdWlsZGVyLCBkZWNvcmF0b3JzOiBbe1xuICAgICAgICAgICAgdHlwZTogSW5qZWN0YWJsZSxcbiAgICAgICAgICAgIGFyZ3M6IFt7IHByb3ZpZGVkSW46ICdyb290JyB9XVxuICAgICAgICB9XSB9KTtcblxuLyoqXG4gKiBAbW9kdWxlXG4gKiBAZGVzY3JpcHRpb25cbiAqIEVudHJ5IHBvaW50IGZvciBhbGwgcHVibGljIEFQSXMgb2YgdGhlIGZvcm1zIHBhY2thZ2UuXG4gKi9cbi8qKlxuICogQHB1YmxpY0FwaVxuICovXG5jb25zdCBWRVJTSU9OID0gbmV3IFZlcnNpb24oJzE3LjMuMTInKTtcblxuLyoqXG4gKiBFeHBvcnRzIHRoZSByZXF1aXJlZCBwcm92aWRlcnMgYW5kIGRpcmVjdGl2ZXMgZm9yIHRlbXBsYXRlLWRyaXZlbiBmb3JtcyxcbiAqIG1ha2luZyB0aGVtIGF2YWlsYWJsZSBmb3IgaW1wb3J0IGJ5IE5nTW9kdWxlcyB0aGF0IGltcG9ydCB0aGlzIG1vZHVsZS5cbiAqXG4gKiBAc2VlIFtGb3JtcyBPdmVydmlld10oL2d1aWRlL2Zvcm1zLW92ZXJ2aWV3KVxuICogQHNlZSBbVGVtcGxhdGUtZHJpdmVuIEZvcm1zIEd1aWRlXSgvZ3VpZGUvZm9ybXMpXG4gKlxuICogQHB1YmxpY0FwaVxuICovXG5jbGFzcyBGb3Jtc01vZHVsZSB7XG4gICAgLyoqXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICogUHJvdmlkZXMgb3B0aW9ucyBmb3IgY29uZmlndXJpbmcgdGhlIGZvcm1zIG1vZHVsZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRzIEFuIG9iamVjdCBvZiBjb25maWd1cmF0aW9uIG9wdGlvbnNcbiAgICAgKiAqIGBjYWxsU2V0RGlzYWJsZWRTdGF0ZWAgQ29uZmlndXJlcyB3aGV0aGVyIHRvIGBhbHdheXNgIGNhbGwgYHNldERpc2FibGVkU3RhdGVgLCB3aGljaCBpcyBtb3JlXG4gICAgICogY29ycmVjdCwgb3IgdG8gb25seSBjYWxsIGl0IGB3aGVuRGlzYWJsZWRgLCB3aGljaCBpcyB0aGUgbGVnYWN5IGJlaGF2aW9yLlxuICAgICAqL1xuICAgIHN0YXRpYyB3aXRoQ29uZmlnKG9wdHMpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG5nTW9kdWxlOiBGb3Jtc01vZHVsZSxcbiAgICAgICAgICAgIHByb3ZpZGVyczogW3tcbiAgICAgICAgICAgICAgICAgICAgcHJvdmlkZTogQ0FMTF9TRVRfRElTQUJMRURfU1RBVEUsXG4gICAgICAgICAgICAgICAgICAgIHVzZVZhbHVlOiBvcHRzLmNhbGxTZXREaXNhYmxlZFN0YXRlID8/IHNldERpc2FibGVkU3RhdGVEZWZhdWx0XG4gICAgICAgICAgICAgICAgfV1cbiAgICAgICAgfTtcbiAgICB9XG4gICAgc3RhdGljIHsgdGhpcy7JtWZhYyA9IGkwLsm1ybVuZ0RlY2xhcmVGYWN0b3J5KHsgbWluVmVyc2lvbjogXCIxMi4wLjBcIiwgdmVyc2lvbjogXCIxNy4zLjEyXCIsIG5nSW1wb3J0OiBpMCwgdHlwZTogRm9ybXNNb2R1bGUsIGRlcHM6IFtdLCB0YXJnZXQ6IGkwLsm1ybVGYWN0b3J5VGFyZ2V0Lk5nTW9kdWxlIH0pOyB9XG4gICAgc3RhdGljIHsgdGhpcy7JtW1vZCA9IGkwLsm1ybVuZ0RlY2xhcmVOZ01vZHVsZSh7IG1pblZlcnNpb246IFwiMTQuMC4wXCIsIHZlcnNpb246IFwiMTcuMy4xMlwiLCBuZ0ltcG9ydDogaTAsIHR5cGU6IEZvcm1zTW9kdWxlLCBkZWNsYXJhdGlvbnM6IFtOZ01vZGVsLCBOZ01vZGVsR3JvdXAsIE5nRm9ybV0sIGV4cG9ydHM6IFvJtUludGVybmFsRm9ybXNTaGFyZWRNb2R1bGUsIE5nTW9kZWwsIE5nTW9kZWxHcm91cCwgTmdGb3JtXSB9KTsgfVxuICAgIHN0YXRpYyB7IHRoaXMuybVpbmogPSBpMC7Jtcm1bmdEZWNsYXJlSW5qZWN0b3IoeyBtaW5WZXJzaW9uOiBcIjEyLjAuMFwiLCB2ZXJzaW9uOiBcIjE3LjMuMTJcIiwgbmdJbXBvcnQ6IGkwLCB0eXBlOiBGb3Jtc01vZHVsZSwgaW1wb3J0czogW8m1SW50ZXJuYWxGb3Jtc1NoYXJlZE1vZHVsZV0gfSk7IH1cbn1cbmkwLsm1ybVuZ0RlY2xhcmVDbGFzc01ldGFkYXRhKHsgbWluVmVyc2lvbjogXCIxMi4wLjBcIiwgdmVyc2lvbjogXCIxNy4zLjEyXCIsIG5nSW1wb3J0OiBpMCwgdHlwZTogRm9ybXNNb2R1bGUsIGRlY29yYXRvcnM6IFt7XG4gICAgICAgICAgICB0eXBlOiBOZ01vZHVsZSxcbiAgICAgICAgICAgIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgICAgIGRlY2xhcmF0aW9uczogVEVNUExBVEVfRFJJVkVOX0RJUkVDVElWRVMsXG4gICAgICAgICAgICAgICAgICAgIGV4cG9ydHM6IFvJtUludGVybmFsRm9ybXNTaGFyZWRNb2R1bGUsIFRFTVBMQVRFX0RSSVZFTl9ESVJFQ1RJVkVTXVxuICAgICAgICAgICAgICAgIH1dXG4gICAgICAgIH1dIH0pO1xuLyoqXG4gKiBFeHBvcnRzIHRoZSByZXF1aXJlZCBpbmZyYXN0cnVjdHVyZSBhbmQgZGlyZWN0aXZlcyBmb3IgcmVhY3RpdmUgZm9ybXMsXG4gKiBtYWtpbmcgdGhlbSBhdmFpbGFibGUgZm9yIGltcG9ydCBieSBOZ01vZHVsZXMgdGhhdCBpbXBvcnQgdGhpcyBtb2R1bGUuXG4gKlxuICogQHNlZSBbRm9ybXMgT3ZlcnZpZXddKGd1aWRlL2Zvcm1zLW92ZXJ2aWV3KVxuICogQHNlZSBbUmVhY3RpdmUgRm9ybXMgR3VpZGVdKGd1aWRlL3JlYWN0aXZlLWZvcm1zKVxuICpcbiAqIEBwdWJsaWNBcGlcbiAqL1xuY2xhc3MgUmVhY3RpdmVGb3Jtc01vZHVsZSB7XG4gICAgLyoqXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICogUHJvdmlkZXMgb3B0aW9ucyBmb3IgY29uZmlndXJpbmcgdGhlIHJlYWN0aXZlIGZvcm1zIG1vZHVsZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRzIEFuIG9iamVjdCBvZiBjb25maWd1cmF0aW9uIG9wdGlvbnNcbiAgICAgKiAqIGB3YXJuT25OZ01vZGVsV2l0aEZvcm1Db250cm9sYCBDb25maWd1cmVzIHdoZW4gdG8gZW1pdCBhIHdhcm5pbmcgd2hlbiBhbiBgbmdNb2RlbGBcbiAgICAgKiBiaW5kaW5nIGlzIHVzZWQgd2l0aCByZWFjdGl2ZSBmb3JtIGRpcmVjdGl2ZXMuXG4gICAgICogKiBgY2FsbFNldERpc2FibGVkU3RhdGVgIENvbmZpZ3VyZXMgd2hldGhlciB0byBgYWx3YXlzYCBjYWxsIGBzZXREaXNhYmxlZFN0YXRlYCwgd2hpY2ggaXMgbW9yZVxuICAgICAqIGNvcnJlY3QsIG9yIHRvIG9ubHkgY2FsbCBpdCBgd2hlbkRpc2FibGVkYCwgd2hpY2ggaXMgdGhlIGxlZ2FjeSBiZWhhdmlvci5cbiAgICAgKi9cbiAgICBzdGF0aWMgd2l0aENvbmZpZyhvcHRzKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBuZ01vZHVsZTogUmVhY3RpdmVGb3Jtc01vZHVsZSxcbiAgICAgICAgICAgIHByb3ZpZGVyczogW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgcHJvdmlkZTogTkdfTU9ERUxfV0lUSF9GT1JNX0NPTlRST0xfV0FSTklORyxcbiAgICAgICAgICAgICAgICAgICAgdXNlVmFsdWU6IG9wdHMud2Fybk9uTmdNb2RlbFdpdGhGb3JtQ29udHJvbCA/PyAnYWx3YXlzJ1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBwcm92aWRlOiBDQUxMX1NFVF9ESVNBQkxFRF9TVEFURSxcbiAgICAgICAgICAgICAgICAgICAgdXNlVmFsdWU6IG9wdHMuY2FsbFNldERpc2FibGVkU3RhdGUgPz8gc2V0RGlzYWJsZWRTdGF0ZURlZmF1bHRcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBdXG4gICAgICAgIH07XG4gICAgfVxuICAgIHN0YXRpYyB7IHRoaXMuybVmYWMgPSBpMC7Jtcm1bmdEZWNsYXJlRmFjdG9yeSh7IG1pblZlcnNpb246IFwiMTIuMC4wXCIsIHZlcnNpb246IFwiMTcuMy4xMlwiLCBuZ0ltcG9ydDogaTAsIHR5cGU6IFJlYWN0aXZlRm9ybXNNb2R1bGUsIGRlcHM6IFtdLCB0YXJnZXQ6IGkwLsm1ybVGYWN0b3J5VGFyZ2V0Lk5nTW9kdWxlIH0pOyB9XG4gICAgc3RhdGljIHsgdGhpcy7JtW1vZCA9IGkwLsm1ybVuZ0RlY2xhcmVOZ01vZHVsZSh7IG1pblZlcnNpb246IFwiMTQuMC4wXCIsIHZlcnNpb246IFwiMTcuMy4xMlwiLCBuZ0ltcG9ydDogaTAsIHR5cGU6IFJlYWN0aXZlRm9ybXNNb2R1bGUsIGRlY2xhcmF0aW9uczogW0Zvcm1Db250cm9sRGlyZWN0aXZlLCBGb3JtR3JvdXBEaXJlY3RpdmUsIEZvcm1Db250cm9sTmFtZSwgRm9ybUdyb3VwTmFtZSwgRm9ybUFycmF5TmFtZV0sIGV4cG9ydHM6IFvJtUludGVybmFsRm9ybXNTaGFyZWRNb2R1bGUsIEZvcm1Db250cm9sRGlyZWN0aXZlLCBGb3JtR3JvdXBEaXJlY3RpdmUsIEZvcm1Db250cm9sTmFtZSwgRm9ybUdyb3VwTmFtZSwgRm9ybUFycmF5TmFtZV0gfSk7IH1cbiAgICBzdGF0aWMgeyB0aGlzLsm1aW5qID0gaTAuybXJtW5nRGVjbGFyZUluamVjdG9yKHsgbWluVmVyc2lvbjogXCIxMi4wLjBcIiwgdmVyc2lvbjogXCIxNy4zLjEyXCIsIG5nSW1wb3J0OiBpMCwgdHlwZTogUmVhY3RpdmVGb3Jtc01vZHVsZSwgaW1wb3J0czogW8m1SW50ZXJuYWxGb3Jtc1NoYXJlZE1vZHVsZV0gfSk7IH1cbn1cbmkwLsm1ybVuZ0RlY2xhcmVDbGFzc01ldGFkYXRhKHsgbWluVmVyc2lvbjogXCIxMi4wLjBcIiwgdmVyc2lvbjogXCIxNy4zLjEyXCIsIG5nSW1wb3J0OiBpMCwgdHlwZTogUmVhY3RpdmVGb3Jtc01vZHVsZSwgZGVjb3JhdG9yczogW3tcbiAgICAgICAgICAgIHR5cGU6IE5nTW9kdWxlLFxuICAgICAgICAgICAgYXJnczogW3tcbiAgICAgICAgICAgICAgICAgICAgZGVjbGFyYXRpb25zOiBbUkVBQ1RJVkVfRFJJVkVOX0RJUkVDVElWRVNdLFxuICAgICAgICAgICAgICAgICAgICBleHBvcnRzOiBbybVJbnRlcm5hbEZvcm1zU2hhcmVkTW9kdWxlLCBSRUFDVElWRV9EUklWRU5fRElSRUNUSVZFU11cbiAgICAgICAgICAgICAgICB9XVxuICAgICAgICB9XSB9KTtcblxuLyoqXG4gKiBAbW9kdWxlXG4gKiBAZGVzY3JpcHRpb25cbiAqIFRoaXMgbW9kdWxlIGlzIHVzZWQgZm9yIGhhbmRsaW5nIHVzZXIgaW5wdXQsIGJ5IGRlZmluaW5nIGFuZCBidWlsZGluZyBhIGBGb3JtR3JvdXBgIHRoYXRcbiAqIGNvbnNpc3RzIG9mIGBGb3JtQ29udHJvbGAgb2JqZWN0cywgYW5kIG1hcHBpbmcgdGhlbSBvbnRvIHRoZSBET00uIGBGb3JtQ29udHJvbGBcbiAqIG9iamVjdHMgY2FuIHRoZW4gYmUgdXNlZCB0byByZWFkIGluZm9ybWF0aW9uIGZyb20gdGhlIGZvcm0gRE9NIGVsZW1lbnRzLlxuICpcbiAqIEZvcm1zIHByb3ZpZGVycyBhcmUgbm90IGluY2x1ZGVkIGluIGRlZmF1bHQgcHJvdmlkZXJzOyB5b3UgbXVzdCBpbXBvcnQgdGhlc2UgcHJvdmlkZXJzXG4gKiBleHBsaWNpdGx5LlxuICovXG5cbi8qKlxuICogQG1vZHVsZVxuICogQGRlc2NyaXB0aW9uXG4gKiBFbnRyeSBwb2ludCBmb3IgYWxsIHB1YmxpYyBBUElzIG9mIHRoaXMgcGFja2FnZS5cbiAqL1xuLy8gVGhpcyBmaWxlIG9ubHkgcmVleHBvcnRzIGNvbnRlbnQgb2YgdGhlIGBzcmNgIGZvbGRlci4gS2VlcCBpdCB0aGF0IHdheS5cblxuLy8gVGhpcyBmaWxlIGlzIG5vdCB1c2VkIHRvIGJ1aWxkIHRoaXMgbW9kdWxlLiBJdCBpcyBvbmx5IHVzZWQgZHVyaW5nIGVkaXRpbmdcblxuLyoqXG4gKiBHZW5lcmF0ZWQgYnVuZGxlIGluZGV4LiBEbyBub3QgZWRpdC5cbiAqL1xuXG5leHBvcnQgeyBBYnN0cmFjdENvbnRyb2wsIEFic3RyYWN0Q29udHJvbERpcmVjdGl2ZSwgQWJzdHJhY3RGb3JtR3JvdXBEaXJlY3RpdmUsIENPTVBPU0lUSU9OX0JVRkZFUl9NT0RFLCBDaGVja2JveENvbnRyb2xWYWx1ZUFjY2Vzc29yLCBDaGVja2JveFJlcXVpcmVkVmFsaWRhdG9yLCBDb250cm9sQ29udGFpbmVyLCBEZWZhdWx0VmFsdWVBY2Nlc3NvciwgRW1haWxWYWxpZGF0b3IsIEZvcm1BcnJheSwgRm9ybUFycmF5TmFtZSwgRm9ybUJ1aWxkZXIsIEZvcm1Db250cm9sLCBGb3JtQ29udHJvbERpcmVjdGl2ZSwgRm9ybUNvbnRyb2xOYW1lLCBGb3JtR3JvdXAsIEZvcm1Hcm91cERpcmVjdGl2ZSwgRm9ybUdyb3VwTmFtZSwgRm9ybVJlY29yZCwgRm9ybXNNb2R1bGUsIE1heExlbmd0aFZhbGlkYXRvciwgTWF4VmFsaWRhdG9yLCBNaW5MZW5ndGhWYWxpZGF0b3IsIE1pblZhbGlkYXRvciwgTkdfQVNZTkNfVkFMSURBVE9SUywgTkdfVkFMSURBVE9SUywgTkdfVkFMVUVfQUNDRVNTT1IsIE5nQ29udHJvbCwgTmdDb250cm9sU3RhdHVzLCBOZ0NvbnRyb2xTdGF0dXNHcm91cCwgTmdGb3JtLCBOZ01vZGVsLCBOZ01vZGVsR3JvdXAsIE5nU2VsZWN0T3B0aW9uLCBOb25OdWxsYWJsZUZvcm1CdWlsZGVyLCBOdW1iZXJWYWx1ZUFjY2Vzc29yLCBQYXR0ZXJuVmFsaWRhdG9yLCBSYWRpb0NvbnRyb2xWYWx1ZUFjY2Vzc29yLCBSYW5nZVZhbHVlQWNjZXNzb3IsIFJlYWN0aXZlRm9ybXNNb2R1bGUsIFJlcXVpcmVkVmFsaWRhdG9yLCBTZWxlY3RDb250cm9sVmFsdWVBY2Nlc3NvciwgU2VsZWN0TXVsdGlwbGVDb250cm9sVmFsdWVBY2Nlc3NvciwgVW50eXBlZEZvcm1BcnJheSwgVW50eXBlZEZvcm1CdWlsZGVyLCBVbnR5cGVkRm9ybUNvbnRyb2wsIFVudHlwZWRGb3JtR3JvdXAsIFZFUlNJT04sIFZhbGlkYXRvcnMsIGlzRm9ybUFycmF5LCBpc0Zvcm1Db250cm9sLCBpc0Zvcm1Hcm91cCwgaXNGb3JtUmVjb3JkLCDJtUludGVybmFsRm9ybXNTaGFyZWRNb2R1bGUsIMm1TmdOb1ZhbGlkYXRlLCDJtU5nU2VsZWN0TXVsdGlwbGVPcHRpb24gfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZvcm1zLm1qcy5tYXBcbiIsImltcG9ydCAqIGFzIGkwIGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgRXZlbnRFbWl0dGVyLCBDb21wb25lbnQsIENoYW5nZURldGVjdGlvblN0cmF0ZWd5LCBJbnB1dCwgT3V0cHV0LCBWaWV3Q2hpbGQsIEhvc3RMaXN0ZW5lciwgTmdNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IE5HX1ZBTFVFX0FDQ0VTU09SLCBGb3Jtc01vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcbmltcG9ydCAqIGFzIGkxIGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQgeyBDb21tb25Nb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuXG4vKipcbiAqIERlZmluZXMgdGhlIHNldCBvZiBzdGF0ZXMgZm9yIGEgY2hlY2tib3ggY29tcG9uZW50LlxuICovXG52YXIgQ2hlY2tib3hTdGF0ZTtcbihmdW5jdGlvbiAoQ2hlY2tib3hTdGF0ZSkge1xuICAgIENoZWNrYm94U3RhdGVbQ2hlY2tib3hTdGF0ZVtcIkluaXRcIl0gPSAwXSA9IFwiSW5pdFwiO1xuICAgIENoZWNrYm94U3RhdGVbQ2hlY2tib3hTdGF0ZVtcIkluZGV0ZXJtaW5hdGVcIl0gPSAxXSA9IFwiSW5kZXRlcm1pbmF0ZVwiO1xuICAgIENoZWNrYm94U3RhdGVbQ2hlY2tib3hTdGF0ZVtcIkNoZWNrZWRcIl0gPSAyXSA9IFwiQ2hlY2tlZFwiO1xuICAgIENoZWNrYm94U3RhdGVbQ2hlY2tib3hTdGF0ZVtcIlVuY2hlY2tlZFwiXSA9IDNdID0gXCJVbmNoZWNrZWRcIjtcbn0pKENoZWNrYm94U3RhdGUgfHwgKENoZWNrYm94U3RhdGUgPSB7fSkpO1xuLyoqXG4gKiBHZXQgc3RhcnRlZCB3aXRoIGltcG9ydGluZyB0aGUgbW9kdWxlOlxuICpcbiAqIGBgYHR5cGVzY3JpcHRcbiAqIGltcG9ydCB7IENoZWNrYm94TW9kdWxlIH0gZnJvbSAnY2FyYm9uLWNvbXBvbmVudHMtYW5ndWxhcic7XG4gKiBgYGBcbiAqXG4gKiBbU2VlIGRlbW9dKC4uLy4uLz9wYXRoPS9zdG9yeS9jb21wb25lbnRzLWNoZWNrYm94LS1iYXNpYylcbiAqL1xuY2xhc3MgQ2hlY2tib3gge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgYENoZWNrYm94YC5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihjaGFuZ2VEZXRlY3RvclJlZikge1xuICAgICAgICB0aGlzLmNoYW5nZURldGVjdG9yUmVmID0gY2hhbmdlRGV0ZWN0b3JSZWY7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXQgdG8gYHRydWVgIGZvciBhIGRpc2FibGVkIGNoZWNrYm94LlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5kaXNhYmxlZCA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogU2V0IHRvIGB0cnVlYCBmb3IgYSBsb2FkaW5nIGNoZWNrYm94LlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5za2VsZXRvbiA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogU2V0IHRvIGB0cnVlYCB0byBoaWRlIHRoZSBjaGVja2JveCBsYWJlbHMuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmhpZGVMYWJlbCA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHVuaXF1ZSBpZCBmb3IgdGhlIGNoZWNrYm94IGNvbXBvbmVudC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuaWQgPSBgY2hlY2tib3gtJHtDaGVja2JveC5jaGVja2JveENvdW50fWA7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFbWl0cyBjbGljayBldmVudC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY2xpY2sgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFbWl0cyBhbiBldmVudCB3aGVuIHRoZSB2YWx1ZSBvZiB0aGUgY2hlY2tib3ggY2hhbmdlcy5cbiAgICAgICAgICpcbiAgICAgICAgICogQWxsb3dzIGRvdWJsZSBiaWRpbmcgd2l0aCB0aGUgYGNoZWNrZWRgIElucHV0LlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jaGVja2VkQ2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICAvKipcbiAgICAgICAgICogRW1pdHMgZXZlbnQgbm90aWZ5aW5nIG90aGVyIGNsYXNzZXMgd2hlbiBhIGNoYW5nZSBpbiBzdGF0ZSBvY2N1cnMgc3BlY2lmaWNhbGx5XG4gICAgICAgICAqIG9uIGFuIGluZGV0ZXJtaW5hdGUgY2hlY2tib3guXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmluZGV0ZXJtaW5hdGVDaGFuZ2UgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXQgdG8gYHRydWVgIGlmIHRoZSBpbnB1dCBjaGVja2JveCBpcyBzZWxlY3RlZCAob3IgY2hlY2tlZCkuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9jaGVja2VkID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXQgdG8gYHRydWVgIGlmIHRoZSBpbnB1dCBjaGVja2JveCBpcyBpbiBzdGF0ZSBpbmRldGVybWluYXRlLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5faW5kZXRlcm1pbmF0ZSA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogS2VlcHMgYSByZWZlcmVuY2UgdG8gdGhlIGNoZWNrYm94ZXMgY3VycmVudCBzdGF0ZSwgYXMgZGVmaW5lZCBpbiBgQ2hlY2tib3hTdGF0ZWAuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmN1cnJlbnRDaGVja2JveFN0YXRlID0gQ2hlY2tib3hTdGF0ZS5Jbml0O1xuICAgICAgICAvKipcbiAgICAgICAgICogQ2FsbGVkIHdoZW4gY2hlY2tib3ggaXMgYmx1cnJlZC4gTmVlZGVkIHRvIHByb3Blcmx5IGltcGxlbWVudCBgQ29udHJvbFZhbHVlQWNjZXNzb3JgLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5vblRvdWNoZWQgPSAoKSA9PiB7IH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBNZXRob2Qgc2V0IGluIGByZWdpc3Rlck9uQ2hhbmdlYCB0byBwcm9wYWdhdGUgY2hhbmdlcyBiYWNrIHRvIHRoZSBmb3JtLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5wcm9wYWdhdGVDaGFuZ2UgPSAoXykgPT4geyB9O1xuICAgICAgICBDaGVja2JveC5jaGVja2JveENvdW50Kys7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgY2hlY2tib3gncyBpbmRldGVybWluYXRlIHN0YXRlIHRvIG1hdGNoIHRoZSBwYXJhbWV0ZXIgYW5kIHRyYW5zaXRpb24gdGhlIHZpZXcgdG8gcmVmbGVjdCB0aGUgY2hhbmdlLlxuICAgICAqXG4gICAgICogQWxsb3dzIGRvdWJsZSBiaW5kaW5nIHdpdGggdGhlIGBpbmRldGVybWluYXRlQ2hhbmdlYCBPdXRwdXQuXG4gICAgICovXG4gICAgc2V0IGluZGV0ZXJtaW5hdGUoaW5kZXRlcm1pbmF0ZSkge1xuICAgICAgICBpZiAoaW5kZXRlcm1pbmF0ZSA9PT0gdGhpcy5faW5kZXRlcm1pbmF0ZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2luZGV0ZXJtaW5hdGUgPSBpbmRldGVybWluYXRlO1xuICAgICAgICBpZiAodGhpcy5faW5kZXRlcm1pbmF0ZSkge1xuICAgICAgICAgICAgdGhpcy50cmFuc2l0aW9uQ2hlY2tib3hTdGF0ZShDaGVja2JveFN0YXRlLkluZGV0ZXJtaW5hdGUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy50cmFuc2l0aW9uQ2hlY2tib3hTdGF0ZSh0aGlzLmNoZWNrZWQgPyBDaGVja2JveFN0YXRlLkNoZWNrZWQgOiBDaGVja2JveFN0YXRlLlVuY2hlY2tlZCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuaW5wdXRDaGVja2JveCAmJiB0aGlzLmlucHV0Q2hlY2tib3gubmF0aXZlRWxlbWVudCkge1xuICAgICAgICAgICAgdGhpcy5pbnB1dENoZWNrYm94Lm5hdGl2ZUVsZW1lbnQuaW5kZXRlcm1pbmF0ZSA9IGluZGV0ZXJtaW5hdGU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jaGFuZ2VEZXRlY3RvclJlZi5tYXJrRm9yQ2hlY2soKTtcbiAgICAgICAgdGhpcy5pbmRldGVybWluYXRlQ2hhbmdlLmVtaXQodGhpcy5faW5kZXRlcm1pbmF0ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlZmxlY3RzIHdoZXRoZXIgdGhlIGNoZWNrYm94IHN0YXRlIGlzIGluZGV0ZXJtaW5hdGUuXG4gICAgICovXG4gICAgZ2V0IGluZGV0ZXJtaW5hdGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbmRldGVybWluYXRlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBgY2hlY2tlZGAgc3RhdGUuIGB0cnVlYCBmb3IgY2hlY2tlZCwgYGZhbHNlYCBmb3IgdW5jaGVja2VkXG4gICAgICpcbiAgICAgKiBBbGxvd3MgZG91YmxlIGJpbmRpbmcgd2l0aCB0aGUgYGNoZWNrZWRDaGFuZ2VgIE91dHB1dC5cbiAgICAgKi9cbiAgICBzZXQgY2hlY2tlZChjaGVja2VkKSB7XG4gICAgICAgIHRoaXMuc2V0Q2hlY2tlZChjaGVja2VkLCBmYWxzZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdmFsdWUgYHRydWVgIGlmIHN0YXRlIGlzIHNlbGVjdGVkIGZvciB0aGUgY2hlY2tib3guXG4gICAgICovXG4gICAgZ2V0IGNoZWNrZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jaGVja2VkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUb2dnbGUgdGhlIHNlbGVjdGVkIHN0YXRlIG9mIHRoZSBjaGVja2JveC5cbiAgICAgKi9cbiAgICB0b2dnbGUoKSB7XG4gICAgICAgIC8vIEZsaXAgY2hlY2tlZCBhbmQgcmVzZXQgaW5kZXRlcm1pbmF0ZVxuICAgICAgICB0aGlzLnNldENoZWNrZWQoIXRoaXMuY2hlY2tlZCwgdHJ1ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdyaXRlcyBhIHZhbHVlIGZyb20gYG5nTW9kZWxgIHRvIHRoZSBjb21wb25lbnQuXG4gICAgICpcbiAgICAgKiBJbiB0aGlzIGNhc2UgdGhlIHZhbHVlIGlzIHRoZSBgY2hlY2tlZGAgcHJvcGVydHkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdmFsdWUgYm9vbGVhbiwgY29ycmVzcG9uZHMgdG8gdGhlIGBjaGVja2VkYCBwcm9wZXJ0eS5cbiAgICAgKi9cbiAgICB3cml0ZVZhbHVlKHZhbHVlKSB7XG4gICAgICAgIC8vIFNldCBjaGVja2VkIGFuZCByZXNldCBpbmRldGVybWluYXRlXG4gICAgICAgIHRoaXMuc2V0Q2hlY2tlZCghIXZhbHVlLCB0cnVlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyBhIG1ldGhvZCBpbiBvcmRlciB0byBwcm9wYWdhdGUgY2hhbmdlcyBiYWNrIHRvIHRoZSBmb3JtLlxuICAgICAqL1xuICAgIHJlZ2lzdGVyT25DaGFuZ2UoZm4pIHtcbiAgICAgICAgdGhpcy5wcm9wYWdhdGVDaGFuZ2UgPSBmbjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVnaXN0ZXJzIGEgY2FsbGJhY2sgdG8gYmUgdHJpZ2dlcmVkIHdoZW4gdGhlIGNvbnRyb2wgaGFzIGJlZW4gdG91Y2hlZC5cbiAgICAgKiBAcGFyYW0gZm4gQ2FsbGJhY2sgdG8gYmUgdHJpZ2dlcmVkIHdoZW4gdGhlIGNoZWNrYm94IGlzIHRvdWNoZWQuXG4gICAgICovXG4gICAgcmVnaXN0ZXJPblRvdWNoZWQoZm4pIHtcbiAgICAgICAgdGhpcy5vblRvdWNoZWQgPSBmbjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogYENvbnRyb2xWYWx1ZUFjY2Vzc29yYCBtZXRob2QgdG8gcHJvZ3JhbW1hdGljYWxseSBkaXNhYmxlIHRoZSBjaGVja2JveC5cbiAgICAgKlxuICAgICAqIGV4OiBgdGhpcy5mb3JtR3JvdXAuZ2V0KFwibXlDaGVja2JveFwiKS5kaXNhYmxlKCk7YFxuICAgICAqXG4gICAgICogQHBhcmFtIGlzRGlzYWJsZWQgYHRydWVgIHRvIGRpc2FibGUgdGhlIGNoZWNrYm94XG4gICAgICovXG4gICAgc2V0RGlzYWJsZWRTdGF0ZShpc0Rpc2FibGVkKSB7XG4gICAgICAgIHRoaXMuZGlzYWJsZWQgPSBpc0Rpc2FibGVkO1xuICAgICAgICB0aGlzLmNoYW5nZURldGVjdG9yUmVmLm1hcmtGb3JDaGVjaygpO1xuICAgIH1cbiAgICBmb2N1c091dCgpIHtcbiAgICAgICAgdGhpcy5vblRvdWNoZWQoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRXhlY3V0ZXMgb24gdGhlIGV2ZW50IG9mIGEgY2hhbmdlIHdpdGhpbiBgQ2hlY2tib3hgIHRvIGJsb2NrIHByb3BhZ2F0aW9uLlxuICAgICAqL1xuICAgIG9uQ2hhbmdlKGV2ZW50KSB7XG4gICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBIYW5kbGVzIGNsaWNrIGV2ZW50cyBvbiB0aGUgYENoZWNrYm94YCBhbmQgZW1pdHMgY2hhbmdlcyB0byBvdGhlciBjbGFzc2VzLlxuICAgICAqL1xuICAgIG9uQ2xpY2soZXZlbnQpIHtcbiAgICAgICAgaWYgKHRoaXMuY2xpY2sub2JzZXJ2ZXJzLmxlbmd0aCkge1xuICAgICAgICAgICAgLy8gRGlzYWJsZSBkZWZhdWx0IGNoZWNrYm94IGFjdGl2YXRpb24gYmVoYXZpb3Igd2hpY2ggZmxpcHMgY2hlY2tlZCBhbmQgcmVzZXRzIGluZGV0ZXJtaW5hdGUuXG4gICAgICAgICAgICAvLyBUaGlzIGFsbG93cyB0aGUgcGFyZW50IGNvbXBvbmVudCB0byBjb250cm9sIHRoZSBjaGVja2VkL2luZGV0ZXJtaW5hdGUgcHJvcGVydGllcy5cbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICB0aGlzLmNsaWNrLmVtaXQoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuZGlzYWJsZWQpIHtcbiAgICAgICAgICAgIHRoaXMudG9nZ2xlKCk7XG4gICAgICAgICAgICB0aGlzLnRyYW5zaXRpb25DaGVja2JveFN0YXRlKHRoaXMuX2NoZWNrZWQgPyBDaGVja2JveFN0YXRlLkNoZWNrZWQgOiBDaGVja2JveFN0YXRlLlVuY2hlY2tlZCk7XG4gICAgICAgICAgICB0aGlzLmVtaXRDaGFuZ2VFdmVudCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEhhbmRsZXMgY2hhbmdlcyBiZXR3ZWVuIGNoZWNrYm94IHN0YXRlcy5cbiAgICAgKi9cbiAgICB0cmFuc2l0aW9uQ2hlY2tib3hTdGF0ZShuZXdTdGF0ZSkge1xuICAgICAgICB0aGlzLmN1cnJlbnRDaGVja2JveFN0YXRlID0gbmV3U3RhdGU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgaW5zdGFuY2Ugb2YgYENoZWNrYm94Q2hhbmdlYCB1c2VkIHRvIHByb3BhZ2F0ZSB0aGUgY2hhbmdlIGV2ZW50LlxuICAgICAqL1xuICAgIGVtaXRDaGFuZ2VFdmVudCgpIHtcbiAgICAgICAgdGhpcy5jaGVja2VkQ2hhbmdlLmVtaXQodGhpcy5jaGVja2VkKTtcbiAgICAgICAgdGhpcy5wcm9wYWdhdGVDaGFuZ2UodGhpcy5jaGVja2VkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXBkYXRlcyB0aGUgY2hlY2tib3ggaWYgaXQgaXMgaW4gdGhlIGluZGV0ZXJtaW5hdGUgc3RhdGUuXG4gICAgICovXG4gICAgbmdBZnRlclZpZXdJbml0KCkge1xuICAgICAgICBpZiAodGhpcy5pbmRldGVybWluYXRlICYmIHRoaXMuaW5wdXRDaGVja2JveCAmJiB0aGlzLmlucHV0Q2hlY2tib3gubmF0aXZlRWxlbWVudCkge1xuICAgICAgICAgICAgdGhpcy5pbnB1dENoZWNrYm94Lm5hdGl2ZUVsZW1lbnQuaW5kZXRlcm1pbmF0ZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyBjaGVja2VkIHN0YXRlIGFuZCBvcHRpb25hbGx5IHJlc2V0cyBpbmRldGVybWluYXRlIHN0YXRlLlxuICAgICAqL1xuICAgIHNldENoZWNrZWQoY2hlY2tlZCwgcmVzZXRJbmRldGVybWluYXRlKSB7XG4gICAgICAgIGlmIChjaGVja2VkID09PSB0aGlzLl9jaGVja2VkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fY2hlY2tlZCA9IGNoZWNrZWQ7XG4gICAgICAgIC8vIFJlc2V0IGluZGV0ZXJtaW5hdGUgaWYgcmVxdWVzdGVkXG4gICAgICAgIGlmIChyZXNldEluZGV0ZXJtaW5hdGUgJiYgdGhpcy5faW5kZXRlcm1pbmF0ZSkge1xuICAgICAgICAgICAgdGhpcy5faW5kZXRlcm1pbmF0ZSA9IGZhbHNlO1xuICAgICAgICAgICAgUHJvbWlzZS5yZXNvbHZlKCkudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5pbmRldGVybWluYXRlQ2hhbmdlLmVtaXQodGhpcy5faW5kZXRlcm1pbmF0ZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNoYW5nZURldGVjdG9yUmVmLm1hcmtGb3JDaGVjaygpO1xuICAgIH1cbn1cbi8qKlxuICogVmFyaWFibGUgdXNlZCBmb3IgY3JlYXRpbmcgdW5pcXVlIGlkcyBmb3IgY2hlY2tib3ggY29tcG9uZW50cy5cbiAqL1xuQ2hlY2tib3guY2hlY2tib3hDb3VudCA9IDA7XG5DaGVja2JveC7JtWZhYyA9IGkwLsm1ybVuZ0RlY2xhcmVGYWN0b3J5KHsgbWluVmVyc2lvbjogXCIxMi4wLjBcIiwgdmVyc2lvbjogXCIxNC4zLjBcIiwgbmdJbXBvcnQ6IGkwLCB0eXBlOiBDaGVja2JveCwgZGVwczogW3sgdG9rZW46IGkwLkNoYW5nZURldGVjdG9yUmVmIH1dLCB0YXJnZXQ6IGkwLsm1ybVGYWN0b3J5VGFyZ2V0LkNvbXBvbmVudCB9KTtcbkNoZWNrYm94Lsm1Y21wID0gaTAuybXJtW5nRGVjbGFyZUNvbXBvbmVudCh7IG1pblZlcnNpb246IFwiMTQuMC4wXCIsIHZlcnNpb246IFwiMTQuMy4wXCIsIHR5cGU6IENoZWNrYm94LCBzZWxlY3RvcjogXCJjZHMtY2hlY2tib3gsIGlibS1jaGVja2JveFwiLCBpbnB1dHM6IHsgZGlzYWJsZWQ6IFwiZGlzYWJsZWRcIiwgc2tlbGV0b246IFwic2tlbGV0b25cIiwgaGlkZUxhYmVsOiBcImhpZGVMYWJlbFwiLCBuYW1lOiBcIm5hbWVcIiwgaWQ6IFwiaWRcIiwgcmVxdWlyZWQ6IFwicmVxdWlyZWRcIiwgdmFsdWU6IFwidmFsdWVcIiwgYXJpYUxhYmVsOiBcImFyaWFMYWJlbFwiLCBhcmlhTGFiZWxsZWRieTogXCJhcmlhTGFiZWxsZWRieVwiLCBpbmRldGVybWluYXRlOiBcImluZGV0ZXJtaW5hdGVcIiwgY2hlY2tlZDogXCJjaGVja2VkXCIgfSwgb3V0cHV0czogeyBjbGljazogXCJjbGlja1wiLCBjaGVja2VkQ2hhbmdlOiBcImNoZWNrZWRDaGFuZ2VcIiwgaW5kZXRlcm1pbmF0ZUNoYW5nZTogXCJpbmRldGVybWluYXRlQ2hhbmdlXCIgfSwgaG9zdDogeyBsaXN0ZW5lcnM6IHsgXCJmb2N1c291dFwiOiBcImZvY3VzT3V0KClcIiB9IH0sIHByb3ZpZGVyczogW1xuICAgICAgICB7XG4gICAgICAgICAgICBwcm92aWRlOiBOR19WQUxVRV9BQ0NFU1NPUixcbiAgICAgICAgICAgIHVzZUV4aXN0aW5nOiBDaGVja2JveCxcbiAgICAgICAgICAgIG11bHRpOiB0cnVlXG4gICAgICAgIH1cbiAgICBdLCB2aWV3UXVlcmllczogW3sgcHJvcGVydHlOYW1lOiBcImlucHV0Q2hlY2tib3hcIiwgZmlyc3Q6IHRydWUsIHByZWRpY2F0ZTogW1wiaW5wdXRDaGVja2JveFwiXSwgZGVzY2VuZGFudHM6IHRydWUgfV0sIG5nSW1wb3J0OiBpMCwgdGVtcGxhdGU6IGBcblx0XHQ8ZGl2IGNsYXNzPVwiY2RzLS1mb3JtLWl0ZW0gY2RzLS1jaGVja2JveC13cmFwcGVyXCI+XG5cdFx0XHQ8aW5wdXRcblx0XHRcdFx0I2lucHV0Q2hlY2tib3hcblx0XHRcdFx0Y2xhc3M9XCJjZHMtLWNoZWNrYm94XCJcblx0XHRcdFx0dHlwZT1cImNoZWNrYm94XCJcblx0XHRcdFx0W2lkXT1cImlkICsgJ19pbnB1dCdcIlxuXHRcdFx0XHRbdmFsdWVdPVwidmFsdWVcIlxuXHRcdFx0XHRbbmFtZV09XCJuYW1lXCJcblx0XHRcdFx0W3JlcXVpcmVkXT1cInJlcXVpcmVkXCJcblx0XHRcdFx0W2NoZWNrZWRdPVwiY2hlY2tlZFwiXG5cdFx0XHRcdFtkaXNhYmxlZF09XCJkaXNhYmxlZFwiXG5cdFx0XHRcdFthdHRyLmFyaWEtbGFiZWxsZWRieV09XCJhcmlhTGFiZWxsZWRieVwiXG5cdFx0XHRcdChjaGFuZ2UpPVwib25DaGFuZ2UoJGV2ZW50KVwiXG5cdFx0XHRcdChjbGljayk9XCJvbkNsaWNrKCRldmVudClcIj5cblx0XHRcdDxsYWJlbFxuXHRcdFx0XHRbZm9yXT1cImlkICsgJ19pbnB1dCdcIlxuXHRcdFx0XHRbYXR0ci5hcmlhLWxhYmVsXT1cImFyaWFMYWJlbFwiXG5cdFx0XHRcdGNsYXNzPVwiY2RzLS1jaGVja2JveC1sYWJlbFwiXG5cdFx0XHRcdFtuZ0NsYXNzXT1cIntcblx0XHRcdFx0XHQnY2RzLS1za2VsZXRvbicgOiBza2VsZXRvblxuXHRcdFx0XHR9XCI+XG5cdFx0XHRcdDxzcGFuIFtuZ0NsYXNzXT1cInsnY2RzLS12aXN1YWxseS1oaWRkZW4nIDogaGlkZUxhYmVsfVwiIGNsYXNzPVwiY2RzLS1jaGVja2JveC1sYWJlbC10ZXh0XCI+XG5cdFx0XHRcdFx0PG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PlxuXHRcdFx0XHQ8L3NwYW4+XG5cdFx0XHQ8L2xhYmVsPlxuXHRcdDwvZGl2PlxuXHRgLCBpc0lubGluZTogdHJ1ZSwgZGVwZW5kZW5jaWVzOiBbeyBraW5kOiBcImRpcmVjdGl2ZVwiLCB0eXBlOiBpMS5OZ0NsYXNzLCBzZWxlY3RvcjogXCJbbmdDbGFzc11cIiwgaW5wdXRzOiBbXCJjbGFzc1wiLCBcIm5nQ2xhc3NcIl0gfV0sIGNoYW5nZURldGVjdGlvbjogaTAuQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoIH0pO1xuaTAuybXJtW5nRGVjbGFyZUNsYXNzTWV0YWRhdGEoeyBtaW5WZXJzaW9uOiBcIjEyLjAuMFwiLCB2ZXJzaW9uOiBcIjE0LjMuMFwiLCBuZ0ltcG9ydDogaTAsIHR5cGU6IENoZWNrYm94LCBkZWNvcmF0b3JzOiBbe1xuICAgICAgICAgICAgdHlwZTogQ29tcG9uZW50LFxuICAgICAgICAgICAgYXJnczogW3tcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0b3I6IFwiY2RzLWNoZWNrYm94LCBpYm0tY2hlY2tib3hcIixcbiAgICAgICAgICAgICAgICAgICAgdGVtcGxhdGU6IGBcblx0XHQ8ZGl2IGNsYXNzPVwiY2RzLS1mb3JtLWl0ZW0gY2RzLS1jaGVja2JveC13cmFwcGVyXCI+XG5cdFx0XHQ8aW5wdXRcblx0XHRcdFx0I2lucHV0Q2hlY2tib3hcblx0XHRcdFx0Y2xhc3M9XCJjZHMtLWNoZWNrYm94XCJcblx0XHRcdFx0dHlwZT1cImNoZWNrYm94XCJcblx0XHRcdFx0W2lkXT1cImlkICsgJ19pbnB1dCdcIlxuXHRcdFx0XHRbdmFsdWVdPVwidmFsdWVcIlxuXHRcdFx0XHRbbmFtZV09XCJuYW1lXCJcblx0XHRcdFx0W3JlcXVpcmVkXT1cInJlcXVpcmVkXCJcblx0XHRcdFx0W2NoZWNrZWRdPVwiY2hlY2tlZFwiXG5cdFx0XHRcdFtkaXNhYmxlZF09XCJkaXNhYmxlZFwiXG5cdFx0XHRcdFthdHRyLmFyaWEtbGFiZWxsZWRieV09XCJhcmlhTGFiZWxsZWRieVwiXG5cdFx0XHRcdChjaGFuZ2UpPVwib25DaGFuZ2UoJGV2ZW50KVwiXG5cdFx0XHRcdChjbGljayk9XCJvbkNsaWNrKCRldmVudClcIj5cblx0XHRcdDxsYWJlbFxuXHRcdFx0XHRbZm9yXT1cImlkICsgJ19pbnB1dCdcIlxuXHRcdFx0XHRbYXR0ci5hcmlhLWxhYmVsXT1cImFyaWFMYWJlbFwiXG5cdFx0XHRcdGNsYXNzPVwiY2RzLS1jaGVja2JveC1sYWJlbFwiXG5cdFx0XHRcdFtuZ0NsYXNzXT1cIntcblx0XHRcdFx0XHQnY2RzLS1za2VsZXRvbicgOiBza2VsZXRvblxuXHRcdFx0XHR9XCI+XG5cdFx0XHRcdDxzcGFuIFtuZ0NsYXNzXT1cInsnY2RzLS12aXN1YWxseS1oaWRkZW4nIDogaGlkZUxhYmVsfVwiIGNsYXNzPVwiY2RzLS1jaGVja2JveC1sYWJlbC10ZXh0XCI+XG5cdFx0XHRcdFx0PG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PlxuXHRcdFx0XHQ8L3NwYW4+XG5cdFx0XHQ8L2xhYmVsPlxuXHRcdDwvZGl2PlxuXHRgLFxuICAgICAgICAgICAgICAgICAgICBwcm92aWRlcnM6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm92aWRlOiBOR19WQUxVRV9BQ0NFU1NPUixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1c2VFeGlzdGluZzogQ2hlY2tib3gsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbXVsdGk6IHRydWVcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgICAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2hcbiAgICAgICAgICAgICAgICB9XVxuICAgICAgICB9XSwgY3RvclBhcmFtZXRlcnM6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFt7IHR5cGU6IGkwLkNoYW5nZURldGVjdG9yUmVmIH1dOyB9LCBwcm9wRGVjb3JhdG9yczogeyBkaXNhYmxlZDogW3tcbiAgICAgICAgICAgICAgICB0eXBlOiBJbnB1dFxuICAgICAgICAgICAgfV0sIHNrZWxldG9uOiBbe1xuICAgICAgICAgICAgICAgIHR5cGU6IElucHV0XG4gICAgICAgICAgICB9XSwgaGlkZUxhYmVsOiBbe1xuICAgICAgICAgICAgICAgIHR5cGU6IElucHV0XG4gICAgICAgICAgICB9XSwgbmFtZTogW3tcbiAgICAgICAgICAgICAgICB0eXBlOiBJbnB1dFxuICAgICAgICAgICAgfV0sIGlkOiBbe1xuICAgICAgICAgICAgICAgIHR5cGU6IElucHV0XG4gICAgICAgICAgICB9XSwgcmVxdWlyZWQ6IFt7XG4gICAgICAgICAgICAgICAgdHlwZTogSW5wdXRcbiAgICAgICAgICAgIH1dLCB2YWx1ZTogW3tcbiAgICAgICAgICAgICAgICB0eXBlOiBJbnB1dFxuICAgICAgICAgICAgfV0sIGFyaWFMYWJlbDogW3tcbiAgICAgICAgICAgICAgICB0eXBlOiBJbnB1dFxuICAgICAgICAgICAgfV0sIGFyaWFMYWJlbGxlZGJ5OiBbe1xuICAgICAgICAgICAgICAgIHR5cGU6IElucHV0XG4gICAgICAgICAgICB9XSwgaW5kZXRlcm1pbmF0ZTogW3tcbiAgICAgICAgICAgICAgICB0eXBlOiBJbnB1dFxuICAgICAgICAgICAgfV0sIGNoZWNrZWQ6IFt7XG4gICAgICAgICAgICAgICAgdHlwZTogSW5wdXRcbiAgICAgICAgICAgIH1dLCBjbGljazogW3tcbiAgICAgICAgICAgICAgICB0eXBlOiBPdXRwdXRcbiAgICAgICAgICAgIH1dLCBjaGVja2VkQ2hhbmdlOiBbe1xuICAgICAgICAgICAgICAgIHR5cGU6IE91dHB1dFxuICAgICAgICAgICAgfV0sIGluZGV0ZXJtaW5hdGVDaGFuZ2U6IFt7XG4gICAgICAgICAgICAgICAgdHlwZTogT3V0cHV0XG4gICAgICAgICAgICB9XSwgaW5wdXRDaGVja2JveDogW3tcbiAgICAgICAgICAgICAgICB0eXBlOiBWaWV3Q2hpbGQsXG4gICAgICAgICAgICAgICAgYXJnczogW1wiaW5wdXRDaGVja2JveFwiXVxuICAgICAgICAgICAgfV0sIGZvY3VzT3V0OiBbe1xuICAgICAgICAgICAgICAgIHR5cGU6IEhvc3RMaXN0ZW5lcixcbiAgICAgICAgICAgICAgICBhcmdzOiBbXCJmb2N1c291dFwiXVxuICAgICAgICAgICAgfV0gfSB9KTtcblxuLy8gbW9kdWxlc1xuY2xhc3MgQ2hlY2tib3hNb2R1bGUge1xufVxuQ2hlY2tib3hNb2R1bGUuybVmYWMgPSBpMC7Jtcm1bmdEZWNsYXJlRmFjdG9yeSh7IG1pblZlcnNpb246IFwiMTIuMC4wXCIsIHZlcnNpb246IFwiMTQuMy4wXCIsIG5nSW1wb3J0OiBpMCwgdHlwZTogQ2hlY2tib3hNb2R1bGUsIGRlcHM6IFtdLCB0YXJnZXQ6IGkwLsm1ybVGYWN0b3J5VGFyZ2V0Lk5nTW9kdWxlIH0pO1xuQ2hlY2tib3hNb2R1bGUuybVtb2QgPSBpMC7Jtcm1bmdEZWNsYXJlTmdNb2R1bGUoeyBtaW5WZXJzaW9uOiBcIjE0LjAuMFwiLCB2ZXJzaW9uOiBcIjE0LjMuMFwiLCBuZ0ltcG9ydDogaTAsIHR5cGU6IENoZWNrYm94TW9kdWxlLCBkZWNsYXJhdGlvbnM6IFtDaGVja2JveF0sIGltcG9ydHM6IFtDb21tb25Nb2R1bGUsXG4gICAgICAgIEZvcm1zTW9kdWxlXSwgZXhwb3J0czogW0NoZWNrYm94XSB9KTtcbkNoZWNrYm94TW9kdWxlLsm1aW5qID0gaTAuybXJtW5nRGVjbGFyZUluamVjdG9yKHsgbWluVmVyc2lvbjogXCIxMi4wLjBcIiwgdmVyc2lvbjogXCIxNC4zLjBcIiwgbmdJbXBvcnQ6IGkwLCB0eXBlOiBDaGVja2JveE1vZHVsZSwgaW1wb3J0czogW0NvbW1vbk1vZHVsZSxcbiAgICAgICAgRm9ybXNNb2R1bGVdIH0pO1xuaTAuybXJtW5nRGVjbGFyZUNsYXNzTWV0YWRhdGEoeyBtaW5WZXJzaW9uOiBcIjEyLjAuMFwiLCB2ZXJzaW9uOiBcIjE0LjMuMFwiLCBuZ0ltcG9ydDogaTAsIHR5cGU6IENoZWNrYm94TW9kdWxlLCBkZWNvcmF0b3JzOiBbe1xuICAgICAgICAgICAgdHlwZTogTmdNb2R1bGUsXG4gICAgICAgICAgICBhcmdzOiBbe1xuICAgICAgICAgICAgICAgICAgICBkZWNsYXJhdGlvbnM6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIENoZWNrYm94XG4gICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgICAgIGV4cG9ydHM6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIENoZWNrYm94XG4gICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgICAgIGltcG9ydHM6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIENvbW1vbk1vZHVsZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIEZvcm1zTW9kdWxlXG4gICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICB9XVxuICAgICAgICB9XSB9KTtcblxuLyoqXG4gKiBHZW5lcmF0ZWQgYnVuZGxlIGluZGV4LiBEbyBub3QgZWRpdC5cbiAqL1xuXG5leHBvcnQgeyBDaGVja2JveCwgQ2hlY2tib3hNb2R1bGUsIENoZWNrYm94U3RhdGUgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNhcmJvbi1jb21wb25lbnRzLWFuZ3VsYXItY2hlY2tib3gubWpzLm1hcFxuIiwiaW1wb3J0ICogYXMgaTAgZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBEaXJlY3RpdmUsIElucHV0LCBPdXRwdXQsIEluamVjdGFibGUsIEV2ZW50RW1pdHRlciwgVGVtcGxhdGVSZWYsIENvbXBvbmVudCwgQ29udGVudENoaWxkLCBWaWV3Q2hpbGQsIEhvc3RCaW5kaW5nLCBIb3N0TGlzdGVuZXIsIFZpZXdDaGlsZHJlbiwgTmdNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IE5HX1ZBTFVFX0FDQ0VTU09SLCBGb3Jtc01vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcbmltcG9ydCB7IFN1YnNjcmlwdGlvbiwgb2YsIGZyb21FdmVudCwgaXNPYnNlcnZhYmxlLCBPYnNlcnZhYmxlIH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgKiBhcyBpMiBmcm9tICdjYXJib24tY29tcG9uZW50cy1hbmd1bGFyL3V0aWxzJztcbmltcG9ydCB7IGNsb3Nlc3RBdHRyLCBoYXNTY3JvbGxhYmxlUGFyZW50cywgZ2V0U2Nyb2xsYWJsZVBhcmVudHMsIFV0aWxzTW9kdWxlIH0gZnJvbSAnY2FyYm9uLWNvbXBvbmVudHMtYW5ndWxhci91dGlscyc7XG5pbXBvcnQgKiBhcyBpMSQxIGZyb20gJ2NhcmJvbi1jb21wb25lbnRzLWFuZ3VsYXIvaTE4bic7XG5pbXBvcnQgeyBJMThuTW9kdWxlIH0gZnJvbSAnY2FyYm9uLWNvbXBvbmVudHMtYW5ndWxhci9pMThuJztcbmltcG9ydCB7IHBvc2l0aW9uIH0gZnJvbSAnQGNhcmJvbi91dGlscy1wb3NpdGlvbic7XG5pbXBvcnQgKiBhcyBpMSBmcm9tICdjYXJib24tY29tcG9uZW50cy1hbmd1bGFyL3BsYWNlaG9sZGVyJztcbmltcG9ydCB7IFBsYWNlaG9sZGVyTW9kdWxlIH0gZnJvbSAnY2FyYm9uLWNvbXBvbmVudHMtYW5ndWxhci9wbGFjZWhvbGRlcic7XG5pbXBvcnQgKiBhcyBpNCBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHsgQ29tbW9uTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcbmltcG9ydCAqIGFzIGk1IGZyb20gJ2NhcmJvbi1jb21wb25lbnRzLWFuZ3VsYXIvaWNvbic7XG5pbXBvcnQgeyBJY29uTW9kdWxlIH0gZnJvbSAnY2FyYm9uLWNvbXBvbmVudHMtYW5ndWxhci9pY29uJztcbmltcG9ydCB7IGRlYm91bmNlVGltZSwgbWFwLCBmaWx0ZXIsIGZpcnN0IH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuXG4vKipcbiAqIEEgY29tcG9uZW50IHRoYXQgaW50ZW5kcyB0byBiZSB1c2VkIHdpdGhpbiBgRHJvcGRvd25gIG11c3QgcHJvdmlkZSBhbiBpbXBsZW1lbnRhdGlvbiB0aGF0IGV4dGVuZHMgdGhpcyBiYXNlIGNsYXNzLlxuICogSXQgYWxzbyBtdXN0IHByb3ZpZGUgdGhlIGJhc2UgY2xhc3MgaW4gdGhlIGBAQ29tcG9uZW50YCBtZXRhLWRhdGEuXG4gKiBleDogYHByb3ZpZGVyczogW3twcm92aWRlOiBBYnN0cmFjdERyb3Bkb3duVmlldywgdXNlRXhpc3Rpbmc6IGZvcndhcmRSZWYoKCkgPT4gTXlEcm9wZG93blZpZXcpfV1gXG4gKi9cbmNsYXNzIEFic3RyYWN0RHJvcGRvd25WaWV3IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNwZWNpZmllcyB3aGV0aGVyIG9yIG5vdCB0aGUgYERyb3Bkb3duTGlzdGAgc3VwcG9ydHMgc2VsZWN0aW5nIG11bHRpcGxlIGl0ZW1zIGFzIG9wcG9zZWQgdG8gc2luZ2xlXG4gICAgICAgICAqIGl0ZW0gc2VsZWN0aW9uLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy50eXBlID0gXCJzaW5nbGVcIjtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNwZWNpZmllcyB0aGUgcmVuZGVyIHNpemUgb2YgdGhlIGl0ZW1zIHdpdGhpbiB0aGUgYEFic3RyYWN0RHJvcGRvd25WaWV3YC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc2l6ZSA9IFwibWRcIjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIGl0ZW1zIHRvIGJlIGRpc3BsYXllZCBpbiB0aGUgbGlzdCB3aXRoaW4gdGhlIGBBYnN0cmFjdERyb3BEb3duVmlld2AuXG4gICAgICovXG4gICAgc2V0IGl0ZW1zKHZhbHVlKSB7IH1cbiAgICBnZXQgaXRlbXMoKSB7IHJldHVybjsgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGBMaXN0SXRlbWAgdGhhdCBpcyBzdWJzZXF1ZW50IHRvIHRoZSBzZWxlY3RlZCBpdGVtIGluIHRoZSBgRHJvcGRvd25MaXN0YC5cbiAgICAgKi9cbiAgICBnZXROZXh0SXRlbSgpIHsgcmV0dXJuOyB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIGJvb2xlYW4gaWYgdGhlIGN1cnJlbnRseSBzZWxlY3RlZCBpdGVtIGlzIHByZWNlZGVkIGJ5IGFub3RoZXJcbiAgICAgKi9cbiAgICBoYXNOZXh0RWxlbWVudCgpIHsgcmV0dXJuOyB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgYEhUTUxFbGVtZW50YCBmb3IgdGhlIGl0ZW0gdGhhdCBpcyBzdWJzZXF1ZW50IHRvIHRoZSBzZWxlY3RlZCBpdGVtLlxuICAgICAqL1xuICAgIGdldE5leHRFbGVtZW50KCkgeyByZXR1cm47IH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBgTGlzdEl0ZW1gIHRoYXQgcHJlY2VkZXMgdGhlIHNlbGVjdGVkIGl0ZW0gd2l0aGluIGBEcm9wZG93bkxpc3RgLlxuICAgICAqL1xuICAgIGdldFByZXZJdGVtKCkgeyByZXR1cm47IH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgYm9vbGVhbiBpZiB0aGUgY3VycmVudGx5IHNlbGVjdGVkIGl0ZW0gaXMgZm9sbG93ZWQgYnkgYW5vdGhlclxuICAgICAqL1xuICAgIGhhc1ByZXZFbGVtZW50KCkgeyByZXR1cm47IH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBgSFRNTEVsZW1lbnRgIGZvciB0aGUgaXRlbSB0aGF0IHByZWNlZGVzIHRoZSBzZWxlY3RlZCBpdGVtLlxuICAgICAqL1xuICAgIGdldFByZXZFbGVtZW50KCkgeyByZXR1cm47IH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBzZWxlY3RlZCBsZWFmIGxldmVsIGl0ZW0ocykgd2l0aGluIHRoZSBgRHJvcGRvd25MaXN0YC5cbiAgICAgKi9cbiAgICBnZXRTZWxlY3RlZCgpIHsgcmV0dXJuOyB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgYExpc3RJdGVtYCB0aGF0IGlzIHNlbGVjdGVkIHdpdGhpbiBgRHJvcGRvd25MaXN0YC5cbiAgICAgKi9cbiAgICBnZXRDdXJyZW50SXRlbSgpIHsgcmV0dXJuOyB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgYEhUTUxFbGVtZW50YCBmb3IgdGhlIGl0ZW0gdGhhdCBpcyBzZWxlY3RlZCB3aXRoaW4gdGhlIGBEcm9wZG93bkxpc3RgLlxuICAgICAqL1xuICAgIGdldEN1cnJlbnRFbGVtZW50KCkgeyByZXR1cm47IH1cbiAgICAvKipcbiAgICAgKiBHdWFyYW50ZWVkIHRvIHJldHVybiB0aGUgY3VycmVudCBpdGVtcyBhcyBhbiBBcnJheS5cbiAgICAgKi9cbiAgICBnZXRMaXN0SXRlbXMoKSB7IHJldHVybjsgfVxuICAgIC8qKlxuICAgICAqIFRyYW5zZm9ybXMgYXJyYXkgaW5wdXQgbGlzdCBvZiBpdGVtcyB0byB0aGUgY29ycmVjdCBzdGF0ZSBieSB1cGRhdGluZyB0aGUgc2VsZWN0ZWQgaXRlbShzKS5cbiAgICAgKi9cbiAgICBwcm9wYWdhdGVTZWxlY3RlZCh2YWx1ZSkgeyB9XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdmFsdWUgdmFsdWUgdG8gZmlsdGVyIHRoZSBsaXN0IGJ5XG4gICAgICovXG4gICAgZmlsdGVyQnkodmFsdWUpIHsgfVxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemVzIGZvY3VzIGluIHRoZSBsaXN0XG4gICAgICogSW4gbW9zdCBjYXNlcyB0aGlzIGp1c3QgY2FsbHMgYGdldEN1cnJlbnRFbGVtZW50KCkuZm9jdXMoKWBcbiAgICAgKi9cbiAgICBpbml0Rm9jdXMoKSB7IH1cbiAgICAvKipcbiAgICAgKiBTdWJzY3JpYmUgdGhlIGZ1bmN0aW9uIHBhc3NlZCB0byBhbiBpbnRlcm5hbCBvYnNlcnZhYmxlIHRoYXQgd2lsbCByZXNvbHZlIG9uY2UgdGhlIGl0ZW1zIGFyZSByZWFkeVxuICAgICAqL1xuICAgIG9uSXRlbXNSZWFkeShzdWJjcmlwdGlvbikgeyB9XG4gICAgLyoqXG4gICAgICogUmVvcmRlciBzZWxlY3RlZCBpdGVtcyBicmluZ2luZyB0aGVtIHRvIHRoZSB0b3Agb2YgdGhlIGxpc3RcbiAgICAgKi9cbiAgICByZW9yZGVyU2VsZWN0ZWQobW92ZUZvY3VzKSB7IH1cbn1cbkFic3RyYWN0RHJvcGRvd25WaWV3Lsm1ZmFjID0gaTAuybXJtW5nRGVjbGFyZUZhY3RvcnkoeyBtaW5WZXJzaW9uOiBcIjEyLjAuMFwiLCB2ZXJzaW9uOiBcIjE0LjMuMFwiLCBuZ0ltcG9ydDogaTAsIHR5cGU6IEFic3RyYWN0RHJvcGRvd25WaWV3LCBkZXBzOiBbXSwgdGFyZ2V0OiBpMC7Jtcm1RmFjdG9yeVRhcmdldC5EaXJlY3RpdmUgfSk7XG5BYnN0cmFjdERyb3Bkb3duVmlldy7JtWRpciA9IGkwLsm1ybVuZ0RlY2xhcmVEaXJlY3RpdmUoeyBtaW5WZXJzaW9uOiBcIjE0LjAuMFwiLCB2ZXJzaW9uOiBcIjE0LjMuMFwiLCB0eXBlOiBBYnN0cmFjdERyb3Bkb3duVmlldywgc2VsZWN0b3I6IFwiW2Nkc0Fic3RyYWN0RHJvcGRvd25WaWV3XSwgW2libUFic3RyYWN0RHJvcGRvd25WaWV3XVwiLCBpbnB1dHM6IHsgaXRlbXM6IFwiaXRlbXNcIiB9LCBvdXRwdXRzOiB7IHNlbGVjdDogXCJzZWxlY3RcIiwgYmx1ckludGVudDogXCJibHVySW50ZW50XCIgfSwgbmdJbXBvcnQ6IGkwIH0pO1xuaTAuybXJtW5nRGVjbGFyZUNsYXNzTWV0YWRhdGEoeyBtaW5WZXJzaW9uOiBcIjEyLjAuMFwiLCB2ZXJzaW9uOiBcIjE0LjMuMFwiLCBuZ0ltcG9ydDogaTAsIHR5cGU6IEFic3RyYWN0RHJvcGRvd25WaWV3LCBkZWNvcmF0b3JzOiBbe1xuICAgICAgICAgICAgdHlwZTogRGlyZWN0aXZlLFxuICAgICAgICAgICAgYXJnczogW3tcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0b3I6IFwiW2Nkc0Fic3RyYWN0RHJvcGRvd25WaWV3XSwgW2libUFic3RyYWN0RHJvcGRvd25WaWV3XVwiXG4gICAgICAgICAgICAgICAgfV1cbiAgICAgICAgfV0sIHByb3BEZWNvcmF0b3JzOiB7IGl0ZW1zOiBbe1xuICAgICAgICAgICAgICAgIHR5cGU6IElucHV0XG4gICAgICAgICAgICB9XSwgc2VsZWN0OiBbe1xuICAgICAgICAgICAgICAgIHR5cGU6IE91dHB1dFxuICAgICAgICAgICAgfV0sIGJsdXJJbnRlbnQ6IFt7XG4gICAgICAgICAgICAgICAgdHlwZTogT3V0cHV0XG4gICAgICAgICAgICB9XSB9IH0pO1xuXG5jb25zdCBkZWZhdWx0T2Zmc2V0ID0geyB0b3A6IDAsIGxlZnQ6IDAgfTtcbmNsYXNzIERyb3Bkb3duU2VydmljZSB7XG4gICAgY29uc3RydWN0b3IocGxhY2Vob2xkZXJTZXJ2aWNlLCBhbmltYXRpb25GcmFtZVNlcnZpY2UpIHtcbiAgICAgICAgdGhpcy5wbGFjZWhvbGRlclNlcnZpY2UgPSBwbGFjZWhvbGRlclNlcnZpY2U7XG4gICAgICAgIHRoaXMuYW5pbWF0aW9uRnJhbWVTZXJ2aWNlID0gYW5pbWF0aW9uRnJhbWVTZXJ2aWNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogTWFpbnRhaW5zIGFuIEV2ZW50IE9ic2VydmFibGUgU3Vic2NyaXB0aW9uIGZvciB0aGUgZ2xvYmFsIHJlcXVlc3RBbmltYXRpb25GcmFtZS5cbiAgICAgICAgICogcmVxdWVzdEFuaW1hdGlvbkZyYW1lIGlzIHRyYWNrZWQgb25seSBpZiB0aGUgYERyb3Bkb3duYCBpcyBhcHBlbmRlZCB0byB0aGUgYm9keSBvdGhlcndpc2Ugd2UgZG9uJ3QgbmVlZCBpdFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5hbmltYXRpb25GcmFtZVN1YnNjcmlwdGlvbiA9IG5ldyBTdWJzY3JpcHRpb24oKTtcbiAgICAgICAgdGhpcy5fb2Zmc2V0ID0gZGVmYXVsdE9mZnNldDtcbiAgICB9XG4gICAgc2V0IG9mZnNldCh2YWx1ZSkge1xuICAgICAgICB0aGlzLl9vZmZzZXQgPSBPYmplY3QuYXNzaWduKHt9LCBkZWZhdWx0T2Zmc2V0LCB2YWx1ZSk7XG4gICAgfVxuICAgIGdldCBvZmZzZXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9vZmZzZXQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFwcGVuZHMgdGhlIG1lbnUgdG8gdGhlIGJvZHksIG9yIGEgYGNkcy1wbGFjZWhvbGRlcmAgKGlmIGRlZmluZWQpXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcGFyZW50UmVmIGNvbnRhaW5lciB0byBwb3NpdGlvbiByZWxhdGl2ZSB0b1xuICAgICAqIEBwYXJhbSBtZW51UmVmIG1lbnUgdG8gYmUgYXBwZW5kZWQgdG8gYm9keVxuICAgICAqIEBwYXJhbSBjbGFzc0xpc3QgYW55IGV4dHJhIGNsYXNzZXMgd2Ugc2hvdWxkIHdyYXAgdGhlIGNvbnRhaW5lciB3aXRoXG4gICAgICovXG4gICAgYXBwZW5kVG9Cb2R5KHBhcmVudFJlZiwgbWVudVJlZiwgY2xhc3NMaXN0KSB7XG4gICAgICAgIC8vIGJ1aWxkIHRoZSBkcm9wZG93biBsaXN0IGNvbnRhaW5lclxuICAgICAgICBtZW51UmVmLnN0eWxlLmRpc3BsYXkgPSBcImJsb2NrXCI7XG4gICAgICAgIGNvbnN0IGRyb3Bkb3duV3JhcHBlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgIGRyb3Bkb3duV3JhcHBlci5jbGFzc05hbWUgPSBgZHJvcGRvd24gJHtjbGFzc0xpc3R9YDtcbiAgICAgICAgZHJvcGRvd25XcmFwcGVyLnN0eWxlLndpZHRoID0gcGFyZW50UmVmLm9mZnNldFdpZHRoICsgXCJweFwiO1xuICAgICAgICBkcm9wZG93bldyYXBwZXIuc3R5bGUucG9zaXRpb24gPSBcImFic29sdXRlXCI7XG4gICAgICAgIGRyb3Bkb3duV3JhcHBlci5hcHBlbmRDaGlsZChtZW51UmVmKTtcbiAgICAgICAgLy8gYXBwZW5kIGl0IHRvIHRoZSBwbGFjZWhvbGRlclxuICAgICAgICBpZiAodGhpcy5wbGFjZWhvbGRlclNlcnZpY2UuaGFzUGxhY2Vob2xkZXJSZWYoKSkge1xuICAgICAgICAgICAgdGhpcy5wbGFjZWhvbGRlclNlcnZpY2UuYXBwZW5kRWxlbWVudChkcm9wZG93bldyYXBwZXIpO1xuICAgICAgICAgICAgLy8gb3IgYXBwZW5kIGl0IGRpcmVjdGx5IHRvIHRoZSBib2R5XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGRyb3Bkb3duV3JhcHBlcik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tZW51SW5zdGFuY2UgPSBkcm9wZG93bldyYXBwZXI7XG4gICAgICAgIHRoaXMuYW5pbWF0aW9uRnJhbWVTdWJzY3JpcHRpb24gPSB0aGlzLmFuaW1hdGlvbkZyYW1lU2VydmljZS50aWNrLnN1YnNjcmliZSgoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnBvc2l0aW9uRHJvcGRvd24ocGFyZW50UmVmLCBkcm9wZG93bldyYXBwZXIpO1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gcnVuIG9uZSBwb3NpdGlvbiBpbiBzeW5jLCBzbyB3ZSdyZSBsZXNzIGxpa2VseSB0byBoYXZlIHRoZSB2aWV3IFwianVtcFwiIGFzIHdlIGZvY3VzXG4gICAgICAgIHRoaXMucG9zaXRpb25Ecm9wZG93bihwYXJlbnRSZWYsIGRyb3Bkb3duV3JhcHBlcik7XG4gICAgICAgIHJldHVybiBkcm9wZG93bldyYXBwZXI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlYXR0YWNoIHRoZSBkcm9wZG93biBtZW51IHRvIHRoZSBwYXJlbnQgY29udGFpbmVyXG4gICAgICogQHBhcmFtIGhvc3RSZWYgY29udGFpbmVyIHRvIGFwcGVuZCB0b1xuICAgICAqL1xuICAgIGFwcGVuZFRvRHJvcGRvd24oaG9zdFJlZikge1xuICAgICAgICAvLyBpZiB0aGUgaW5zdGFuY2UgaXMgYWxyZWFkeSByZW1vdmVkIGRvbid0IHRyeSBhbmQgcmVtb3ZlIGl0IGFnYWluXG4gICAgICAgIGlmICghdGhpcy5tZW51SW5zdGFuY2UpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpbnN0YW5jZSA9IHRoaXMubWVudUluc3RhbmNlO1xuICAgICAgICBjb25zdCBtZW51ID0gaW5zdGFuY2UuZmlyc3RFbGVtZW50Q2hpbGQ7XG4gICAgICAgIC8vIGNsZWFuIHVwIHRoZSBpbnN0YW5jZVxuICAgICAgICB0aGlzLm1lbnVJbnN0YW5jZSA9IG51bGw7XG4gICAgICAgIG1lbnUuc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiO1xuICAgICAgICBob3N0UmVmLmFwcGVuZENoaWxkKG1lbnUpO1xuICAgICAgICB0aGlzLmFuaW1hdGlvbkZyYW1lU3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgIGlmICh0aGlzLnBsYWNlaG9sZGVyU2VydmljZS5oYXNQbGFjZWhvbGRlclJlZigpICYmIHRoaXMucGxhY2Vob2xkZXJTZXJ2aWNlLmhhc0VsZW1lbnQoaW5zdGFuY2UpKSB7XG4gICAgICAgICAgICB0aGlzLnBsYWNlaG9sZGVyU2VydmljZS5yZW1vdmVFbGVtZW50KGluc3RhbmNlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChkb2N1bWVudC5ib2R5LmNvbnRhaW5zKGluc3RhbmNlKSkge1xuICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChpbnN0YW5jZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGluc3RhbmNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBwb3NpdGlvbiBhbiBvcGVuIGRyb3Bkb3duIHJlbGF0aXZlIHRvIHRoZSBnaXZlbiBwYXJlbnRSZWZcbiAgICAgKi9cbiAgICB1cGRhdGVQb3NpdGlvbihwYXJlbnRSZWYpIHtcbiAgICAgICAgdGhpcy5wb3NpdGlvbkRyb3Bkb3duKHBhcmVudFJlZiwgdGhpcy5tZW51SW5zdGFuY2UpO1xuICAgIH1cbiAgICBuZ09uRGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5hbmltYXRpb25GcmFtZVN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgIH1cbiAgICBwb3NpdGlvbkRyb3Bkb3duKHBhcmVudFJlZiwgbWVudVJlZikge1xuICAgICAgICBpZiAoIW1lbnVSZWYpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgbGVmdE9mZnNldCA9IDA7XG4gICAgICAgIGNvbnN0IGJveE1lbnUgPSBtZW51UmVmLnF1ZXJ5U2VsZWN0b3IoXCIuY2RzLS1saXN0LWJveF9fbWVudVwiKTtcbiAgICAgICAgaWYgKGJveE1lbnUpIHtcbiAgICAgICAgICAgIC8vIElmIHRoZSBwYXJlbnRSZWYgYW5kIGJveE1lbnUgYXJlIGluIGEgZGlmZmVyZW50IGxlZnQgcG9zaXRpb24gcmVsYXRpdmUgdG8gdGhlXG4gICAgICAgICAgICAvLyB3aW5kb3csIHRoZSB0aGUgYm94TWVudSBwb3NpdGlvbiBoYXMgYWxyZWFkeSBiZWVuIGZsaXBwZWQgYW5kIGEgY2hlY2sgbmVlZHMgdG8gYmUgZG9uZVxuICAgICAgICAgICAgLy8gdG8gc2VlIGlmIGl0IG5lZWRzIHRvIHN0YXkgZmxpcHBlZC5cbiAgICAgICAgICAgIGlmIChwYXJlbnRSZWYuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkubGVmdCAhPT0gYm94TWVudS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5sZWZ0KSB7XG4gICAgICAgICAgICAgICAgLy8gVGhlIGdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLnJpZ2h0IG9mIHRoZSBib3hNZW51IGlmIGl0IHdlcmUgaHlwb3RoZXRpY2FsbHkgZmxpcHBlZFxuICAgICAgICAgICAgICAgIC8vIGJhY2sgaW50byB0aGUgb3JpZ2luYWwgcG9zaXRpb24gYmVmb3JlIHRoZSBmbGlwLlxuICAgICAgICAgICAgICAgIGNvbnN0IHRlc3RCb3hNZW51UmlnaHRFZGdlUG9zID0gcGFyZW50UmVmLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmxlZnQgLSBib3hNZW51LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmxlZnQgKyBib3hNZW51LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLnJpZ2h0O1xuICAgICAgICAgICAgICAgIGlmICh0ZXN0Qm94TWVudVJpZ2h0RWRnZVBvcyA+ICh3aW5kb3cuaW5uZXJXaWR0aCB8fCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50V2lkdGgpKSB7XG4gICAgICAgICAgICAgICAgICAgIGxlZnRPZmZzZXQgPSBwYXJlbnRSZWYub2Zmc2V0V2lkdGggLSBib3hNZW51Lm9mZnNldFdpZHRoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBJZiBpdCBoYXMgbm90IGFscmVhZHkgYmVlbiBmbGlwcGVkLCBjaGVjayBpZiBpdCBpcyBuZWNlc3NhcnkgdG8gZmxpcCwgaWUuIGlmIHRoZVxuICAgICAgICAgICAgICAgIC8vIGJveE1lbnUgaXMgb3V0c2lkZSBvZiB0aGUgcmlnaHQgdmlld1BvcnQuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChib3hNZW51LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLnJpZ2h0ID4gKHdpbmRvdy5pbm5lcldpZHRoIHx8IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRXaWR0aCkpIHtcbiAgICAgICAgICAgICAgICBsZWZ0T2Zmc2V0ID0gcGFyZW50UmVmLm9mZnNldFdpZHRoIC0gYm94TWVudS5vZmZzZXRXaWR0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBJZiBjZHMtcGxhY2Vob2xkZXIgaGFzIGEgcGFyZW50IHdpdGggYSBwb3NpdGlvbihyZWxhdGl2ZXxmaXhlZHxhYnNvbHV0ZSkgYWNjb3VudCBmb3IgdGhlIHBhcmVudCBvZmZzZXRcbiAgICAgICAgY29uc3QgY2xvc2VzdE1lbnVXaXRoUG9zID0gY2xvc2VzdEF0dHIoXCJwb3NpdGlvblwiLCBbXCJyZWxhdGl2ZVwiLCBcImZpeGVkXCIsIFwiYWJzb2x1dGVcIl0sIG1lbnVSZWYucGFyZW50RWxlbWVudCk7XG4gICAgICAgIGNvbnN0IHRvcFBvcyA9IGNsb3Nlc3RNZW51V2l0aFBvcyA/IGNsb3Nlc3RNZW51V2l0aFBvcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS50b3AgKiAtMSA6IHRoaXMub2Zmc2V0LnRvcDtcbiAgICAgICAgY29uc3QgbGVmdFBvcyA9IGNsb3Nlc3RNZW51V2l0aFBvcyA/IGNsb3Nlc3RNZW51V2l0aFBvcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5sZWZ0ICogLTEgOiB0aGlzLm9mZnNldC5sZWZ0ICsgbGVmdE9mZnNldDtcbiAgICAgICAgbGV0IHBvcyA9IHBvc2l0aW9uLmZpbmRBYnNvbHV0ZShwYXJlbnRSZWYsIG1lbnVSZWYsIFwiYm90dG9tXCIpO1xuICAgICAgICBwb3MgPSBwb3NpdGlvbi5hZGRPZmZzZXQocG9zLCB0b3BQb3MsIGxlZnRQb3MpO1xuICAgICAgICBwb3NpdGlvbi5zZXRFbGVtZW50KG1lbnVSZWYsIHBvcyk7XG4gICAgfVxufVxuRHJvcGRvd25TZXJ2aWNlLsm1ZmFjID0gaTAuybXJtW5nRGVjbGFyZUZhY3RvcnkoeyBtaW5WZXJzaW9uOiBcIjEyLjAuMFwiLCB2ZXJzaW9uOiBcIjE0LjMuMFwiLCBuZ0ltcG9ydDogaTAsIHR5cGU6IERyb3Bkb3duU2VydmljZSwgZGVwczogW3sgdG9rZW46IGkxLlBsYWNlaG9sZGVyU2VydmljZSB9LCB7IHRva2VuOiBpMi5BbmltYXRpb25GcmFtZVNlcnZpY2UgfV0sIHRhcmdldDogaTAuybXJtUZhY3RvcnlUYXJnZXQuSW5qZWN0YWJsZSB9KTtcbkRyb3Bkb3duU2VydmljZS7JtXByb3YgPSBpMC7Jtcm1bmdEZWNsYXJlSW5qZWN0YWJsZSh7IG1pblZlcnNpb246IFwiMTIuMC4wXCIsIHZlcnNpb246IFwiMTQuMy4wXCIsIG5nSW1wb3J0OiBpMCwgdHlwZTogRHJvcGRvd25TZXJ2aWNlIH0pO1xuaTAuybXJtW5nRGVjbGFyZUNsYXNzTWV0YWRhdGEoeyBtaW5WZXJzaW9uOiBcIjEyLjAuMFwiLCB2ZXJzaW9uOiBcIjE0LjMuMFwiLCBuZ0ltcG9ydDogaTAsIHR5cGU6IERyb3Bkb3duU2VydmljZSwgZGVjb3JhdG9yczogW3tcbiAgICAgICAgICAgIHR5cGU6IEluamVjdGFibGVcbiAgICAgICAgfV0sIGN0b3JQYXJhbWV0ZXJzOiBmdW5jdGlvbiAoKSB7IHJldHVybiBbeyB0eXBlOiBpMS5QbGFjZWhvbGRlclNlcnZpY2UgfSwgeyB0eXBlOiBpMi5BbmltYXRpb25GcmFtZVNlcnZpY2UgfV07IH0gfSk7XG5cbi8qKlxuICogRHJvcC1kb3duIGxpc3RzIGVuYWJsZSB1c2VycyB0byBzZWxlY3Qgb25lIG9yIG1vcmUgaXRlbXMgZnJvbSBhIGxpc3QuXG4gKlxuICogIyMjIyBPcGVuaW5nIGJlaGF2aW9yL0xpc3QgRE9NIHBsYWNlbWVudFxuICogQnkgZGVmYXVsdCB0aGUgZHJvcGRvd24gd2lsbCB0cnkgdG8gZmlndXJlIG91dCB0aGUgYmVzdCBwbGFjZW1lbnQgZm9yIHRoZSBkcm9wZG93biBsaXN0LlxuICpcbiAqIElmIGl0J3Mgbm90IGNvbnRhaW5lZCB3aXRoaW4gYW55IHNjcm9sbGluZyBlbGVtZW50cywgaXQgd2lsbCBvcGVuIGlubGluZSwgaWYgaXQgX2lzX1xuICogY29udGFpbmVkIHdpdGhpbiBhIHNjcm9sbGluZyBjb250YWluZXIgaXQgd2lsbCB0cnkgdG8gb3BlbiBpbiB0aGUgYm9keSwgb3IgYW4gYGNkcy1wbGFjZWhvbGRlcmAuXG4gKlxuICogVG8gY29udHJvbCB0aGlzIGJlaGF2aW9yIHlvdSBjYW4gdXNlIHRoZSBgYXBwZW5kSW5saW5lYCBpbnB1dDpcbiAqIC0gYFthcHBlbmRJbmxpbmVdPVwibnVsbFwiYCBpcyB0aGUgZGVmYXVsdCAoYXV0byBkZXRlY3Rpb24pXG4gKiAtIGBbYXBwZW5kSW5saW5lXT1cImZhbHNlXCJgIHdpbGwgYWx3YXlzIGFwcGVuZCB0byB0aGUgYm9keS9gY2RzLXBsYWNlaG9sZGVyYFxuICogLSBgW2FwcGVuZElubGluZV09XCJ0cnVlXCJgIHdpbGwgYWx3YXlzIGFwcGVuZCBpbmxpbmUgKG5leHQgdG8gdGhlIGRyb3Bkb3duIGJ1dHRvbilcbiAqXG4gKiBHZXQgc3RhcnRlZCB3aXRoIGltcG9ydGluZyB0aGUgbW9kdWxlOlxuICpcbiAqIGBgYHR5cGVzY3JpcHRcbiAqIGltcG9ydCB7IERyb3Bkb3duTW9kdWxlIH0gZnJvbSAnY2FyYm9uLWNvbXBvbmVudHMtYW5ndWxhcic7XG4gKiBgYGBcbiAqXG4gKiBbU2VlIGRlbW9dKC4uLy4uLz9wYXRoPS9zdG9yeS9jb21wb25lbnRzLWRyb3Bkb3duLS1iYXNpYylcbiAqL1xuY2xhc3MgRHJvcGRvd24ge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgRHJvcGRvd24uXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoZWxlbWVudFJlZiwgaTE4biwgZHJvcGRvd25TZXJ2aWNlLCBlbGVtZW50U2VydmljZSkge1xuICAgICAgICB0aGlzLmVsZW1lbnRSZWYgPSBlbGVtZW50UmVmO1xuICAgICAgICB0aGlzLmkxOG4gPSBpMThuO1xuICAgICAgICB0aGlzLmRyb3Bkb3duU2VydmljZSA9IGRyb3Bkb3duU2VydmljZTtcbiAgICAgICAgdGhpcy5lbGVtZW50U2VydmljZSA9IGVsZW1lbnRTZXJ2aWNlO1xuICAgICAgICB0aGlzLmlkID0gYGRyb3Bkb3duLSR7RHJvcGRvd24uZHJvcGRvd25Db3VudCsrfWA7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBIaWRlIGxhYmVsIHdoaWxlIGtlZXBpbmcgaXQgYWNjZXNzaWJsZSBmb3Igc2NyZWVuIHJlYWRlcnNcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuaGlkZUxhYmVsID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBWYWx1ZSBkaXNwbGF5ZWQgaWYgbm8gaXRlbSBpcyBzZWxlY3RlZC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucGxhY2Vob2xkZXIgPSBcIlwiO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHNlbGVjdGVkIHZhbHVlIGZyb20gdGhlIGBEcm9wZG93bmAuIENhbiBiZSBhIHN0cmluZyBvciB0ZW1wbGF0ZS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZGlzcGxheVZhbHVlID0gXCJcIjtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldHMgdGhlIG9wdGlvbmFsIGNsZWFyIGJ1dHRvbiB0b29sdGlwIHRleHQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNsZWFyVGV4dCA9IHRoaXMuaTE4bi5nZXQoKS5EUk9QRE9XTi5DTEVBUjtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNpemUgdG8gcmVuZGVyIHRoZSBkcm9wZG93biBmaWVsZC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc2l6ZSA9IFwibWRcIjtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIERlZmluZXMgd2hldGhlciBvciBub3QgdGhlIGBEcm9wZG93bmAgc3VwcG9ydHMgc2VsZWN0aW5nIG11bHRpcGxlIGl0ZW1zIGFzIG9wcG9zZWQgdG8gc2luZ2xlXG4gICAgICAgICAqIGl0ZW0gc2VsZWN0aW9uLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy50eXBlID0gXCJzaW5nbGVcIjtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBkZXByZWNhdGVkIHNpbmNlIHY1IC0gVXNlIGBjZHNMYXllcmAgZGlyZWN0aXZlIGluc3RlYWRcbiAgICAgICAgICogYGxpZ2h0YCBvciBgZGFya2AgZHJvcGRvd24gdGhlbWVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudGhlbWUgPSBcImRhcmtcIjtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldCB0byBgdHJ1ZWAgdG8gZGlzYWJsZSB0aGUgZHJvcGRvd24uXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmRpc2FibGVkID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXQgdG8gYHRydWVgIGZvciBhIGxvYWRpbmcgZHJvcGRvd24uXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnNrZWxldG9uID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXQgdG8gYHRydWVgIGZvciBhbiBpbmxpbmUgZHJvcGRvd24uXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmlubGluZSA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogU2V0IHRvIGB0cnVlYCBmb3IgYSBkcm9wZG93biB3aXRob3V0IGFycm93IGtleSBhY3RpdmF0aW9uLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5kaXNhYmxlQXJyb3dLZXlzID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXQgdG8gYHRydWVgIGZvciBpbnZhbGlkIHN0YXRlLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5pbnZhbGlkID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgICogU2V0IHRvIGB0cnVlYCB0byBzaG93IGEgd2FybmluZyAoY29udGVudHMgc2V0IGJ5IHdhcm5pbmdUZXh0KVxuICAgICAgICAgICovXG4gICAgICAgIHRoaXMud2FybiA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogc2V0IHRvIGB0cnVlYCB0byBwbGFjZSB0aGUgZHJvcGRvd24gdmlldyBpbmxpbmUgd2l0aCB0aGUgY29tcG9uZW50XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmFwcGVuZElubGluZSA9IG51bGw7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTcGVjaWZ5IGZlZWRiYWNrIChtb2RlKSBvZiB0aGUgc2VsZWN0aW9uLlxuICAgICAgICAgKiBgdG9wYDogc2VsZWN0ZWQgaXRlbSBqdW1wcyB0byB0b3BcbiAgICAgICAgICogYGZpeGVkYDogc2VsZWN0ZWQgaXRlbSBzdGF5cyBhdCBpdCdzIHBvc2l0aW9uXG4gICAgICAgICAqIGB0b3AtYWZ0ZXItcmVvcGVuYDogc2VsZWN0ZWQgaXRlbSBqdW1wIHRvIHRvcCBhZnRlciByZW9wZW4gZHJvcGRvd25cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc2VsZWN0aW9uRmVlZGJhY2sgPSBcInRvcC1hZnRlci1yZW9wZW5cIjtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFjY2Vzc2libGUgbGFiZWwgZm9yIHRoZSBidXR0b24gdGhhdCBvcGVucyB0aGUgZHJvcGRvd24gbGlzdC5cbiAgICAgICAgICogRGVmYXVsdHMgdG8gdGhlIGBEUk9QRE9XTi5PUEVOYCB2YWx1ZSBmcm9tIHRoZSBpMThuIHNlcnZpY2UuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm1lbnVCdXR0b25MYWJlbCA9IHRoaXMuaTE4bi5nZXQoKS5EUk9QRE9XTi5PUEVOO1xuICAgICAgICAvKipcbiAgICAgICAgICogUHJvdmlkZXMgdGhlIGxhYmVsIGZvciB0aGUgXCIjIHNlbGVjdGVkXCIgdGV4dC5cbiAgICAgICAgICogRGVmYXVsdHMgdG8gdGhlIGBEUk9QRE9XTi5TRUxFQ1RFRGAgdmFsdWUgZnJvbSB0aGUgaTE4biBzZXJ2aWNlLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zZWxlY3RlZExhYmVsID0gdGhpcy5pMThuLmdldCgpLkRST1BET1dOLlNFTEVDVEVEO1xuICAgICAgICAvKipcbiAgICAgICAgICogRW1pdHMgc2VsZWN0aW9uIGV2ZW50cy5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc2VsZWN0ZWQgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFbWl0cyBldmVudCBub3RpZnlpbmcgdG8gb3RoZXIgY2xhc3NlcyB0aGF0IHRoZSBgRHJvcGRvd25gIGhhcyBiZWVuIGNsb3NlZCAoY29sbGFwc2VkKS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMub25DbG9zZSA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEVtaXRzIGV2ZW50IG5vdGlmeWluZyB0byBvdGhlciBjbGFzc2VzIHRoYXQgdGhlIGBEcm9wZG93bmAgaGFzIGJlZW4gY2xvc2VkIChjb2xsYXBzZWQpLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jbG9zZSA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgdGhpcy5ob3N0Q2xhc3MgPSB0cnVlO1xuICAgICAgICAvKipcbiAgICAgICAgICogU2V0IHRvIGB0cnVlYCBpZiB0aGUgZHJvcGRvd24gaXMgY2xvc2VkIChub3QgZXhwYW5kZWQpLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5tZW51SXNDbG9zZWQgPSB0cnVlO1xuICAgICAgICAvKipcbiAgICAgICAgICogY29udHJvbHMgd2hldGhlciB0aGUgYGRyb3AtdXBgIGNsYXNzIGlzIGFwcGxpZWRcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX2Ryb3BVcCA9IGZhbHNlO1xuICAgICAgICAvLyAuYmluZCBjcmVhdGVzIGEgbmV3IGZ1bmN0aW9uLCBzbyB3ZSBkZWNsYXJlIHRoZSBtZXRob2RzIGJlbG93XG4gICAgICAgIC8vIGJ1dCAuYmluZCB0aGVtIHVwIGhlcmVcbiAgICAgICAgdGhpcy5ub29wID0gdGhpcy5fbm9vcC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLm91dHNpZGVDbGljayA9IHRoaXMuX291dHNpZGVDbGljay5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLm91dHNpZGVLZXkgPSB0aGlzLl9vdXRzaWRlS2V5LmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMua2V5Ym9hcmROYXYgPSB0aGlzLl9rZXlib2FyZE5hdi5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnZpc2liaWxpdHlTdWJzY3JpcHRpb24gPSBuZXcgU3Vic2NyaXB0aW9uKCk7XG4gICAgICAgIHRoaXMub25Ub3VjaGVkQ2FsbGJhY2sgPSB0aGlzLl9ub29wO1xuICAgICAgICAvLyBwcmltYXJpbHkgdXNlZCB0byBjYXB0dXJlIGFuZCBwcm9wYWdhdGUgaW5wdXQgdG8gYHdyaXRlVmFsdWVgIGJlZm9yZSB0aGUgY29udGVudCBpcyBhdmFpbGFibGVcbiAgICAgICAgdGhpcy5fd3JpdHRlblZhbHVlID0gW107XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBmdW5jdGlvbiBwYXNzZWQgaW4gYnkgYHJlZ2lzdGVyT25DaGFuZ2VgXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnByb3BhZ2F0ZUNoYW5nZSA9IChfKSA9PiB7IH07XG4gICAgfVxuICAgIGdldCB3cml0dGVuVmFsdWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl93cml0dGVuVmFsdWU7XG4gICAgfVxuICAgIHNldCB3cml0dGVuVmFsdWUodmFsKSB7XG4gICAgICAgIGlmICh2YWwgJiYgdmFsLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy5jbGVhclNlbGVjdGVkKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fd3JpdHRlblZhbHVlID0gdmFsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIHRoZSBgdHlwZWAgcHJvcGVydHkgaW4gdGhlIGBAQ29udGVudENoaWxkYC5cbiAgICAgKiBUaGUgYHR5cGVgIHByb3BlcnR5IHNwZWNpZmllcyB3aGV0aGVyIHRoZSBgRHJvcGRvd25gIGFsbG93cyBzaW5nbGUgc2VsZWN0aW9uIG9yIG11bHRpIHNlbGVjdGlvbi5cbiAgICAgKi9cbiAgICBuZ09uSW5pdCgpIHtcbiAgICAgICAgaWYgKHRoaXMudmlldykge1xuICAgICAgICAgICAgdGhpcy52aWV3LnR5cGUgPSB0aGlzLnR5cGU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZXMgY2xhc3NlcyBhbmQgc3Vic2NyaWJlcyB0byBldmVudHMgZm9yIHNpbmdsZSBvciBtdWx0aSBzZWxlY3Rpb24uXG4gICAgICovXG4gICAgbmdBZnRlckNvbnRlbnRJbml0KCkge1xuICAgICAgICBpZiAoIXRoaXMudmlldykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICgodGhpcy53cml0dGVuVmFsdWUgJiYgdGhpcy53cml0dGVuVmFsdWUubGVuZ3RoKSB8fCB0eXBlb2YgdGhpcy53cml0dGVuVmFsdWUgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgIHRoaXMud3JpdGVWYWx1ZSh0aGlzLndyaXR0ZW5WYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy52aWV3LnR5cGUgPSB0aGlzLnR5cGU7XG4gICAgICAgIHRoaXMudmlldy5zaXplID0gdGhpcy5zaXplO1xuICAgICAgICAvLyBmdW5jdGlvbiB0byBjaGVjayBpZiB0aGUgZXZlbnQgaXMgb3JnYW5pYyAoaXNVcGRhdGUgPT09IGZhbHNlKSBvciBwcm9ncmFtbWF0aWNcbiAgICAgICAgY29uc3QgaXNVcGRhdGUgPSBldmVudCA9PiBldmVudCAmJiBldmVudC5pc1VwZGF0ZTtcbiAgICAgICAgdGhpcy52aWV3LnNlbGVjdC5zdWJzY3JpYmUoZXZlbnQgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMudHlwZSA9PT0gXCJzaW5nbGVcIiAmJiAhaXNVcGRhdGUoZXZlbnQpICYmICFBcnJheS5pc0FycmF5KGV2ZW50KSkge1xuICAgICAgICAgICAgICAgIHRoaXMuY2xvc2VNZW51KCk7XG4gICAgICAgICAgICAgICAgaWYgKGV2ZW50Lml0ZW0gJiYgZXZlbnQuaXRlbS5zZWxlY3RlZCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5pdGVtVmFsdWVLZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucHJvcGFnYXRlQ2hhbmdlKGV2ZW50Lml0ZW1bdGhpcy5pdGVtVmFsdWVLZXldKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucHJvcGFnYXRlQ2hhbmdlKGV2ZW50Lml0ZW0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnByb3BhZ2F0ZUNoYW5nZShudWxsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy50eXBlID09PSBcIm11bHRpXCIgJiYgIWlzVXBkYXRlKGV2ZW50KSkge1xuICAgICAgICAgICAgICAgIC8vIGlmIHdlIGhhdmUgYSBgdmFsdWVgIHNlbGVjdG9yIGFuZCBzZWxlY3RlZCBpdGVtcyBtYXAgdGhlbSBhcHByb3ByaWF0ZWx5XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaXRlbVZhbHVlS2V5ICYmIHRoaXMudmlldy5nZXRTZWxlY3RlZCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlcyA9IHRoaXMudmlldy5nZXRTZWxlY3RlZCgpLm1hcChpdGVtID0+IGl0ZW1bdGhpcy5pdGVtVmFsdWVLZXldKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wcm9wYWdhdGVDaGFuZ2UodmFsdWVzKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gb3RoZXJ3aXNlIGp1c3QgcGFzcyB1cCB0aGUgdmFsdWVzIGZyb20gYGdldFNlbGVjdGVkYFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wcm9wYWdhdGVDaGFuZ2UodGhpcy52aWV3LmdldFNlbGVjdGVkKCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIG9ubHkgZW1pdCBzZWxlY3RlZCBmb3IgXCJvcmdhbmljXCIgc2VsZWN0aW9uc1xuICAgICAgICAgICAgaWYgKCFpc1VwZGF0ZShldmVudCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNoZWNrRm9yUmVvcmRlcigpO1xuICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWQuZW1pdChldmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBuZ0FmdGVyVmlld0luaXQoKSB7XG4gICAgICAgIC8vIGlmIGFwcGVuZElubGluZSBpcyBkZWZhdWx0IHZhbHVlZCAobnVsbCkgd2Ugc2hvdWxkOlxuICAgICAgICAvLyAxLiBpZiB0aGVyZSBhcmUgc2Nyb2xsYWJsZSBwYXJlbnRzIChub3QgaW5jbHVkaW5nIGJvZHkpIGRvbid0IGFwcGVuZCBpbmxpbmVcbiAgICAgICAgLy8gICAgdGhpcyBzaG91bGQgYWxzbyBjb3ZlciB0aGUgY2FzZSB3aGVyZSB0aGUgZHJvcGRvd24gaXMgaW4gYSBtb2RhbFxuICAgICAgICAvLyAgICAod2hlcmUgd2UgX2RvXyB3YW50IHRvIGFwcGVuZCB0byB0aGUgcGxhY2Vob2xkZXIpXG4gICAgICAgIGlmICh0aGlzLmFwcGVuZElubGluZSA9PT0gbnVsbCAmJiBoYXNTY3JvbGxhYmxlUGFyZW50cyh0aGlzLmVsZW1lbnRSZWYubmF0aXZlRWxlbWVudCkpIHtcbiAgICAgICAgICAgIHRoaXMuYXBwZW5kSW5saW5lID0gZmFsc2U7XG4gICAgICAgICAgICAvLyAyLiBvdGhlcndpc2Ugd2Ugc2hvdWxkIGFwcGVuZCBpbmxpbmVcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLmFwcGVuZElubGluZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5hcHBlbmRJbmxpbmUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2hlY2tGb3JSZW9yZGVyKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbW92aW5nIHRoZSBgRHJvcGRvd25gIGZyb20gdGhlIGJvZHkgaWYgaXQgaXMgYXBwZW5kZWQgdG8gdGhlIGJvZHkuXG4gICAgICovXG4gICAgbmdPbkRlc3Ryb3koKSB7XG4gICAgICAgIGlmICghdGhpcy5hcHBlbmRJbmxpbmUpIHtcbiAgICAgICAgICAgIHRoaXMuX2FwcGVuZFRvRHJvcGRvd24oKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBQcm9wYWdhdGVzIHRoZSBpbmplY3RlZCBgdmFsdWVgLlxuICAgICAqL1xuICAgIHdyaXRlVmFsdWUodmFsdWUpIHtcbiAgICAgICAgLy8gY2FjaGUgdGhlIHdyaXR0ZW4gdmFsdWUgc28gd2UgY2FuIHVzZSBpdCBpbiBgQWZ0ZXJDb250ZW50SW5pdGBcbiAgICAgICAgdGhpcy53cml0dGVuVmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy52aWV3Lm9uSXRlbXNSZWFkeSgoKSA9PiB7XG4gICAgICAgICAgICAvLyBwcm9wYWdhdGUgbnVsbC9mYWxzZXkgYXMgYW4gYXJyYXkgKGRlc2VsZWN0IGV2ZXJ5dGhpbmcpXG4gICAgICAgICAgICBpZiAoIXZhbHVlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy52aWV3LnByb3BhZ2F0ZVNlbGVjdGVkKFt2YWx1ZV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy50eXBlID09PSBcInNpbmdsZVwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaXRlbVZhbHVlS2V5KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGNsb25lIHRoZSBzcGVjaWZpZWQgaXRlbSBhbmQgdXBkYXRlIGl0cyBzdGF0ZVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBuZXdWYWx1ZSA9IE9iamVjdC5hc3NpZ24oe30sIHRoaXMudmlldy5nZXRMaXN0SXRlbXMoKS5maW5kKGl0ZW0gPT4gaXRlbVt0aGlzLml0ZW1WYWx1ZUtleV0gPT09IHZhbHVlKSk7XG4gICAgICAgICAgICAgICAgICAgIG5ld1ZhbHVlLnNlbGVjdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy52aWV3LnByb3BhZ2F0ZVNlbGVjdGVkKFtuZXdWYWx1ZV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gcGFzcyB0aGUgc2luZ3VsYXIgdmFsdWUgYXMgYW4gYXJyYXkgb2YgTGlzdEl0ZW1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy52aWV3LnByb3BhZ2F0ZVNlbGVjdGVkKFt2YWx1ZV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLml0ZW1WYWx1ZUtleSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBjbG9uZSB0aGUgaXRlbXMgYW5kIHVwZGF0ZSB0aGVpciBzdGF0ZSBiYXNlZCBvbiB0aGUgcmVjZWl2ZWQgdmFsdWUgYXJyYXlcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhpcyB3YXkgd2UgZG9uJ3QgbG9zZSBhbnkgYWRkaXRpb25hbCBtZXRhZGF0YSB0aGF0IG1heSBiZSBwYXNzZWQgaW4gdmlhIHRoZSBgaXRlbXNgIElucHV0XG4gICAgICAgICAgICAgICAgICAgIGxldCBuZXdWYWx1ZXMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCB2IG9mIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgdGhpcy52aWV3LmdldExpc3RJdGVtcygpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGl0ZW1bdGhpcy5pdGVtVmFsdWVLZXldID09PSB2KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld1ZhbHVlcy5wdXNoKE9iamVjdC5hc3NpZ24oe30sIGl0ZW0sIHsgc2VsZWN0ZWQ6IHRydWUgfSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnZpZXcucHJvcGFnYXRlU2VsZWN0ZWQobmV3VmFsdWVzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHdlIGNhbiBzYWZlbHkgYXNzdW1lIHdlJ3JlIHBhc3NpbmcgYW4gYXJyYXkgb2YgYExpc3RJdGVtYHNcbiAgICAgICAgICAgICAgICAgICAgdGhpcy52aWV3LnByb3BhZ2F0ZVNlbGVjdGVkKHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmNoZWNrRm9yUmVvcmRlcigpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgb25CbHVyKCkge1xuICAgICAgICB0aGlzLm9uVG91Y2hlZENhbGxiYWNrKCk7XG4gICAgfVxuICAgIHJlZ2lzdGVyT25DaGFuZ2UoZm4pIHtcbiAgICAgICAgdGhpcy5wcm9wYWdhdGVDaGFuZ2UgPSBmbjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVnaXN0ZXJpbmcgdGhlIGZ1bmN0aW9uIGluamVjdGVkIHRvIGNvbnRyb2wgdGhlIHRvdWNoIHVzZSBvZiB0aGUgYERyb3Bkb3duYC5cbiAgICAgKi9cbiAgICByZWdpc3Rlck9uVG91Y2hlZChmbikge1xuICAgICAgICB0aGlzLm9uVG91Y2hlZENhbGxiYWNrID0gZm47XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGBDb250cm9sVmFsdWVBY2Nlc3NvcmAgbWV0aG9kIHRvIHByb2dyYW1tYXRpY2FsbHkgZGlzYWJsZSB0aGUgZHJvcGRvd24uXG4gICAgICpcbiAgICAgKiBleDogYHRoaXMuZm9ybUdyb3VwLmdldChcIm15RHJvcGRvd25cIikuZGlzYWJsZSgpO2BcbiAgICAgKlxuICAgICAqIEBwYXJhbSBpc0Rpc2FibGVkIGB0cnVlYCB0byBkaXNhYmxlIHRoZSBpbnB1dFxuICAgICAqL1xuICAgIHNldERpc2FibGVkU3RhdGUoaXNEaXNhYmxlZCkge1xuICAgICAgICB0aGlzLmRpc2FibGVkID0gaXNEaXNhYmxlZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkcyBrZXlib2FyZCBmdW5jdGlvbmFsaXR5IGZvciBuYXZpZ2F0aW9uLCBzZWxlY3Rpb24gYW5kIGNsb3Npbmcgb2YgdGhlIGBEcm9wZG93bmAuXG4gICAgICovXG4gICAgb25LZXlEb3duKGV2ZW50KSB7XG4gICAgICAgIGlmICgoZXZlbnQua2V5ID09PSBcIkVzY2FwZVwiKSAmJiAhdGhpcy5tZW51SXNDbG9zZWQpIHtcbiAgICAgICAgICAgIGV2ZW50LnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpOyAvLyBkb24ndCB1bmludGVudGlvbmFsbHkgY2xvc2Ugb3RoZXIgd2lkZ2V0cyB0aGF0IGxpc3RlbiBmb3IgRXNjYXBlXG4gICAgICAgIH1cbiAgICAgICAgaWYgKGV2ZW50LmtleSA9PT0gXCJFc2NhcGVcIikge1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIHRoaXMuY2xvc2VNZW51KCk7XG4gICAgICAgICAgICB0aGlzLmRyb3Bkb3duQnV0dG9uLm5hdGl2ZUVsZW1lbnQuZm9jdXMoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLm1lbnVJc0Nsb3NlZCAmJiAoZXZlbnQua2V5ID09PSBcIiBcIiB8fCBldmVudC5rZXkgPT09IFwiQXJyb3dEb3duXCIgfHwgZXZlbnQua2V5ID09PSBcIkFycm93VXBcIikpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmRpc2FibGVBcnJvd0tleXMgJiYgKGV2ZW50LmtleSA9PT0gXCJBcnJvd0Rvd25cIiB8fCBldmVudC5rZXkgPT09IFwiQXJyb3dVcFwiKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICB0aGlzLm9wZW5NZW51KCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLm1lbnVJc0Nsb3NlZCAmJiBldmVudC5rZXkgPT09IFwiVGFiXCIgJiYgdGhpcy5kcm9wZG93bk1lbnUubmF0aXZlRWxlbWVudC5jb250YWlucyhldmVudC50YXJnZXQpKSB7XG4gICAgICAgICAgICB0aGlzLmNsb3NlTWVudSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5tZW51SXNDbG9zZWQgJiYgZXZlbnQua2V5ID09PSBcIlRhYlwiICYmIGV2ZW50LnNoaWZ0S2V5KSB7XG4gICAgICAgICAgICB0aGlzLmNsb3NlTWVudSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnR5cGUgPT09IFwibXVsdGlcIikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm1lbnVJc0Nsb3NlZCkge1xuICAgICAgICAgICAgdGhpcy5jbG9zZWREcm9wZG93bk5hdmlnYXRpb24oZXZlbnQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNsb3NlZERyb3Bkb3duTmF2aWdhdGlvbihldmVudCkge1xuICAgICAgICBpZiAoZXZlbnQua2V5ID09PSBcIkFycm93RG93blwiKSB7XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgdGhpcy52aWV3LmdldEN1cnJlbnRJdGVtKCkuc2VsZWN0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIGxldCBpdGVtID0gdGhpcy52aWV3LmdldE5leHRJdGVtKCk7XG4gICAgICAgICAgICBpZiAoaXRlbSkge1xuICAgICAgICAgICAgICAgIGl0ZW0uc2VsZWN0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGV2ZW50LmtleSA9PT0gXCJBcnJvd1VwXCIpIHtcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICB0aGlzLnZpZXcuZ2V0Q3VycmVudEl0ZW0oKS5zZWxlY3RlZCA9IGZhbHNlO1xuICAgICAgICAgICAgbGV0IGl0ZW0gPSB0aGlzLnZpZXcuZ2V0UHJldkl0ZW0oKTtcbiAgICAgICAgICAgIGlmIChpdGVtKSB7XG4gICAgICAgICAgICAgICAgaXRlbS5zZWxlY3RlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgZGlzcGxheSB2YWx1ZSBpZiB0aGVyZSBpcyBhIHNlbGVjdGlvbiBhbmQgZGlzcGxheVZhbHVlIGlzIHNldCxcbiAgICAgKiBpZiB0aGVyZSBpcyBqdXN0IGEgc2VsZWN0aW9uIHRoZSBMaXN0SXRlbSBjb250ZW50IHByb3BlcnR5IHdpbGwgYmUgcmV0dXJuZWQsXG4gICAgICogb3RoZXJ3aXNlIHRoZSBwbGFjZWhvbGRlciB3aWxsIGJlIHJldHVybmVkLlxuICAgICAqL1xuICAgIGdldERpc3BsYXlTdHJpbmdWYWx1ZSgpIHtcbiAgICAgICAgaWYgKCF0aGlzLnZpZXcgfHwgdGhpcy5za2VsZXRvbikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGxldCBzZWxlY3RlZCA9IHRoaXMudmlldy5nZXRTZWxlY3RlZCgpO1xuICAgICAgICBpZiAoc2VsZWN0ZWQubGVuZ3RoICYmICghdGhpcy5kaXNwbGF5VmFsdWUgfHwgIXRoaXMuaXNSZW5kZXJTdHJpbmcoKSkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnR5cGUgPT09IFwibXVsdGlcIikge1xuICAgICAgICAgICAgICAgIHJldHVybiBvZih0aGlzLnBsYWNlaG9sZGVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBvZihzZWxlY3RlZFswXS5jb250ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzZWxlY3RlZC5sZW5ndGggJiYgdGhpcy5pc1JlbmRlclN0cmluZygpKSB7XG4gICAgICAgICAgICByZXR1cm4gb2YodGhpcy5kaXNwbGF5VmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvZih0aGlzLnBsYWNlaG9sZGVyKTtcbiAgICB9XG4gICAgaXNSZW5kZXJTdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgdGhpcy5kaXNwbGF5VmFsdWUgPT09IFwic3RyaW5nXCI7XG4gICAgfVxuICAgIGdldFJlbmRlclRlbXBsYXRlQ29udGV4dCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLnZpZXcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgc2VsZWN0ZWQgPSB0aGlzLnZpZXcuZ2V0U2VsZWN0ZWQoKTtcbiAgICAgICAgaWYgKHRoaXMudHlwZSA9PT0gXCJtdWx0aVwiKSB7XG4gICAgICAgICAgICByZXR1cm4geyBpdGVtczogc2VsZWN0ZWQgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzZWxlY3RlZCAmJiBzZWxlY3RlZC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICByZXR1cm4geyBpdGVtOiBzZWxlY3RlZFswXSB9OyAvLyB0aGlzIGlzIHRvIGJlIGNvbXBhdGlibGUgd2l0aCB0aGUgZHJvcGRvd24tbGlzdCB0ZW1wbGF0ZVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldFNlbGVjdGVkQ291bnQoKSB7XG4gICAgICAgIGlmICh0aGlzLnZpZXcuZ2V0U2VsZWN0ZWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudmlldy5nZXRTZWxlY3RlZCgpLmxlbmd0aDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjbGVhclNlbGVjdGVkKCkge1xuICAgICAgICBpZiAodGhpcy5kaXNhYmxlZCB8fCB0aGlzLmdldFNlbGVjdGVkQ291bnQoKSA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgaXRlbSBvZiB0aGlzLnZpZXcuZ2V0TGlzdEl0ZW1zKCkpIHtcbiAgICAgICAgICAgIGl0ZW0uc2VsZWN0ZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNlbGVjdGVkLmVtaXQoW10pO1xuICAgICAgICB0aGlzLnByb3BhZ2F0ZUNoYW5nZShbXSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYHRydWVgIGlmIHRoZXJlIGlzIGEgdmFsdWUgc2VsZWN0ZWQuXG4gICAgICovXG4gICAgdmFsdWVTZWxlY3RlZCgpIHtcbiAgICAgICAgaWYgKHRoaXMudmlldy5nZXRTZWxlY3RlZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIF9ub29wKCkgeyB9XG4gICAgLyoqXG4gICAgICogSGFuZGxlcyBjbGlja3Mgb3V0c2lkZSBvZiB0aGUgYERyb3Bkb3duYC5cbiAgICAgKi9cbiAgICBfb3V0c2lkZUNsaWNrKGV2ZW50KSB7XG4gICAgICAgIGlmICghdGhpcy5lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQuY29udGFpbnMoZXZlbnQudGFyZ2V0KSAmJlxuICAgICAgICAgICAgLy8gaWYgd2UncmUgYXBwZW5kVG9Cb2R5IHRoZSBsaXN0IGlzbid0IHdpdGhpbiB0aGUgX2VsZW1lbnRSZWYsXG4gICAgICAgICAgICAvLyBzbyB3ZSd2ZSBnb3QgdG8gY2hlY2sgaWYgb3VyIHRhcmdldCBpcyBwb3NzaWJseSBpbiB0aGVyZSB0b28uXG4gICAgICAgICAgICAhdGhpcy5kcm9wZG93bk1lbnUubmF0aXZlRWxlbWVudC5jb250YWlucyhldmVudC50YXJnZXQpKSB7XG4gICAgICAgICAgICB0aGlzLmNsb3NlTWVudSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9vdXRzaWRlS2V5KGV2ZW50KSB7XG4gICAgICAgIGlmICghdGhpcy5tZW51SXNDbG9zZWQgJiYgZXZlbnQua2V5ID09PSBcIlRhYlwiICYmIHRoaXMuZHJvcGRvd25NZW51Lm5hdGl2ZUVsZW1lbnQuY29udGFpbnMoZXZlbnQudGFyZ2V0KSkge1xuICAgICAgICAgICAgdGhpcy5jbG9zZU1lbnUoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBIYW5kbGVzIGtleWJvYXJkIGV2ZW50cyBzbyB1c2VycyBhcmUgY29udHJvbGxpbmcgdGhlIGBEcm9wZG93bmAgaW5zdGVhZCBvZiB1bmludGVudGlvbmFsbHkgY29udHJvbGxpbmcgb3V0c2lkZSBlbGVtZW50cy5cbiAgICAgKi9cbiAgICBfa2V5Ym9hcmROYXYoZXZlbnQpIHtcbiAgICAgICAgaWYgKGV2ZW50LmtleSA9PT0gXCJFc2NhcGVcIiAmJiAhdGhpcy5tZW51SXNDbG9zZWQpIHtcbiAgICAgICAgICAgIGV2ZW50LnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpOyAvLyBkb24ndCB1bmludGVudGlvbmFsbHkgY2xvc2UgbW9kYWwgaWYgaW5zaWRlIG9mIGl0XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGV2ZW50LmtleSA9PT0gXCJFc2NhcGVcIikge1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIHRoaXMuY2xvc2VNZW51KCk7XG4gICAgICAgICAgICB0aGlzLmRyb3Bkb3duQnV0dG9uLm5hdGl2ZUVsZW1lbnQuZm9jdXMoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghdGhpcy5tZW51SXNDbG9zZWQgJiYgZXZlbnQua2V5ID09PSBcIlRhYlwiKSB7XG4gICAgICAgICAgICAvLyB0aGlzIHdheSBmb2N1cyB3aWxsIHN0YXJ0IG9uIHRoZSBuZXh0IGZvY3VzYWJsZSBpdGVtIGZyb20gdGhlIGRyb3Bkb3duXG4gICAgICAgICAgICAvLyBub3QgdGhlIHRvcCBvZiB0aGUgYm9keSFcbiAgICAgICAgICAgIHRoaXMuZHJvcGRvd25CdXR0b24ubmF0aXZlRWxlbWVudC5mb2N1cygpO1xuICAgICAgICAgICAgdGhpcy5kcm9wZG93bkJ1dHRvbi5uYXRpdmVFbGVtZW50LmRpc3BhdGNoRXZlbnQobmV3IEtleWJvYXJkRXZlbnQoXCJrZXlkb3duXCIsIHsgYnViYmxlczogdHJ1ZSwgY2FuY2VsYWJsZTogdHJ1ZSwga2V5OiBcIlRhYlwiIH0pKTtcbiAgICAgICAgICAgIHRoaXMuY2xvc2VNZW51KCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyB0aGUgYERyb3Bkb3duYCBsaXN0IGFwcGVuZGluZyBpdCB0byB0aGUgZHJvcGRvd24gcGFyZW50IG9iamVjdCBpbnN0ZWFkIG9mIHRoZSBib2R5LlxuICAgICAqL1xuICAgIF9hcHBlbmRUb0Ryb3Bkb3duKCkge1xuICAgICAgICB0aGlzLmRyb3Bkb3duU2VydmljZS5hcHBlbmRUb0Ryb3Bkb3duKHRoaXMuZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50KTtcbiAgICAgICAgdGhpcy5kcm9wZG93bk1lbnUubmF0aXZlRWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCB0aGlzLmtleWJvYXJkTmF2LCB0cnVlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyB0aGUgYERyb3Bkb3duYCBsaXN0IGFzIGFuIGVsZW1lbnQgdGhhdCBpcyBhcHBlbmRlZCB0byB0aGUgRE9NIGJvZHkuXG4gICAgICovXG4gICAgX2FwcGVuZFRvQm9keSgpIHtcbiAgICAgICAgY29uc3QgbGlnaHRDbGFzcyA9IHRoaXMudGhlbWUgPT09IFwibGlnaHRcIiA/IFwiIGNkcy0tbGlzdC1ib3gtLWxpZ2h0XCIgOiBcIlwiO1xuICAgICAgICBjb25zdCBleHBhbmRlZENsYXNzID0gIXRoaXMubWVudUlzQ2xvc2VkID8gXCIgY2RzLS1saXN0LWJveC0tZXhwYW5kZWRcIiA6IFwiXCI7XG4gICAgICAgIHRoaXMuZHJvcGRvd25TZXJ2aWNlLmFwcGVuZFRvQm9keSh0aGlzLmRyb3Bkb3duQnV0dG9uLm5hdGl2ZUVsZW1lbnQsIHRoaXMuZHJvcGRvd25NZW51Lm5hdGl2ZUVsZW1lbnQsIGAke3RoaXMuZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LmNsYXNzTmFtZX0ke2xpZ2h0Q2xhc3N9JHtleHBhbmRlZENsYXNzfWApO1xuICAgICAgICB0aGlzLmRyb3Bkb3duTWVudS5uYXRpdmVFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIHRoaXMua2V5Ym9hcmROYXYsIHRydWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZXRlY3RzIHdoZXRoZXIgb3Igbm90IHRoZSBgRHJvcGRvd25gIGxpc3QgaXMgdmlzaWJsZSB3aXRoaW4gYWxsIHNjcm9sbGFibGUgcGFyZW50cy5cbiAgICAgKiBUaGlzIGNhbiBiZSBvdmVycmlkZGVuIGJ5IHBhc3NpbmcgaW4gYSB2YWx1ZSB0byB0aGUgYGRyb3BVcGAgaW5wdXQuXG4gICAgICovXG4gICAgX3Nob3VsZERyb3BVcCgpIHtcbiAgICAgICAgLy8gY2hlY2sgaWYgZHJvcGRvd25NZW51IGV4aXN0cyBmaXJzdC5cbiAgICAgICAgY29uc3QgbWVudSA9IHRoaXMuZHJvcGRvd25NZW51ICYmIHRoaXMuZHJvcGRvd25NZW51Lm5hdGl2ZUVsZW1lbnQucXVlcnlTZWxlY3RvcihcIi5jZHMtLWxpc3QtYm94X19tZW51XCIpO1xuICAgICAgICAvLyBjaGVjayBpZiBtZW51IGV4aXN0cyBmaXJzdC5cbiAgICAgICAgY29uc3QgbWVudVJlY3QgPSBtZW51ICYmIG1lbnUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIGlmIChtZW51ICYmIG1lbnVSZWN0KSB7XG4gICAgICAgICAgICBjb25zdCBzY3JvbGxhYmxlUGFyZW50cyA9IGdldFNjcm9sbGFibGVQYXJlbnRzKG1lbnUpO1xuICAgICAgICAgICAgcmV0dXJuIHNjcm9sbGFibGVQYXJlbnRzLnJlZHVjZSgoc2hvdWxkRHJvcFVwLCBwYXJlbnQpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXJlbnRSZWN0ID0gcGFyZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGlzQmVsb3dQYXJlbnQgPSAhKG1lbnVSZWN0LmJvdHRvbSA8PSBwYXJlbnRSZWN0LmJvdHRvbSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNob3VsZERyb3BVcCB8fCBpc0JlbG93UGFyZW50O1xuICAgICAgICAgICAgfSwgZmFsc2UpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRXhwYW5kcyB0aGUgZHJvcGRvd24gbWVudSBpbiB0aGUgdmlldy5cbiAgICAgKi9cbiAgICBvcGVuTWVudSgpIHtcbiAgICAgICAgLy8gcHJldmVudHMgdGhlIGRyb3Bkb3duIGZyb20gb3BlbmluZyB3aGVuIGxpc3Qgb2YgaXRlbXMgaXMgZW1wdHlcbiAgICAgICAgaWYgKHRoaXMudmlldy5nZXRMaXN0SXRlbXMoKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9kcm9wVXAgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5tZW51SXNDbG9zZWQgPSBmYWxzZTtcbiAgICAgICAgLy8gbW92ZSB0aGUgZHJvcGRvd24gbGlzdCB0byB0aGUgYm9keSBpZiB3ZSdyZSBub3QgYXBwZW5kaW5nIGlubGluZVxuICAgICAgICAvLyBhbmQgcG9zaXRpb24gaXQgcmVsYXRpdmUgdG8gdGhlIGRyb3Bkb3duIHdyYXBwZXJcbiAgICAgICAgaWYgKCF0aGlzLmFwcGVuZElubGluZSkge1xuICAgICAgICAgICAgY29uc3QgdGFyZ2V0ID0gdGhpcy5kcm9wZG93bkJ1dHRvbi5uYXRpdmVFbGVtZW50O1xuICAgICAgICAgICAgY29uc3QgcGFyZW50ID0gdGhpcy5lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQ7XG4gICAgICAgICAgICB0aGlzLnZpc2liaWxpdHlTdWJzY3JpcHRpb24gPSB0aGlzLmVsZW1lbnRTZXJ2aWNlXG4gICAgICAgICAgICAgICAgLnZpc2liaWxpdHkodGFyZ2V0LCBwYXJlbnQpXG4gICAgICAgICAgICAgICAgLnN1YnNjcmliZSh2YWx1ZSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCF2YWx1ZS52aXNpYmxlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2xvc2VNZW51KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLl9hcHBlbmRUb0JvZHkoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBzZXQgdGhlIGRyb3Bkb3duIG1lbnUgdG8gZHJvcCB1cCBpZiBpdCdzIG5lYXIgdGhlIGJvdHRvbSBvZiB0aGUgc2NyZWVuXG4gICAgICAgIC8vIHNldFRpbWVvdXQgbGV0cyB1cyBtZWFzdXJlIGFmdGVyIGl0J3MgdmlzaWJsZSBpbiB0aGUgRE9NXG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuZHJvcFVwID09PSBudWxsIHx8IHRoaXMuZHJvcFVwID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9kcm9wVXAgPSB0aGlzLl9zaG91bGREcm9wVXAoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgMCk7XG4gICAgICAgIC8vIHdlIGJpbmQgbm9vcCB0byBkb2N1bWVudC5ib2R5LmZpcnN0RWxlbWVudENoaWxkIHRvIGFsbG93IHNhZmFyaSB0byBmaXJlIGV2ZW50c1xuICAgICAgICAvLyBmcm9tIGRvY3VtZW50LiBUaGVuIHdlIHVuYmluZCBldmVyeXRoaW5nIGxhdGVyIHRvIGtlZXAgdGhpbmdzIGxpZ2h0LlxuICAgICAgICBkb2N1bWVudC5ib2R5LmZpcnN0RWxlbWVudENoaWxkLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCB0aGlzLm5vb3AsIHRydWUpO1xuICAgICAgICBkb2N1bWVudC5ib2R5LmZpcnN0RWxlbWVudENoaWxkLmFkZEV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIHRoaXMubm9vcCwgdHJ1ZSk7XG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCB0aGlzLm91dHNpZGVDbGljaywgdHJ1ZSk7XG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIHRoaXMub3V0c2lkZUtleSwgdHJ1ZSk7XG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4gdGhpcy52aWV3LmluaXRGb2N1cygpLCAwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29sbGFwc2luZyB0aGUgZHJvcGRvd24gbWVudSBhbmQgcmVtb3ZpbmcgdW5uZWNlc3NhcnkgYEV2ZW50TGlzdGVuZXJzYC5cbiAgICAgKi9cbiAgICBjbG9zZU1lbnUoKSB7XG4gICAgICAgIC8vIHJldHVybiBlYXJseSBpZiB0aGUgbWVudSBpcyBhbHJlYWR5IGNsb3NlZFxuICAgICAgICBpZiAodGhpcy5tZW51SXNDbG9zZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm1lbnVJc0Nsb3NlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuY2hlY2tGb3JSZW9yZGVyKCk7XG4gICAgICAgIHRoaXMub25DbG9zZS5lbWl0KCk7XG4gICAgICAgIHRoaXMuY2xvc2UuZW1pdCgpO1xuICAgICAgICAvLyBmb2N1cyB0aGUgdHJpZ2dlciBidXR0b24gd2hlbiB3ZSBjbG9zZSAuLi5cbiAgICAgICAgdGhpcy5kcm9wZG93bkJ1dHRvbi5uYXRpdmVFbGVtZW50LmZvY3VzKCk7XG4gICAgICAgIC8vIHJlbW92ZSB0aGUgY29uZGl0aW9uYWwgb25jZSB0aGlzIGFwaSBpcyBzZXR0bGVkIGFuZCBwYXJ0IG9mIGFic3RyYWN0LWRyb3Bkb3duLXZpZXcuY2xhc3NcbiAgICAgICAgaWYgKHRoaXMudmlld1tcImRpc2FibGVTY3JvbGxcIl0pIHtcbiAgICAgICAgICAgIHRoaXMudmlld1tcImRpc2FibGVTY3JvbGxcIl0oKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBtb3ZlIHRoZSBsaXN0IGJhY2sgaW4gdGhlIGNvbXBvbmVudCBvbiBjbG9zZVxuICAgICAgICBpZiAoIXRoaXMuYXBwZW5kSW5saW5lKSB7XG4gICAgICAgICAgICB0aGlzLnZpc2liaWxpdHlTdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgIHRoaXMuX2FwcGVuZFRvRHJvcGRvd24oKTtcbiAgICAgICAgfVxuICAgICAgICBkb2N1bWVudC5ib2R5LmZpcnN0RWxlbWVudENoaWxkLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCB0aGlzLm5vb3AsIHRydWUpO1xuICAgICAgICBkb2N1bWVudC5ib2R5LmZpcnN0RWxlbWVudENoaWxkLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIHRoaXMubm9vcCwgdHJ1ZSk7XG4gICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCB0aGlzLm91dHNpZGVDbGljaywgdHJ1ZSk7XG4gICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIHRoaXMub3V0c2lkZUtleSwgdHJ1ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbnRyb2xzIHRvZ2dsaW5nIG1lbnUgc3RhdGVzIGJldHdlZW4gb3Blbi9leHBhbmRlZCBhbmQgY2xvc2VkL2NvbGxhcHNlZC5cbiAgICAgKi9cbiAgICB0b2dnbGVNZW51KCkge1xuICAgICAgICBpZiAodGhpcy5tZW51SXNDbG9zZWQpIHtcbiAgICAgICAgICAgIHRoaXMub3Blbk1lbnUoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuY2xvc2VNZW51KCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaXNUZW1wbGF0ZSh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBUZW1wbGF0ZVJlZjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29udHJvbHMgd2hlbiBpdCdzIG5lZWRlZCB0byBhcHBseSB0aGUgc2VsZWN0aW9uIGZlZWRiYWNrXG4gICAgICovXG4gICAgY2hlY2tGb3JSZW9yZGVyKCkge1xuICAgICAgICBjb25zdCB0b3BBZnRlclJlb3BlbiA9IHRoaXMubWVudUlzQ2xvc2VkICYmIHRoaXMuc2VsZWN0aW9uRmVlZGJhY2sgPT09IFwidG9wLWFmdGVyLXJlb3BlblwiO1xuICAgICAgICBpZiAoKHRoaXMudHlwZSA9PT0gXCJtdWx0aVwiKSAmJiAodG9wQWZ0ZXJSZW9wZW4gfHwgdGhpcy5zZWxlY3Rpb25GZWVkYmFjayA9PT0gXCJ0b3BcIikpIHtcbiAgICAgICAgICAgIHRoaXMudmlldy5yZW9yZGVyU2VsZWN0ZWQoKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbkRyb3Bkb3duLmRyb3Bkb3duQ291bnQgPSAwO1xuRHJvcGRvd24uybVmYWMgPSBpMC7Jtcm1bmdEZWNsYXJlRmFjdG9yeSh7IG1pblZlcnNpb246IFwiMTIuMC4wXCIsIHZlcnNpb246IFwiMTQuMy4wXCIsIG5nSW1wb3J0OiBpMCwgdHlwZTogRHJvcGRvd24sIGRlcHM6IFt7IHRva2VuOiBpMC5FbGVtZW50UmVmIH0sIHsgdG9rZW46IGkxJDEuSTE4biB9LCB7IHRva2VuOiBEcm9wZG93blNlcnZpY2UgfSwgeyB0b2tlbjogaTIuRWxlbWVudFNlcnZpY2UgfV0sIHRhcmdldDogaTAuybXJtUZhY3RvcnlUYXJnZXQuQ29tcG9uZW50IH0pO1xuRHJvcGRvd24uybVjbXAgPSBpMC7Jtcm1bmdEZWNsYXJlQ29tcG9uZW50KHsgbWluVmVyc2lvbjogXCIxNC4wLjBcIiwgdmVyc2lvbjogXCIxNC4zLjBcIiwgdHlwZTogRHJvcGRvd24sIHNlbGVjdG9yOiBcImNkcy1kcm9wZG93biwgaWJtLWRyb3Bkb3duXCIsIGlucHV0czogeyBpZDogXCJpZFwiLCBsYWJlbDogXCJsYWJlbFwiLCBoaWRlTGFiZWw6IFwiaGlkZUxhYmVsXCIsIGhlbHBlclRleHQ6IFwiaGVscGVyVGV4dFwiLCBwbGFjZWhvbGRlcjogXCJwbGFjZWhvbGRlclwiLCBkaXNwbGF5VmFsdWU6IFwiZGlzcGxheVZhbHVlXCIsIGNsZWFyVGV4dDogXCJjbGVhclRleHRcIiwgc2l6ZTogXCJzaXplXCIsIHR5cGU6IFwidHlwZVwiLCB0aGVtZTogXCJ0aGVtZVwiLCBkaXNhYmxlZDogXCJkaXNhYmxlZFwiLCBza2VsZXRvbjogXCJza2VsZXRvblwiLCBpbmxpbmU6IFwiaW5saW5lXCIsIGRpc2FibGVBcnJvd0tleXM6IFwiZGlzYWJsZUFycm93S2V5c1wiLCBpbnZhbGlkOiBcImludmFsaWRcIiwgaW52YWxpZFRleHQ6IFwiaW52YWxpZFRleHRcIiwgd2FybjogXCJ3YXJuXCIsIHdhcm5UZXh0OiBcIndhcm5UZXh0XCIsIGFwcGVuZElubGluZTogXCJhcHBlbmRJbmxpbmVcIiwgc2Nyb2xsYWJsZUNvbnRhaW5lcjogXCJzY3JvbGxhYmxlQ29udGFpbmVyXCIsIGl0ZW1WYWx1ZUtleTogXCJpdGVtVmFsdWVLZXlcIiwgc2VsZWN0aW9uRmVlZGJhY2s6IFwic2VsZWN0aW9uRmVlZGJhY2tcIiwgbWVudUJ1dHRvbkxhYmVsOiBcIm1lbnVCdXR0b25MYWJlbFwiLCBzZWxlY3RlZExhYmVsOiBcInNlbGVjdGVkTGFiZWxcIiwgZHJvcFVwOiBcImRyb3BVcFwiIH0sIG91dHB1dHM6IHsgc2VsZWN0ZWQ6IFwic2VsZWN0ZWRcIiwgb25DbG9zZTogXCJvbkNsb3NlXCIsIGNsb3NlOiBcImNsb3NlXCIgfSwgaG9zdDogeyBsaXN0ZW5lcnM6IHsgXCJrZXlkb3duXCI6IFwib25LZXlEb3duKCRldmVudClcIiB9LCBwcm9wZXJ0aWVzOiB7IFwiY2xhc3MuY2RzLS1kcm9wZG93bl9fd3JhcHBlclwiOiBcInRoaXMuaG9zdENsYXNzXCIgfSB9LCBwcm92aWRlcnM6IFtcbiAgICAgICAge1xuICAgICAgICAgICAgcHJvdmlkZTogTkdfVkFMVUVfQUNDRVNTT1IsXG4gICAgICAgICAgICB1c2VFeGlzdGluZzogRHJvcGRvd24sXG4gICAgICAgICAgICBtdWx0aTogdHJ1ZVxuICAgICAgICB9XG4gICAgXSwgcXVlcmllczogW3sgcHJvcGVydHlOYW1lOiBcInZpZXdcIiwgZmlyc3Q6IHRydWUsIHByZWRpY2F0ZTogQWJzdHJhY3REcm9wZG93blZpZXcsIGRlc2NlbmRhbnRzOiB0cnVlLCBzdGF0aWM6IHRydWUgfV0sIHZpZXdRdWVyaWVzOiBbeyBwcm9wZXJ0eU5hbWU6IFwiZHJvcGRvd25CdXR0b25cIiwgZmlyc3Q6IHRydWUsIHByZWRpY2F0ZTogW1wiZHJvcGRvd25CdXR0b25cIl0sIGRlc2NlbmRhbnRzOiB0cnVlLCBzdGF0aWM6IHRydWUgfSwgeyBwcm9wZXJ0eU5hbWU6IFwiZHJvcGRvd25NZW51XCIsIGZpcnN0OiB0cnVlLCBwcmVkaWNhdGU6IFtcImRyb3Bkb3duTWVudVwiXSwgZGVzY2VuZGFudHM6IHRydWUsIHN0YXRpYzogdHJ1ZSB9XSwgbmdJbXBvcnQ6IGkwLCB0ZW1wbGF0ZTogYFxuXHQ8bGFiZWxcblx0XHQqbmdJZj1cImxhYmVsICYmICFza2VsZXRvblwiXG5cdFx0W2Zvcl09XCJpZFwiXG5cdFx0Y2xhc3M9XCJjZHMtLWxhYmVsXCJcblx0XHRbbmdDbGFzc109XCJ7XG5cdFx0XHQnY2RzLS1sYWJlbC0tZGlzYWJsZWQnOiBkaXNhYmxlZCxcblx0XHRcdCdjZHMtLXZpc3VhbGx5LWhpZGRlbic6IGhpZGVMYWJlbFxuXHRcdH1cIj5cblx0XHQ8bmctY29udGFpbmVyICpuZ0lmPVwiIWlzVGVtcGxhdGUobGFiZWwpXCI+e3tsYWJlbH19PC9uZy1jb250YWluZXI+XG5cdFx0PG5nLXRlbXBsYXRlICpuZ0lmPVwiaXNUZW1wbGF0ZShsYWJlbClcIiBbbmdUZW1wbGF0ZU91dGxldF09XCJsYWJlbFwiPjwvbmctdGVtcGxhdGU+XG5cdDwvbGFiZWw+XG5cdDxkaXZcblx0XHRjbGFzcz1cImNkcy0tbGlzdC1ib3hcIlxuXHRcdFtuZ0NsYXNzXT1cIntcblx0XHRcdCdjZHMtLWRyb3Bkb3duJzogdHlwZSAhPT0gJ211bHRpJyxcblx0XHRcdCdjZHMtLW11bHRpc2VsZWN0JzogdHlwZSA9PT0gJ211bHRpJyxcblx0XHRcdCdjZHMtLW11bHRpLXNlbGVjdC0tc2VsZWN0ZWQnOiB0eXBlID09PSAnbXVsdGknICYmIGdldFNlbGVjdGVkQ291bnQoKSA+IDAsXG5cdFx0XHQnY2RzLS1kcm9wZG93bi0tbGlnaHQnOiB0aGVtZSA9PT0gJ2xpZ2h0Jyxcblx0XHRcdCdjZHMtLWxpc3QtYm94LS1saWdodCc6IHRoZW1lID09PSAnbGlnaHQnLFxuXHRcdFx0J2Nkcy0tbGlzdC1ib3gtLWlubGluZSc6IGlubGluZSxcblx0XHRcdCdjZHMtLXNrZWxldG9uJzogc2tlbGV0b24sXG5cdFx0XHQnY2RzLS1kcm9wZG93bi0tZGlzYWJsZWQgY2RzLS1saXN0LWJveC0tZGlzYWJsZWQnOiBkaXNhYmxlZCxcblx0XHRcdCdjZHMtLWRyb3Bkb3duLS1pbnZhbGlkJzogaW52YWxpZCxcblx0XHRcdCdjZHMtLWRyb3Bkb3duLS13YXJuaW5nIGNkcy0tbGlzdC1ib3gtLXdhcm5pbmcnOiB3YXJuLFxuXHRcdFx0J2Nkcy0tZHJvcGRvd24tLXNtIGNkcy0tbGlzdC1ib3gtLXNtJzogc2l6ZSA9PT0gJ3NtJyxcblx0XHRcdCdjZHMtLWRyb3Bkb3duLS1tZCBjZHMtLWxpc3QtYm94LS1tZCc6IHNpemUgPT09ICdtZCcsXG5cdFx0XHQnY2RzLS1kcm9wZG93bi0tbGcgY2RzLS1saXN0LWJveC0tbGcnOiBzaXplID09PSAnbGcnLFxuXHRcdFx0J2Nkcy0tbGlzdC1ib3gtLWV4cGFuZGVkJzogIW1lbnVJc0Nsb3NlZFxuXHRcdH1cIj5cblx0XHQ8YnV0dG9uXG5cdFx0XHQjZHJvcGRvd25CdXR0b25cblx0XHRcdFtpZF09XCJpZFwiXG5cdFx0XHR0eXBlPVwiYnV0dG9uXCJcblx0XHRcdGNsYXNzPVwiY2RzLS1saXN0LWJveF9fZmllbGRcIlxuXHRcdFx0W25nQ2xhc3NdPVwieydhJzogIW1lbnVJc0Nsb3NlZH1cIlxuXHRcdFx0W2F0dHIuYXJpYS1leHBhbmRlZF09XCIhbWVudUlzQ2xvc2VkXCJcblx0XHRcdFthdHRyLmFyaWEtZGlzYWJsZWRdPVwiZGlzYWJsZWRcIlxuXHRcdFx0YXJpYS1oYXNwb3B1cD1cImxpc3Rib3hcIlxuXHRcdFx0KGNsaWNrKT1cImRpc2FibGVkID8gJGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpIDogdG9nZ2xlTWVudSgpXCJcblx0XHRcdChibHVyKT1cIm9uQmx1cigpXCJcblx0XHRcdFthdHRyLmRpc2FibGVkXT1cImRpc2FibGVkID8gdHJ1ZSA6IG51bGxcIj5cblx0XHRcdDxkaXZcblx0XHRcdFx0KGNsaWNrKT1cImNsZWFyU2VsZWN0ZWQoKVwiXG5cdFx0XHRcdChrZXlkb3duLmVudGVyKT1cImNsZWFyU2VsZWN0ZWQoKVwiXG5cdFx0XHRcdCpuZ0lmPVwidHlwZSA9PT0gJ211bHRpJyAmJiBnZXRTZWxlY3RlZENvdW50KCkgPiAwXCJcblx0XHRcdFx0Y2xhc3M9XCJjZHMtLWxpc3QtYm94X19zZWxlY3Rpb24gY2RzLS10YWctLWZpbHRlciBjZHMtLWxpc3QtYm94X19zZWxlY3Rpb24tLW11bHRpXCJcblx0XHRcdFx0dGFiaW5kZXg9XCIwXCJcblx0XHRcdFx0W3RpdGxlXT1cImNsZWFyVGV4dFwiPlxuXHRcdFx0XHR7e2dldFNlbGVjdGVkQ291bnQoKX19XG5cdFx0XHRcdDxzdmdcblx0XHRcdFx0XHRmb2N1c2FibGU9XCJmYWxzZVwiXG5cdFx0XHRcdFx0cHJlc2VydmVBc3BlY3RSYXRpbz1cInhNaWRZTWlkIG1lZXRcIlxuXHRcdFx0XHRcdHN0eWxlPVwid2lsbC1jaGFuZ2U6IHRyYW5zZm9ybTtcIlxuXHRcdFx0XHRcdHJvbGU9XCJpbWdcIlxuXHRcdFx0XHRcdHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIlxuXHRcdFx0XHRcdHdpZHRoPVwiMTZcIlxuXHRcdFx0XHRcdGhlaWdodD1cIjE2XCJcblx0XHRcdFx0XHR2aWV3Qm94PVwiMCAwIDE2IDE2XCJcblx0XHRcdFx0XHRhcmlhLWhpZGRlbj1cInRydWVcIj5cblx0XHRcdFx0XHQ8cGF0aCBkPVwiTTEyIDQuN2wtLjctLjdMOCA3LjMgNC43IDRsLS43LjdMNy4zIDggNCAxMS4zbC43LjdMOCA4LjdsMy4zIDMuMy43LS43TDguNyA4elwiPjwvcGF0aD5cblx0XHRcdFx0PC9zdmc+XG5cdFx0XHQ8L2Rpdj5cblx0XHRcdDxzcGFuICpuZ0lmPVwiaXNSZW5kZXJTdHJpbmcoKVwiIGNsYXNzPVwiY2RzLS1saXN0LWJveF9fbGFiZWxcIj57e2dldERpc3BsYXlTdHJpbmdWYWx1ZSgpIHwgYXN5bmN9fTwvc3Bhbj5cblx0XHRcdDxuZy10ZW1wbGF0ZVxuXHRcdFx0XHQqbmdJZj1cIiFpc1JlbmRlclN0cmluZygpXCJcblx0XHRcdFx0W25nVGVtcGxhdGVPdXRsZXRDb250ZXh0XT1cImdldFJlbmRlclRlbXBsYXRlQ29udGV4dCgpXCJcblx0XHRcdFx0W25nVGVtcGxhdGVPdXRsZXRdPVwiZGlzcGxheVZhbHVlXCI+XG5cdFx0XHQ8L25nLXRlbXBsYXRlPlxuXHRcdFx0PHN2Z1xuXHRcdFx0XHQqbmdJZj1cImludmFsaWRcIlxuXHRcdFx0XHRjbGFzcz1cImNkcy0tZHJvcGRvd25fX2ludmFsaWQtaWNvblwiXG5cdFx0XHRcdGNkc0ljb249XCJ3YXJuaW5nLS1maWxsZWRcIlxuXHRcdFx0XHRzaXplPVwiMTZcIj5cblx0XHRcdDwvc3ZnPlxuXHRcdFx0PHN2Z1xuXHRcdFx0XHQqbmdJZj1cIiFpbnZhbGlkICYmIHdhcm5cIlxuXHRcdFx0XHRjZHNJY29uPVwid2FybmluZy0tYWx0LS1maWxsZWRcIlxuXHRcdFx0XHRzaXplPVwiMTZcIlxuXHRcdFx0XHRjbGFzcz1cImNkcy0tbGlzdC1ib3hfX2ludmFsaWQtaWNvbiBjZHMtLWxpc3QtYm94X19pbnZhbGlkLWljb24tLXdhcm5pbmdcIj5cblx0XHRcdDwvc3ZnPlxuXHRcdFx0PHNwYW4gY2xhc3M9XCJjZHMtLWxpc3QtYm94X19tZW51LWljb25cIj5cblx0XHRcdFx0PHN2Z1xuXHRcdFx0XHRcdCpuZ0lmPVwiIXNrZWxldG9uXCJcblx0XHRcdFx0XHRjZHNJY29uPVwiY2hldnJvbi0tZG93blwiXG5cdFx0XHRcdFx0c2l6ZT1cIjE2XCJcblx0XHRcdFx0XHRbYXR0ci5hcmlhLWxhYmVsXT1cIm1lbnVCdXR0b25MYWJlbFwiXG5cdFx0XHRcdFx0W25nQ2xhc3NdPVwieydjZHMtLWxpc3QtYm94X19tZW51LWljb24tLW9wZW4nOiAhbWVudUlzQ2xvc2VkIH1cIj5cblx0XHRcdFx0PC9zdmc+XG5cdFx0XHQ8L3NwYW4+XG5cdFx0PC9idXR0b24+XG5cdFx0PGRpdlxuXHRcdFx0I2Ryb3Bkb3duTWVudVxuXHRcdFx0W25nQ2xhc3NdPVwie1xuXHRcdFx0XHQnY2RzLS1saXN0LWJveC0tdXAnOiB0aGlzLmRyb3BVcCAhPT0gbnVsbCAmJiB0aGlzLmRyb3BVcCAhPT0gdW5kZWZpbmVkID8gZHJvcFVwIDogX2Ryb3BVcFxuXHRcdFx0fVwiPlxuXHRcdFx0PG5nLWNvbnRlbnQgKm5nSWY9XCIhbWVudUlzQ2xvc2VkXCI+PC9uZy1jb250ZW50PlxuXHRcdDwvZGl2PlxuXHQ8L2Rpdj5cblx0PGRpdlxuXHRcdCpuZ0lmPVwiaGVscGVyVGV4dCAmJiAhaW52YWxpZCAmJiAhd2FybiAmJiAhc2tlbGV0b25cIlxuXHRcdGNsYXNzPVwiY2RzLS1mb3JtX19oZWxwZXItdGV4dFwiXG5cdFx0W25nQ2xhc3NdPVwie1xuXHRcdFx0J2Nkcy0tZm9ybV9faGVscGVyLXRleHQtLWRpc2FibGVkJzogZGlzYWJsZWRcblx0XHR9XCI+XG5cdFx0PG5nLWNvbnRhaW5lciAqbmdJZj1cIiFpc1RlbXBsYXRlKGhlbHBlclRleHQpXCI+e3toZWxwZXJUZXh0fX08L25nLWNvbnRhaW5lcj5cblx0XHQ8bmctdGVtcGxhdGUgKm5nSWY9XCJpc1RlbXBsYXRlKGhlbHBlclRleHQpXCIgW25nVGVtcGxhdGVPdXRsZXRdPVwiaGVscGVyVGV4dFwiPjwvbmctdGVtcGxhdGU+XG5cdDwvZGl2PlxuXHQ8ZGl2ICpuZ0lmPVwiaW52YWxpZFwiIGNsYXNzPVwiY2RzLS1mb3JtLXJlcXVpcmVtZW50XCI+XG5cdFx0PG5nLWNvbnRhaW5lciAqbmdJZj1cIiFpc1RlbXBsYXRlKGludmFsaWRUZXh0KVwiPnt7IGludmFsaWRUZXh0IH19PC9uZy1jb250YWluZXI+XG5cdFx0PG5nLXRlbXBsYXRlICpuZ0lmPVwiaXNUZW1wbGF0ZShpbnZhbGlkVGV4dClcIiBbbmdUZW1wbGF0ZU91dGxldF09XCJpbnZhbGlkVGV4dFwiPjwvbmctdGVtcGxhdGU+XG5cdDwvZGl2PlxuXHQ8ZGl2ICpuZ0lmPVwiIWludmFsaWQgJiYgd2FyblwiIGNsYXNzPVwiY2RzLS1mb3JtLXJlcXVpcmVtZW50XCI+XG5cdFx0PG5nLWNvbnRhaW5lciAqbmdJZj1cIiFpc1RlbXBsYXRlKHdhcm5UZXh0KVwiPnt7d2FyblRleHR9fTwvbmctY29udGFpbmVyPlxuXHRcdDxuZy10ZW1wbGF0ZSAqbmdJZj1cImlzVGVtcGxhdGUod2FyblRleHQpXCIgW25nVGVtcGxhdGVPdXRsZXRdPVwid2FyblRleHRcIj48L25nLXRlbXBsYXRlPlxuXHQ8L2Rpdj5cblx0YCwgaXNJbmxpbmU6IHRydWUsIGRlcGVuZGVuY2llczogW3sga2luZDogXCJkaXJlY3RpdmVcIiwgdHlwZTogaTQuTmdDbGFzcywgc2VsZWN0b3I6IFwiW25nQ2xhc3NdXCIsIGlucHV0czogW1wiY2xhc3NcIiwgXCJuZ0NsYXNzXCJdIH0sIHsga2luZDogXCJkaXJlY3RpdmVcIiwgdHlwZTogaTQuTmdJZiwgc2VsZWN0b3I6IFwiW25nSWZdXCIsIGlucHV0czogW1wibmdJZlwiLCBcIm5nSWZUaGVuXCIsIFwibmdJZkVsc2VcIl0gfSwgeyBraW5kOiBcImRpcmVjdGl2ZVwiLCB0eXBlOiBpNC5OZ1RlbXBsYXRlT3V0bGV0LCBzZWxlY3RvcjogXCJbbmdUZW1wbGF0ZU91dGxldF1cIiwgaW5wdXRzOiBbXCJuZ1RlbXBsYXRlT3V0bGV0Q29udGV4dFwiLCBcIm5nVGVtcGxhdGVPdXRsZXRcIiwgXCJuZ1RlbXBsYXRlT3V0bGV0SW5qZWN0b3JcIl0gfSwgeyBraW5kOiBcImRpcmVjdGl2ZVwiLCB0eXBlOiBpNS5JY29uRGlyZWN0aXZlLCBzZWxlY3RvcjogXCJbY2RzSWNvbl0sIFtpYm1JY29uXVwiLCBpbnB1dHM6IFtcImlibUljb25cIiwgXCJjZHNJY29uXCIsIFwic2l6ZVwiLCBcInRpdGxlXCIsIFwiYXJpYUxhYmVsXCIsIFwiYXJpYUxhYmVsbGVkQnlcIiwgXCJhcmlhSGlkZGVuXCIsIFwiaXNGb2N1c2FibGVcIl0gfSwgeyBraW5kOiBcInBpcGVcIiwgdHlwZTogaTQuQXN5bmNQaXBlLCBuYW1lOiBcImFzeW5jXCIgfV0gfSk7XG5pMC7Jtcm1bmdEZWNsYXJlQ2xhc3NNZXRhZGF0YSh7IG1pblZlcnNpb246IFwiMTIuMC4wXCIsIHZlcnNpb246IFwiMTQuMy4wXCIsIG5nSW1wb3J0OiBpMCwgdHlwZTogRHJvcGRvd24sIGRlY29yYXRvcnM6IFt7XG4gICAgICAgICAgICB0eXBlOiBDb21wb25lbnQsXG4gICAgICAgICAgICBhcmdzOiBbe1xuICAgICAgICAgICAgICAgICAgICBzZWxlY3RvcjogXCJjZHMtZHJvcGRvd24sIGlibS1kcm9wZG93blwiLFxuICAgICAgICAgICAgICAgICAgICB0ZW1wbGF0ZTogYFxuXHQ8bGFiZWxcblx0XHQqbmdJZj1cImxhYmVsICYmICFza2VsZXRvblwiXG5cdFx0W2Zvcl09XCJpZFwiXG5cdFx0Y2xhc3M9XCJjZHMtLWxhYmVsXCJcblx0XHRbbmdDbGFzc109XCJ7XG5cdFx0XHQnY2RzLS1sYWJlbC0tZGlzYWJsZWQnOiBkaXNhYmxlZCxcblx0XHRcdCdjZHMtLXZpc3VhbGx5LWhpZGRlbic6IGhpZGVMYWJlbFxuXHRcdH1cIj5cblx0XHQ8bmctY29udGFpbmVyICpuZ0lmPVwiIWlzVGVtcGxhdGUobGFiZWwpXCI+e3tsYWJlbH19PC9uZy1jb250YWluZXI+XG5cdFx0PG5nLXRlbXBsYXRlICpuZ0lmPVwiaXNUZW1wbGF0ZShsYWJlbClcIiBbbmdUZW1wbGF0ZU91dGxldF09XCJsYWJlbFwiPjwvbmctdGVtcGxhdGU+XG5cdDwvbGFiZWw+XG5cdDxkaXZcblx0XHRjbGFzcz1cImNkcy0tbGlzdC1ib3hcIlxuXHRcdFtuZ0NsYXNzXT1cIntcblx0XHRcdCdjZHMtLWRyb3Bkb3duJzogdHlwZSAhPT0gJ211bHRpJyxcblx0XHRcdCdjZHMtLW11bHRpc2VsZWN0JzogdHlwZSA9PT0gJ211bHRpJyxcblx0XHRcdCdjZHMtLW11bHRpLXNlbGVjdC0tc2VsZWN0ZWQnOiB0eXBlID09PSAnbXVsdGknICYmIGdldFNlbGVjdGVkQ291bnQoKSA+IDAsXG5cdFx0XHQnY2RzLS1kcm9wZG93bi0tbGlnaHQnOiB0aGVtZSA9PT0gJ2xpZ2h0Jyxcblx0XHRcdCdjZHMtLWxpc3QtYm94LS1saWdodCc6IHRoZW1lID09PSAnbGlnaHQnLFxuXHRcdFx0J2Nkcy0tbGlzdC1ib3gtLWlubGluZSc6IGlubGluZSxcblx0XHRcdCdjZHMtLXNrZWxldG9uJzogc2tlbGV0b24sXG5cdFx0XHQnY2RzLS1kcm9wZG93bi0tZGlzYWJsZWQgY2RzLS1saXN0LWJveC0tZGlzYWJsZWQnOiBkaXNhYmxlZCxcblx0XHRcdCdjZHMtLWRyb3Bkb3duLS1pbnZhbGlkJzogaW52YWxpZCxcblx0XHRcdCdjZHMtLWRyb3Bkb3duLS13YXJuaW5nIGNkcy0tbGlzdC1ib3gtLXdhcm5pbmcnOiB3YXJuLFxuXHRcdFx0J2Nkcy0tZHJvcGRvd24tLXNtIGNkcy0tbGlzdC1ib3gtLXNtJzogc2l6ZSA9PT0gJ3NtJyxcblx0XHRcdCdjZHMtLWRyb3Bkb3duLS1tZCBjZHMtLWxpc3QtYm94LS1tZCc6IHNpemUgPT09ICdtZCcsXG5cdFx0XHQnY2RzLS1kcm9wZG93bi0tbGcgY2RzLS1saXN0LWJveC0tbGcnOiBzaXplID09PSAnbGcnLFxuXHRcdFx0J2Nkcy0tbGlzdC1ib3gtLWV4cGFuZGVkJzogIW1lbnVJc0Nsb3NlZFxuXHRcdH1cIj5cblx0XHQ8YnV0dG9uXG5cdFx0XHQjZHJvcGRvd25CdXR0b25cblx0XHRcdFtpZF09XCJpZFwiXG5cdFx0XHR0eXBlPVwiYnV0dG9uXCJcblx0XHRcdGNsYXNzPVwiY2RzLS1saXN0LWJveF9fZmllbGRcIlxuXHRcdFx0W25nQ2xhc3NdPVwieydhJzogIW1lbnVJc0Nsb3NlZH1cIlxuXHRcdFx0W2F0dHIuYXJpYS1leHBhbmRlZF09XCIhbWVudUlzQ2xvc2VkXCJcblx0XHRcdFthdHRyLmFyaWEtZGlzYWJsZWRdPVwiZGlzYWJsZWRcIlxuXHRcdFx0YXJpYS1oYXNwb3B1cD1cImxpc3Rib3hcIlxuXHRcdFx0KGNsaWNrKT1cImRpc2FibGVkID8gJGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpIDogdG9nZ2xlTWVudSgpXCJcblx0XHRcdChibHVyKT1cIm9uQmx1cigpXCJcblx0XHRcdFthdHRyLmRpc2FibGVkXT1cImRpc2FibGVkID8gdHJ1ZSA6IG51bGxcIj5cblx0XHRcdDxkaXZcblx0XHRcdFx0KGNsaWNrKT1cImNsZWFyU2VsZWN0ZWQoKVwiXG5cdFx0XHRcdChrZXlkb3duLmVudGVyKT1cImNsZWFyU2VsZWN0ZWQoKVwiXG5cdFx0XHRcdCpuZ0lmPVwidHlwZSA9PT0gJ211bHRpJyAmJiBnZXRTZWxlY3RlZENvdW50KCkgPiAwXCJcblx0XHRcdFx0Y2xhc3M9XCJjZHMtLWxpc3QtYm94X19zZWxlY3Rpb24gY2RzLS10YWctLWZpbHRlciBjZHMtLWxpc3QtYm94X19zZWxlY3Rpb24tLW11bHRpXCJcblx0XHRcdFx0dGFiaW5kZXg9XCIwXCJcblx0XHRcdFx0W3RpdGxlXT1cImNsZWFyVGV4dFwiPlxuXHRcdFx0XHR7e2dldFNlbGVjdGVkQ291bnQoKX19XG5cdFx0XHRcdDxzdmdcblx0XHRcdFx0XHRmb2N1c2FibGU9XCJmYWxzZVwiXG5cdFx0XHRcdFx0cHJlc2VydmVBc3BlY3RSYXRpbz1cInhNaWRZTWlkIG1lZXRcIlxuXHRcdFx0XHRcdHN0eWxlPVwid2lsbC1jaGFuZ2U6IHRyYW5zZm9ybTtcIlxuXHRcdFx0XHRcdHJvbGU9XCJpbWdcIlxuXHRcdFx0XHRcdHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIlxuXHRcdFx0XHRcdHdpZHRoPVwiMTZcIlxuXHRcdFx0XHRcdGhlaWdodD1cIjE2XCJcblx0XHRcdFx0XHR2aWV3Qm94PVwiMCAwIDE2IDE2XCJcblx0XHRcdFx0XHRhcmlhLWhpZGRlbj1cInRydWVcIj5cblx0XHRcdFx0XHQ8cGF0aCBkPVwiTTEyIDQuN2wtLjctLjdMOCA3LjMgNC43IDRsLS43LjdMNy4zIDggNCAxMS4zbC43LjdMOCA4LjdsMy4zIDMuMy43LS43TDguNyA4elwiPjwvcGF0aD5cblx0XHRcdFx0PC9zdmc+XG5cdFx0XHQ8L2Rpdj5cblx0XHRcdDxzcGFuICpuZ0lmPVwiaXNSZW5kZXJTdHJpbmcoKVwiIGNsYXNzPVwiY2RzLS1saXN0LWJveF9fbGFiZWxcIj57e2dldERpc3BsYXlTdHJpbmdWYWx1ZSgpIHwgYXN5bmN9fTwvc3Bhbj5cblx0XHRcdDxuZy10ZW1wbGF0ZVxuXHRcdFx0XHQqbmdJZj1cIiFpc1JlbmRlclN0cmluZygpXCJcblx0XHRcdFx0W25nVGVtcGxhdGVPdXRsZXRDb250ZXh0XT1cImdldFJlbmRlclRlbXBsYXRlQ29udGV4dCgpXCJcblx0XHRcdFx0W25nVGVtcGxhdGVPdXRsZXRdPVwiZGlzcGxheVZhbHVlXCI+XG5cdFx0XHQ8L25nLXRlbXBsYXRlPlxuXHRcdFx0PHN2Z1xuXHRcdFx0XHQqbmdJZj1cImludmFsaWRcIlxuXHRcdFx0XHRjbGFzcz1cImNkcy0tZHJvcGRvd25fX2ludmFsaWQtaWNvblwiXG5cdFx0XHRcdGNkc0ljb249XCJ3YXJuaW5nLS1maWxsZWRcIlxuXHRcdFx0XHRzaXplPVwiMTZcIj5cblx0XHRcdDwvc3ZnPlxuXHRcdFx0PHN2Z1xuXHRcdFx0XHQqbmdJZj1cIiFpbnZhbGlkICYmIHdhcm5cIlxuXHRcdFx0XHRjZHNJY29uPVwid2FybmluZy0tYWx0LS1maWxsZWRcIlxuXHRcdFx0XHRzaXplPVwiMTZcIlxuXHRcdFx0XHRjbGFzcz1cImNkcy0tbGlzdC1ib3hfX2ludmFsaWQtaWNvbiBjZHMtLWxpc3QtYm94X19pbnZhbGlkLWljb24tLXdhcm5pbmdcIj5cblx0XHRcdDwvc3ZnPlxuXHRcdFx0PHNwYW4gY2xhc3M9XCJjZHMtLWxpc3QtYm94X19tZW51LWljb25cIj5cblx0XHRcdFx0PHN2Z1xuXHRcdFx0XHRcdCpuZ0lmPVwiIXNrZWxldG9uXCJcblx0XHRcdFx0XHRjZHNJY29uPVwiY2hldnJvbi0tZG93blwiXG5cdFx0XHRcdFx0c2l6ZT1cIjE2XCJcblx0XHRcdFx0XHRbYXR0ci5hcmlhLWxhYmVsXT1cIm1lbnVCdXR0b25MYWJlbFwiXG5cdFx0XHRcdFx0W25nQ2xhc3NdPVwieydjZHMtLWxpc3QtYm94X19tZW51LWljb24tLW9wZW4nOiAhbWVudUlzQ2xvc2VkIH1cIj5cblx0XHRcdFx0PC9zdmc+XG5cdFx0XHQ8L3NwYW4+XG5cdFx0PC9idXR0b24+XG5cdFx0PGRpdlxuXHRcdFx0I2Ryb3Bkb3duTWVudVxuXHRcdFx0W25nQ2xhc3NdPVwie1xuXHRcdFx0XHQnY2RzLS1saXN0LWJveC0tdXAnOiB0aGlzLmRyb3BVcCAhPT0gbnVsbCAmJiB0aGlzLmRyb3BVcCAhPT0gdW5kZWZpbmVkID8gZHJvcFVwIDogX2Ryb3BVcFxuXHRcdFx0fVwiPlxuXHRcdFx0PG5nLWNvbnRlbnQgKm5nSWY9XCIhbWVudUlzQ2xvc2VkXCI+PC9uZy1jb250ZW50PlxuXHRcdDwvZGl2PlxuXHQ8L2Rpdj5cblx0PGRpdlxuXHRcdCpuZ0lmPVwiaGVscGVyVGV4dCAmJiAhaW52YWxpZCAmJiAhd2FybiAmJiAhc2tlbGV0b25cIlxuXHRcdGNsYXNzPVwiY2RzLS1mb3JtX19oZWxwZXItdGV4dFwiXG5cdFx0W25nQ2xhc3NdPVwie1xuXHRcdFx0J2Nkcy0tZm9ybV9faGVscGVyLXRleHQtLWRpc2FibGVkJzogZGlzYWJsZWRcblx0XHR9XCI+XG5cdFx0PG5nLWNvbnRhaW5lciAqbmdJZj1cIiFpc1RlbXBsYXRlKGhlbHBlclRleHQpXCI+e3toZWxwZXJUZXh0fX08L25nLWNvbnRhaW5lcj5cblx0XHQ8bmctdGVtcGxhdGUgKm5nSWY9XCJpc1RlbXBsYXRlKGhlbHBlclRleHQpXCIgW25nVGVtcGxhdGVPdXRsZXRdPVwiaGVscGVyVGV4dFwiPjwvbmctdGVtcGxhdGU+XG5cdDwvZGl2PlxuXHQ8ZGl2ICpuZ0lmPVwiaW52YWxpZFwiIGNsYXNzPVwiY2RzLS1mb3JtLXJlcXVpcmVtZW50XCI+XG5cdFx0PG5nLWNvbnRhaW5lciAqbmdJZj1cIiFpc1RlbXBsYXRlKGludmFsaWRUZXh0KVwiPnt7IGludmFsaWRUZXh0IH19PC9uZy1jb250YWluZXI+XG5cdFx0PG5nLXRlbXBsYXRlICpuZ0lmPVwiaXNUZW1wbGF0ZShpbnZhbGlkVGV4dClcIiBbbmdUZW1wbGF0ZU91dGxldF09XCJpbnZhbGlkVGV4dFwiPjwvbmctdGVtcGxhdGU+XG5cdDwvZGl2PlxuXHQ8ZGl2ICpuZ0lmPVwiIWludmFsaWQgJiYgd2FyblwiIGNsYXNzPVwiY2RzLS1mb3JtLXJlcXVpcmVtZW50XCI+XG5cdFx0PG5nLWNvbnRhaW5lciAqbmdJZj1cIiFpc1RlbXBsYXRlKHdhcm5UZXh0KVwiPnt7d2FyblRleHR9fTwvbmctY29udGFpbmVyPlxuXHRcdDxuZy10ZW1wbGF0ZSAqbmdJZj1cImlzVGVtcGxhdGUod2FyblRleHQpXCIgW25nVGVtcGxhdGVPdXRsZXRdPVwid2FyblRleHRcIj48L25nLXRlbXBsYXRlPlxuXHQ8L2Rpdj5cblx0YCxcbiAgICAgICAgICAgICAgICAgICAgcHJvdmlkZXJzOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvdmlkZTogTkdfVkFMVUVfQUNDRVNTT1IsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdXNlRXhpc3Rpbmc6IERyb3Bkb3duLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG11bHRpOiB0cnVlXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICB9XVxuICAgICAgICB9XSwgY3RvclBhcmFtZXRlcnM6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFt7IHR5cGU6IGkwLkVsZW1lbnRSZWYgfSwgeyB0eXBlOiBpMSQxLkkxOG4gfSwgeyB0eXBlOiBEcm9wZG93blNlcnZpY2UgfSwgeyB0eXBlOiBpMi5FbGVtZW50U2VydmljZSB9XTsgfSwgcHJvcERlY29yYXRvcnM6IHsgaWQ6IFt7XG4gICAgICAgICAgICAgICAgdHlwZTogSW5wdXRcbiAgICAgICAgICAgIH1dLCBsYWJlbDogW3tcbiAgICAgICAgICAgICAgICB0eXBlOiBJbnB1dFxuICAgICAgICAgICAgfV0sIGhpZGVMYWJlbDogW3tcbiAgICAgICAgICAgICAgICB0eXBlOiBJbnB1dFxuICAgICAgICAgICAgfV0sIGhlbHBlclRleHQ6IFt7XG4gICAgICAgICAgICAgICAgdHlwZTogSW5wdXRcbiAgICAgICAgICAgIH1dLCBwbGFjZWhvbGRlcjogW3tcbiAgICAgICAgICAgICAgICB0eXBlOiBJbnB1dFxuICAgICAgICAgICAgfV0sIGRpc3BsYXlWYWx1ZTogW3tcbiAgICAgICAgICAgICAgICB0eXBlOiBJbnB1dFxuICAgICAgICAgICAgfV0sIGNsZWFyVGV4dDogW3tcbiAgICAgICAgICAgICAgICB0eXBlOiBJbnB1dFxuICAgICAgICAgICAgfV0sIHNpemU6IFt7XG4gICAgICAgICAgICAgICAgdHlwZTogSW5wdXRcbiAgICAgICAgICAgIH1dLCB0eXBlOiBbe1xuICAgICAgICAgICAgICAgIHR5cGU6IElucHV0XG4gICAgICAgICAgICB9XSwgdGhlbWU6IFt7XG4gICAgICAgICAgICAgICAgdHlwZTogSW5wdXRcbiAgICAgICAgICAgIH1dLCBkaXNhYmxlZDogW3tcbiAgICAgICAgICAgICAgICB0eXBlOiBJbnB1dFxuICAgICAgICAgICAgfV0sIHNrZWxldG9uOiBbe1xuICAgICAgICAgICAgICAgIHR5cGU6IElucHV0XG4gICAgICAgICAgICB9XSwgaW5saW5lOiBbe1xuICAgICAgICAgICAgICAgIHR5cGU6IElucHV0XG4gICAgICAgICAgICB9XSwgZGlzYWJsZUFycm93S2V5czogW3tcbiAgICAgICAgICAgICAgICB0eXBlOiBJbnB1dFxuICAgICAgICAgICAgfV0sIGludmFsaWQ6IFt7XG4gICAgICAgICAgICAgICAgdHlwZTogSW5wdXRcbiAgICAgICAgICAgIH1dLCBpbnZhbGlkVGV4dDogW3tcbiAgICAgICAgICAgICAgICB0eXBlOiBJbnB1dFxuICAgICAgICAgICAgfV0sIHdhcm46IFt7XG4gICAgICAgICAgICAgICAgdHlwZTogSW5wdXRcbiAgICAgICAgICAgIH1dLCB3YXJuVGV4dDogW3tcbiAgICAgICAgICAgICAgICB0eXBlOiBJbnB1dFxuICAgICAgICAgICAgfV0sIGFwcGVuZElubGluZTogW3tcbiAgICAgICAgICAgICAgICB0eXBlOiBJbnB1dFxuICAgICAgICAgICAgfV0sIHNjcm9sbGFibGVDb250YWluZXI6IFt7XG4gICAgICAgICAgICAgICAgdHlwZTogSW5wdXRcbiAgICAgICAgICAgIH1dLCBpdGVtVmFsdWVLZXk6IFt7XG4gICAgICAgICAgICAgICAgdHlwZTogSW5wdXRcbiAgICAgICAgICAgIH1dLCBzZWxlY3Rpb25GZWVkYmFjazogW3tcbiAgICAgICAgICAgICAgICB0eXBlOiBJbnB1dFxuICAgICAgICAgICAgfV0sIG1lbnVCdXR0b25MYWJlbDogW3tcbiAgICAgICAgICAgICAgICB0eXBlOiBJbnB1dFxuICAgICAgICAgICAgfV0sIHNlbGVjdGVkTGFiZWw6IFt7XG4gICAgICAgICAgICAgICAgdHlwZTogSW5wdXRcbiAgICAgICAgICAgIH1dLCBkcm9wVXA6IFt7XG4gICAgICAgICAgICAgICAgdHlwZTogSW5wdXRcbiAgICAgICAgICAgIH1dLCBzZWxlY3RlZDogW3tcbiAgICAgICAgICAgICAgICB0eXBlOiBPdXRwdXRcbiAgICAgICAgICAgIH1dLCBvbkNsb3NlOiBbe1xuICAgICAgICAgICAgICAgIHR5cGU6IE91dHB1dFxuICAgICAgICAgICAgfV0sIGNsb3NlOiBbe1xuICAgICAgICAgICAgICAgIHR5cGU6IE91dHB1dFxuICAgICAgICAgICAgfV0sIHZpZXc6IFt7XG4gICAgICAgICAgICAgICAgdHlwZTogQ29udGVudENoaWxkLFxuICAgICAgICAgICAgICAgIGFyZ3M6IFtBYnN0cmFjdERyb3Bkb3duVmlldywgeyBzdGF0aWM6IHRydWUgfV1cbiAgICAgICAgICAgIH1dLCBkcm9wZG93bkJ1dHRvbjogW3tcbiAgICAgICAgICAgICAgICB0eXBlOiBWaWV3Q2hpbGQsXG4gICAgICAgICAgICAgICAgYXJnczogW1wiZHJvcGRvd25CdXR0b25cIiwgeyBzdGF0aWM6IHRydWUgfV1cbiAgICAgICAgICAgIH1dLCBkcm9wZG93bk1lbnU6IFt7XG4gICAgICAgICAgICAgICAgdHlwZTogVmlld0NoaWxkLFxuICAgICAgICAgICAgICAgIGFyZ3M6IFtcImRyb3Bkb3duTWVudVwiLCB7IHN0YXRpYzogdHJ1ZSB9XVxuICAgICAgICAgICAgfV0sIGhvc3RDbGFzczogW3tcbiAgICAgICAgICAgICAgICB0eXBlOiBIb3N0QmluZGluZyxcbiAgICAgICAgICAgICAgICBhcmdzOiBbXCJjbGFzcy5jZHMtLWRyb3Bkb3duX193cmFwcGVyXCJdXG4gICAgICAgICAgICB9XSwgb25LZXlEb3duOiBbe1xuICAgICAgICAgICAgICAgIHR5cGU6IEhvc3RMaXN0ZW5lcixcbiAgICAgICAgICAgICAgICBhcmdzOiBbXCJrZXlkb3duXCIsIFtcIiRldmVudFwiXV1cbiAgICAgICAgICAgIH1dIH0gfSk7XG5cbi8qKlxuICogcmV0dXJucyBhbiBvYnNlcnZhYmxlIGJvdW5kIHRvIGtleWRvd24gZXZlbnRzIHRoYXRcbiAqIGZpbHRlcnMgdG8gYSBzaW5nbGUgZWxlbWVudCB3aGVyZSB0aGUgZmlyc3QgbGV0dGVyIG9mXG4gKiBpdCdzIHRleHRDb250ZW50IG1hdGNoZXMgdGhlIGtleSBwcmVzc2VkXG4gKlxuICogQHBhcmFtIHRhcmdldCBlbGVtZW50IHRvIHdhdGNoXG4gKiBAcGFyYW0gZWxlbWVudHMgZWxlbWVudHMgdG8gc2VhcmNoXG4gKi9cbmZ1bmN0aW9uIHdhdGNoRm9jdXNKdW1wKHRhcmdldCwgZWxlbWVudHMpIHtcbiAgICByZXR1cm4gZnJvbUV2ZW50KHRhcmdldCwgXCJrZXlkb3duXCIpXG4gICAgICAgIC5waXBlKGRlYm91bmNlVGltZSgxNTApLCBtYXAoKGV2KSA9PiB7XG4gICAgICAgIGxldCBlbCA9IGVsZW1lbnRzLmZpbmQoKGl0ZW1FbCkgPT4gaXRlbUVsLnRleHRDb250ZW50LnRyaW0oKS50b0xvd2VyQ2FzZSgpLnN0YXJ0c1dpdGgoZXYua2V5KSk7XG4gICAgICAgIGlmIChlbCkge1xuICAgICAgICAgICAgcmV0dXJuIGVsO1xuICAgICAgICB9XG4gICAgfSksIGZpbHRlcihlbCA9PiAhIWVsKSk7XG59XG4vKiogYnVuZGxlIG9mIGZ1bmN0aW9ucyB0byBhaWQgaW4gbWFuaXB1bGF0aW5nIHRyZWUgc3RydWN0dXJlcyAqL1xuY29uc3QgdHJlZXRvb2xzID0ge1xuICAgIC8qKiBmaW5kcyBhbiBpdGVtIGluIGEgc2V0IG9mIGl0ZW1zIGFuZCByZXR1cm5zIHRoZSBpdGVtIGFuZCBwYXRoIHRvIHRoZSBpdGVtIGFzIGFuIGFycmF5ICovXG4gICAgZmluZDogZnVuY3Rpb24gKGl0ZW1zLCBpdGVtVG9GaW5kLCBwYXRoID0gW10pIHtcbiAgICAgICAgbGV0IGZvdW5kO1xuICAgICAgICBmb3IgKGxldCBpIG9mIGl0ZW1zKSB7XG4gICAgICAgICAgICBpZiAoaSA9PT0gaXRlbVRvRmluZCkge1xuICAgICAgICAgICAgICAgIHBhdGgucHVzaChpKTtcbiAgICAgICAgICAgICAgICBmb3VuZCA9IGk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaS5pdGVtcyAmJiAhZm91bmQpIHtcbiAgICAgICAgICAgICAgICBwYXRoLnB1c2goaSk7XG4gICAgICAgICAgICAgICAgZm91bmQgPSB0aGlzLmZpbmQoaS5pdGVtcywgaXRlbVRvRmluZCwgcGF0aCkuZm91bmQ7XG4gICAgICAgICAgICAgICAgaWYgKCFmb3VuZCkge1xuICAgICAgICAgICAgICAgICAgICBwYXRoID0gW107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IGZvdW5kLCBwYXRoIH07XG4gICAgfVxufTtcblxuLyoqXG4gKiBgYGBodG1sXG4gKiA8Y2RzLWRyb3Bkb3duLWxpc3QgW2l0ZW1zXT1cImxpc3RJdGVtc1wiPjwvY2RzLWRyb3Bkb3duLWxpc3Q+XG4gKiBgYGBcbiAqIGBgYHR5cGVzY3JpcHRcbiAqIGxpc3RJdGVtcyA9IFtcbiAqIFx0e1xuICogXHRcdGNvbnRlbnQ6IFwiaXRlbSBvbmVcIixcbiAqIFx0XHRzZWxlY3RlZDogZmFsc2VcbiAqIFx0fSxcbiAqIFx0e1xuICogXHRcdGNvbnRlbnQ6IFwiaXRlbSB0d29cIixcbiAqIFx0XHRzZWxlY3RlZDogZmFsc2UsXG4gKiBcdH0sXG4gKiBcdHtcbiAqIFx0XHRjb250ZW50OiBcIml0ZW0gdGhyZWVcIixcbiAqIFx0XHRzZWxlY3RlZDogZmFsc2VcbiAqIFx0fSxcbiAqIFx0e1xuICogXHRcdGNvbnRlbnQ6IFwiaXRlbSBmb3VyXCIsXG4gKiBcdFx0c2VsZWN0ZWQ6IGZhbHNlXG4gKiBcdH1cbiAqIF07XG4gKiBgYGBcbiAqL1xuY2xhc3MgRHJvcGRvd25MaXN0IHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIGBEcm9wZG93bkxpc3RgLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGVsZW1lbnRSZWYsIGkxOG4sIGFwcFJlZikge1xuICAgICAgICB0aGlzLmVsZW1lbnRSZWYgPSBlbGVtZW50UmVmO1xuICAgICAgICB0aGlzLmkxOG4gPSBpMThuO1xuICAgICAgICB0aGlzLmFwcFJlZiA9IGFwcFJlZjtcbiAgICAgICAgdGhpcy5hcmlhTGFiZWwgPSB0aGlzLmkxOG4uZ2V0KCkuRFJPUERPV05fTElTVC5MQUJFTDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRlbXBsYXRlIHRvIGJpbmQgdG8gaXRlbXMgaW4gdGhlIGBEcm9wZG93bkxpc3RgIChvcHRpb25hbCkuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmxpc3RUcGwgPSBudWxsO1xuICAgICAgICAvKipcbiAgICAgICAgICogRXZlbnQgdG8gZW1pdCBzZWxlY3Rpb24gb2YgYSBsaXN0IGl0ZW0gd2l0aGluIHRoZSBgRHJvcGRvd25MaXN0YC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc2VsZWN0ID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICAvKipcbiAgICAgICAgICogRXZlbnQgdG8gZW1pdCBzY3JvbGwgZXZlbnQgb2YgYSBsaXN0IHdpdGhpbiB0aGUgYERyb3Bkb3duTGlzdGAuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnNjcm9sbCA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEV2ZW50IHRvIHN1Z2dlc3QgYSBibHVyIG9uIHRoZSB2aWV3LlxuICAgICAgICAgKiBFbWl0cyBfYWZ0ZXJfIHRoZSBmaXJzdC9sYXN0IGl0ZW0gaGFzIGJlZW4gZm9jdXNlZC5cbiAgICAgICAgICogZXguXG4gICAgICAgICAqIEFycm93VXAgLT4gZm9jdXMgZmlyc3QgaXRlbVxuICAgICAgICAgKiBBcnJvd1VwIC0+IGVtaXQgZXZlbnRcbiAgICAgICAgICpcbiAgICAgICAgICogV2hlbiB0aGlzIGV2ZW50IGZpcmVzIGZvY3VzIHNob3VsZCBiZSBwbGFjZWQgb24gc29tZSBlbGVtZW50IG91dHNpZGUgb2YgdGhlIGxpc3QgLSBibHVycmluZyB0aGUgbGlzdCBhcyBhIHJlc3VsdFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5ibHVySW50ZW50ID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICAvKipcbiAgICAgICAgICogRGVmaW5lcyB3aGV0aGVyIG9yIG5vdCB0aGUgYERyb3Bkb3duTGlzdGAgc3VwcG9ydHMgc2VsZWN0aW5nIG11bHRpcGxlIGl0ZW1zIGFzIG9wcG9zZWQgdG8gc2luZ2xlXG4gICAgICAgICAqIGl0ZW0gc2VsZWN0aW9uLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy50eXBlID0gXCJzaW5nbGVcIjtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIERlZmluZXMgd2hldGhlciB0byBzaG93IHRpdGxlIGF0dHJpYnV0ZSBvciBub3RcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc2hvd1RpdGxlcyA9IHRydWU7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZWZpbmVzIHRoZSByZW5kZXJpbmcgc2l6ZSBvZiB0aGUgYERyb3Bkb3duTGlzdGAgaW5wdXQgY29tcG9uZW50LlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zaXplID0gXCJtZFwiO1xuICAgICAgICB0aGlzLmxpc3RJZCA9IGBsaXN0Ym94LSR7RHJvcGRvd25MaXN0Lmxpc3RDb3VudCsrfWA7XG4gICAgICAgIHRoaXMuaGlnaGxpZ2h0ZWRJdGVtID0gbnVsbDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEhvbGRzIHRoZSBsaXN0IG9mIGl0ZW1zIHRoYXQgd2lsbCBiZSBkaXNwbGF5ZWQgaW4gdGhlIGBEcm9wZG93bkxpc3RgLlxuICAgICAgICAgKiBJdCBkaWZmZXJzIGZyb20gdGhlIHRoZSBjb21wbGV0ZSBzZXQgb2YgaXRlbXMgd2hlbiBmaWx0ZXJpbmcgaXMgdXNlZCAoYnV0XG4gICAgICAgICAqIGl0IGlzIGFsd2F5cyBhIHN1YnNldCBvZiB0aGUgdG90YWwgaXRlbXMgaW4gYERyb3Bkb3duTGlzdGApLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5kaXNwbGF5SXRlbXMgPSBbXTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE1haW50YWlucyB0aGUgaW5kZXggZm9yIHRoZSBzZWxlY3RlZCBpdGVtIHdpdGhpbiB0aGUgYERyb3Bkb3duTGlzdGAuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmluZGV4ID0gLTE7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBVc2VmdWwgcmVwcmVzZW50YXRpb24gb2YgdGhlIGl0ZW1zLCBzaG91bGQgYmUgYWNjZXNzZWQgdmlhIGBnZXRMaXN0SXRlbXNgLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5faXRlbXMgPSBbXTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIGxpc3QgaXRlbXMgYmVsb25naW5nIHRvIHRoZSBgRHJvcGRvd25MaXN0YC5cbiAgICAgKi9cbiAgICBzZXQgaXRlbXModmFsdWUpIHtcbiAgICAgICAgaWYgKGlzT2JzZXJ2YWJsZSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9pdGVtc1N1YnNjcmlwdGlvbikge1xuICAgICAgICAgICAgICAgIHRoaXMuX2l0ZW1zU3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9pdGVtc1JlYWR5ID0gbmV3IE9ic2VydmFibGUoKG9ic2VydmVyKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5faXRlbXNTdWJzY3JpcHRpb24gPSB2YWx1ZS5zdWJzY3JpYmUodiA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlTGlzdCh2KTtcbiAgICAgICAgICAgICAgICAgICAgb2JzZXJ2ZXIubmV4dCh0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgb2JzZXJ2ZXIuY29tcGxldGUoKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5vbkl0ZW1zUmVhZHkobnVsbCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUxpc3QodmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX29yaWdpbmFsSXRlbXMgPSB2YWx1ZTtcbiAgICB9XG4gICAgZ2V0IGl0ZW1zKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fb3JpZ2luYWxJdGVtcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIGFycmF5IG9mIGxpc3QgaXRlbXMgYW5kIGluZGV4IG9mIHRoZSBzZWxlY3RlZCBpdGVtIGFmdGVyIHZpZXcgaGFzIHJlbmRlcmVkLlxuICAgICAqIEFkZGl0aW9uYWxseSwgYW55IE9ic2VydmFibGVzIGZvciB0aGUgYERyb3Bkb3duTGlzdGAgYXJlIGluaXRpYWxpemVkLlxuICAgICAqL1xuICAgIG5nQWZ0ZXJWaWV3SW5pdCgpIHtcbiAgICAgICAgdGhpcy5pbmRleCA9IHRoaXMuZ2V0TGlzdEl0ZW1zKCkuZmluZEluZGV4KGl0ZW0gPT4gaXRlbS5zZWxlY3RlZCk7XG4gICAgICAgIHRoaXMuc2V0dXBGb2N1c09ic2VydmFibGUoKTtcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmRvRW1pdFNlbGVjdCh0cnVlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYW55IE9ic2VydmFibGVzIG9uIGRlc3RydWN0aW9uIG9mIHRoZSBjb21wb25lbnQuXG4gICAgICovXG4gICAgbmdPbkRlc3Ryb3koKSB7XG4gICAgICAgIGlmICh0aGlzLmZvY3VzSnVtcCkge1xuICAgICAgICAgICAgdGhpcy5mb2N1c0p1bXAudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5faXRlbXNTdWJzY3JpcHRpb24pIHtcbiAgICAgICAgICAgIHRoaXMuX2l0ZW1zU3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZG9FbWl0U2VsZWN0KGlzVXBkYXRlID0gdHJ1ZSkge1xuICAgICAgICBpZiAodGhpcy50eXBlID09PSBcInNpbmdsZVwiKSB7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdC5lbWl0KHsgaXRlbTogdGhpcy5faXRlbXMuZmluZChpdGVtID0+IGl0ZW0uc2VsZWN0ZWQpLCBpc1VwZGF0ZTogaXNVcGRhdGUgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBhYnVzZSBqYXZhc2NyaXB0cyBvYmplY3QgbXV0YWJpbGl0eSB1bnRpbCB3ZSBjYW4gYnJlYWsgdGhlIEFQSSBhbmQgc3dpdGNoIHRvXG4gICAgICAgICAgICAvLyB7IGl0ZW1zOiBbXSwgaXNVcGRhdGU6IHRydWUgfVxuICAgICAgICAgICAgY29uc3Qgc2VsZWN0ZWQgPSB0aGlzLmdldFNlbGVjdGVkKCkgfHwgW107XG4gICAgICAgICAgICBzZWxlY3RlZFtcImlzVXBkYXRlXCJdID0gaXNVcGRhdGU7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdC5lbWl0KHNlbGVjdGVkKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXRJdGVtSWQoaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIGAke3RoaXMubGlzdElkfS0ke2luZGV4fWA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgdGhlIGRpc3BsYXllZCBsaXN0IG9mIGl0ZW1zIGFuZCB0aGVuIHJldHJpZXZlcyB0aGUgbW9zdCBjdXJyZW50IHByb3BlcnRpZXMgZm9yIHRoZSBgRHJvcGRvd25MaXN0YCBmcm9tIHRoZSBET00uXG4gICAgICovXG4gICAgdXBkYXRlTGlzdChpdGVtcykge1xuICAgICAgICB0aGlzLl9pdGVtcyA9IGl0ZW1zLm1hcChpdGVtID0+IE9iamVjdC5hc3NpZ24oe30sIGl0ZW0pKTtcbiAgICAgICAgdGhpcy5kaXNwbGF5SXRlbXMgPSB0aGlzLl9pdGVtcztcbiAgICAgICAgdGhpcy51cGRhdGVJbmRleCgpO1xuICAgICAgICB0aGlzLnNldHVwRm9jdXNPYnNlcnZhYmxlKCk7XG4gICAgICAgIHRoaXMuZG9FbWl0U2VsZWN0KCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZpbHRlcnMgdGhlIGl0ZW1zIGJlaW5nIGRpc3BsYXllZCBpbiB0aGUgRE9NIGxpc3QuXG4gICAgICovXG4gICAgZmlsdGVyQnkocXVlcnkgPSBcIlwiKSB7XG4gICAgICAgIGlmIChxdWVyeSkge1xuICAgICAgICAgICAgdGhpcy5kaXNwbGF5SXRlbXMgPSB0aGlzLmdldExpc3RJdGVtcygpLmZpbHRlcihpdGVtID0+IGl0ZW0uY29udGVudC50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKHF1ZXJ5LnRvTG93ZXJDYXNlKCkpKTtcbiAgICAgICAgICAgIC8vIFJlc2V0IGluZGV4IGlmIGl0ZW1zIHdlcmUgZm91bmRcbiAgICAgICAgICAgIC8vIFByZXZlbnQgc2VsZWN0aW5nIGluZGV4IGluIGxpc3QgdGhhdCBhcmUgdW5kZWZpbmVkLlxuICAgICAgICAgICAgaWYgKHRoaXMuZGlzcGxheUl0ZW1zKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pbmRleCA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmRpc3BsYXlJdGVtcyA9IHRoaXMuZ2V0TGlzdEl0ZW1zKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy51cGRhdGVJbmRleCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplcyAob3IgcmUtaW5pdGlhbGl6ZXMpIHRoZSBPYnNlcnZhYmxlIHRoYXQgaGFuZGxlcyBzd2l0Y2hpbmcgZm9jdXMgdG8gYW4gZWxlbWVudCBiYXNlZCBvblxuICAgICAqIGtleSBpbnB1dCBtYXRjaGluZyB0aGUgZmlyc3QgbGV0dGVyIG9mIHRoZSBpdGVtIGluIHRoZSBsaXN0LlxuICAgICAqL1xuICAgIHNldHVwRm9jdXNPYnNlcnZhYmxlKCkge1xuICAgICAgICBpZiAoIXRoaXMubGlzdCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmZvY3VzSnVtcCkge1xuICAgICAgICAgICAgdGhpcy5mb2N1c0p1bXAudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgZWxMaXN0ID0gQXJyYXkuZnJvbSh0aGlzLmxpc3QubmF0aXZlRWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsKFwibGlcIikpO1xuICAgICAgICB0aGlzLmZvY3VzSnVtcCA9IHdhdGNoRm9jdXNKdW1wKHRoaXMubGlzdC5uYXRpdmVFbGVtZW50LCBlbExpc3QpXG4gICAgICAgICAgICAuc3Vic2NyaWJlKGVsID0+IHtcbiAgICAgICAgICAgIGVsLmZvY3VzKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBgTGlzdEl0ZW1gIHRoYXQgaXMgc3Vic2VxdWVudCB0byB0aGUgc2VsZWN0ZWQgaXRlbSBpbiB0aGUgYERyb3Bkb3duTGlzdGAuXG4gICAgICovXG4gICAgZ2V0TmV4dEl0ZW0oKSB7XG4gICAgICAgIGlmICh0aGlzLmluZGV4IDwgdGhpcy5kaXNwbGF5SXRlbXMubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgdGhpcy5pbmRleCsrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmRpc3BsYXlJdGVtc1t0aGlzLmluZGV4XTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHNlbGVjdGVkIGl0ZW0gaXMgbm90IHRoZSBsYXN0IGl0ZW0gaW4gdGhlIGBEcm9wZG93bkxpc3RgLlxuICAgICAqL1xuICAgIGhhc05leHRFbGVtZW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pbmRleCA8IHRoaXMuZGlzcGxheUl0ZW1zLmxlbmd0aCAtIDEgJiZcbiAgICAgICAgICAgICghKHRoaXMuaW5kZXggPT09IHRoaXMuZGlzcGxheUl0ZW1zLmxlbmd0aCAtIDIpIHx8ICF0aGlzLmRpc3BsYXlJdGVtc1t0aGlzLmluZGV4ICsgMV0uZGlzYWJsZWQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBgSFRNTEVsZW1lbnRgIGZvciB0aGUgaXRlbSB0aGF0IGlzIHN1YnNlcXVlbnQgdG8gdGhlIHNlbGVjdGVkIGl0ZW0uXG4gICAgICovXG4gICAgZ2V0TmV4dEVsZW1lbnQoKSB7XG4gICAgICAgIC8vIE9ubHkgcmV0dXJuIG5hdGl2ZSBlbGVtZW50cyBpZiB0aGV5IGFyZSByZW5kZXJlZFxuICAgICAgICBjb25zdCBlbGVtTGlzdCA9IHRoaXMubGlzdEVsZW1lbnRMaXN0ID8gdGhpcy5saXN0RWxlbWVudExpc3QudG9BcnJheSgpIDogW107XG4gICAgICAgIGlmICghZWxlbUxpc3QubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogU3RhcnQgY2hlY2tpbmcgZnJvbSBuZXh0IGluZGV4XG4gICAgICAgICAqIENvbnRpbnVlIGxvb3BpbmcgdGhyb3VnaCB0aGUgbGlzdCB1bnRpbCBhIG5vbiBkaXNhYmVsZWQgZWxlbWVudCBpcyBmb3VuZCBvclxuICAgICAgICAgKiBlbmQgb2YgbGlzdCBpcyByZWFjaGVkXG4gICAgICAgICAqL1xuICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5pbmRleCArIDE7IGkgPCBlbGVtTGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgLy8gSWYgdGhlIHZhbHVlcyBpbiB0aGUgbGlzdCBhcmUgbm90IGRpc2FibGVkXG4gICAgICAgICAgICBpZiAoIXRoaXMuZGlzcGxheUl0ZW1zW2ldLmRpc2FibGVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pbmRleCA9IGk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVsZW1MaXN0W2ldLm5hdGl2ZUVsZW1lbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVsZW1MaXN0W3RoaXMuaW5kZXhdPy5uYXRpdmVFbGVtZW50O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBgTGlzdEl0ZW1gIHRoYXQgcHJlY2VkZXMgdGhlIHNlbGVjdGVkIGl0ZW0gd2l0aGluIGBEcm9wZG93bkxpc3RgLlxuICAgICAqL1xuICAgIGdldFByZXZJdGVtKCkge1xuICAgICAgICBpZiAodGhpcy5pbmRleCA+IDApIHtcbiAgICAgICAgICAgIHRoaXMuaW5kZXgtLTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5kaXNwbGF5SXRlbXNbdGhpcy5pbmRleF07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYHRydWVgIGlmIHRoZSBzZWxlY3RlZCBpdGVtIGlzIG5vdCB0aGUgZmlyc3QgaW4gdGhlIGxpc3QuXG4gICAgICovXG4gICAgaGFzUHJldkVsZW1lbnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmluZGV4ID4gMCAmJiAoISh0aGlzLmluZGV4ID09PSAxKSB8fCAhdGhpcy5kaXNwbGF5SXRlbXNbMF0uZGlzYWJsZWQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBgSFRNTEVsZW1lbnRgIGZvciB0aGUgaXRlbSB0aGF0IHByZWNlZGVzIHRoZSBzZWxlY3RlZCBpdGVtLlxuICAgICAqL1xuICAgIGdldFByZXZFbGVtZW50KCkge1xuICAgICAgICAvLyBPbmx5IHJldHVybiBuYXRpdmUgZWxlbWVudHMgaWYgdGhleSBhcmUgcmVuZGVyZWRcbiAgICAgICAgY29uc3QgZWxlbUxpc3QgPSB0aGlzLmxpc3RFbGVtZW50TGlzdCA/IHRoaXMubGlzdEVsZW1lbnRMaXN0LnRvQXJyYXkoKSA6IFtdO1xuICAgICAgICBpZiAoIWVsZW1MaXN0Lmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFN0YXJ0IGNoZWNraW5nIGZyb20gbmV4dCBpbmRleFxuICAgICAgICAgKiBDb250aW51ZSBsb29waW5nIHRocm91Z2ggdGhlIGxpc3QgdW50aWwgYSBub24gZGlzYWJlbGVkIGVsZW1lbnQgaXMgZm91bmQgb3JcbiAgICAgICAgICogZW5kIG9mIGxpc3QgaXMgcmVhY2hlZFxuICAgICAgICAgKi9cbiAgICAgICAgZm9yIChsZXQgaSA9IHRoaXMuaW5kZXggLSAxOyBpIDwgdGhpcy5pbmRleCAmJiBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgLy8gSWYgdGhlIHZhbHVlcyBpbiB0aGUgbGlzdCBhcmUgbm90IGRpc2FibGVkXG4gICAgICAgICAgICBpZiAoIXRoaXMuZGlzcGxheUl0ZW1zW2ldLmRpc2FibGVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pbmRleCA9IGk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVsZW1MaXN0W2ldLm5hdGl2ZUVsZW1lbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVsZW1MaXN0W3RoaXMuaW5kZXhdLm5hdGl2ZUVsZW1lbnQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGBMaXN0SXRlbWAgdGhhdCBpcyBzZWxlY3RlZCB3aXRoaW4gYERyb3Bkb3duTGlzdGAuXG4gICAgICovXG4gICAgZ2V0Q3VycmVudEl0ZW0oKSB7XG4gICAgICAgIGlmICh0aGlzLmluZGV4IDwgMCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGlzcGxheUl0ZW1zWzBdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmRpc3BsYXlJdGVtc1t0aGlzLmluZGV4XTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgYEhUTUxFbGVtZW50YCBmb3IgdGhlIGl0ZW0gdGhhdCBpcyBzZWxlY3RlZCB3aXRoaW4gdGhlIGBEcm9wZG93bkxpc3RgLlxuICAgICAqL1xuICAgIGdldEN1cnJlbnRFbGVtZW50KCkge1xuICAgICAgICBpZiAodGhpcy5pbmRleCA8IDApIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxpc3RFbGVtZW50TGlzdC5maXJzdC5uYXRpdmVFbGVtZW50O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmxpc3RFbGVtZW50TGlzdC50b0FycmF5KClbdGhpcy5pbmRleF0ubmF0aXZlRWxlbWVudDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgaXRlbXMgYXMgYW4gQXJyYXlcbiAgICAgKi9cbiAgICBnZXRMaXN0SXRlbXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pdGVtcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIGxpc3QgY29udGFpbmluZyB0aGUgc2VsZWN0ZWQgaXRlbShzKSBpbiB0aGUgYERyb3Bkb3duTGlzdGAuXG4gICAgICovXG4gICAgZ2V0U2VsZWN0ZWQoKSB7XG4gICAgICAgIGxldCBzZWxlY3RlZCA9IHRoaXMuZ2V0TGlzdEl0ZW1zKCkuZmlsdGVyKGl0ZW0gPT4gaXRlbS5zZWxlY3RlZCk7XG4gICAgICAgIGlmIChzZWxlY3RlZC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2VsZWN0ZWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRyYW5zZm9ybXMgYXJyYXkgaW5wdXQgbGlzdCBvZiBpdGVtcyB0byB0aGUgY29ycmVjdCBzdGF0ZSBieSB1cGRhdGluZyB0aGUgc2VsZWN0ZWQgaXRlbShzKS5cbiAgICAgKi9cbiAgICBwcm9wYWdhdGVTZWxlY3RlZCh2YWx1ZSkge1xuICAgICAgICAvLyBpZiB3ZSBnZXQgYSBub24tYXJyYXksIGxvZyBvdXQgYW4gZXJyb3IgKHNpbmNlIGl0IGlzIG9uZSlcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihgJHt0aGlzLmNvbnN0cnVjdG9yLm5hbWV9LnByb3BhZ2F0ZVNlbGVjdGVkIGV4cGVjdHMgYW4gQXJyYXk8TGlzdEl0ZW0+LCBnb3QgJHtKU09OLnN0cmluZ2lmeSh2YWx1ZSl9YCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vbkl0ZW1zUmVhZHkoKCkgPT4ge1xuICAgICAgICAgICAgY29uc3Qgc2VsZWN0ZWROZXdJdGVtcyA9IFtdO1xuICAgICAgICAgICAgZm9yIChsZXQgbmV3SXRlbSBvZiB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGlmIChuZXdJdGVtICYmIG5ld0l0ZW0uc2VsZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gY29weSB0aGUgaXRlbVxuICAgICAgICAgICAgICAgICAgICBsZXQgdGVtcE5ld0l0ZW0gPSBPYmplY3QuYXNzaWduKHt9LCBuZXdJdGVtKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gZGVsZXRlZCBzZWxlY3RlZCBiZWNhdXNlIGl0J3Mgd2hhdCB3ZSBfd2FudF8gdG8gY2hhbmdlXG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSB0ZW1wTmV3SXRlbS5zZWxlY3RlZDtcbiAgICAgICAgICAgICAgICAgICAgLy8gc3RyaW5naWZ5IGZvciBjb21wYXJlIGxhdGVyXG4gICAgICAgICAgICAgICAgICAgIHRlbXBOZXdJdGVtID0gSlNPTi5zdHJpbmdpZnkodGVtcE5ld0l0ZW0pO1xuICAgICAgICAgICAgICAgICAgICAvLyBhZGQgdG8gdGhlIGxpc3Qgb2Ygc2VsZWN0ZWQgaXRlbXNcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0ZWROZXdJdGVtcy5wdXNoKHRlbXBOZXdJdGVtKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBsb29wIHRocm91Z2ggdGhlIGxpc3QgaXRlbXMgYW5kIHVwZGF0ZSB0aGUgYHNlbGVjdGVkYCBzdGF0ZSBmb3IgbWF0Y2hpbmcgaXRlbXMgaW4gYHZhbHVlYFxuICAgICAgICAgICAgZm9yIChsZXQgb2xkSXRlbSBvZiB0aGlzLmdldExpc3RJdGVtcygpKSB7XG4gICAgICAgICAgICAgICAgLy8gZmFzdCBwYXRoIHdoZW4gbm8gaXRlbXMgYXJlIHNlbGVjdGVkXG4gICAgICAgICAgICAgICAgaWYgKHNlbGVjdGVkTmV3SXRlbXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIG9sZEl0ZW0uc2VsZWN0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGNvcHkgdGhlIGl0ZW1cbiAgICAgICAgICAgICAgICBsZXQgdGVtcE9sZEl0ZW0gPSBPYmplY3QuYXNzaWduKHt9LCBvbGRJdGVtKTtcbiAgICAgICAgICAgICAgICAvLyBkZWxldGVkIHNlbGVjdGVkIGJlY2F1c2UgaXQncyB3aGF0IHdlIF93YW50XyB0byBjaGFuZ2VcbiAgICAgICAgICAgICAgICBkZWxldGUgdGVtcE9sZEl0ZW0uc2VsZWN0ZWQ7XG4gICAgICAgICAgICAgICAgLy8gc3RyaW5naWZ5IGZvciBjb21wYXJlXG4gICAgICAgICAgICAgICAgdGVtcE9sZEl0ZW0gPSBKU09OLnN0cmluZ2lmeSh0ZW1wT2xkSXRlbSk7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgc2VsZWN0ZWROZXdJdGVtIG9mIHNlbGVjdGVkTmV3SXRlbXMpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZG8gdGhlIGNvbXBhcmVcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRlbXBPbGRJdGVtLmluY2x1ZGVzKHNlbGVjdGVkTmV3SXRlbSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9sZEl0ZW0uc2VsZWN0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWYgd2UndmUgZm91bmQgYSBtYXRjaGluZyBpdGVtLCB3ZSBjYW4gc3RvcCBsb29waW5nXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9sZEl0ZW0uc2VsZWN0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemVzIGZvY3VzIGluIHRoZSBsaXN0LCBlZmZlY3RpdmVseSBhIHdyYXBwZXIgZm9yIGBnZXRDdXJyZW50RWxlbWVudCgpLmZvY3VzKClgXG4gICAgICovXG4gICAgaW5pdEZvY3VzKCkge1xuICAgICAgICBpZiAodGhpcy5pbmRleCA8IDApIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlSW5kZXgoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxpc3QubmF0aXZlRWxlbWVudC5mb2N1cygpO1xuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuaGlnaGxpZ2h0ZWRJdGVtID0gdGhpcy5nZXRJdGVtSWQodGhpcy5pbmRleCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICB1cGRhdGVJbmRleCgpIHtcbiAgICAgICAgLy8gaW5pdGlhbGl6ZSBpbmRleCBvbiB0aGUgZmlyc3Qgc2VsZWN0ZWQgaXRlbSBvclxuICAgICAgICAvLyBvbiB0aGUgbmV4dCBub24gZGlzYWJsZWQgaXRlbSBpZiBubyBpdGVtcyBhcmUgc2VsZWN0ZWRcbiAgICAgICAgLy8gaW4gY2FzZSwgaWYgYWxsIGl0ZW1zIGFyZSBkaXNhYmxlZCwgdGhlIGluZGV4IHZhbHVlIHdpbGwgcmVtYWluIHNhbWVcbiAgICAgICAgY29uc3Qgc2VsZWN0ZWQgPSB0aGlzLmdldFNlbGVjdGVkKCk7XG4gICAgICAgIGlmIChzZWxlY3RlZC5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMuaW5kZXggPSB0aGlzLmRpc3BsYXlJdGVtcy5pbmRleE9mKHNlbGVjdGVkWzBdKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLmhhc05leHRFbGVtZW50KCkpIHtcbiAgICAgICAgICAgIHRoaXMuZ2V0TmV4dEVsZW1lbnQoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBNYW5hZ2VzIHRoZSBrZXlib2FyZCBhY2Nlc3NpYmlsaXR5IGZvciBuYXZpZ2F0aW9uIGFuZCBzZWxlY3Rpb24gd2l0aGluIGEgYERyb3Bkb3duTGlzdGAuXG4gICAgICovXG4gICAgbmF2aWdhdGVMaXN0KGV2ZW50KSB7XG4gICAgICAgIGlmIChldmVudC5rZXkgPT09IFwiRW50ZXJcIiB8fCBldmVudC5rZXkgPT09IFwiIFwiKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5saXN0RWxlbWVudExpc3Quc29tZShvcHRpb24gPT4gb3B0aW9uLm5hdGl2ZUVsZW1lbnQgPT09IGV2ZW50LnRhcmdldCkpIHtcbiAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGV2ZW50LmtleSA9PT0gXCJFbnRlclwiKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kb0NsaWNrKGV2ZW50LCB0aGlzLmdldEN1cnJlbnRJdGVtKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGV2ZW50LmtleSA9PT0gXCJBcnJvd0Rvd25cIiB8fCBldmVudC5rZXkgPT09IFwiQXJyb3dVcFwiKSB7XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgaWYgKGV2ZW50LmtleSA9PT0gXCJBcnJvd0Rvd25cIikge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmhhc05leHRFbGVtZW50KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5nZXROZXh0RWxlbWVudCgpPy5zY3JvbGxJbnRvVmlldyh7IGJsb2NrOiBcImVuZFwiIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5ibHVySW50ZW50LmVtaXQoXCJib3R0b21cIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZXZlbnQua2V5ID09PSBcIkFycm93VXBcIikge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmhhc1ByZXZFbGVtZW50KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5nZXRQcmV2RWxlbWVudCgpLnNjcm9sbEludG9WaWV3KHsgYmxvY2s6IFwibmVhcmVzdFwiIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5ibHVySW50ZW50LmVtaXQoXCJ0b3BcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5oaWdobGlnaHRlZEl0ZW0gPSB0aGlzLmdldEl0ZW1JZCh0aGlzLmluZGV4KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVtaXRzIHRoZSBzZWxlY3RlZCBpdGVtIG9yIGl0ZW1zIGFmdGVyIGEgbW91c2UgY2xpY2sgZXZlbnQgaGFzIG9jY3VycmVkLlxuICAgICAqL1xuICAgIGRvQ2xpY2soZXZlbnQsIGl0ZW0pIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgaWYgKGl0ZW0gJiYgIWl0ZW0uZGlzYWJsZWQpIHtcbiAgICAgICAgICAgIHRoaXMubGlzdC5uYXRpdmVFbGVtZW50LmZvY3VzKCk7XG4gICAgICAgICAgICBpZiAodGhpcy50eXBlID09PSBcInNpbmdsZVwiKSB7XG4gICAgICAgICAgICAgICAgaXRlbS5zZWxlY3RlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgLy8gcmVzZXQgdGhlIHNlbGVjdGlvblxuICAgICAgICAgICAgICAgIGZvciAobGV0IG90aGVySXRlbSBvZiB0aGlzLmdldExpc3RJdGVtcygpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpdGVtICE9PSBvdGhlckl0ZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG90aGVySXRlbS5zZWxlY3RlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaXRlbS5zZWxlY3RlZCA9ICFpdGVtLnNlbGVjdGVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5pbmRleCA9IHRoaXMuZGlzcGxheUl0ZW1zLmluZGV4T2YoaXRlbSk7XG4gICAgICAgICAgICB0aGlzLmhpZ2hsaWdodGVkSXRlbSA9IHRoaXMuZ2V0SXRlbUlkKHRoaXMuaW5kZXgpO1xuICAgICAgICAgICAgdGhpcy5kb0VtaXRTZWxlY3QoZmFsc2UpO1xuICAgICAgICAgICAgdGhpcy5hcHBSZWYudGljaygpO1xuICAgICAgICB9XG4gICAgfVxuICAgIG9uSXRlbUZvY3VzKGluZGV4KSB7XG4gICAgICAgIGNvbnN0IGVsZW1lbnQgPSB0aGlzLmxpc3RFbGVtZW50TGlzdC50b0FycmF5KClbaW5kZXhdLm5hdGl2ZUVsZW1lbnQ7XG4gICAgICAgIGVsZW1lbnQuY2xhc3NMaXN0LmFkZChcImNkcy0tbGlzdC1ib3hfX21lbnUtaXRlbS0taGlnaGxpZ2h0ZWRcIik7XG4gICAgICAgIGVsZW1lbnQudGFiSW5kZXggPSAwO1xuICAgIH1cbiAgICBvbkl0ZW1CbHVyKGluZGV4KSB7XG4gICAgICAgIGNvbnN0IGVsZW1lbnQgPSB0aGlzLmxpc3RFbGVtZW50TGlzdC50b0FycmF5KClbaW5kZXhdLm5hdGl2ZUVsZW1lbnQ7XG4gICAgICAgIGVsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZShcImNkcy0tbGlzdC1ib3hfX21lbnUtaXRlbS0taGlnaGxpZ2h0ZWRcIik7XG4gICAgICAgIGVsZW1lbnQudGFiSW5kZXggPSAtMTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRW1pdHMgdGhlIHNjcm9sbCBldmVudCBvZiB0aGUgb3B0aW9ucyBsaXN0XG4gICAgICovXG4gICAgZW1pdFNjcm9sbChldmVudCkge1xuICAgICAgICBjb25zdCBhdFRvcCA9IGV2ZW50LnNyY0VsZW1lbnQuc2Nyb2xsVG9wID09PSAwO1xuICAgICAgICBjb25zdCBhdEJvdHRvbSA9IGV2ZW50LnNyY0VsZW1lbnQuc2Nyb2xsSGVpZ2h0IC0gZXZlbnQuc3JjRWxlbWVudC5zY3JvbGxUb3AgPT09IGV2ZW50LnNyY0VsZW1lbnQuY2xpZW50SGVpZ2h0O1xuICAgICAgICBjb25zdCBjdXN0b21TY3JvbGxFdmVudCA9IHsgYXRUb3AsIGF0Qm90dG9tLCBldmVudCB9O1xuICAgICAgICB0aGlzLnNjcm9sbC5lbWl0KGN1c3RvbVNjcm9sbEV2ZW50KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3Vic2NyaWJlIHRoZSBmdW5jdGlvbiBwYXNzZWQgdG8gYW4gaW50ZXJuYWwgb2JzZXJ2YWJsZSB0aGF0IHdpbGwgcmVzb2x2ZSBvbmNlIHRoZSBpdGVtcyBhcmUgcmVhZHlcbiAgICAgKi9cbiAgICBvbkl0ZW1zUmVhZHkoc3ViY3JpcHRpb24pIHtcbiAgICAgICAgLy8gdGhpcyBzdWJzY3JpcHRpb24gd2lsbCBhdXRvIHVuc3Vic2NyaWJlIGJlY2F1c2Ugb2YgdGhlIGBmaXJzdCgpYCBwaXBlXG4gICAgICAgICh0aGlzLl9pdGVtc1JlYWR5IHx8IG9mKHRydWUpKS5waXBlKGZpcnN0KCkpLnN1YnNjcmliZShzdWJjcmlwdGlvbik7XG4gICAgfVxuICAgIHJlb3JkZXJTZWxlY3RlZChtb3ZlRm9jdXMgPSB0cnVlKSB7XG4gICAgICAgIHRoaXMuZGlzcGxheUl0ZW1zID0gWy4uLnRoaXMuZ2V0U2VsZWN0ZWQoKSwgLi4udGhpcy5nZXRMaXN0SXRlbXMoKS5maWx0ZXIoaXRlbSA9PiAhaXRlbS5zZWxlY3RlZCldO1xuICAgICAgICBpZiAobW92ZUZvY3VzKSB7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZUluZGV4KCk7XG4gICAgICAgICAgICAgICAgdGhpcy5oaWdobGlnaHRlZEl0ZW0gPSB0aGlzLmdldEl0ZW1JZCh0aGlzLmluZGV4KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxufVxuRHJvcGRvd25MaXN0Lmxpc3RDb3VudCA9IDA7XG5Ecm9wZG93bkxpc3QuybVmYWMgPSBpMC7Jtcm1bmdEZWNsYXJlRmFjdG9yeSh7IG1pblZlcnNpb246IFwiMTIuMC4wXCIsIHZlcnNpb246IFwiMTQuMy4wXCIsIG5nSW1wb3J0OiBpMCwgdHlwZTogRHJvcGRvd25MaXN0LCBkZXBzOiBbeyB0b2tlbjogaTAuRWxlbWVudFJlZiB9LCB7IHRva2VuOiBpMSQxLkkxOG4gfSwgeyB0b2tlbjogaTAuQXBwbGljYXRpb25SZWYgfV0sIHRhcmdldDogaTAuybXJtUZhY3RvcnlUYXJnZXQuQ29tcG9uZW50IH0pO1xuRHJvcGRvd25MaXN0Lsm1Y21wID0gaTAuybXJtW5nRGVjbGFyZUNvbXBvbmVudCh7IG1pblZlcnNpb246IFwiMTQuMC4wXCIsIHZlcnNpb246IFwiMTQuMy4wXCIsIHR5cGU6IERyb3Bkb3duTGlzdCwgc2VsZWN0b3I6IFwiY2RzLWRyb3Bkb3duLWxpc3QsIGlibS1kcm9wZG93bi1saXN0XCIsIGlucHV0czogeyBhcmlhTGFiZWw6IFwiYXJpYUxhYmVsXCIsIGl0ZW1zOiBcIml0ZW1zXCIsIGxpc3RUcGw6IFwibGlzdFRwbFwiLCB0eXBlOiBcInR5cGVcIiwgc2hvd1RpdGxlczogXCJzaG93VGl0bGVzXCIgfSwgb3V0cHV0czogeyBzZWxlY3Q6IFwic2VsZWN0XCIsIHNjcm9sbDogXCJzY3JvbGxcIiwgYmx1ckludGVudDogXCJibHVySW50ZW50XCIgfSwgcHJvdmlkZXJzOiBbXG4gICAgICAgIHtcbiAgICAgICAgICAgIHByb3ZpZGU6IEFic3RyYWN0RHJvcGRvd25WaWV3LFxuICAgICAgICAgICAgdXNlRXhpc3Rpbmc6IERyb3Bkb3duTGlzdFxuICAgICAgICB9XG4gICAgXSwgdmlld1F1ZXJpZXM6IFt7IHByb3BlcnR5TmFtZTogXCJsaXN0XCIsIGZpcnN0OiB0cnVlLCBwcmVkaWNhdGU6IFtcImxpc3RcIl0sIGRlc2NlbmRhbnRzOiB0cnVlLCBzdGF0aWM6IHRydWUgfSwgeyBwcm9wZXJ0eU5hbWU6IFwibGlzdEVsZW1lbnRMaXN0XCIsIHByZWRpY2F0ZTogW1wibGlzdEl0ZW1cIl0sIGRlc2NlbmRhbnRzOiB0cnVlIH1dLCBuZ0ltcG9ydDogaTAsIHRlbXBsYXRlOiBgXG5cdFx0PHVsXG5cdFx0XHQjbGlzdFxuXHRcdFx0W2lkXT1cImxpc3RJZFwiXG5cdFx0XHRyb2xlPVwibGlzdGJveFwiXG5cdFx0XHRjbGFzcz1cImNkcy0tbGlzdC1ib3hfX21lbnUgY2RzLS1tdWx0aS1zZWxlY3RcIlxuXHRcdFx0KHNjcm9sbCk9XCJlbWl0U2Nyb2xsKCRldmVudClcIlxuXHRcdFx0KGtleWRvd24pPVwibmF2aWdhdGVMaXN0KCRldmVudClcIlxuXHRcdFx0dGFiaW5kZXg9XCItMVwiXG5cdFx0XHRbYXR0ci5hcmlhLWxhYmVsXT1cImFyaWFMYWJlbFwiXG5cdFx0XHRbYXR0ci5hcmlhLWFjdGl2ZWRlc2NlbmRhbnRdPVwiaGlnaGxpZ2h0ZWRJdGVtXCI+XG5cdFx0XHQ8bGlcblx0XHRcdFx0cm9sZT1cIm9wdGlvblwiXG5cdFx0XHRcdCpuZ0Zvcj1cImxldCBpdGVtIG9mIGRpc3BsYXlJdGVtczsgbGV0IGkgPSBpbmRleFwiXG5cdFx0XHRcdChjbGljayk9XCJkb0NsaWNrKCRldmVudCwgaXRlbSlcIlxuXHRcdFx0XHRjbGFzcz1cImNkcy0tbGlzdC1ib3hfX21lbnUtaXRlbVwiXG5cdFx0XHRcdFthdHRyLmFyaWEtc2VsZWN0ZWRdPVwiaXRlbS5zZWxlY3RlZFwiXG5cdFx0XHRcdFtpZF09XCJnZXRJdGVtSWQoaSlcIlxuXHRcdFx0XHRbYXR0ci50aXRsZV09XCIgc2hvd1RpdGxlcyA/IGl0ZW0uY29udGVudCA6IG51bGxcIlxuXHRcdFx0XHRbYXR0ci5kaXNhYmxlZF09XCJpdGVtLmRpc2FibGVkID8gdHJ1ZSA6IG51bGxcIlxuXHRcdFx0XHRbbmdDbGFzc109XCJ7XG5cdFx0XHRcdFx0J2Nkcy0tbGlzdC1ib3hfX21lbnUtaXRlbS0tYWN0aXZlJzogaXRlbS5zZWxlY3RlZCxcblx0XHRcdFx0XHQnY2RzLS1saXN0LWJveF9fbWVudS1pdGVtLS1oaWdobGlnaHRlZCc6IGhpZ2hsaWdodGVkSXRlbSA9PT0gZ2V0SXRlbUlkKGkpXG5cdFx0XHRcdH1cIj5cblx0XHRcdFx0PGRpdlxuXHRcdFx0XHRcdCNsaXN0SXRlbVxuXHRcdFx0XHRcdHRhYmluZGV4PVwiLTFcIlxuXHRcdFx0XHRcdGNsYXNzPVwiY2RzLS1saXN0LWJveF9fbWVudS1pdGVtX19vcHRpb25cIj5cblx0XHRcdFx0XHQ8ZGl2XG5cdFx0XHRcdFx0XHQqbmdJZj1cIiFsaXN0VHBsICYmIHR5cGUgPT09ICdtdWx0aSdcIlxuXHRcdFx0XHRcdFx0Y2xhc3M9XCJjZHMtLWZvcm0taXRlbSBjZHMtLWNoZWNrYm94LXdyYXBwZXJcIj5cblx0XHRcdFx0XHRcdDxsYWJlbFxuXHRcdFx0XHRcdFx0XHRbYXR0ci5kYXRhLWNvbnRhaW5lZC1jaGVja2JveC1zdGF0ZV09XCJpdGVtLnNlbGVjdGVkXCJcblx0XHRcdFx0XHRcdFx0Y2xhc3M9XCJjZHMtLWNoZWNrYm94LWxhYmVsXCI+XG5cdFx0XHRcdFx0XHRcdDxpbnB1dFxuXHRcdFx0XHRcdFx0XHRcdGNsYXNzPVwiY2RzLS1jaGVja2JveFwiXG5cdFx0XHRcdFx0XHRcdFx0dHlwZT1cImNoZWNrYm94XCJcblx0XHRcdFx0XHRcdFx0XHRbY2hlY2tlZF09XCJpdGVtLnNlbGVjdGVkXCJcblx0XHRcdFx0XHRcdFx0XHRbZGlzYWJsZWRdPVwiaXRlbS5kaXNhYmxlZFwiXG5cdFx0XHRcdFx0XHRcdFx0dGFiaW5kZXg9XCItMVwiPlxuXHRcdFx0XHRcdFx0XHQ8c3BhbiBjbGFzcz1cImNkcy0tY2hlY2tib3gtYXBwZWFyYW5jZVwiPjwvc3Bhbj5cblx0XHRcdFx0XHRcdFx0PHNwYW4gY2xhc3M9XCJjZHMtLWNoZWNrYm94LWxhYmVsLXRleHRcIj57e2l0ZW0uY29udGVudH19PC9zcGFuPlxuXHRcdFx0XHRcdFx0PC9sYWJlbD5cblx0XHRcdFx0XHQ8L2Rpdj5cblx0XHRcdFx0XHQ8bmctY29udGFpbmVyICpuZ0lmPVwiIWxpc3RUcGwgJiYgdHlwZSA9PT0gJ3NpbmdsZSdcIj57e2l0ZW0uY29udGVudH19PC9uZy1jb250YWluZXI+XG5cdFx0XHRcdFx0PHN2Z1xuXHRcdFx0XHRcdFx0Km5nSWY9XCIhbGlzdFRwbCAmJiB0eXBlID09PSAnc2luZ2xlJ1wiXG5cdFx0XHRcdFx0XHRjZHNJY29uPVwiY2hlY2ttYXJrXCJcblx0XHRcdFx0XHRcdHNpemU9XCIxNlwiXG5cdFx0XHRcdFx0XHRjbGFzcz1cImNkcy0tbGlzdC1ib3hfX21lbnUtaXRlbV9fc2VsZWN0ZWQtaWNvblwiPlxuXHRcdFx0XHRcdDwvc3ZnPlxuXHRcdFx0XHRcdDxuZy10ZW1wbGF0ZVxuXHRcdFx0XHRcdFx0Km5nSWY9XCJsaXN0VHBsXCJcblx0XHRcdFx0XHRcdFtuZ1RlbXBsYXRlT3V0bGV0Q29udGV4dF09XCJ7aXRlbTogaXRlbX1cIlxuXHRcdFx0XHRcdFx0W25nVGVtcGxhdGVPdXRsZXRdPVwibGlzdFRwbFwiPlxuXHRcdFx0XHRcdDwvbmctdGVtcGxhdGU+XG5cdFx0XHRcdDwvZGl2PlxuXHRcdFx0PC9saT5cblx0XHQ8L3VsPmAsIGlzSW5saW5lOiB0cnVlLCBkZXBlbmRlbmNpZXM6IFt7IGtpbmQ6IFwiZGlyZWN0aXZlXCIsIHR5cGU6IGk0Lk5nQ2xhc3MsIHNlbGVjdG9yOiBcIltuZ0NsYXNzXVwiLCBpbnB1dHM6IFtcImNsYXNzXCIsIFwibmdDbGFzc1wiXSB9LCB7IGtpbmQ6IFwiZGlyZWN0aXZlXCIsIHR5cGU6IGk0Lk5nRm9yT2YsIHNlbGVjdG9yOiBcIltuZ0Zvcl1bbmdGb3JPZl1cIiwgaW5wdXRzOiBbXCJuZ0Zvck9mXCIsIFwibmdGb3JUcmFja0J5XCIsIFwibmdGb3JUZW1wbGF0ZVwiXSB9LCB7IGtpbmQ6IFwiZGlyZWN0aXZlXCIsIHR5cGU6IGk0Lk5nSWYsIHNlbGVjdG9yOiBcIltuZ0lmXVwiLCBpbnB1dHM6IFtcIm5nSWZcIiwgXCJuZ0lmVGhlblwiLCBcIm5nSWZFbHNlXCJdIH0sIHsga2luZDogXCJkaXJlY3RpdmVcIiwgdHlwZTogaTQuTmdUZW1wbGF0ZU91dGxldCwgc2VsZWN0b3I6IFwiW25nVGVtcGxhdGVPdXRsZXRdXCIsIGlucHV0czogW1wibmdUZW1wbGF0ZU91dGxldENvbnRleHRcIiwgXCJuZ1RlbXBsYXRlT3V0bGV0XCIsIFwibmdUZW1wbGF0ZU91dGxldEluamVjdG9yXCJdIH0sIHsga2luZDogXCJkaXJlY3RpdmVcIiwgdHlwZTogaTUuSWNvbkRpcmVjdGl2ZSwgc2VsZWN0b3I6IFwiW2Nkc0ljb25dLCBbaWJtSWNvbl1cIiwgaW5wdXRzOiBbXCJpYm1JY29uXCIsIFwiY2RzSWNvblwiLCBcInNpemVcIiwgXCJ0aXRsZVwiLCBcImFyaWFMYWJlbFwiLCBcImFyaWFMYWJlbGxlZEJ5XCIsIFwiYXJpYUhpZGRlblwiLCBcImlzRm9jdXNhYmxlXCJdIH1dIH0pO1xuaTAuybXJtW5nRGVjbGFyZUNsYXNzTWV0YWRhdGEoeyBtaW5WZXJzaW9uOiBcIjEyLjAuMFwiLCB2ZXJzaW9uOiBcIjE0LjMuMFwiLCBuZ0ltcG9ydDogaTAsIHR5cGU6IERyb3Bkb3duTGlzdCwgZGVjb3JhdG9yczogW3tcbiAgICAgICAgICAgIHR5cGU6IENvbXBvbmVudCxcbiAgICAgICAgICAgIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdG9yOiBcImNkcy1kcm9wZG93bi1saXN0LCBpYm0tZHJvcGRvd24tbGlzdFwiLFxuICAgICAgICAgICAgICAgICAgICB0ZW1wbGF0ZTogYFxuXHRcdDx1bFxuXHRcdFx0I2xpc3Rcblx0XHRcdFtpZF09XCJsaXN0SWRcIlxuXHRcdFx0cm9sZT1cImxpc3Rib3hcIlxuXHRcdFx0Y2xhc3M9XCJjZHMtLWxpc3QtYm94X19tZW51IGNkcy0tbXVsdGktc2VsZWN0XCJcblx0XHRcdChzY3JvbGwpPVwiZW1pdFNjcm9sbCgkZXZlbnQpXCJcblx0XHRcdChrZXlkb3duKT1cIm5hdmlnYXRlTGlzdCgkZXZlbnQpXCJcblx0XHRcdHRhYmluZGV4PVwiLTFcIlxuXHRcdFx0W2F0dHIuYXJpYS1sYWJlbF09XCJhcmlhTGFiZWxcIlxuXHRcdFx0W2F0dHIuYXJpYS1hY3RpdmVkZXNjZW5kYW50XT1cImhpZ2hsaWdodGVkSXRlbVwiPlxuXHRcdFx0PGxpXG5cdFx0XHRcdHJvbGU9XCJvcHRpb25cIlxuXHRcdFx0XHQqbmdGb3I9XCJsZXQgaXRlbSBvZiBkaXNwbGF5SXRlbXM7IGxldCBpID0gaW5kZXhcIlxuXHRcdFx0XHQoY2xpY2spPVwiZG9DbGljaygkZXZlbnQsIGl0ZW0pXCJcblx0XHRcdFx0Y2xhc3M9XCJjZHMtLWxpc3QtYm94X19tZW51LWl0ZW1cIlxuXHRcdFx0XHRbYXR0ci5hcmlhLXNlbGVjdGVkXT1cIml0ZW0uc2VsZWN0ZWRcIlxuXHRcdFx0XHRbaWRdPVwiZ2V0SXRlbUlkKGkpXCJcblx0XHRcdFx0W2F0dHIudGl0bGVdPVwiIHNob3dUaXRsZXMgPyBpdGVtLmNvbnRlbnQgOiBudWxsXCJcblx0XHRcdFx0W2F0dHIuZGlzYWJsZWRdPVwiaXRlbS5kaXNhYmxlZCA/IHRydWUgOiBudWxsXCJcblx0XHRcdFx0W25nQ2xhc3NdPVwie1xuXHRcdFx0XHRcdCdjZHMtLWxpc3QtYm94X19tZW51LWl0ZW0tLWFjdGl2ZSc6IGl0ZW0uc2VsZWN0ZWQsXG5cdFx0XHRcdFx0J2Nkcy0tbGlzdC1ib3hfX21lbnUtaXRlbS0taGlnaGxpZ2h0ZWQnOiBoaWdobGlnaHRlZEl0ZW0gPT09IGdldEl0ZW1JZChpKVxuXHRcdFx0XHR9XCI+XG5cdFx0XHRcdDxkaXZcblx0XHRcdFx0XHQjbGlzdEl0ZW1cblx0XHRcdFx0XHR0YWJpbmRleD1cIi0xXCJcblx0XHRcdFx0XHRjbGFzcz1cImNkcy0tbGlzdC1ib3hfX21lbnUtaXRlbV9fb3B0aW9uXCI+XG5cdFx0XHRcdFx0PGRpdlxuXHRcdFx0XHRcdFx0Km5nSWY9XCIhbGlzdFRwbCAmJiB0eXBlID09PSAnbXVsdGknXCJcblx0XHRcdFx0XHRcdGNsYXNzPVwiY2RzLS1mb3JtLWl0ZW0gY2RzLS1jaGVja2JveC13cmFwcGVyXCI+XG5cdFx0XHRcdFx0XHQ8bGFiZWxcblx0XHRcdFx0XHRcdFx0W2F0dHIuZGF0YS1jb250YWluZWQtY2hlY2tib3gtc3RhdGVdPVwiaXRlbS5zZWxlY3RlZFwiXG5cdFx0XHRcdFx0XHRcdGNsYXNzPVwiY2RzLS1jaGVja2JveC1sYWJlbFwiPlxuXHRcdFx0XHRcdFx0XHQ8aW5wdXRcblx0XHRcdFx0XHRcdFx0XHRjbGFzcz1cImNkcy0tY2hlY2tib3hcIlxuXHRcdFx0XHRcdFx0XHRcdHR5cGU9XCJjaGVja2JveFwiXG5cdFx0XHRcdFx0XHRcdFx0W2NoZWNrZWRdPVwiaXRlbS5zZWxlY3RlZFwiXG5cdFx0XHRcdFx0XHRcdFx0W2Rpc2FibGVkXT1cIml0ZW0uZGlzYWJsZWRcIlxuXHRcdFx0XHRcdFx0XHRcdHRhYmluZGV4PVwiLTFcIj5cblx0XHRcdFx0XHRcdFx0PHNwYW4gY2xhc3M9XCJjZHMtLWNoZWNrYm94LWFwcGVhcmFuY2VcIj48L3NwYW4+XG5cdFx0XHRcdFx0XHRcdDxzcGFuIGNsYXNzPVwiY2RzLS1jaGVja2JveC1sYWJlbC10ZXh0XCI+e3tpdGVtLmNvbnRlbnR9fTwvc3Bhbj5cblx0XHRcdFx0XHRcdDwvbGFiZWw+XG5cdFx0XHRcdFx0PC9kaXY+XG5cdFx0XHRcdFx0PG5nLWNvbnRhaW5lciAqbmdJZj1cIiFsaXN0VHBsICYmIHR5cGUgPT09ICdzaW5nbGUnXCI+e3tpdGVtLmNvbnRlbnR9fTwvbmctY29udGFpbmVyPlxuXHRcdFx0XHRcdDxzdmdcblx0XHRcdFx0XHRcdCpuZ0lmPVwiIWxpc3RUcGwgJiYgdHlwZSA9PT0gJ3NpbmdsZSdcIlxuXHRcdFx0XHRcdFx0Y2RzSWNvbj1cImNoZWNrbWFya1wiXG5cdFx0XHRcdFx0XHRzaXplPVwiMTZcIlxuXHRcdFx0XHRcdFx0Y2xhc3M9XCJjZHMtLWxpc3QtYm94X19tZW51LWl0ZW1fX3NlbGVjdGVkLWljb25cIj5cblx0XHRcdFx0XHQ8L3N2Zz5cblx0XHRcdFx0XHQ8bmctdGVtcGxhdGVcblx0XHRcdFx0XHRcdCpuZ0lmPVwibGlzdFRwbFwiXG5cdFx0XHRcdFx0XHRbbmdUZW1wbGF0ZU91dGxldENvbnRleHRdPVwie2l0ZW06IGl0ZW19XCJcblx0XHRcdFx0XHRcdFtuZ1RlbXBsYXRlT3V0bGV0XT1cImxpc3RUcGxcIj5cblx0XHRcdFx0XHQ8L25nLXRlbXBsYXRlPlxuXHRcdFx0XHQ8L2Rpdj5cblx0XHRcdDwvbGk+XG5cdFx0PC91bD5gLFxuICAgICAgICAgICAgICAgICAgICBwcm92aWRlcnM6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm92aWRlOiBBYnN0cmFjdERyb3Bkb3duVmlldyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1c2VFeGlzdGluZzogRHJvcGRvd25MaXN0XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICB9XVxuICAgICAgICB9XSwgY3RvclBhcmFtZXRlcnM6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFt7IHR5cGU6IGkwLkVsZW1lbnRSZWYgfSwgeyB0eXBlOiBpMSQxLkkxOG4gfSwgeyB0eXBlOiBpMC5BcHBsaWNhdGlvblJlZiB9XTsgfSwgcHJvcERlY29yYXRvcnM6IHsgYXJpYUxhYmVsOiBbe1xuICAgICAgICAgICAgICAgIHR5cGU6IElucHV0XG4gICAgICAgICAgICB9XSwgaXRlbXM6IFt7XG4gICAgICAgICAgICAgICAgdHlwZTogSW5wdXRcbiAgICAgICAgICAgIH1dLCBsaXN0VHBsOiBbe1xuICAgICAgICAgICAgICAgIHR5cGU6IElucHV0XG4gICAgICAgICAgICB9XSwgc2VsZWN0OiBbe1xuICAgICAgICAgICAgICAgIHR5cGU6IE91dHB1dFxuICAgICAgICAgICAgfV0sIHNjcm9sbDogW3tcbiAgICAgICAgICAgICAgICB0eXBlOiBPdXRwdXRcbiAgICAgICAgICAgIH1dLCBibHVySW50ZW50OiBbe1xuICAgICAgICAgICAgICAgIHR5cGU6IE91dHB1dFxuICAgICAgICAgICAgfV0sIGxpc3Q6IFt7XG4gICAgICAgICAgICAgICAgdHlwZTogVmlld0NoaWxkLFxuICAgICAgICAgICAgICAgIGFyZ3M6IFtcImxpc3RcIiwgeyBzdGF0aWM6IHRydWUgfV1cbiAgICAgICAgICAgIH1dLCB0eXBlOiBbe1xuICAgICAgICAgICAgICAgIHR5cGU6IElucHV0XG4gICAgICAgICAgICB9XSwgc2hvd1RpdGxlczogW3tcbiAgICAgICAgICAgICAgICB0eXBlOiBJbnB1dFxuICAgICAgICAgICAgfV0sIGxpc3RFbGVtZW50TGlzdDogW3tcbiAgICAgICAgICAgICAgICB0eXBlOiBWaWV3Q2hpbGRyZW4sXG4gICAgICAgICAgICAgICAgYXJnczogW1wibGlzdEl0ZW1cIl1cbiAgICAgICAgICAgIH1dIH0gfSk7XG5cbmNsYXNzIFNjcm9sbGFibGVMaXN0IHtcbiAgICBjb25zdHJ1Y3RvcihlbGVtZW50UmVmKSB7XG4gICAgICAgIHRoaXMuZWxlbWVudFJlZiA9IGVsZW1lbnRSZWY7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBPcHRpb25hbCB0YXJnZXQgbGlzdCB0byBzY3JvbGxcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMublNjcm9sbGFibGVMaXN0ID0gbnVsbDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEVuYWJsZXMgb3IgZGlzYWJsZXMgc2Nyb2xsaW5nIGZvciB0aGUgd2hvbGUgZGlyZWN0aXZlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnNjcm9sbEVuYWJsZWQgPSB0cnVlO1xuICAgICAgICAvKipcbiAgICAgICAgICogSG93IG1hbnkgbGluZXMgdG8gc2Nyb2xsIGJ5IGVhY2ggdGltZSBgd2hlZWxgIGZpcmVzXG4gICAgICAgICAqIERlZmF1bHRzIHRvIDEwIC0gYmFzZWQgb24gdGVzdGluZyB0aGlzIGlzbid0IHRvbyBmYXN0IG9yIHNsb3cgb24gYW55IHBsYXRmb3JtXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnNjcm9sbEJ5ID0gMTA7XG4gICAgICAgIHRoaXMuY2FuU2Nyb2xsVXAgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5jYW5TY3JvbGxEb3duID0gZmFsc2U7XG4gICAgICAgIHRoaXMubGlzdCA9IHRoaXMuZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50O1xuICAgIH1cbiAgICBuZ09uQ2hhbmdlcyhjaGFuZ2VzKSB7XG4gICAgICAgIGlmIChjaGFuZ2VzLnNjcm9sbEVuYWJsZWQpIHtcbiAgICAgICAgICAgIGlmIChjaGFuZ2VzLnNjcm9sbEVuYWJsZWQuY3VycmVudFZhbHVlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5saXN0LnN0eWxlLm92ZXJmbG93ID0gXCJoaWRkZW5cIjtcbiAgICAgICAgICAgICAgICB0aGlzLnNjcm9sbFVwVGFyZ2V0LnN0eWxlLmRpc3BsYXkgPSBcImZsZXhcIjtcbiAgICAgICAgICAgICAgICB0aGlzLnNjcm9sbERvd25UYXJnZXQuc3R5bGUuZGlzcGxheSA9IFwiZmxleFwiO1xuICAgICAgICAgICAgICAgIHRoaXMuY2FuU2Nyb2xsVXAgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRoaXMuY2FuU2Nyb2xsRG93biA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVTY3JvbGxIZWlnaHQoKTtcbiAgICAgICAgICAgICAgICB0aGlzLmNoZWNrU2Nyb2xsQXJyb3dzKCk7XG4gICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2hlY2tTY3JvbGxBcnJvd3MoKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuc2Nyb2xsVXBUYXJnZXQuc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiO1xuICAgICAgICAgICAgICAgIHRoaXMuc2Nyb2xsRG93blRhcmdldC5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCI7XG4gICAgICAgICAgICAgICAgdGhpcy5jYW5TY3JvbGxVcCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHRoaXMuY2FuU2Nyb2xsRG93biA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHRoaXMubGlzdC5zdHlsZS5oZWlnaHQgPSBudWxsO1xuICAgICAgICAgICAgICAgIHRoaXMubGlzdC5zdHlsZS5vdmVyZmxvdyA9IG51bGw7XG4gICAgICAgICAgICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLmhvdmVyU2Nyb2xsSW50ZXJ2YWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIG5nQWZ0ZXJWaWV3SW5pdCgpIHtcbiAgICAgICAgaWYgKHRoaXMublNjcm9sbGFibGVMaXN0KSB7XG4gICAgICAgICAgICB0aGlzLmxpc3QgPSB0aGlzLmVsZW1lbnRSZWYubmF0aXZlRWxlbWVudC5xdWVyeVNlbGVjdG9yKHRoaXMublNjcm9sbGFibGVMaXN0KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNjcm9sbFVwVGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZW92ZXJcIiwgKCkgPT4gdGhpcy5vbkhvdmVyVXAodHJ1ZSkpO1xuICAgICAgICB0aGlzLnNjcm9sbFVwVGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZW91dFwiLCAoKSA9PiB0aGlzLm9uSG92ZXJVcChmYWxzZSkpO1xuICAgICAgICB0aGlzLnNjcm9sbERvd25UYXJnZXQuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlb3ZlclwiLCAoKSA9PiB0aGlzLm9uSG92ZXJEb3duKHRydWUpKTtcbiAgICAgICAgdGhpcy5zY3JvbGxEb3duVGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZW91dFwiLCAoKSA9PiB0aGlzLm9uSG92ZXJEb3duKGZhbHNlKSk7XG4gICAgfVxuICAgIHVwZGF0ZVNjcm9sbEhlaWdodCgpIHtcbiAgICAgICAgaWYgKHRoaXMuc2Nyb2xsRW5hYmxlZCkge1xuICAgICAgICAgICAgY29uc3QgY29udGFpbmVyID0gdGhpcy5lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQucGFyZW50RWxlbWVudDtcbiAgICAgICAgICAgIGNvbnN0IGNvbnRhaW5lclJlY3QgPSBjb250YWluZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICAgICBjb25zdCBpbm5lckhlaWdodERpZmYgPSB0aGlzLmxpc3QuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkudG9wIC0gY29udGFpbmVyUmVjdC50b3A7XG4gICAgICAgICAgICBjb25zdCBvdXRlckhlaWdodERpZmYgPSBjb250YWluZXJSZWN0LmhlaWdodCAtIChjb250YWluZXJSZWN0LmJvdHRvbSAtIHdpbmRvdy5pbm5lckhlaWdodCk7XG4gICAgICAgICAgICAvLyA0MCBnaXZlcyB1cyBzb21lIHBhZGRpbmcgYmV0d2VlbiB0aGUgYm90dG9tIG9mIHRoZSBsaXN0LFxuICAgICAgICAgICAgLy8gdGhlIGJvdHRvbSBvZiB0aGUgd2luZG93LCBhbmQgdGhlIHNjcm9sbCBkb3duIGJ1dHRvblxuICAgICAgICAgICAgY29uc3QgaGVpZ2h0ID0gb3V0ZXJIZWlnaHREaWZmIC0gaW5uZXJIZWlnaHREaWZmIC0gNDA7XG4gICAgICAgICAgICB0aGlzLmxpc3Quc3R5bGUuaGVpZ2h0ID0gYCR7aGVpZ2h0fXB4YDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjaGVja1Njcm9sbEFycm93cygpIHtcbiAgICAgICAgY29uc3Qgc2Nyb2xsVXBIZWlnaHQgPSB0aGlzLnNjcm9sbFVwVGFyZ2V0Lm9mZnNldEhlaWdodDtcbiAgICAgICAgY29uc3Qgc2Nyb2xsRG93bkhlaWdodCA9IHRoaXMuc2Nyb2xsRG93blRhcmdldC5vZmZzZXRIZWlnaHQ7XG4gICAgICAgIGlmICh0aGlzLmxpc3Quc2Nyb2xsVG9wID09PSAwKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5jYW5TY3JvbGxVcCkge1xuICAgICAgICAgICAgICAgIHRoaXMubGlzdC5zdHlsZS5oZWlnaHQgPSBgJHtwYXJzZUludCh0aGlzLmxpc3Quc3R5bGUuaGVpZ2h0LCAxMCkgKyBzY3JvbGxVcEhlaWdodH1weGA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnNjcm9sbFVwVGFyZ2V0LnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjtcbiAgICAgICAgICAgIHRoaXMuY2FuU2Nyb2xsVXAgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLmxpc3Quc2Nyb2xsVG9wID09PSB0aGlzLmxpc3Quc2Nyb2xsVG9wTWF4KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5jYW5TY3JvbGxEb3duKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5saXN0LnN0eWxlLmhlaWdodCA9IGAke3BhcnNlSW50KHRoaXMubGlzdC5zdHlsZS5oZWlnaHQsIDEwKSArIHNjcm9sbERvd25IZWlnaHR9cHhgO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5zY3JvbGxEb3duVGFyZ2V0LnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjtcbiAgICAgICAgICAgIHRoaXMuY2FuU2Nyb2xsRG93biA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmNhblNjcm9sbFVwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5saXN0LnN0eWxlLmhlaWdodCA9IGAke3BhcnNlSW50KHRoaXMubGlzdC5zdHlsZS5oZWlnaHQsIDEwKSAtIHNjcm9sbFVwSGVpZ2h0fXB4YDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghdGhpcy5jYW5TY3JvbGxEb3duKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5saXN0LnN0eWxlLmhlaWdodCA9IGAke3BhcnNlSW50KHRoaXMubGlzdC5zdHlsZS5oZWlnaHQsIDEwKSAtIHNjcm9sbERvd25IZWlnaHR9cHhgO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5zY3JvbGxVcFRhcmdldC5zdHlsZS5kaXNwbGF5ID0gXCJmbGV4XCI7XG4gICAgICAgICAgICB0aGlzLnNjcm9sbERvd25UYXJnZXQuc3R5bGUuZGlzcGxheSA9IFwiZmxleFwiO1xuICAgICAgICAgICAgdGhpcy5jYW5TY3JvbGxVcCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLmNhblNjcm9sbERvd24gPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIG9uV2hlZWwoZXZlbnQpIHtcbiAgICAgICAgaWYgKGV2ZW50LmRlbHRhWSA8IDApIHtcbiAgICAgICAgICAgIHRoaXMubGlzdC5zY3JvbGxUb3AgLT0gdGhpcy5zY3JvbGxCeTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMubGlzdC5zY3JvbGxUb3AgKz0gdGhpcy5zY3JvbGxCeTtcbiAgICAgICAgfVxuICAgICAgICAvLyBvbmx5IHByZXZlbnQgdGhlIHBhcmVudC93aW5kb3cgZnJvbSBzY3JvbGxpbmcgaWYgd2UgY2FuIHNjcm9sbFxuICAgICAgICBpZiAoISh0aGlzLmxpc3Quc2Nyb2xsVG9wID09PSB0aGlzLmxpc3Quc2Nyb2xsVG9wTWF4IHx8IHRoaXMubGlzdC5zY3JvbGxUb3AgPT09IDApKSB7XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jaGVja1Njcm9sbEFycm93cygpO1xuICAgIH1cbiAgICBvblRvdWNoU3RhcnQoZXZlbnQpIHtcbiAgICAgICAgaWYgKGV2ZW50LnRvdWNoZXNbMF0pIHtcbiAgICAgICAgICAgIHRoaXMubGFzdFRvdWNoID0gZXZlbnQudG91Y2hlc1swXS5jbGllbnRZO1xuICAgICAgICB9XG4gICAgfVxuICAgIG9uVG91Y2hNb3ZlKGV2ZW50KSB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICBpZiAoZXZlbnQudG91Y2hlc1swXSkge1xuICAgICAgICAgICAgY29uc3QgdG91Y2ggPSBldmVudC50b3VjaGVzWzBdO1xuICAgICAgICAgICAgdGhpcy5saXN0LnNjcm9sbFRvcCArPSB0aGlzLmxhc3RUb3VjaCAtIHRvdWNoLmNsaWVudFk7XG4gICAgICAgICAgICB0aGlzLmxhc3RUb3VjaCA9IHRvdWNoLmNsaWVudFk7XG4gICAgICAgICAgICB0aGlzLmNoZWNrU2Nyb2xsQXJyb3dzKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaG92ZXJTY3JvbGxCeShob3ZlcmluZywgYW1vdW50KSB7XG4gICAgICAgIGlmIChob3ZlcmluZykge1xuICAgICAgICAgICAgdGhpcy5ob3ZlclNjcm9sbEludGVydmFsID0gc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMubGlzdC5zY3JvbGxUb3AgKz0gYW1vdW50O1xuICAgICAgICAgICAgICAgIHRoaXMuY2hlY2tTY3JvbGxBcnJvd3MoKTtcbiAgICAgICAgICAgIH0sIDEpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLmhvdmVyU2Nyb2xsSW50ZXJ2YWwpO1xuICAgICAgICB9XG4gICAgfVxuICAgIG9uSG92ZXJVcChob3ZlcmluZykge1xuICAgICAgICAvLyBob3cgbWFueSBweC9saW5lcyB0byBzY3JvbGwgYnkgb24gaG92ZXJcbiAgICAgICAgLy8gMyBpcyBqdXN0IGEgcmFuZG9tIG51bWJlciB0aGF0IGZlbHQgZ29vZFxuICAgICAgICAvLyAxIGFuZCAyIGFyZSB0b28gc2xvdywgNCB3b3JrcyBidXQgaXQgbWlnaHQgYmUgYSB0YWQgZmFzdFxuICAgICAgICB0aGlzLmhvdmVyU2Nyb2xsQnkoaG92ZXJpbmcsIC0zKTtcbiAgICB9XG4gICAgb25Ib3ZlckRvd24oaG92ZXJpbmcpIHtcbiAgICAgICAgdGhpcy5ob3ZlclNjcm9sbEJ5KGhvdmVyaW5nLCAzKTtcbiAgICB9XG4gICAgb25LZXlEb3duKGV2ZW50KSB7XG4gICAgICAgIGlmIChldmVudC5rZXkgPT09IFwiQXJyb3dEb3duXCIgfHwgZXZlbnQua2V5ID09PSBcIkFycm93VXBcIikge1xuICAgICAgICAgICAgdGhpcy5jaGVja1Njcm9sbEFycm93cygpO1xuICAgICAgICB9XG4gICAgfVxufVxuU2Nyb2xsYWJsZUxpc3QuybVmYWMgPSBpMC7Jtcm1bmdEZWNsYXJlRmFjdG9yeSh7IG1pblZlcnNpb246IFwiMTIuMC4wXCIsIHZlcnNpb246IFwiMTQuMy4wXCIsIG5nSW1wb3J0OiBpMCwgdHlwZTogU2Nyb2xsYWJsZUxpc3QsIGRlcHM6IFt7IHRva2VuOiBpMC5FbGVtZW50UmVmIH1dLCB0YXJnZXQ6IGkwLsm1ybVGYWN0b3J5VGFyZ2V0LkRpcmVjdGl2ZSB9KTtcblNjcm9sbGFibGVMaXN0Lsm1ZGlyID0gaTAuybXJtW5nRGVjbGFyZURpcmVjdGl2ZSh7IG1pblZlcnNpb246IFwiMTQuMC4wXCIsIHZlcnNpb246IFwiMTQuMy4wXCIsIHR5cGU6IFNjcm9sbGFibGVMaXN0LCBzZWxlY3RvcjogXCJbY2RzU2Nyb2xsYWJsZUxpc3RdLCBbaWJtU2Nyb2xsYWJsZUxpc3RdXCIsIGlucHV0czogeyBuU2Nyb2xsYWJsZUxpc3Q6IFwiblNjcm9sbGFibGVMaXN0XCIsIHNjcm9sbEVuYWJsZWQ6IFwic2Nyb2xsRW5hYmxlZFwiLCBzY3JvbGxVcFRhcmdldDogXCJzY3JvbGxVcFRhcmdldFwiLCBzY3JvbGxEb3duVGFyZ2V0OiBcInNjcm9sbERvd25UYXJnZXRcIiwgc2Nyb2xsQnk6IFwic2Nyb2xsQnlcIiB9LCBob3N0OiB7IGxpc3RlbmVyczogeyBcIndoZWVsXCI6IFwib25XaGVlbCgkZXZlbnQpXCIsIFwidG91Y2hzdGFydFwiOiBcIm9uVG91Y2hTdGFydCgkZXZlbnQpXCIsIFwidG91Y2htb3ZlXCI6IFwib25Ub3VjaE1vdmUoJGV2ZW50KVwiLCBcImtleWRvd25cIjogXCJvbktleURvd24oJGV2ZW50KVwiIH0gfSwgZXhwb3J0QXM6IFtcInNjcm9sbGFibGUtbGlzdFwiXSwgdXNlc09uQ2hhbmdlczogdHJ1ZSwgbmdJbXBvcnQ6IGkwIH0pO1xuaTAuybXJtW5nRGVjbGFyZUNsYXNzTWV0YWRhdGEoeyBtaW5WZXJzaW9uOiBcIjEyLjAuMFwiLCB2ZXJzaW9uOiBcIjE0LjMuMFwiLCBuZ0ltcG9ydDogaTAsIHR5cGU6IFNjcm9sbGFibGVMaXN0LCBkZWNvcmF0b3JzOiBbe1xuICAgICAgICAgICAgdHlwZTogRGlyZWN0aXZlLFxuICAgICAgICAgICAgYXJnczogW3tcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0b3I6IFwiW2Nkc1Njcm9sbGFibGVMaXN0XSwgW2libVNjcm9sbGFibGVMaXN0XVwiLFxuICAgICAgICAgICAgICAgICAgICBleHBvcnRBczogXCJzY3JvbGxhYmxlLWxpc3RcIlxuICAgICAgICAgICAgICAgIH1dXG4gICAgICAgIH1dLCBjdG9yUGFyYW1ldGVyczogZnVuY3Rpb24gKCkgeyByZXR1cm4gW3sgdHlwZTogaTAuRWxlbWVudFJlZiB9XTsgfSwgcHJvcERlY29yYXRvcnM6IHsgblNjcm9sbGFibGVMaXN0OiBbe1xuICAgICAgICAgICAgICAgIHR5cGU6IElucHV0XG4gICAgICAgICAgICB9XSwgc2Nyb2xsRW5hYmxlZDogW3tcbiAgICAgICAgICAgICAgICB0eXBlOiBJbnB1dFxuICAgICAgICAgICAgfV0sIHNjcm9sbFVwVGFyZ2V0OiBbe1xuICAgICAgICAgICAgICAgIHR5cGU6IElucHV0XG4gICAgICAgICAgICB9XSwgc2Nyb2xsRG93blRhcmdldDogW3tcbiAgICAgICAgICAgICAgICB0eXBlOiBJbnB1dFxuICAgICAgICAgICAgfV0sIHNjcm9sbEJ5OiBbe1xuICAgICAgICAgICAgICAgIHR5cGU6IElucHV0XG4gICAgICAgICAgICB9XSwgb25XaGVlbDogW3tcbiAgICAgICAgICAgICAgICB0eXBlOiBIb3N0TGlzdGVuZXIsXG4gICAgICAgICAgICAgICAgYXJnczogW1wid2hlZWxcIiwgW1wiJGV2ZW50XCJdXVxuICAgICAgICAgICAgfV0sIG9uVG91Y2hTdGFydDogW3tcbiAgICAgICAgICAgICAgICB0eXBlOiBIb3N0TGlzdGVuZXIsXG4gICAgICAgICAgICAgICAgYXJnczogW1widG91Y2hzdGFydFwiLCBbXCIkZXZlbnRcIl1dXG4gICAgICAgICAgICB9XSwgb25Ub3VjaE1vdmU6IFt7XG4gICAgICAgICAgICAgICAgdHlwZTogSG9zdExpc3RlbmVyLFxuICAgICAgICAgICAgICAgIGFyZ3M6IFtcInRvdWNobW92ZVwiLCBbXCIkZXZlbnRcIl1dXG4gICAgICAgICAgICB9XSwgb25LZXlEb3duOiBbe1xuICAgICAgICAgICAgICAgIHR5cGU6IEhvc3RMaXN0ZW5lcixcbiAgICAgICAgICAgICAgICBhcmdzOiBbXCJrZXlkb3duXCIsIFtcIiRldmVudFwiXV1cbiAgICAgICAgICAgIH1dIH0gfSk7XG5cbmNsYXNzIERyb3Bkb3duTW9kdWxlIHtcbn1cbkRyb3Bkb3duTW9kdWxlLsm1ZmFjID0gaTAuybXJtW5nRGVjbGFyZUZhY3RvcnkoeyBtaW5WZXJzaW9uOiBcIjEyLjAuMFwiLCB2ZXJzaW9uOiBcIjE0LjMuMFwiLCBuZ0ltcG9ydDogaTAsIHR5cGU6IERyb3Bkb3duTW9kdWxlLCBkZXBzOiBbXSwgdGFyZ2V0OiBpMC7Jtcm1RmFjdG9yeVRhcmdldC5OZ01vZHVsZSB9KTtcbkRyb3Bkb3duTW9kdWxlLsm1bW9kID0gaTAuybXJtW5nRGVjbGFyZU5nTW9kdWxlKHsgbWluVmVyc2lvbjogXCIxNC4wLjBcIiwgdmVyc2lvbjogXCIxNC4zLjBcIiwgbmdJbXBvcnQ6IGkwLCB0eXBlOiBEcm9wZG93bk1vZHVsZSwgZGVjbGFyYXRpb25zOiBbRHJvcGRvd24sXG4gICAgICAgIERyb3Bkb3duTGlzdCxcbiAgICAgICAgU2Nyb2xsYWJsZUxpc3QsXG4gICAgICAgIEFic3RyYWN0RHJvcGRvd25WaWV3XSwgaW1wb3J0czogW0NvbW1vbk1vZHVsZSxcbiAgICAgICAgRm9ybXNNb2R1bGUsXG4gICAgICAgIEkxOG5Nb2R1bGUsXG4gICAgICAgIFBsYWNlaG9sZGVyTW9kdWxlLFxuICAgICAgICBVdGlsc01vZHVsZSxcbiAgICAgICAgSWNvbk1vZHVsZV0sIGV4cG9ydHM6IFtEcm9wZG93bixcbiAgICAgICAgRHJvcGRvd25MaXN0LFxuICAgICAgICBTY3JvbGxhYmxlTGlzdCxcbiAgICAgICAgQWJzdHJhY3REcm9wZG93blZpZXddIH0pO1xuRHJvcGRvd25Nb2R1bGUuybVpbmogPSBpMC7Jtcm1bmdEZWNsYXJlSW5qZWN0b3IoeyBtaW5WZXJzaW9uOiBcIjEyLjAuMFwiLCB2ZXJzaW9uOiBcIjE0LjMuMFwiLCBuZ0ltcG9ydDogaTAsIHR5cGU6IERyb3Bkb3duTW9kdWxlLCBwcm92aWRlcnM6IFtEcm9wZG93blNlcnZpY2VdLCBpbXBvcnRzOiBbQ29tbW9uTW9kdWxlLFxuICAgICAgICBGb3Jtc01vZHVsZSxcbiAgICAgICAgSTE4bk1vZHVsZSxcbiAgICAgICAgUGxhY2Vob2xkZXJNb2R1bGUsXG4gICAgICAgIFV0aWxzTW9kdWxlLFxuICAgICAgICBJY29uTW9kdWxlXSB9KTtcbmkwLsm1ybVuZ0RlY2xhcmVDbGFzc01ldGFkYXRhKHsgbWluVmVyc2lvbjogXCIxMi4wLjBcIiwgdmVyc2lvbjogXCIxNC4zLjBcIiwgbmdJbXBvcnQ6IGkwLCB0eXBlOiBEcm9wZG93bk1vZHVsZSwgZGVjb3JhdG9yczogW3tcbiAgICAgICAgICAgIHR5cGU6IE5nTW9kdWxlLFxuICAgICAgICAgICAgYXJnczogW3tcbiAgICAgICAgICAgICAgICAgICAgZGVjbGFyYXRpb25zOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICBEcm9wZG93bixcbiAgICAgICAgICAgICAgICAgICAgICAgIERyb3Bkb3duTGlzdCxcbiAgICAgICAgICAgICAgICAgICAgICAgIFNjcm9sbGFibGVMaXN0LFxuICAgICAgICAgICAgICAgICAgICAgICAgQWJzdHJhY3REcm9wZG93blZpZXdcbiAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgICAgZXhwb3J0czogW1xuICAgICAgICAgICAgICAgICAgICAgICAgRHJvcGRvd24sXG4gICAgICAgICAgICAgICAgICAgICAgICBEcm9wZG93bkxpc3QsXG4gICAgICAgICAgICAgICAgICAgICAgICBTY3JvbGxhYmxlTGlzdCxcbiAgICAgICAgICAgICAgICAgICAgICAgIEFic3RyYWN0RHJvcGRvd25WaWV3XG4gICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgICAgIGltcG9ydHM6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIENvbW1vbk1vZHVsZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIEZvcm1zTW9kdWxlLFxuICAgICAgICAgICAgICAgICAgICAgICAgSTE4bk1vZHVsZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIFBsYWNlaG9sZGVyTW9kdWxlLFxuICAgICAgICAgICAgICAgICAgICAgICAgVXRpbHNNb2R1bGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBJY29uTW9kdWxlXG4gICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgICAgIHByb3ZpZGVyczogW0Ryb3Bkb3duU2VydmljZV1cbiAgICAgICAgICAgICAgICB9XVxuICAgICAgICB9XSB9KTtcblxuLyoqXG4gKiBHZW5lcmF0ZWQgYnVuZGxlIGluZGV4LiBEbyBub3QgZWRpdC5cbiAqL1xuXG5leHBvcnQgeyBBYnN0cmFjdERyb3Bkb3duVmlldywgRHJvcGRvd24sIERyb3Bkb3duTGlzdCwgRHJvcGRvd25Nb2R1bGUsIERyb3Bkb3duU2VydmljZSwgU2Nyb2xsYWJsZUxpc3QgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNhcmJvbi1jb21wb25lbnRzLWFuZ3VsYXItZHJvcGRvd24ubWpzLm1hcFxuIiwiaW1wb3J0ICogYXMgaTAgZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBJbmplY3RhYmxlLCBQaXBlLCBPcHRpb25hbCwgU2tpcFNlbGYsIE5nTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBCZWhhdmlvclN1YmplY3QsIGlpZiwgaXNPYnNlcnZhYmxlIH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBtYXAgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5pbXBvcnQgeyBtZXJnZSB9IGZyb20gJ2NhcmJvbi1jb21wb25lbnRzLWFuZ3VsYXIvdXRpbHMnO1xuXG52YXIgRU4gPSB7XG4gICAgXCJCUkVBRENSVU1CXCI6IHtcbiAgICAgICAgXCJMQUJFTFwiOiBcIkJyZWFkY3J1bWJcIlxuICAgIH0sXG4gICAgXCJDT0RFX1NOSVBQRVRcIjoge1xuICAgICAgICBcIkNPREVfU05JUFBFVF9URVhUXCI6IFwiQ29kZSBTbmlwcGV0IFRleHRcIixcbiAgICAgICAgXCJTSE9XX01PUkVcIjogXCJTaG93IG1vcmVcIixcbiAgICAgICAgXCJTSE9XX0xFU1NcIjogXCJTaG93IGxlc3NcIixcbiAgICAgICAgXCJTSE9XX01PUkVfSUNPTlwiOiBcIlNob3cgbW9yZSBpY29uXCIsXG4gICAgICAgIFwiQ09QWV9DT0RFXCI6IFwiQ29weSBjb2RlXCIsXG4gICAgICAgIFwiQ09QSUVEXCI6IFwiQ29waWVkIVwiXG4gICAgfSxcbiAgICBcIkNPTUJPQk9YXCI6IHtcbiAgICAgICAgXCJQTEFDRUhPTERFUlwiOiBcIkZpbHRlci4uLlwiLFxuICAgICAgICBcIkNMRUFSX1NFTEVDVElPTlNcIjogXCJDbGVhciBhbGwgc2VsZWN0ZWQgaXRlbXNcIixcbiAgICAgICAgXCJDTEVBUl9TRUxFQ1RFRFwiOiBcIkNsZWFyIHNlbGVjdGVkIGl0ZW1cIixcbiAgICAgICAgXCJBMTFZXCI6IHtcbiAgICAgICAgICAgIFwiT1BFTl9NRU5VXCI6IFwiT3BlbiBtZW51XCIsXG4gICAgICAgICAgICBcIkNMT1NFX01FTlVcIjogXCJDbG9zZSBtZW51XCIsXG4gICAgICAgICAgICBcIkNMRUFSX1NFTEVDVElPTlNcIjogXCJDbGVhciBhbGwgc2VsZWN0ZWQgaXRlbXNcIixcbiAgICAgICAgICAgIFwiQ0xFQVJfU0VMRUNURURcIjogXCJDbGVhciBTZWxlY3Rpb25cIlxuICAgICAgICB9XG4gICAgfSxcbiAgICBcIkRST1BET1dOXCI6IHtcbiAgICAgICAgXCJPUEVOXCI6IFwiT3BlbiBtZW51XCIsXG4gICAgICAgIFwiU0VMRUNURURcIjogXCJTZWxlY3RlZFwiLFxuICAgICAgICBcIkNMRUFSXCI6IFwiQ2xlYXIgYWxsIHNlbGVjdGVkIGl0ZW1zXCIsXG4gICAgICAgIFwiRklMVEVSXCI6IHtcbiAgICAgICAgICAgIFwiU0VMRUNURURfT05MWVwiOiBcIlNob3cgc2VsZWN0ZWQgb25seVwiLFxuICAgICAgICAgICAgXCJTRUFSQ0hcIjogXCJTZWFyY2hcIixcbiAgICAgICAgICAgIFwiTk9fUkVTVUxUU1wiOiBcIk5vIHNlYXJjaCByZXN1bHRzXCIsXG4gICAgICAgICAgICBcIlJFU0VUX1NFQVJDSFwiOiBcIlJlc2V0IHNlYXJjaFwiXG4gICAgICAgIH1cbiAgICB9LFxuICAgIFwiRFJPUERPV05fTElTVFwiOiB7XG4gICAgICAgIFwiTEFCRUxcIjogXCJMaXN0Ym94XCJcbiAgICB9LFxuICAgIFwiRklMRV9VUExPQURFUlwiOiB7XG4gICAgICAgIFwiQ0hFQ0tNQVJLXCI6IFwiQ2hlY2ttYXJrXCIsXG4gICAgICAgIFwiT1BFTlwiOiBcIkFkZCBmaWxlXCIsXG4gICAgICAgIFwiUkVNT1ZFX0JVVFRPTlwiOiBcIkNsb3NlIGJ1dHRvblwiXG4gICAgfSxcbiAgICBcIkxPQURJTkdcIjoge1xuICAgICAgICBcIlRJVExFXCI6IFwiTG9hZGluZ1wiXG4gICAgfSxcbiAgICBcIk1PREFMXCI6IHtcbiAgICAgICAgXCJDTE9TRVwiOiBcIkNsb3NlIG1vZGFsXCJcbiAgICB9LFxuICAgIFwiTk9USUZJQ0FUSU9OXCI6IHtcbiAgICAgICAgXCJDTE9TRV9CVVRUT05cIjogXCJDbG9zZSBhbGVydCBub3RpZmljYXRpb25cIlxuICAgIH0sXG4gICAgXCJOVU1CRVJcIjoge1xuICAgICAgICBcIklOQ1JFTUVOVFwiOiBcIkluY3JlbWVudCB2YWx1ZVwiLFxuICAgICAgICBcIkRFQ1JFTUVOVFwiOiBcIkRlY3JlbWVudCB2YWx1ZVwiXG4gICAgfSxcbiAgICBcIk9WRVJGTE9XX01FTlVcIjoge1xuICAgICAgICBcIk9WRVJGTE9XXCI6IFwiT3ZlcmZsb3dcIlxuICAgIH0sXG4gICAgXCJTRUFSQ0hcIjoge1xuICAgICAgICBcIkxBQkVMXCI6IFwiU2VhcmNoXCIsXG4gICAgICAgIFwiUExBQ0VIT0xERVJcIjogXCJTZWFyY2hcIixcbiAgICAgICAgXCJDTEVBUl9CVVRUT05cIjogXCJDbGVhciBzZWFyY2ggaW5wdXRcIlxuICAgIH0sXG4gICAgXCJQQUdJTkFUSU9OXCI6IHtcbiAgICAgICAgXCJJVEVNU19QRVJfUEFHRVwiOiBcIkl0ZW1zIHBlciBwYWdlOlwiLFxuICAgICAgICBcIk9QRU5fTElTVF9PRl9PUFRJT05TXCI6IFwiT3BlbiBsaXN0IG9mIG9wdGlvbnNcIixcbiAgICAgICAgXCJCQUNLV0FSRFwiOiBcIkJhY2t3YXJkXCIsXG4gICAgICAgIFwiRk9SV0FSRFwiOiBcIkZvcndhcmRcIixcbiAgICAgICAgXCJUT1RBTF9JVEVNU19VTktOT1dOXCI6IFwie3tzdGFydH19LXt7ZW5kfX0gaXRlbXNcIixcbiAgICAgICAgXCJUT1RBTF9JVEVNU1wiOiBcInt7c3RhcnR9fS17e2VuZH19IG9mIHt7dG90YWx9fSBpdGVtc1wiLFxuICAgICAgICBcIlRPVEFMX0lURU1cIjogXCJ7e3N0YXJ0fX0te3tlbmR9fSBvZiB7e3RvdGFsfX0gaXRlbVwiLFxuICAgICAgICBcIlBBR0VcIjogXCJwYWdlXCIsXG4gICAgICAgIFwiT0ZfTEFTVF9QQUdFU1wiOiBcIm9mIHt7bGFzdH19IHBhZ2VzXCIsXG4gICAgICAgIFwiT0ZfTEFTVF9QQUdFXCI6IFwib2Yge3tsYXN0fX0gcGFnZVwiLFxuICAgICAgICBcIk5FWFRcIjogXCJOZXh0XCIsXG4gICAgICAgIFwiUFJFVklPVVNcIjogXCJQcmV2aW91c1wiLFxuICAgICAgICBcIlNFTEVDVF9BUklBXCI6IFwiU2VsZWN0IHBhZ2UgbnVtYmVyXCJcbiAgICB9LFxuICAgIFwiUFJPR1JFU1NfSU5ESUNBVE9SXCI6IHtcbiAgICAgICAgXCJDVVJSRU5UXCI6IFwiQ3VycmVudFwiLFxuICAgICAgICBcIklOQ09NUExFVEVcIjogXCJJbmNvbXBsZXRlXCIsXG4gICAgICAgIFwiQ09NUExFVEVcIjogXCJDb21wbGV0ZVwiLFxuICAgICAgICBcIklOVkFMSURcIjogXCJJbnZhbGlkXCJcbiAgICB9LFxuICAgIFwiVEFCTEVcIjoge1xuICAgICAgICBcIkZJTFRFUlwiOiBcIkZpbHRlclwiLFxuICAgICAgICBcIkVORF9PRl9EQVRBXCI6IFwiWW91J3ZlIHJlYWNoZWQgdGhlIGVuZCBvZiB5b3VyIGNvbnRlbnRcIixcbiAgICAgICAgXCJTQ1JPTExfVE9QXCI6IFwiU2Nyb2xsIHRvIHRvcFwiLFxuICAgICAgICBcIkNIRUNLQk9YX0hFQURFUlwiOiBcIlNlbGVjdCBhbGwgcm93c1wiLFxuICAgICAgICBcIkNIRUNLQk9YX1JPV1wiOiBcIlNlbGVjdCB7e3ZhbHVlfX1cIixcbiAgICAgICAgXCJFWFBBTkRfQlVUVE9OXCI6IFwiRXhwYW5kIHJvd1wiLFxuICAgICAgICBcIlNPUlRfREVTQ0VORElOR1wiOiBcIlNvcnQgcm93cyBieSB0aGlzIGhlYWRlciBpbiBkZXNjZW5kaW5nIG9yZGVyXCIsXG4gICAgICAgIFwiU09SVF9BU0NFTkRJTkdcIjogXCJTb3J0IHJvd3MgYnkgdGhpcyBoZWFkZXIgaW4gYXNjZW5kaW5nIG9yZGVyXCIsXG4gICAgICAgIFwiUk9XXCI6IFwicm93XCJcbiAgICB9LFxuICAgIFwiVEFCTEVfVE9PTEJBUlwiOiB7XG4gICAgICAgIFwiQUNUSU9OX0JBUlwiOiBcIlRhYmxlIGFjdGlvbiBiYXJcIixcbiAgICAgICAgXCJCQVRDSF9URVhUXCI6IFwiXCIsXG4gICAgICAgIFwiQkFUQ0hfVEVYVF9TSU5HTEVcIjogXCIxIGl0ZW0gc2VsZWN0ZWRcIixcbiAgICAgICAgXCJCQVRDSF9URVhUX01VTFRJUExFXCI6IFwie3tjb3VudH19IGl0ZW1zIHNlbGVjdGVkXCIsXG4gICAgICAgIFwiQ0FOQ0VMXCI6IFwiQ2FuY2VsXCJcbiAgICB9LFxuICAgIFwiVEFCU1wiOiB7XG4gICAgICAgIFwiQlVUVE9OX0FSSUFfTEVGVFwiOiBcIkdvIHRvIHRoZSBwcmV2aW91cyB0YWJcIixcbiAgICAgICAgXCJCVVRUT05fQVJJQV9SSUdIVFwiOiBcIkdvIHRvIHRoZSBuZXh0IHRhYlwiLFxuICAgICAgICBcIkhFQURFUl9BUklBX0xBQkVMXCI6IFwiTGlzdCBvZiB0YWJzXCJcbiAgICB9LFxuICAgIFwiVElMRVNcIjoge1xuICAgICAgICBcIlRJTEVcIjogXCJ0aWxlXCIsXG4gICAgICAgIFwiRVhQQU5EXCI6IFwiRXhwYW5kXCIsXG4gICAgICAgIFwiQ09MTEFQU0VcIjogXCJDb2xsYXBzZVwiXG4gICAgfSxcbiAgICBcIlRPR0dMRVwiOiB7XG4gICAgICAgIFwiT0ZGXCI6IFwiT2ZmXCIsXG4gICAgICAgIFwiT05cIjogXCJPblwiXG4gICAgfSxcbiAgICBcIlVJX1NIRUxMXCI6IHtcbiAgICAgICAgXCJTS0lQX1RPXCI6IFwiU2tpcCB0byBjb250ZW50XCIsXG4gICAgICAgIFwiSEVBREVSXCI6IHtcbiAgICAgICAgICAgIFwiT1BFTl9NRU5VXCI6IFwiT3BlbiBtZW51XCIsXG4gICAgICAgICAgICBcIkNMT1NFX01FTlVcIjogXCJDbG9zZSBtZW51XCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJTSURFX05BVlwiOiB7XG4gICAgICAgICAgICBcIlRPR0dMRV9PUEVOXCI6IFwiT3BlblwiLFxuICAgICAgICAgICAgXCJUT0dHTEVfQ0xPU0VcIjogXCJDbG9zZVwiXG4gICAgICAgIH1cbiAgICB9XG59O1xuXG4vKipcbiAqIFRha2VzIHRoZSBgT2JzZXJ2YWJsZWAgcmV0dXJuZWQgZnJvbSBgaTE4bi5nZXRgIGFuZCBhbiBvYmplY3Qgb2YgdmFyaWFibGVzIHRvIHJlcGxhY2UuXG4gKlxuICogVGhlIGtleXMgc3BlY2lmeSB0aGUgdmFyaWFibGUgbmFtZSBpbiB0aGUgc3RyaW5nLlxuICpcbiAqIEV4YW1wbGU6XG4gKiBgYGB0eXBlc2NyaXB0XG4gKiBzZXJ2aWNlLnNldCh7IFwiVEVTVFwiOiBcInt7Zm9vfX0ge3tiYXJ9fVwiIH0pO1xuICpcbiAqIHNlcnZpY2UucmVwbGFjZShzZXJ2aWNlLmdldChcIlRFU1RcIiksIHsgZm9vOiBcInRlc3RcIiwgYmFyOiBcImFzZGZcIiB9KVxuICogYGBgXG4gKlxuICogUHJvZHVjZXM6IGBcInRlc3QgYXNkZlwiYFxuICpcbiAqIEBwYXJhbSBzdWJqZWN0IHRoZSB0cmFuc2xhdGlvbiB0byByZXBsYWNlIHZhcmlhYmxlcyBvblxuICogQHBhcmFtIHZhcmlhYmxlcyBvYmplY3Qgb2YgdmFyaWFibGVzIHRvIHJlcGxhY2VcbiAqL1xuY29uc3QgcmVwbGFjZSA9IChzdWJqZWN0LCB2YXJpYWJsZXMpID0+IHN1YmplY3QucGlwZShtYXAoc3RyID0+IHtcbiAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXModmFyaWFibGVzKTtcbiAgICBmb3IgKGNvbnN0IGtleSBvZiBrZXlzKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gdmFyaWFibGVzW2tleV07XG4gICAgICAgIHN0ciA9IHN0ci5yZXBsYWNlKG5ldyBSZWdFeHAoYHt7XFxcXHMqJHtrZXl9XFxcXHMqfX1gLCBcImdcIiksIHZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIHN0cjtcbn0pKTtcbi8qKlxuICogUmVwcmVzZW50cyBhbiBcIm92ZXJyaWRhYmxlXCIgdHJhbnNsYXRpb24gdmFsdWUuXG4gKlxuICogTGFyZ2VseSBhbiBpbnRlcm5hbCB1c2VjYXNlLiBUaGVyZSBhcmUgc2l0dWF0aW9ucyB3aGVyZSB3ZSB3YW50IGFuIGBPYnNlcnZhYmxlYCB0aGF0XG4gKiBjYW4gZW1pdCBldmVudHMgZnJvbSBhIGNlbnRyYWxpemVkIHNvdXJjZSAqKk9SKiogYW4gYE9ic2VydmFibGVgIHRoYXQgd2lsbCBlbWl0IGV2ZW50c1xuICogZnJvbSBhIGNvbXBvbmVudCBsb2NhbCBzb3VyY2UuIFRoZSBrZXkgZXhhbXBsZSBiZWluZyBvbi9vZmYgdGV4dCBpbiBhIGBUb2dnbGVgIC0gSW4gc29tZSBjYXNlc1xuICogd2Ugd2FudCB0aGUgYFRvZ2dsZWAgdG8gdXNlIGBJMThuYHMgZ2xvYmFsIHRyYW5zbGF0aW9ucywgYnV0IGluIG90aGVycyB3ZSdkIHByZWZlciB0byB1c2UgYSBsb2NhbFxuICogb3ZlcnJpZGUuIFdlIGRvbid0IGV2ZXIgbmVlZCB0byByZXR1cm4gdG8gYSBub24tb3ZlcnJpZGRlbiBzdGF0ZSwgYnV0IHdlIGRvIG5lZWQgdGhlIGFiaWxpdHkgdG9cbiAqIHN3aXRjaCBfdG9fIGFuIG92ZXJyaWRkZW4gc2F0ZS5cbiAqL1xuY2xhc3MgT3ZlcnJpZGFibGUge1xuICAgIGNvbnN0cnVjdG9yKHBhdGgsIGkxOG4pIHtcbiAgICAgICAgdGhpcy5wYXRoID0gcGF0aDtcbiAgICAgICAgdGhpcy5pMThuID0gaTE4bjtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE91ciBiYXNlIG5vbi1vdmVycmlkZGVuIHRyYW5zbGF0aW9uLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5iYXNlVHJhbnNsYXRpb24gPSB0aGlzLmkxOG4uZ2V0KHRoaXMucGF0aCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIGJvb2xlYW4gdG8gZmxpcCBiZXR3ZWVuIG92ZXJyaWRkZW4gYW5kIG5vbi1vdmVycmlkZGVuIHN0YXRlcy5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuaXNPdmVycmlkZGVuID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBlbnN1cmUgYCRvdmVycmlkZWAgaXMgaW5pdGlhbGl6ZWQgd2l0aCB0aGUgY29ycmVjdCBkZWZhdWx0IHZhbHVlXG4gICAgICAgICAqIGluIHNvbWUgY2FzZXMgYF92YWx1ZWAgY2FuIGdldCBjaGFuZ2VkIGZvciBhbiBgT2JzZXJ2YWJsZWAgYmVmb3JlIGAkb3ZlcnJpZGVgIGlzIGNyZWF0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy5pMThuLmdldFZhbHVlRnJvbVBhdGgodGhpcy5wYXRoKTtcbiAgICAgICAgdGhpcy4kb3ZlcnJpZGUgPSBuZXcgQmVoYXZpb3JTdWJqZWN0KHZhbHVlKTtcbiAgICAgICAgdGhpcy5fdmFsdWUgPSB2YWx1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIHJhdyB2YWx1ZSBvZiB0aGUgdHJhbnNsYXRpb24uIERlZmF1bHRzIHRvIHRoZSBzdHJpbmcgdmFsdWUsIGJ1dCB3aWxsIHJldHVybiB0aGUgdmFsdWUgcGFzc2VkIHRvIGBvdmVycmlkZWBcbiAgICAgKlxuICAgICAqIEByZWFkb25seVxuICAgICAqL1xuICAgIGdldCB2YWx1ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ZhbHVlO1xuICAgIH1cbiAgICBzZXQgdmFsdWUodikge1xuICAgICAgICB0aGlzLm92ZXJyaWRlKHYpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgdHJhbnNsYXRpb24gc3ViamVjdC4gUmV0dXJucyBlaXRoZXIgYSBzdHJlYW0gb2Ygb3ZlcnJpZGRlbiB2YWx1ZXMsIG9yIG91ciBiYXNlIHRyYW5zbGF0aW9uIHZhbHVlcy5cbiAgICAgKlxuICAgICAqIEByZWFkb25seVxuICAgICAqL1xuICAgIGdldCBzdWJqZWN0KCkge1xuICAgICAgICAvKipcbiAgICAgICAgICogc2luY2UgaW5wdXRzIGFyZSBib3VuZCBvbiB0ZW1wbGF0ZSBpbnN0YW50aWF0aW9uIChhbmQgdGh1c2x5IHdpbGwgYWx3YXlzIGhhdmUgX3NvbWVfIHZhbHVlKVxuICAgICAgICAgKiBXZSBjYW4gdXNlIGEgc2ltcGxlIGJvb2xlYW4gYW5kIHRoZSBgaWlmYCBmdW5jdGlvbiB0byBkZXRlcm1pbmUgd2hpY2ggc3ViamVjdCB0byByZXR1cm4gb24gc3Vic2NyaXB0aW9uXG4gICAgICAgICAqL1xuICAgICAgICByZXR1cm4gaWlmKCgpID0+IHRoaXMuaXNPdmVycmlkZGVuLCB0aGlzLiRvdmVycmlkZSwgdGhpcy5iYXNlVHJhbnNsYXRpb24pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUYWtlcyBhIHN0cmluZyBvciBhbiBgT2JzZXJ2YWJsZWAgdGhhdCBlbWl0cyBzdHJpbmdzLlxuICAgICAqIE92ZXJyaWRlcyB0aGUgdmFsdWUgcHJvdmlkZWQgYnkgdGhlIGBJMThuYCBzZXJ2aWNlLlxuICAgICAqL1xuICAgIG92ZXJyaWRlKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuaXNPdmVycmlkZGVuID0gdHJ1ZTtcbiAgICAgICAgLy8gVG8gZW5zdXJlIHRoYXQgdGhlcmUgYXJlIG5vdCBtdWx0aXBsZSBzdWJzY3JpcHRpb25zIGNyZWF0ZWQgZm9yIHRoZSBzYW1lIG9ic2VydmFibGUsIHdlXG4gICAgICAgIC8vIHVuc3Vic2NyaWJlIGlmIGEgc3Vic2NyaXB0aW9uIGFscmVhZHkgZXhpc3RzIGZvciBhbiBvYnNlcnZhYmxlIGJlZm9yZSBjcmVhdGluZyBhIG5ldyBvbmUuXG4gICAgICAgIGlmICh0aGlzLnN1YnNjcmlwdGlvbikge1xuICAgICAgICAgICAgdGhpcy5zdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgIHRoaXMuc3Vic2NyaXB0aW9uID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl92YWx1ZSA9IHZhbHVlO1xuICAgICAgICBpZiAoaXNPYnNlcnZhYmxlKHZhbHVlKSkge1xuICAgICAgICAgICAgdGhpcy5zdWJzY3JpcHRpb24gPSB2YWx1ZS5zdWJzY3JpYmUodiA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy4kb3ZlcnJpZGUubmV4dCh2KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy4kb3ZlcnJpZGUubmV4dCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG59XG4vKipcbiAqIFRoZSBJMThuIHNlcnZpY2UgaXMgYSBtaW5pbWFsIGludGVybmFsIHNpbmdsZXRvbiBzZXJ2aWNlIHVzZWQgdG8gc3VwcGx5IG91ciBjb21wb25lbnRzIHdpdGggdHJhbnNsYXRlZCBzdHJpbmdzLlxuICpcbiAqIEFsbCB0aGUgY29tcG9uZW50cyB0aGF0IHN1cHBvcnQgSTE4biBhbHNvIHN1cHBvcnQgZGlyZWN0bHkgcGFzc2VkIHN0cmluZ3MuXG4gKiBVc2FnZSBvZiBJMThuIGlzIG9wdGlvbmFsLCBhbmQgaXQgaXMgbm90IHJlY29tbWVuZGVkIGZvciBhcHBsaWNhdGlvbiB1c2UgKGxpYnJhcmllcyBsaWtlIG5neC10cmFuc2xhdGVcbiAqIGFyZSBhIGJldHRlciBjaG9pY2UpXG4gKlxuICovXG5jbGFzcyBJMThuIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy50cmFuc2xhdGlvblN0cmluZ3MgPSBFTjtcbiAgICAgICAgdGhpcy50cmFuc2xhdGlvbnMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMubG9jYWxlID0gbmV3IEJlaGF2aW9yU3ViamVjdChcImVuXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBsb2NhbGUgYW5kIG9wdGlvbmFsbHkgdGhlIHRyYW5zbGF0aW9uIHN0cmluZ3MuIExvY2FsZSBpcyB1c2VkIGJ5IGNvbXBvbmVudHMgdGhhdFxuICAgICAqIGFyZSBhbHJlYWR5IGxvY2FsZSBhd2FyZSAoZGF0ZXBpY2tlciBmb3IgZXhhbXBsZSkgd2hpbGUgdGhlIHRyYW5zbGF0aW9uIHN0cmluZ3MgYXJlIHVzZWRcbiAgICAgKiBmb3IgY29tcG9uZW50cyB0aGF0IGFyZSBub3QuXG4gICAgICpcbiAgICAgKiBMb2NhbGVzIHNldCBoZXJlIHdpbGwgb3ZlcnJpZGUgbG9jYWxlcy9sYW5ndWFnZXMgc2V0IGluIGNvbXBvbmVudHNcbiAgICAgKiBAcGFyYW0gbGFuZ3VhZ2UgYW4gSVNPIDYzOS0xIGxhbmd1YWdlIGNvZGUgLSBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9MaXN0X29mX0lTT182MzktMV9jb2Rlc1xuICAgICAqIEBwYXJhbSBzdHJpbmdzIGFuIG9iamVjdCBvZiBzdHJpbmdzLCBvcHRpb25hbFxuICAgICAqL1xuICAgIHNldExvY2FsZShsYW5ndWFnZSwgc3RyaW5ncykge1xuICAgICAgICB0aGlzLmxvY2FsZS5uZXh0KGxhbmd1YWdlKTtcbiAgICAgICAgaWYgKHN0cmluZ3MpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0KHN0cmluZ3MpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGN1cnJlbnQgbG9jYWxlXG4gICAgICovXG4gICAgZ2V0TG9jYWxlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGUudmFsdWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYW4gb2JzZXJ2YWJsZSB0aGF0IHJlc29sdmVzIHRvIHRoZSBjdXJyZW50IGxvY2FsZSwgYW5kIHdpbGwgdXBkYXRlIHdoZW4gY2hhbmdlZFxuICAgICAqL1xuICAgIGdldExvY2FsZU9ic2VydmFibGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxvY2FsZS5hc09ic2VydmFibGUoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0L3VwZGF0ZSB0aGUgdHJhbnNsYXRpb25zIGZyb20gYW4gb2JqZWN0LiBBbHNvIG5vdGlmaWVzIGFsbCBwYXJ0aWNpcGF0aW5nIGNvbXBvbmVudHMgb2YgdGhlIHVwZGF0ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBzdHJpbmdzIGFuIG9iamVjdCBvZiBzdHJpbmdzLCBzaG91bGQgZm9sbG93IHRoZSBzYW1lIGZvcm1hdCBhcyBzcmMvaTE4bi9lbi5qc29uXG4gICAgICovXG4gICAgc2V0KHN0cmluZ3MpIHtcbiAgICAgICAgdGhpcy50cmFuc2xhdGlvblN0cmluZ3MgPSBtZXJnZSh7fSwgRU4sIHN0cmluZ3MpO1xuICAgICAgICAvLyBpdGVyYXRlIG92ZXIgYWxsIG91ciB0cmFja2VkIHRyYW5zbGF0aW9ucyBhbmQgdXBkYXRlIGVhY2ggb2JzZXJ2YWJsZVxuICAgICAgICBjb25zdCB0cmFuc2xhdGlvbnMgPSBBcnJheS5mcm9tKHRoaXMudHJhbnNsYXRpb25zKTtcbiAgICAgICAgZm9yIChjb25zdCBbcGF0aCwgc3ViamVjdF0gb2YgdHJhbnNsYXRpb25zKSB7XG4gICAgICAgICAgICBzdWJqZWN0Lm5leHQodGhpcy5nZXRWYWx1ZUZyb21QYXRoKHBhdGgpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBXaGVuIGEgcGF0aCBpcyBzcGVjaWZpZWQgcmV0dXJucyBhbiBvYnNlcnZhYmxlIHRoYXQgd2lsbCByZXNvbHZlIHRvIHRoZSB0cmFuc2xhdGlvbiBzdHJpbmcgdmFsdWUuXG4gICAgICpcbiAgICAgKiBSZXR1cm5zIHRoZSBmdWxsIHRyYW5zbGF0aW9ucyBvYmplY3QgaWYgcGF0aCBpcyBub3Qgc3BlY2lmaWVkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHBhdGggb3B0aW9uYWwsIGxvb2tzIGxpa2UgYFwiTk9USUZJQ0FUSU9OLkNMT1NFX0JVVFRPTlwiYFxuICAgICAqL1xuICAgIGdldChwYXRoKSB7XG4gICAgICAgIGlmICghcGF0aCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNsYXRpb25TdHJpbmdzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmdldFN1YmplY3QocGF0aCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYWxsIGRlc2NlbmRlbnRzIG9mIHNvbWUgcGF0aCBmcmFnbWVudCBhcyBhbiBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcGFydGlhbFBhdGggYSBwYXRoIGZyYWdtZW50LCBmb3IgZXhhbXBsZSBgXCJOT1RJRklDQVRJT05cImBcbiAgICAgKi9cbiAgICBnZXRNdWx0aXBsZShwYXJ0aWFsUGF0aCkge1xuICAgICAgICBjb25zdCB2YWx1ZXMgPSB0aGlzLmdldFZhbHVlRnJvbVBhdGgocGFydGlhbFBhdGgpO1xuICAgICAgICBjb25zdCBzdWJqZWN0cyA9IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyh2YWx1ZXMpKSB7XG4gICAgICAgICAgICBpZiAodmFsdWVzW2tleV0gPT09IE9iamVjdCh2YWx1ZXNba2V5XSkpIHtcbiAgICAgICAgICAgICAgICBzdWJqZWN0c1trZXldID0gdGhpcy5nZXRNdWx0aXBsZShgJHtwYXJ0aWFsUGF0aH0uJHtrZXl9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBzdWJqZWN0c1trZXldID0gdGhpcy5nZXRTdWJqZWN0KGAke3BhcnRpYWxQYXRofS4ke2tleX1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3ViamVjdHM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYW4gaW5zdGFuY2Ugb2YgYE92ZXJyaWRhYmxlYCB0aGF0IGNhbiBiZSB1c2VkIHRvIG9wdGlvbmFsbHkgb3ZlcnJpZGUgdGhlIHZhbHVlIHByb3ZpZGVkIGJ5IGBJMThuYFxuICAgICAqIEBwYXJhbSBwYXRoIGxvb2tzIGxpa2UgYFwiTk9USUZJQ0FUSU9OLkNMT1NFX0JVVFRPTlwiYFxuICAgICAqL1xuICAgIGdldE92ZXJyaWRhYmxlKHBhdGgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBPdmVycmlkYWJsZShwYXRoLCB0aGlzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGFrZXMgdGhlIGBPYnNlcnZhYmxlYCByZXR1cm5lZCBmcm9tIGBpMThuLmdldGAgYW5kIGFuIG9iamVjdCBvZiB2YXJpYWJsZXMgdG8gcmVwbGFjZS5cbiAgICAgKlxuICAgICAqIFRoZSBrZXlzIHNwZWNpZnkgdGhlIHZhcmlhYmxlIG5hbWUgaW4gdGhlIHN0cmluZy5cbiAgICAgKlxuICAgICAqIEV4YW1wbGU6XG4gICAgICogYGBgXG4gICAgICogc2VydmljZS5zZXQoeyBcIlRFU1RcIjogXCJ7e2Zvb319IHt7YmFyfX1cIiB9KTtcbiAgICAgKlxuICAgICAqIHNlcnZpY2UucmVwbGFjZShzZXJ2aWNlLmdldChcIlRFU1RcIiksIHsgZm9vOiBcInRlc3RcIiwgYmFyOiBcImFzZGZcIiB9KVxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogUHJvZHVjZXM6IGBcInRlc3QgYXNkZlwiYFxuICAgICAqXG4gICAgICogQHBhcmFtIHN1YmplY3QgdGhlIHRyYW5zbGF0aW9uIHRvIHJlcGxhY2UgdmFyaWFibGVzIG9uXG4gICAgICogQHBhcmFtIHZhcmlhYmxlcyBvYmplY3Qgb2YgdmFyaWFibGVzIHRvIHJlcGxhY2VcbiAgICAgKi9cbiAgICByZXBsYWNlKHN1YmplY3QsIHZhcmlhYmxlcykge1xuICAgICAgICByZXR1cm4gcmVwbGFjZShzdWJqZWN0LCB2YXJpYWJsZXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUcnlzIHRvIHJlc29sdmUgYSB2YWx1ZSBmcm9tIHRoZSBwcm92aWRlZCBwYXRoLlxuICAgICAqXG4gICAgICogQHBhcmFtIHBhdGggbG9va3MgbGlrZSBgXCJOT1RJRklDQVRJT04uQ0xPU0VfQlVUVE9OXCJgXG4gICAgICovXG4gICAgZ2V0VmFsdWVGcm9tUGF0aChwYXRoKSB7XG4gICAgICAgIGxldCB2YWx1ZSA9IHRoaXMudHJhbnNsYXRpb25TdHJpbmdzO1xuICAgICAgICBmb3IgKGNvbnN0IHNlZ21lbnQgb2YgcGF0aC5zcGxpdChcIi5cIikpIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZVtzZWdtZW50XSAhPT0gdW5kZWZpbmVkICYmIHZhbHVlW3NlZ21lbnRdICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZVtzZWdtZW50XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgbm8ga2V5ICR7c2VnbWVudH0gYXQgJHtwYXRofWApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSGVscGVyIG1ldGhvZCB0aGF0IHJldHVybnMgYW4gb2JzZXJ2YWJsZSBmcm9tIHRoZSBpbnRlcm5hbCBjYWNoZSBiYXNlZCBvbiB0aGUgcGF0aFxuICAgICAqXG4gICAgICogQHBhcmFtIHBhdGggbG9va3MgbGlrZSBgXCJOT1RJRklDQVRJT04uQ0xPU0VfQlVUVE9OXCJgXG4gICAgICovXG4gICAgZ2V0U3ViamVjdChwYXRoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyB3ZSBydW4gdGhpcyBoZXJlIHRvIHZhbGlkYXRlIHRoZSBwYXRoIGV4aXN0cyBiZWZvcmUgYWRkaW5nIGl0IHRvIHRoZSB0cmFuc2xhdGlvbiBtYXBcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy5nZXRWYWx1ZUZyb21QYXRoKHBhdGgpO1xuICAgICAgICAgICAgaWYgKHRoaXMudHJhbnNsYXRpb25zLmhhcyhwYXRoKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnRyYW5zbGF0aW9ucy5nZXQocGF0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB0cmFuc2xhdGlvbiA9IG5ldyBCZWhhdmlvclN1YmplY3QodmFsdWUpO1xuICAgICAgICAgICAgdGhpcy50cmFuc2xhdGlvbnMuc2V0KHBhdGgsIHRyYW5zbGF0aW9uKTtcbiAgICAgICAgICAgIHJldHVybiB0cmFuc2xhdGlvbjtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyb3IpO1xuICAgICAgICB9XG4gICAgfVxufVxuSTE4bi7JtWZhYyA9IGkwLsm1ybVuZ0RlY2xhcmVGYWN0b3J5KHsgbWluVmVyc2lvbjogXCIxMi4wLjBcIiwgdmVyc2lvbjogXCIxNC4zLjBcIiwgbmdJbXBvcnQ6IGkwLCB0eXBlOiBJMThuLCBkZXBzOiBbXSwgdGFyZ2V0OiBpMC7Jtcm1RmFjdG9yeVRhcmdldC5JbmplY3RhYmxlIH0pO1xuSTE4bi7JtXByb3YgPSBpMC7Jtcm1bmdEZWNsYXJlSW5qZWN0YWJsZSh7IG1pblZlcnNpb246IFwiMTIuMC4wXCIsIHZlcnNpb246IFwiMTQuMy4wXCIsIG5nSW1wb3J0OiBpMCwgdHlwZTogSTE4biB9KTtcbmkwLsm1ybVuZ0RlY2xhcmVDbGFzc01ldGFkYXRhKHsgbWluVmVyc2lvbjogXCIxMi4wLjBcIiwgdmVyc2lvbjogXCIxNC4zLjBcIiwgbmdJbXBvcnQ6IGkwLCB0eXBlOiBJMThuLCBkZWNvcmF0b3JzOiBbe1xuICAgICAgICAgICAgdHlwZTogSW5qZWN0YWJsZVxuICAgICAgICB9XSB9KTtcblxuY2xhc3MgUmVwbGFjZVBpcGUge1xuICAgIHRyYW5zZm9ybSh2YWx1ZSwgdmFyaWFibGVzKSB7XG4gICAgICAgIHJldHVybiByZXBsYWNlKHZhbHVlLCB2YXJpYWJsZXMpO1xuICAgIH1cbn1cblJlcGxhY2VQaXBlLsm1ZmFjID0gaTAuybXJtW5nRGVjbGFyZUZhY3RvcnkoeyBtaW5WZXJzaW9uOiBcIjEyLjAuMFwiLCB2ZXJzaW9uOiBcIjE0LjMuMFwiLCBuZ0ltcG9ydDogaTAsIHR5cGU6IFJlcGxhY2VQaXBlLCBkZXBzOiBbXSwgdGFyZ2V0OiBpMC7Jtcm1RmFjdG9yeVRhcmdldC5QaXBlIH0pO1xuUmVwbGFjZVBpcGUuybVwaXBlID0gaTAuybXJtW5nRGVjbGFyZVBpcGUoeyBtaW5WZXJzaW9uOiBcIjE0LjAuMFwiLCB2ZXJzaW9uOiBcIjE0LjMuMFwiLCBuZ0ltcG9ydDogaTAsIHR5cGU6IFJlcGxhY2VQaXBlLCBuYW1lOiBcImkxOG5SZXBsYWNlXCIgfSk7XG5pMC7Jtcm1bmdEZWNsYXJlQ2xhc3NNZXRhZGF0YSh7IG1pblZlcnNpb246IFwiMTIuMC4wXCIsIHZlcnNpb246IFwiMTQuMy4wXCIsIG5nSW1wb3J0OiBpMCwgdHlwZTogUmVwbGFjZVBpcGUsIGRlY29yYXRvcnM6IFt7XG4gICAgICAgICAgICB0eXBlOiBQaXBlLFxuICAgICAgICAgICAgYXJnczogW3tcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogXCJpMThuUmVwbGFjZVwiXG4gICAgICAgICAgICAgICAgfV1cbiAgICAgICAgfV0gfSk7XG5cbi8vIGVpdGhlciBwcm92aWRlcyBhIG5ldyBpbnN0YW5jZSBvZiBJMThuLCBvciByZXR1cm5zIHRoZSBwYXJlbnRcbmZ1bmN0aW9uIEkxOE5fU0VSVklDRV9QUk9WSURFUl9GQUNUT1JZKHBhcmVudFNlcnZpY2UpIHtcbiAgICByZXR1cm4gcGFyZW50U2VydmljZSB8fCBuZXcgSTE4bigpO1xufVxuLy8gSTE4biBzaG91bGQgcHJvdmlkZSBhIHNpbmdsZSBpbnN0YW5jZSBvZiBpdHNlbGYgdG8gZW5zdXJlIHRoYXQgdHJhbnNsYXRpb25zIGFyZSBjb25zaXN0ZW50IHRocm91Z2ggdGhlIGFwcFxuY29uc3QgSTE4Tl9TRVJWSUNFX1BST1ZJREVSID0ge1xuICAgIHByb3ZpZGU6IEkxOG4sXG4gICAgZGVwczogW1tuZXcgT3B0aW9uYWwoKSwgbmV3IFNraXBTZWxmKCksIEkxOG5dXSxcbiAgICB1c2VGYWN0b3J5OiBJMThOX1NFUlZJQ0VfUFJPVklERVJfRkFDVE9SWVxufTtcbmNsYXNzIEkxOG5Nb2R1bGUge1xufVxuSTE4bk1vZHVsZS7JtWZhYyA9IGkwLsm1ybVuZ0RlY2xhcmVGYWN0b3J5KHsgbWluVmVyc2lvbjogXCIxMi4wLjBcIiwgdmVyc2lvbjogXCIxNC4zLjBcIiwgbmdJbXBvcnQ6IGkwLCB0eXBlOiBJMThuTW9kdWxlLCBkZXBzOiBbXSwgdGFyZ2V0OiBpMC7Jtcm1RmFjdG9yeVRhcmdldC5OZ01vZHVsZSB9KTtcbkkxOG5Nb2R1bGUuybVtb2QgPSBpMC7Jtcm1bmdEZWNsYXJlTmdNb2R1bGUoeyBtaW5WZXJzaW9uOiBcIjE0LjAuMFwiLCB2ZXJzaW9uOiBcIjE0LjMuMFwiLCBuZ0ltcG9ydDogaTAsIHR5cGU6IEkxOG5Nb2R1bGUsIGRlY2xhcmF0aW9uczogW1JlcGxhY2VQaXBlXSwgZXhwb3J0czogW1JlcGxhY2VQaXBlXSB9KTtcbkkxOG5Nb2R1bGUuybVpbmogPSBpMC7Jtcm1bmdEZWNsYXJlSW5qZWN0b3IoeyBtaW5WZXJzaW9uOiBcIjEyLjAuMFwiLCB2ZXJzaW9uOiBcIjE0LjMuMFwiLCBuZ0ltcG9ydDogaTAsIHR5cGU6IEkxOG5Nb2R1bGUsIHByb3ZpZGVyczogW1xuICAgICAgICBJMThuLFxuICAgICAgICBJMThOX1NFUlZJQ0VfUFJPVklERVJcbiAgICBdIH0pO1xuaTAuybXJtW5nRGVjbGFyZUNsYXNzTWV0YWRhdGEoeyBtaW5WZXJzaW9uOiBcIjEyLjAuMFwiLCB2ZXJzaW9uOiBcIjE0LjMuMFwiLCBuZ0ltcG9ydDogaTAsIHR5cGU6IEkxOG5Nb2R1bGUsIGRlY29yYXRvcnM6IFt7XG4gICAgICAgICAgICB0eXBlOiBOZ01vZHVsZSxcbiAgICAgICAgICAgIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgICAgIGRlY2xhcmF0aW9uczogW1JlcGxhY2VQaXBlXSxcbiAgICAgICAgICAgICAgICAgICAgZXhwb3J0czogW1JlcGxhY2VQaXBlXSxcbiAgICAgICAgICAgICAgICAgICAgcHJvdmlkZXJzOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICBJMThuLFxuICAgICAgICAgICAgICAgICAgICAgICAgSTE4Tl9TRVJWSUNFX1BST1ZJREVSXG4gICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICB9XVxuICAgICAgICB9XSB9KTtcblxuLyoqXG4gKiBHZW5lcmF0ZWQgYnVuZGxlIGluZGV4LiBEbyBub3QgZWRpdC5cbiAqL1xuXG5leHBvcnQgeyBJMThOX1NFUlZJQ0VfUFJPVklERVIsIEkxOE5fU0VSVklDRV9QUk9WSURFUl9GQUNUT1JZLCBJMThuLCBJMThuTW9kdWxlLCBPdmVycmlkYWJsZSwgUmVwbGFjZVBpcGUsIHJlcGxhY2UgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNhcmJvbi1jb21wb25lbnRzLWFuZ3VsYXItaTE4bi5tanMubWFwXG4iLCJpbXBvcnQgKiBhcyBpMCBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IEluamVjdGFibGUsIERpcmVjdGl2ZSwgSW5wdXQsIE9wdGlvbmFsLCBTa2lwU2VsZiwgTmdNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IHRvU3RyaW5nLCBnZXRBdHRyaWJ1dGVzIH0gZnJvbSAnQGNhcmJvbi9pY29uLWhlbHBlcnMnO1xuaW1wb3J0IHsgQ29tbW9uTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcbmltcG9ydCBBZGQxNiBmcm9tICdAY2FyYm9uL2ljb25zL2VzL2FkZC8xNic7XG5pbXBvcnQgQWRkMjAgZnJvbSAnQGNhcmJvbi9pY29ucy9lcy9hZGQvMjAnO1xuaW1wb3J0IEJlZTE2IGZyb20gJ0BjYXJib24vaWNvbnMvZXMvYmVlLzE2JztcbmltcG9ydCBCZWUyMCBmcm9tICdAY2FyYm9uL2ljb25zL2VzL2JlZS8yMCc7XG5pbXBvcnQgQ2FsZW5kYXIxNiBmcm9tICdAY2FyYm9uL2ljb25zL2VzL2NhbGVuZGFyLzE2JztcbmltcG9ydCBDYXJib24xNiBmcm9tICdAY2FyYm9uL2ljb25zL2VzL2NhcmJvbi8xNic7XG5pbXBvcnQgQ2FyYm9uMjAgZnJvbSAnQGNhcmJvbi9pY29ucy9lcy9jYXJib24vMjAnO1xuaW1wb3J0IENhcmV0RG93bjE2IGZyb20gJ0BjYXJib24vaWNvbnMvZXMvY2FyZXQtLWRvd24vMTYnO1xuaW1wb3J0IENhcmV0TGVmdDE2IGZyb20gJ0BjYXJib24vaWNvbnMvZXMvY2FyZXQtLWxlZnQvMTYnO1xuaW1wb3J0IENhcmV0UmlnaHQxNiBmcm9tICdAY2FyYm9uL2ljb25zL2VzL2NhcmV0LS1yaWdodC8xNic7XG5pbXBvcnQgQ2FyZXRVcDE2IGZyb20gJ0BjYXJib24vaWNvbnMvZXMvY2FyZXQtLXVwLzE2JztcbmltcG9ydCBDaGVja21hcmsxNiBmcm9tICdAY2FyYm9uL2ljb25zL2VzL2NoZWNrbWFyay8xNic7XG5pbXBvcnQgQ2hlY2ttYXJrRmlsbGVkMTYgZnJvbSAnQGNhcmJvbi9pY29ucy9lcy9jaGVja21hcmstLWZpbGxlZC8xNic7XG5pbXBvcnQgQ2hlY2ttYXJrRmlsbGVkMjAgZnJvbSAnQGNhcmJvbi9pY29ucy9lcy9jaGVja21hcmstLWZpbGxlZC8yMCc7XG5pbXBvcnQgQ2hlY2ttYXJrT3V0bGluZTE2IGZyb20gJ0BjYXJib24vaWNvbnMvZXMvY2hlY2ttYXJrLS1vdXRsaW5lLzE2JztcbmltcG9ydCBDaGV2cm9uRG93bjE2IGZyb20gJ0BjYXJib24vaWNvbnMvZXMvY2hldnJvbi0tZG93bi8xNic7XG5pbXBvcnQgQ2hldnJvblJpZ2h0MTYgZnJvbSAnQGNhcmJvbi9pY29ucy9lcy9jaGV2cm9uLS1yaWdodC8xNic7XG5pbXBvcnQgQ2lyY2xlRGFzaDE2IGZyb20gJ0BjYXJib24vaWNvbnMvZXMvY2lyY2xlLWRhc2gvMTYnO1xuaW1wb3J0IENsb3NlMTYgZnJvbSAnQGNhcmJvbi9pY29ucy9lcy9jbG9zZS8xNic7XG5pbXBvcnQgQ2xvc2UyMCBmcm9tICdAY2FyYm9uL2ljb25zL2VzL2Nsb3NlLzIwJztcbmltcG9ydCBDb3B5MTYgZnJvbSAnQGNhcmJvbi9pY29ucy9lcy9jb3B5LzE2JztcbmltcG9ydCBDb3B5MjAgZnJvbSAnQGNhcmJvbi9pY29ucy9lcy9jb3B5LzIwJztcbmltcG9ydCBEYXRhMjE2IGZyb20gJ0BjYXJib24vaWNvbnMvZXMvZGF0YS0tMi8xNic7XG5pbXBvcnQgRGF0YTIyMCBmcm9tICdAY2FyYm9uL2ljb25zL2VzL2RhdGEtLTIvMjAnO1xuaW1wb3J0IERvY3VtZW50MTYgZnJvbSAnQGNhcmJvbi9pY29ucy9lcy9kb2N1bWVudC8xNic7XG5pbXBvcnQgRG9jdW1lbnQyMCBmcm9tICdAY2FyYm9uL2ljb25zL2VzL2RvY3VtZW50LzIwJztcbmltcG9ydCBEb3dubG9hZDE2IGZyb20gJ0BjYXJib24vaWNvbnMvZXMvZG93bmxvYWQvMTYnO1xuaW1wb3J0IEVycm9yRmlsbGVkMTYgZnJvbSAnQGNhcmJvbi9pY29ucy9lcy9lcnJvci0tZmlsbGVkLzE2JztcbmltcG9ydCBFcnJvckZpbGxlZDIwIGZyb20gJ0BjYXJib24vaWNvbnMvZXMvZXJyb3ItLWZpbGxlZC8yMCc7XG5pbXBvcnQgRmFkZTE2IGZyb20gJ0BjYXJib24vaWNvbnMvZXMvZmFkZS8xNic7XG5pbXBvcnQgRmFkZTIwIGZyb20gJ0BjYXJib24vaWNvbnMvZXMvZmFkZS8yMCc7XG5pbXBvcnQgRm9sZGVyMTYgZnJvbSAnQGNhcmJvbi9pY29ucy9lcy9mb2xkZXIvMTYnO1xuaW1wb3J0IEluY29tcGxldGUxNiBmcm9tICdAY2FyYm9uL2ljb25zL2VzL2luY29tcGxldGUvMTYnO1xuaW1wb3J0IEluZm9ybWF0aW9uRmlsbGVkMTYgZnJvbSAnQGNhcmJvbi9pY29ucy9lcy9pbmZvcm1hdGlvbi0tZmlsbGVkLzE2JztcbmltcG9ydCBJbmZvcm1hdGlvbkZpbGxlZDIwIGZyb20gJ0BjYXJib24vaWNvbnMvZXMvaW5mb3JtYXRpb24tLWZpbGxlZC8yMCc7XG5pbXBvcnQgSW5mb3JtYXRpb25TcXVhcmVGaWxsZWQyMCBmcm9tICdAY2FyYm9uL2ljb25zL2VzL2luZm9ybWF0aW9uLS1zcXVhcmUtLWZpbGxlZC8yMCc7XG5pbXBvcnQgTWVudTE2IGZyb20gJ0BjYXJib24vaWNvbnMvZXMvbWVudS8xNic7XG5pbXBvcnQgTWVudTIwIGZyb20gJ0BjYXJib24vaWNvbnMvZXMvbWVudS8yMCc7XG5pbXBvcnQgT3ZlcmZsb3dNZW51VmVydGljYWwxNiBmcm9tICdAY2FyYm9uL2ljb25zL2VzL292ZXJmbG93LW1lbnUtLXZlcnRpY2FsLzE2JztcbmltcG9ydCBPdmVyZmxvd01lbnVIb3Jpem9udGFsMTYgZnJvbSAnQGNhcmJvbi9pY29ucy9lcy9vdmVyZmxvdy1tZW51LS1ob3Jpem9udGFsLzE2JztcbmltcG9ydCBTYXZlMTYgZnJvbSAnQGNhcmJvbi9pY29ucy9lcy9zYXZlLzE2JztcbmltcG9ydCBTZWFyY2gxNiBmcm9tICdAY2FyYm9uL2ljb25zL2VzL3NlYXJjaC8xNic7XG5pbXBvcnQgU2V0dGluZ3MxNiBmcm9tICdAY2FyYm9uL2ljb25zL2VzL3NldHRpbmdzLzE2JztcbmltcG9ydCBTZXR0aW5nc0FkanVzdDE2IGZyb20gJ0BjYXJib24vaWNvbnMvZXMvc2V0dGluZ3MtLWFkanVzdC8xNic7XG5pbXBvcnQgU3VidHJhY3QxNiBmcm9tICdAY2FyYm9uL2ljb25zL2VzL3N1YnRyYWN0LzE2JztcbmltcG9ydCBUcmFzaENhbjE2IGZyb20gJ0BjYXJib24vaWNvbnMvZXMvdHJhc2gtY2FuLzE2JztcbmltcG9ydCBXYXJuaW5nMTYgZnJvbSAnQGNhcmJvbi9pY29ucy9lcy93YXJuaW5nLzE2JztcbmltcG9ydCBXYXJuaW5nRmlsbGVkMTYgZnJvbSAnQGNhcmJvbi9pY29ucy9lcy93YXJuaW5nLS1maWxsZWQvMTYnO1xuaW1wb3J0IFdhcm5pbmdGaWxsZWQyMCBmcm9tICdAY2FyYm9uL2ljb25zL2VzL3dhcm5pbmctLWZpbGxlZC8yMCc7XG5pbXBvcnQgV2FybmluZ0FsdEZpbGxlZDE2IGZyb20gJ0BjYXJib24vaWNvbnMvZXMvd2FybmluZy0tYWx0LS1maWxsZWQvMTYnO1xuaW1wb3J0IFdhcm5pbmdBbHRGaWxsZWQyMCBmcm9tICdAY2FyYm9uL2ljb25zL2VzL3dhcm5pbmctLWFsdC0tZmlsbGVkLzIwJztcbmltcG9ydCBWaWV3MTYgZnJvbSAnQGNhcmJvbi9pY29ucy9lcy92aWV3LzE2JztcbmltcG9ydCBWaWV3T2ZmMTYgZnJvbSAnQGNhcmJvbi9pY29ucy9lcy92aWV3LS1vZmYvMTYnO1xuXG4vKipcbiAqIEFic3RyYWN0IGNsYXNzIHRoYXQgcmVwcmVzZW50IGEgY2FjaGUgb2YgaWNvbnMuXG4gKlxuICogVGhlIGFjdHVhbCBjYWNoaW5nIG1lY2hhbmlzbSB3aWxsIGJlIGltcGxlbWVudGF0aW9uIHNwZWNpZmljLFxuICogYnV0IGl0J3MgbGlrZWx5IGEgZ29vZCBpZGVhIHRvIGtleSBieSB0aGUgaWNvbnMgbmFtZSBhbmQvb3Igc2l6ZS5cbiAqIEljb24gbmFtZSBhbmQgc2l6ZSB3aWxsIGFsd2F5cyBiZSBzdHJpbmdzLCBhbmQgdGhleSB3aWxsIGJlIHRoZSB0d28gY29uc2lzdGVudFxuICogaWRlbnRpZmllcnMgb2YgYW4gaWNvbi4gRm9yIHRoZSBwdXJwb3NlcyBvZiBzdG9yYWdlIGFkZGl0b25hbCBkZXNjcmlwdG9yIHByb3BlcnRpZXMgbWF5XG4gKiBiZSB1c2VkLCBidXQgdGhlIG5hbWUgYW5kIHNpemUgYXJlIHRoZSBvbmx5IG9uZXMgZ3VhcmVudGVlZCB0byBiZSBwYXNzZWQgZm9yIGxvb2t1cCBwdXJwb3Nlcy5cbiAqL1xuY2xhc3MgSWNvbkNhY2hlIHtcbn1cbi8qKlxuICogQ3VzdG9tIGVycm9yIGZvciB3aGVuIGEgbmFtZSBjYW4ndCBiZSBmb3VuZFxuICovXG5jbGFzcyBJY29uTmFtZU5vdEZvdW5kRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3IobmFtZSkge1xuICAgICAgICBzdXBlcihgSWNvbiAke25hbWV9IG5vdCBmb3VuZGApO1xuICAgIH1cbn1cbi8qKlxuICogQ3VzdG9tIGVycm9yIGZvciB3aGVuIGEgc3BlY2lmaWMgc2l6ZSBjYW4ndCBiZSBmb3VuZFxuICovXG5jbGFzcyBJY29uU2l6ZU5vdEZvdW5kRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3Ioc2l6ZSwgbmFtZSkge1xuICAgICAgICBzdXBlcihcIlNpemUgJHtzaXplfSBmb3IgJHtuYW1lfSBub3QgZm91bmRcIik7XG4gICAgfVxufVxuLyoqXG4gKiBDb25jcmV0ZSBpbXBsZW1lbnRhdGlvbiBvZiBgSWNvbkNhY2hlYCBhcyBhIHNpbXBsZSBpbiBtZW1vcnkgY2FjaGVcbiAqL1xuY2xhc3MgSWNvbk1lbW9yeUNhY2hlIGV4dGVuZHMgSWNvbkNhY2hlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5pY29uTWFwID0gbmV3IE1hcCgpO1xuICAgIH1cbiAgICBnZXQobmFtZSwgc2l6ZSkge1xuICAgICAgICBpZiAoIXRoaXMuaWNvbk1hcC5oYXMobmFtZSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBJY29uTmFtZU5vdEZvdW5kRXJyb3IobmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2l6ZU1hcCA9IHRoaXMuaWNvbk1hcC5nZXQobmFtZSk7XG4gICAgICAgIGlmICghc2l6ZU1hcC5oYXMoc2l6ZSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBJY29uU2l6ZU5vdEZvdW5kRXJyb3Ioc2l6ZSwgbmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNpemVNYXAuZ2V0KHNpemUpO1xuICAgIH1cbiAgICBzZXQobmFtZSwgc2l6ZSwgZGVzY3JpcHRvcikge1xuICAgICAgICBpZiAoIXRoaXMuaWNvbk1hcC5oYXMobmFtZSkpIHtcbiAgICAgICAgICAgIHRoaXMuaWNvbk1hcC5zZXQobmFtZSwgbmV3IE1hcCgpKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzaXplTWFwID0gdGhpcy5pY29uTWFwLmdldChuYW1lKTtcbiAgICAgICAgc2l6ZU1hcC5zZXQoc2l6ZSwgZGVzY3JpcHRvcik7XG4gICAgfVxufVxuLyoqXG4gKiBUaGUgaWNvbiBzZXJ2aWNlIGlzIGEgc2luZ2xldG9uIHNlcnZpY2UgcmVzcG9uc2libGUgZm9yIHJlZ2lzdGVyaW5nIGFuZCByZXRyaXZpbmcgaWNvbnMgZnJvbSBgQGNhcmJvbi9pY29uc2AuXG4gKlxuICogSXQncyBpbXBvcnRhbnQgdG8gcmVnaXN0ZXIgaWNvbnMgYmVmb3JlIHVzZS4gSXQncyByZWNjb21tZW5kZWQgdG8gcmVnaXN0ZXIgeW91ciBpY29ucyBlYXJseSwgbGlrZWx5IGluIHlvdXIgYXBwLmNvbXBvbmVudC5cbiAqXG4gKiBUbyBhbGxvdyBmb3IgaW1wcm92ZWQgdHJlZSBzaGFraW5nIF9kbyBub3RfIGltcG9ydCBhbGwgdGhlIGljb25zIGZyb20gYEBjYXJib24vaWNvbnNgIGFuZCByZWdpc3RlciB0aGVtLlxuICogSW5zdGVhZCByZWdpc3RlciBvbmx5IHRoZSBpY29ucyBpbiB1c2UgYnkgeW91ciBhcHBsaWNhdGlvbi4gSWYgeW91ciBhcHBsaWNhdGlvbiBtYWtlcyB1c2Ugb2YgbGF6eSBsb2FkZWRcbiAqIG1vZHVsZXMgeW91IG1heSBhbHNvIGxhenkgbG9hZCB0aGUgaWNvbnMgdXNlZCBpbiB0aGF0IG1vZHVsZSBieSByZWdpc3RlcmluZyB0aGVtIGVhcmx5IG9uIGluIHRoYXQgbW9kdWxlLlxuICpcbiAqIGBuZ09uSW5pdGAgc2hvdWxkIGJlIHN1ZmZpY2lhbnRseSBlYXJseSB0byByZWdpc3RlciBpY29ucy5cbiAqXG4gKiBFeGFtcGxlOlxuICogYGBgXG4gKiBpbXBvcnQgeyBBY2Nlc3NpYmlsaXR5MTYgfSBmcm9tIFwiQGNhcmJvbi9pY29uc1wiO1xuICpcbiAqIC8vIC4uLlxuICpcbiAqIGNsYXNzIE15Q29tcG9uZW50IGltcGxlbWVudHMgT25Jbml0IHtcbiAqIFx0Y29uc3RydWN0b3IocHJvdGVjdGVkIGljb25TZXJ2aWNlOiBJY29uU2VydmljZSkge31cbiAqXG4gKiBcdC8vIC4uLlxuICpcbiAqIFx0bmdPbkluaXQoKSB7XG4gKiBcdFx0dGhpcy5pY29uU2VydmljZS5yZWdpc3RlcihBY2Nlc3NpYmlsaXR5MTYpO1xuICogXHR9XG4gKlxuICogXHQvLyAuLi5cbiAqIH1cbiAqIGBgYFxuICpcbiAqIElmIG5lZWRlZCBpdCBpcyBwb3NzaWJsZSB0byByZWdpc3RlciBhbiBpY29uIHVuZGVyIGEgZGlmZmVyZW50IG5hbWUsIHZpYSBgcmVnaXN0ZXJBc2AuXG4gKi9cbmNsYXNzIEljb25TZXJ2aWNlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5pY29uQ2FjaGUgPSBuZXcgSWNvbk1lbW9yeUNhY2hlKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlZ2lzdGVycyBhbiBhcnJheSBvZiBpY29ucyBiYXNlZCBvbiB0aGUgbWV0YWRhdGEgcHJvdmlkZWQgYnkgYEBjYXJib24vaWNvbnNgXG4gICAgICovXG4gICAgcmVnaXN0ZXJBbGwoZGVzY3JpcHRvcnMpIHtcbiAgICAgICAgZGVzY3JpcHRvcnMuZm9yRWFjaChpY29uID0+IHRoaXMucmVnaXN0ZXIoaWNvbikpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWdpc3RlcnMgYW4gaWNvbiBiYXNlZCBvbiB0aGUgbWV0YWRhdGEgcHJvdmlkZWQgYnkgYEBjYXJib24vaWNvbnNgXG4gICAgICovXG4gICAgcmVnaXN0ZXIoZGVzY3JpcHRvcikge1xuICAgICAgICBjb25zdCB7IG5hbWUgfSA9IGRlc2NyaXB0b3I7XG4gICAgICAgIHRoaXMucmVnaXN0ZXJBcyhuYW1lLCBkZXNjcmlwdG9yKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVnaXN0ZXJzIGFuIGljb24gYmFzZWQgb24gYSB1bmlxZSBuYW1lIGFuZCBtZXRhZGF0YSBwcm92aWRlZCBieSBgQGNhcmJvbi9pY29uc2BcbiAgICAgKi9cbiAgICByZWdpc3RlckFzKG5hbWUsIGRlc2NyaXB0b3IpIHtcbiAgICAgICAgY29uc3QgeyBzaXplIH0gPSBkZXNjcmlwdG9yO1xuICAgICAgICB0aGlzLmljb25DYWNoZS5zZXQobmFtZSwgc2l6ZS50b1N0cmluZygpLCBkZXNjcmlwdG9yKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyBhbiBpY29uLCBjb252ZXJ0cyBpdCB0byBhIHN0cmluZywgYW5kIGNhY2hlcyB0aGUgcmVzdWx0XG4gICAgICovXG4gICAgZ2V0KG5hbWUsIHNpemUpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGljb24gPSB0aGlzLmljb25DYWNoZS5nZXQobmFtZSwgc2l6ZS50b1N0cmluZygpKTtcbiAgICAgICAgICAgIGlmICghaWNvbi5zdmcpIHtcbiAgICAgICAgICAgICAgICBpY29uLnN2ZyA9IHRvU3RyaW5nKGljb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGljb247XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29uZmlndXJlIHZhcmlvdXMgc2VydmljZSBzZXR0aW5ncyAoY2FjaGluZyBzdHJhdGVneSAuLi4pXG4gICAgICovXG4gICAgY29uZmlndXJlKG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5pY29uQ2FjaGUgPSBvcHRpb25zLmNhY2hlO1xuICAgIH1cbn1cbkljb25TZXJ2aWNlLsm1ZmFjID0gaTAuybXJtW5nRGVjbGFyZUZhY3RvcnkoeyBtaW5WZXJzaW9uOiBcIjEyLjAuMFwiLCB2ZXJzaW9uOiBcIjE0LjMuMFwiLCBuZ0ltcG9ydDogaTAsIHR5cGU6IEljb25TZXJ2aWNlLCBkZXBzOiBbXSwgdGFyZ2V0OiBpMC7Jtcm1RmFjdG9yeVRhcmdldC5JbmplY3RhYmxlIH0pO1xuSWNvblNlcnZpY2UuybVwcm92ID0gaTAuybXJtW5nRGVjbGFyZUluamVjdGFibGUoeyBtaW5WZXJzaW9uOiBcIjEyLjAuMFwiLCB2ZXJzaW9uOiBcIjE0LjMuMFwiLCBuZ0ltcG9ydDogaTAsIHR5cGU6IEljb25TZXJ2aWNlIH0pO1xuaTAuybXJtW5nRGVjbGFyZUNsYXNzTWV0YWRhdGEoeyBtaW5WZXJzaW9uOiBcIjEyLjAuMFwiLCB2ZXJzaW9uOiBcIjE0LjMuMFwiLCBuZ0ltcG9ydDogaTAsIHR5cGU6IEljb25TZXJ2aWNlLCBkZWNvcmF0b3JzOiBbe1xuICAgICAgICAgICAgdHlwZTogSW5qZWN0YWJsZVxuICAgICAgICB9XSB9KTtcblxuLyoqXG4gKiBBIGRpcmVjdGl2ZSBmb3IgcG9wdWxhdGluZyBhIHN2ZyBlbGVtZW50IGJhc2VkIG9uIHRoZSBwcm92aWRlZCBjYXJib24gaWNvbiBuYW1lLlxuICpcbiAqIEdldCBzdGFydGVkIHdpdGggaW1wb3J0aW5nIHRoZSBtb2R1bGU6XG4gKlxuICogYGBgdHlwZXNjcmlwdFxuICogaW1wb3J0IHsgSWNvbk1vZHVsZSB9IGZyb20gJ2NhcmJvbi1jb21wb25lbnRzLWFuZ3VsYXInO1xuICogYGBgXG4gKlxuICogW1NlZSBkZW1vXSguLi8uLi8/cGF0aD0vc3RvcnkvY29tcG9uZW50cy1pY29uLS1iYXNpYylcbiAqL1xuY2xhc3MgSWNvbkRpcmVjdGl2ZSB7XG4gICAgY29uc3RydWN0b3IoZWxlbWVudFJlZiwgaWNvblNlcnZpY2UpIHtcbiAgICAgICAgdGhpcy5lbGVtZW50UmVmID0gZWxlbWVudFJlZjtcbiAgICAgICAgdGhpcy5pY29uU2VydmljZSA9IGljb25TZXJ2aWNlO1xuICAgICAgICB0aGlzLmNkc0ljb24gPSBcIlwiO1xuICAgICAgICB0aGlzLnNpemUgPSBcIjE2XCI7XG4gICAgICAgIHRoaXMudGl0bGUgPSBcIlwiO1xuICAgICAgICB0aGlzLmFyaWFMYWJlbCA9IFwiXCI7XG4gICAgICAgIHRoaXMuYXJpYUxhYmVsbGVkQnkgPSBcIlwiO1xuICAgICAgICB0aGlzLmFyaWFIaWRkZW4gPSBcIlwiO1xuICAgICAgICB0aGlzLmlzRm9jdXNhYmxlID0gZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBkZXByZWNhdGVkIHNpbmNlIHY1IC0gVXNlIGBjZHNJY29uYCBpbnB1dCBwcm9wZXJ0eSBpbnN0ZWFkXG4gICAgICovXG4gICAgc2V0IGlibUljb24oaWNvbk5hbWUpIHtcbiAgICAgICAgdGhpcy5jZHNJY29uID0gaWNvbk5hbWU7XG4gICAgfVxuICAgIHJlbmRlckljb24oaWNvbk5hbWUpIHtcbiAgICAgICAgY29uc3Qgcm9vdCA9IHRoaXMuZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50O1xuICAgICAgICBsZXQgaWNvbjtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGljb24gPSB0aGlzLmljb25TZXJ2aWNlLmdldChpY29uTmFtZSwgdGhpcy5zaXplLnRvU3RyaW5nKCkpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKGVycm9yKTtcbiAgICAgICAgICAgIC8vIGJhaWwgb3V0XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZG9tUGFyc2VyID0gbmV3IERPTVBhcnNlcigpO1xuICAgICAgICBjb25zdCByYXdTVkcgPSBpY29uLnN2ZztcbiAgICAgICAgY29uc3Qgc3ZnRWxlbWVudCA9IGRvbVBhcnNlci5wYXJzZUZyb21TdHJpbmcocmF3U1ZHLCBcImltYWdlL3N2Zyt4bWxcIikuZG9jdW1lbnRFbGVtZW50O1xuICAgICAgICBsZXQgbm9kZSA9IHJvb3QudGFnTmFtZS50b1VwcGVyQ2FzZSgpICE9PSBcIlNWR1wiID8gc3ZnRWxlbWVudCA6IHN2Z0VsZW1lbnQuZmlyc3RDaGlsZDtcbiAgICAgICAgcm9vdC5pbm5lckhUTUwgPSBcIlwiOyAvLyBDbGVhciByb290IGVsZW1lbnRcbiAgICAgICAgd2hpbGUgKG5vZGUpIHtcbiAgICAgICAgICAgIC8vIGltcG9ydE5vZGUgbWFrZXMgYSBjbG9uZSBvZiB0aGUgbm9kZVxuICAgICAgICAgICAgLy8gdGhpcyBlbnN1cmVzIHdlIGtlZXAgbG9vcGluZyBvdmVyIHRoZSBub2RlcyBpbiB0aGUgcGFyc2VkIGRvY3VtZW50XG4gICAgICAgICAgICByb290LmFwcGVuZENoaWxkKHJvb3Qub3duZXJEb2N1bWVudC5pbXBvcnROb2RlKG5vZGUsIHRydWUpKTtcbiAgICAgICAgICAgIC8vIHR5cGUgdGhlIG5vZGUgYmVjYXVzZSB0aGUgYW5ndWxhciBjb21waWxlciBmcmVha3Mgb3V0IGlmIGl0XG4gICAgICAgICAgICAvLyBlbmRzIHVwIHRoaW5raW5nIGl0J3MgYSBgTm9kZWAgaW5zdGVhZCBvZiBhIGBDaGlsZE5vZGVgXG4gICAgICAgICAgICBub2RlID0gbm9kZS5uZXh0U2libGluZztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzdmcgPSByb290LnRhZ05hbWUudG9VcHBlckNhc2UoKSAhPT0gXCJTVkdcIiA/IHN2Z0VsZW1lbnQgOiByb290O1xuICAgICAgICBzdmcuc2V0QXR0cmlidXRlKFwieG1sbnNcIiwgXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiKTtcbiAgICAgICAgY29uc3QgYXR0cmlidXRlcyA9IGdldEF0dHJpYnV0ZXMoe1xuICAgICAgICAgICAgd2lkdGg6IGljb24uYXR0cnMud2lkdGgsXG4gICAgICAgICAgICBoZWlnaHQ6IGljb24uYXR0cnMuaGVpZ2h0LFxuICAgICAgICAgICAgdmlld0JveDogaWNvbi5hdHRycy52aWV3Qm94LFxuICAgICAgICAgICAgdGl0bGU6IHRoaXMudGl0bGUsXG4gICAgICAgICAgICBcImFyaWEtbGFiZWxcIjogdGhpcy5hcmlhTGFiZWwsXG4gICAgICAgICAgICBcImFyaWEtbGFiZWxsZWRieVwiOiB0aGlzLmFyaWFMYWJlbGxlZEJ5LFxuICAgICAgICAgICAgXCJhcmlhLWhpZGRlblwiOiB0aGlzLmFyaWFIaWRkZW4sXG4gICAgICAgICAgICBmb2N1c2FibGU6IHRoaXMuaXNGb2N1c2FibGUudG9TdHJpbmcoKVxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgYXR0cktleXMgPSBPYmplY3Qua2V5cyhhdHRyaWJ1dGVzKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhdHRyS2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3Qga2V5ID0gYXR0cktleXNbaV07XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGF0dHJpYnV0ZXNba2V5XTtcbiAgICAgICAgICAgIGlmIChrZXkgPT09IFwidGl0bGVcIikge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgc3ZnLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoYXR0cmlidXRlc1tcInRpdGxlXCJdKSB7XG4gICAgICAgICAgICBjb25zdCB0aXRsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJ0aXRsZVwiKTtcbiAgICAgICAgICAgIHRpdGxlLnRleHRDb250ZW50ID0gYXR0cmlidXRlcy50aXRsZTtcbiAgICAgICAgICAgIEljb25EaXJlY3RpdmUudGl0bGVJZENvdW50ZXIrKztcbiAgICAgICAgICAgIHRpdGxlLnNldEF0dHJpYnV0ZShcImlkXCIsIGAke2ljb24ubmFtZX0tdGl0bGUtJHtJY29uRGlyZWN0aXZlLnRpdGxlSWRDb3VudGVyfWApO1xuICAgICAgICAgICAgLy8gdGl0bGUgbXVzdCBiZSBmaXJzdCBmb3Igc2NyZWVuIHJlYWRlcnNcbiAgICAgICAgICAgIHN2Zy5pbnNlcnRCZWZvcmUodGl0bGUsIHN2Zy5maXJzdEVsZW1lbnRDaGlsZCk7XG4gICAgICAgICAgICBzdmcuc2V0QXR0cmlidXRlKFwiYXJpYS1sYWJlbGxlZGJ5XCIsIGAke2ljb24ubmFtZX0tdGl0bGUtJHtJY29uRGlyZWN0aXZlLnRpdGxlSWRDb3VudGVyfWApO1xuICAgICAgICB9XG4gICAgfVxuICAgIG5nQWZ0ZXJWaWV3SW5pdCgpIHtcbiAgICAgICAgdGhpcy5yZW5kZXJJY29uKHRoaXMuY2RzSWNvbik7XG4gICAgfVxuICAgIG5nT25DaGFuZ2VzKHsgY2RzSWNvbiB9KSB7XG4gICAgICAgIC8vIFdlIHdhbnQgdG8gaWdub3JlIGZpcnN0IGNoYW5nZSB0byBsZXQgdGhlIGljb24gcmVnaXN0ZXJcbiAgICAgICAgLy8gYW5kIGFkZCBvbmx5IGFmdGVyIHZpZXcgaGFzIGJlZW4gaW5pdGlhbGl6ZWRcbiAgICAgICAgaWYgKGNkc0ljb24gJiYgIWNkc0ljb24uaXNGaXJzdENoYW5nZSgpKSB7XG4gICAgICAgICAgICB0aGlzLnJlbmRlckljb24odGhpcy5jZHNJY29uKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbkljb25EaXJlY3RpdmUudGl0bGVJZENvdW50ZXIgPSAwO1xuSWNvbkRpcmVjdGl2ZS7JtWZhYyA9IGkwLsm1ybVuZ0RlY2xhcmVGYWN0b3J5KHsgbWluVmVyc2lvbjogXCIxMi4wLjBcIiwgdmVyc2lvbjogXCIxNC4zLjBcIiwgbmdJbXBvcnQ6IGkwLCB0eXBlOiBJY29uRGlyZWN0aXZlLCBkZXBzOiBbeyB0b2tlbjogaTAuRWxlbWVudFJlZiB9LCB7IHRva2VuOiBJY29uU2VydmljZSB9XSwgdGFyZ2V0OiBpMC7Jtcm1RmFjdG9yeVRhcmdldC5EaXJlY3RpdmUgfSk7XG5JY29uRGlyZWN0aXZlLsm1ZGlyID0gaTAuybXJtW5nRGVjbGFyZURpcmVjdGl2ZSh7IG1pblZlcnNpb246IFwiMTQuMC4wXCIsIHZlcnNpb246IFwiMTQuMy4wXCIsIHR5cGU6IEljb25EaXJlY3RpdmUsIHNlbGVjdG9yOiBcIltjZHNJY29uXSwgW2libUljb25dXCIsIGlucHV0czogeyBpYm1JY29uOiBcImlibUljb25cIiwgY2RzSWNvbjogXCJjZHNJY29uXCIsIHNpemU6IFwic2l6ZVwiLCB0aXRsZTogXCJ0aXRsZVwiLCBhcmlhTGFiZWw6IFwiYXJpYUxhYmVsXCIsIGFyaWFMYWJlbGxlZEJ5OiBcImFyaWFMYWJlbGxlZEJ5XCIsIGFyaWFIaWRkZW46IFwiYXJpYUhpZGRlblwiLCBpc0ZvY3VzYWJsZTogXCJpc0ZvY3VzYWJsZVwiIH0sIHVzZXNPbkNoYW5nZXM6IHRydWUsIG5nSW1wb3J0OiBpMCB9KTtcbmkwLsm1ybVuZ0RlY2xhcmVDbGFzc01ldGFkYXRhKHsgbWluVmVyc2lvbjogXCIxMi4wLjBcIiwgdmVyc2lvbjogXCIxNC4zLjBcIiwgbmdJbXBvcnQ6IGkwLCB0eXBlOiBJY29uRGlyZWN0aXZlLCBkZWNvcmF0b3JzOiBbe1xuICAgICAgICAgICAgdHlwZTogRGlyZWN0aXZlLFxuICAgICAgICAgICAgYXJnczogW3tcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0b3I6IFwiW2Nkc0ljb25dLCBbaWJtSWNvbl1cIlxuICAgICAgICAgICAgICAgIH1dXG4gICAgICAgIH1dLCBjdG9yUGFyYW1ldGVyczogZnVuY3Rpb24gKCkgeyByZXR1cm4gW3sgdHlwZTogaTAuRWxlbWVudFJlZiB9LCB7IHR5cGU6IEljb25TZXJ2aWNlIH1dOyB9LCBwcm9wRGVjb3JhdG9yczogeyBpYm1JY29uOiBbe1xuICAgICAgICAgICAgICAgIHR5cGU6IElucHV0XG4gICAgICAgICAgICB9XSwgY2RzSWNvbjogW3tcbiAgICAgICAgICAgICAgICB0eXBlOiBJbnB1dFxuICAgICAgICAgICAgfV0sIHNpemU6IFt7XG4gICAgICAgICAgICAgICAgdHlwZTogSW5wdXRcbiAgICAgICAgICAgIH1dLCB0aXRsZTogW3tcbiAgICAgICAgICAgICAgICB0eXBlOiBJbnB1dFxuICAgICAgICAgICAgfV0sIGFyaWFMYWJlbDogW3tcbiAgICAgICAgICAgICAgICB0eXBlOiBJbnB1dFxuICAgICAgICAgICAgfV0sIGFyaWFMYWJlbGxlZEJ5OiBbe1xuICAgICAgICAgICAgICAgIHR5cGU6IElucHV0XG4gICAgICAgICAgICB9XSwgYXJpYUhpZGRlbjogW3tcbiAgICAgICAgICAgICAgICB0eXBlOiBJbnB1dFxuICAgICAgICAgICAgfV0sIGlzRm9jdXNhYmxlOiBbe1xuICAgICAgICAgICAgICAgIHR5cGU6IElucHV0XG4gICAgICAgICAgICB9XSB9IH0pO1xuXG4vLyBtb2R1bGVzXG4vLyBlaXRoZXIgcHJvdmlkZXMgYSBuZXcgaW5zdGFuY2Ugb2YgSWNvblNlcnZpY2UsIG9yIHJldHVybnMgdGhlIHBhcmVudFxuZnVuY3Rpb24gSUNPTl9TRVJWSUNFX1BST1ZJREVSX0ZBQ1RPUlkocGFyZW50U2VydmljZSkge1xuICAgIHJldHVybiBwYXJlbnRTZXJ2aWNlIHx8IG5ldyBJY29uU2VydmljZSgpO1xufVxuLy8gaWNvbiBzZXJ2aWNlICptdXN0KiBiZSBhIHNpbmdsZXRvbiB0byBlbnN1cmUgdGhhdCBpY29ucyBhcmUgYWNjZXNzaWJsZSBnbG9iYWxseSBhbmQgbm90IGR1cGxpY2F0ZWRcbmNvbnN0IElDT05fU0VSVklDRV9QUk9WSURFUiA9IHtcbiAgICBwcm92aWRlOiBJY29uU2VydmljZSxcbiAgICBkZXBzOiBbW25ldyBPcHRpb25hbCgpLCBuZXcgU2tpcFNlbGYoKSwgSWNvblNlcnZpY2VdXSxcbiAgICB1c2VGYWN0b3J5OiBJQ09OX1NFUlZJQ0VfUFJPVklERVJfRkFDVE9SWVxufTtcbmNsYXNzIEljb25Nb2R1bGUge1xuICAgIGNvbnN0cnVjdG9yKGljb25TZXJ2aWNlKSB7XG4gICAgICAgIHRoaXMuaWNvblNlcnZpY2UgPSBpY29uU2VydmljZTtcbiAgICAgICAgaWNvblNlcnZpY2UucmVnaXN0ZXJBbGwoW1xuICAgICAgICAgICAgQWRkMTYsXG4gICAgICAgICAgICBBZGQyMCxcbiAgICAgICAgICAgIEJlZTE2LFxuICAgICAgICAgICAgQmVlMjAsXG4gICAgICAgICAgICBDYWxlbmRhcjE2LFxuICAgICAgICAgICAgQ2FyYm9uMTYsXG4gICAgICAgICAgICBDYXJib24yMCxcbiAgICAgICAgICAgIENhcmV0RG93bjE2LFxuICAgICAgICAgICAgQ2FyZXRMZWZ0MTYsXG4gICAgICAgICAgICBDYXJldFJpZ2h0MTYsXG4gICAgICAgICAgICBDYXJldFVwMTYsXG4gICAgICAgICAgICBDaGVja21hcmsxNixcbiAgICAgICAgICAgIENoZWNrbWFya0ZpbGxlZDE2LFxuICAgICAgICAgICAgQ2hlY2ttYXJrRmlsbGVkMjAsXG4gICAgICAgICAgICBDaGVja21hcmtPdXRsaW5lMTYsXG4gICAgICAgICAgICBDaGV2cm9uRG93bjE2LFxuICAgICAgICAgICAgQ2hldnJvblJpZ2h0MTYsXG4gICAgICAgICAgICBDaXJjbGVEYXNoMTYsXG4gICAgICAgICAgICBDbG9zZTE2LFxuICAgICAgICAgICAgQ2xvc2UyMCxcbiAgICAgICAgICAgIENvcHkxNixcbiAgICAgICAgICAgIENvcHkyMCxcbiAgICAgICAgICAgIERhdGEyMTYsXG4gICAgICAgICAgICBEYXRhMjIwLFxuICAgICAgICAgICAgRG9jdW1lbnQxNixcbiAgICAgICAgICAgIERvY3VtZW50MjAsXG4gICAgICAgICAgICBEb3dubG9hZDE2LFxuICAgICAgICAgICAgRXJyb3JGaWxsZWQxNixcbiAgICAgICAgICAgIEVycm9yRmlsbGVkMjAsXG4gICAgICAgICAgICBGYWRlMTYsXG4gICAgICAgICAgICBGYWRlMjAsXG4gICAgICAgICAgICBGb2xkZXIxNixcbiAgICAgICAgICAgIEluY29tcGxldGUxNixcbiAgICAgICAgICAgIEluZm9ybWF0aW9uRmlsbGVkMTYsXG4gICAgICAgICAgICBJbmZvcm1hdGlvbkZpbGxlZDIwLFxuICAgICAgICAgICAgSW5mb3JtYXRpb25TcXVhcmVGaWxsZWQyMCxcbiAgICAgICAgICAgIE1lbnUxNixcbiAgICAgICAgICAgIE1lbnUyMCxcbiAgICAgICAgICAgIE92ZXJmbG93TWVudVZlcnRpY2FsMTYsXG4gICAgICAgICAgICBPdmVyZmxvd01lbnVIb3Jpem9udGFsMTYsXG4gICAgICAgICAgICBTYXZlMTYsXG4gICAgICAgICAgICBTZWFyY2gxNixcbiAgICAgICAgICAgIFNldHRpbmdzMTYsXG4gICAgICAgICAgICBTZXR0aW5nc0FkanVzdDE2LFxuICAgICAgICAgICAgU3VidHJhY3QxNixcbiAgICAgICAgICAgIFRyYXNoQ2FuMTYsXG4gICAgICAgICAgICBWaWV3MTYsXG4gICAgICAgICAgICBWaWV3T2ZmMTYsXG4gICAgICAgICAgICBXYXJuaW5nMTYsXG4gICAgICAgICAgICBXYXJuaW5nRmlsbGVkMTYsXG4gICAgICAgICAgICBXYXJuaW5nRmlsbGVkMjAsXG4gICAgICAgICAgICBXYXJuaW5nQWx0RmlsbGVkMTYsXG4gICAgICAgICAgICBXYXJuaW5nQWx0RmlsbGVkMjBcbiAgICAgICAgXSk7XG4gICAgfVxufVxuSWNvbk1vZHVsZS7JtWZhYyA9IGkwLsm1ybVuZ0RlY2xhcmVGYWN0b3J5KHsgbWluVmVyc2lvbjogXCIxMi4wLjBcIiwgdmVyc2lvbjogXCIxNC4zLjBcIiwgbmdJbXBvcnQ6IGkwLCB0eXBlOiBJY29uTW9kdWxlLCBkZXBzOiBbeyB0b2tlbjogSWNvblNlcnZpY2UgfV0sIHRhcmdldDogaTAuybXJtUZhY3RvcnlUYXJnZXQuTmdNb2R1bGUgfSk7XG5JY29uTW9kdWxlLsm1bW9kID0gaTAuybXJtW5nRGVjbGFyZU5nTW9kdWxlKHsgbWluVmVyc2lvbjogXCIxNC4wLjBcIiwgdmVyc2lvbjogXCIxNC4zLjBcIiwgbmdJbXBvcnQ6IGkwLCB0eXBlOiBJY29uTW9kdWxlLCBkZWNsYXJhdGlvbnM6IFtJY29uRGlyZWN0aXZlXSwgaW1wb3J0czogW0NvbW1vbk1vZHVsZV0sIGV4cG9ydHM6IFtJY29uRGlyZWN0aXZlXSB9KTtcbkljb25Nb2R1bGUuybVpbmogPSBpMC7Jtcm1bmdEZWNsYXJlSW5qZWN0b3IoeyBtaW5WZXJzaW9uOiBcIjEyLjAuMFwiLCB2ZXJzaW9uOiBcIjE0LjMuMFwiLCBuZ0ltcG9ydDogaTAsIHR5cGU6IEljb25Nb2R1bGUsIHByb3ZpZGVyczogW1xuICAgICAgICBJQ09OX1NFUlZJQ0VfUFJPVklERVJcbiAgICBdLCBpbXBvcnRzOiBbQ29tbW9uTW9kdWxlXSB9KTtcbmkwLsm1ybVuZ0RlY2xhcmVDbGFzc01ldGFkYXRhKHsgbWluVmVyc2lvbjogXCIxMi4wLjBcIiwgdmVyc2lvbjogXCIxNC4zLjBcIiwgbmdJbXBvcnQ6IGkwLCB0eXBlOiBJY29uTW9kdWxlLCBkZWNvcmF0b3JzOiBbe1xuICAgICAgICAgICAgdHlwZTogTmdNb2R1bGUsXG4gICAgICAgICAgICBhcmdzOiBbe1xuICAgICAgICAgICAgICAgICAgICBkZWNsYXJhdGlvbnM6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIEljb25EaXJlY3RpdmVcbiAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgICAgZXhwb3J0czogW1xuICAgICAgICAgICAgICAgICAgICAgICAgSWNvbkRpcmVjdGl2ZVxuICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgICAgICBpbXBvcnRzOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICBDb21tb25Nb2R1bGVcbiAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgICAgcHJvdmlkZXJzOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICBJQ09OX1NFUlZJQ0VfUFJPVklERVJcbiAgICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgIH1dXG4gICAgICAgIH1dLCBjdG9yUGFyYW1ldGVyczogZnVuY3Rpb24gKCkgeyByZXR1cm4gW3sgdHlwZTogSWNvblNlcnZpY2UgfV07IH0gfSk7XG5cbi8qKlxuICogR2VuZXJhdGVkIGJ1bmRsZSBpbmRleC4gRG8gbm90IGVkaXQuXG4gKi9cblxuZXhwb3J0IHsgSUNPTl9TRVJWSUNFX1BST1ZJREVSLCBJQ09OX1NFUlZJQ0VfUFJPVklERVJfRkFDVE9SWSwgSWNvbkNhY2hlLCBJY29uRGlyZWN0aXZlLCBJY29uTWVtb3J5Q2FjaGUsIEljb25Nb2R1bGUsIEljb25OYW1lTm90Rm91bmRFcnJvciwgSWNvblNlcnZpY2UsIEljb25TaXplTm90Rm91bmRFcnJvciB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2FyYm9uLWNvbXBvbmVudHMtYW5ndWxhci1pY29uLm1qcy5tYXBcbiIsImltcG9ydCAqIGFzIGkwIGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgSW5qZWN0YWJsZSwgVmlld0NvbnRhaW5lclJlZiwgQ29tcG9uZW50LCBJbnB1dCwgVmlld0NoaWxkLCBPcHRpb25hbCwgU2tpcFNlbGYsIE5nTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBDb21tb25Nb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuXG4vKipcbiAqIFNpbmdsZXRvbiBzZXJ2aWNlIHVzZWQgdG8gcmVnaXN0ZXIgdGhlIGNvbnRhaW5lciBmb3Igb3V0LW9mLWZsb3cgY29tcG9uZW50cyB0byBpbnNlcnQgaW50by5cbiAqIEFsc28gdXNlZCB0byBpbnNlcnQvcmVtb3ZlIGNvbXBvbmVudHMgZnJvbSB0aGF0IHZpZXcuXG4gKi9cbmNsYXNzIFBsYWNlaG9sZGVyU2VydmljZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBNYWluIGBWaWV3Q29udGFpbmVyUmVmYCB0byBpbnNlcnQgY29tcG9uZW50cyBpbnRvXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnZpZXdDb250YWluZXJSZWYgPSBudWxsO1xuICAgICAgICAvKipcbiAgICAgICAgICogTWFwIG9mIGlkJ3MgdG8gc2Vjb25kYXJ5IGBWaWV3Q29udGFpbmVyUmVmYHNcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudmlld0NvbnRhaW5lck1hcCA9IG5ldyBNYXAoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXNlZCBieSBgUGxhY2Vob2xkZXJgIHRvIHJlZ2lzdGVyIHZpZXctY29udGFpbmVyIHJlZmVyZW5jZS5cbiAgICAgKi9cbiAgICByZWdpc3RlclZpZXdDb250YWluZXJSZWYodmNSZWYsIGlkKSB7XG4gICAgICAgIGlmIChpZCkge1xuICAgICAgICAgICAgdGhpcy52aWV3Q29udGFpbmVyTWFwLnNldChpZCwgdmNSZWYpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy52aWV3Q29udGFpbmVyUmVmID0gdmNSZWY7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbmQgcmV0dXJucyBjb21wb25lbnQgaW4gdGhlIHZpZXcuXG4gICAgICovXG4gICAgY3JlYXRlQ29tcG9uZW50KGNvbXBvbmVudCwgaW5qZWN0b3IsIGlkKSB7XG4gICAgICAgIGlmIChpZCkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLnZpZXdDb250YWluZXJNYXAuaGFzKGlkKSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYE5vIHZpZXcgY29udGFpbmVyIHdpdGggaWQgJHtpZH0gZm91bmRgKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy52aWV3Q29udGFpbmVyTWFwLmdldChpZCkuY3JlYXRlQ29tcG9uZW50KGNvbXBvbmVudCwgeyBpbmRleDogdGhpcy52aWV3Q29udGFpbmVyTWFwLnNpemUsIGluamVjdG9yIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy52aWV3Q29udGFpbmVyUmVmKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiTm8gdmlldyBjb250YWluZXIgZGVmaW5lZCEgTGlrZWx5IGR1ZSB0byBhIG1pc3NpbmcgYGNkcy1wbGFjZWhvbGRlcmBcIik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMudmlld0NvbnRhaW5lclJlZi5jcmVhdGVDb21wb25lbnQoY29tcG9uZW50LCB7IGluZGV4OiB0aGlzLnZpZXdDb250YWluZXJSZWYubGVuZ3RoLCBpbmplY3RvciB9KTtcbiAgICB9XG4gICAgZGVzdHJveUNvbXBvbmVudChjb21wb25lbnQpIHtcbiAgICAgICAgY29tcG9uZW50LmRlc3Ryb3koKTtcbiAgICB9XG4gICAgaGFzQ29tcG9uZW50UmVmKGNvbXBvbmVudCwgaWQpIHtcbiAgICAgICAgaWYgKGlkKSB7XG4gICAgICAgICAgICByZXR1cm4gISh0aGlzLnZpZXdDb250YWluZXJNYXAuZ2V0KGlkKS5pbmRleE9mKGNvbXBvbmVudC5ob3N0VmlldykgPCAwKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gISh0aGlzLnZpZXdDb250YWluZXJSZWYuaW5kZXhPZihjb21wb25lbnQuaG9zdFZpZXcpIDwgMCk7XG4gICAgfVxuICAgIGhhc1BsYWNlaG9sZGVyUmVmKGlkKSB7XG4gICAgICAgIGlmIChpZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudmlld0NvbnRhaW5lck1hcC5oYXMoaWQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAhIXRoaXMudmlld0NvbnRhaW5lclJlZjtcbiAgICB9XG4gICAgYXBwZW5kRWxlbWVudChlbGVtZW50LCBpZCkge1xuICAgICAgICBpZiAoaWQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnZpZXdDb250YWluZXJNYXAuZ2V0KGlkKS5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQuYXBwZW5kQ2hpbGQoZWxlbWVudCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMudmlld0NvbnRhaW5lclJlZi5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQuYXBwZW5kQ2hpbGQoZWxlbWVudCk7XG4gICAgfVxuICAgIHJlbW92ZUVsZW1lbnQoZWxlbWVudCwgaWQpIHtcbiAgICAgICAgaWYgKGlkKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy52aWV3Q29udGFpbmVyTWFwLmdldChpZCkuZWxlbWVudC5uYXRpdmVFbGVtZW50LnJlbW92ZUNoaWxkKGVsZW1lbnQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnZpZXdDb250YWluZXJSZWYuZWxlbWVudC5uYXRpdmVFbGVtZW50LnJlbW92ZUNoaWxkKGVsZW1lbnQpO1xuICAgIH1cbiAgICBoYXNFbGVtZW50KGVsZW1lbnQsIGlkKSB7XG4gICAgICAgIGlmIChpZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudmlld0NvbnRhaW5lck1hcC5nZXQoaWQpLmVsZW1lbnQubmF0aXZlRWxlbWVudC5jb250YWlucyhlbGVtZW50KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy52aWV3Q29udGFpbmVyUmVmLmVsZW1lbnQubmF0aXZlRWxlbWVudC5jb250YWlucyhlbGVtZW50KTtcbiAgICB9XG59XG5QbGFjZWhvbGRlclNlcnZpY2UuybVmYWMgPSBpMC7Jtcm1bmdEZWNsYXJlRmFjdG9yeSh7IG1pblZlcnNpb246IFwiMTIuMC4wXCIsIHZlcnNpb246IFwiMTQuMy4wXCIsIG5nSW1wb3J0OiBpMCwgdHlwZTogUGxhY2Vob2xkZXJTZXJ2aWNlLCBkZXBzOiBbXSwgdGFyZ2V0OiBpMC7Jtcm1RmFjdG9yeVRhcmdldC5JbmplY3RhYmxlIH0pO1xuUGxhY2Vob2xkZXJTZXJ2aWNlLsm1cHJvdiA9IGkwLsm1ybVuZ0RlY2xhcmVJbmplY3RhYmxlKHsgbWluVmVyc2lvbjogXCIxMi4wLjBcIiwgdmVyc2lvbjogXCIxNC4zLjBcIiwgbmdJbXBvcnQ6IGkwLCB0eXBlOiBQbGFjZWhvbGRlclNlcnZpY2UgfSk7XG5pMC7Jtcm1bmdEZWNsYXJlQ2xhc3NNZXRhZGF0YSh7IG1pblZlcnNpb246IFwiMTIuMC4wXCIsIHZlcnNpb246IFwiMTQuMy4wXCIsIG5nSW1wb3J0OiBpMCwgdHlwZTogUGxhY2Vob2xkZXJTZXJ2aWNlLCBkZWNvcmF0b3JzOiBbe1xuICAgICAgICAgICAgdHlwZTogSW5qZWN0YWJsZVxuICAgICAgICB9XSB9KTtcblxuLyoqXG4gKiBVc2luZyBhIG1vZGFsLCBkaWFsb2cgKFRvb2x0aXAsIE92ZXJmbG93TWVudSksIG9yIGFueSBvdGhlciBjb21wb25lbnQgdGhhdCBkcmF3cyBvdXQgb2YgdGhlIG5vcm1hbCBwYWdlIGZsb3dcbiAqIGluIHlvdXIgYXBwbGljYXRpb24gKnJlcXVpcmVzKiB0aGlzIGNvbXBvbmVudCAoYGNkcy1wbGFjZWhvbGRlcmApLlxuICogSXQgd291bGQgZ2VuZXJhbGx5IGJlIHBsYWNlZCBuZWFyIHRoZSBlbmQgb2YgeW91ciByb290IGFwcCBjb21wb25lbnQgdGVtcGxhdGVcbiAqIChhcHAuY29tcG9uZW50LnRzIG9yIGFwcC5jb21wb25lbnQuaHRtbCkgYXM6XG4gKlxuICogYGBgXG4gKiA8Y2RzLXBsYWNlaG9sZGVyPjwvY2RzLXBsYWNlaG9sZGVyPlxuICogYGBgXG4gKi9cbmNsYXNzIFBsYWNlaG9sZGVyIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIGBQbGFjZWhvbGRlcmAuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IocGxhY2Vob2xkZXJTZXJ2aWNlKSB7XG4gICAgICAgIHRoaXMucGxhY2Vob2xkZXJTZXJ2aWNlID0gcGxhY2Vob2xkZXJTZXJ2aWNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWdpc3RlcnMgdGhlIGNvbXBvbmVudHMgdmlldyB3aXRoIGBQbGFjZWhvbGRlclNlcnZpY2VgXG4gICAgICovXG4gICAgbmdPbkluaXQoKSB7XG4gICAgICAgIC8vIFRPRE8gdXNlIGBpZGAgdG8gcmVnaXN0ZXIgd2l0aCB0aGUgcGxhY2Vob2xkZXJTZXJ2aWNlXG4gICAgICAgIHRoaXMucGxhY2Vob2xkZXJTZXJ2aWNlLnJlZ2lzdGVyVmlld0NvbnRhaW5lclJlZih0aGlzLnZpZXdDb250YWluZXJSZWYpO1xuICAgIH1cbn1cblBsYWNlaG9sZGVyLsm1ZmFjID0gaTAuybXJtW5nRGVjbGFyZUZhY3RvcnkoeyBtaW5WZXJzaW9uOiBcIjEyLjAuMFwiLCB2ZXJzaW9uOiBcIjE0LjMuMFwiLCBuZ0ltcG9ydDogaTAsIHR5cGU6IFBsYWNlaG9sZGVyLCBkZXBzOiBbeyB0b2tlbjogUGxhY2Vob2xkZXJTZXJ2aWNlIH1dLCB0YXJnZXQ6IGkwLsm1ybVGYWN0b3J5VGFyZ2V0LkNvbXBvbmVudCB9KTtcblBsYWNlaG9sZGVyLsm1Y21wID0gaTAuybXJtW5nRGVjbGFyZUNvbXBvbmVudCh7IG1pblZlcnNpb246IFwiMTQuMC4wXCIsIHZlcnNpb246IFwiMTQuMy4wXCIsIHR5cGU6IFBsYWNlaG9sZGVyLCBzZWxlY3RvcjogXCJjZHMtcGxhY2Vob2xkZXIsIGlibS1wbGFjZWhvbGRlclwiLCBpbnB1dHM6IHsgaWQ6IFwiaWRcIiB9LCB2aWV3UXVlcmllczogW3sgcHJvcGVydHlOYW1lOiBcInZpZXdDb250YWluZXJSZWZcIiwgZmlyc3Q6IHRydWUsIHByZWRpY2F0ZTogW1wicGxhY2Vob2xkZXJcIl0sIGRlc2NlbmRhbnRzOiB0cnVlLCByZWFkOiBWaWV3Q29udGFpbmVyUmVmLCBzdGF0aWM6IHRydWUgfV0sIG5nSW1wb3J0OiBpMCwgdGVtcGxhdGU6IGA8ZGl2ICNwbGFjZWhvbGRlcj48L2Rpdj5gLCBpc0lubGluZTogdHJ1ZSB9KTtcbmkwLsm1ybVuZ0RlY2xhcmVDbGFzc01ldGFkYXRhKHsgbWluVmVyc2lvbjogXCIxMi4wLjBcIiwgdmVyc2lvbjogXCIxNC4zLjBcIiwgbmdJbXBvcnQ6IGkwLCB0eXBlOiBQbGFjZWhvbGRlciwgZGVjb3JhdG9yczogW3tcbiAgICAgICAgICAgIHR5cGU6IENvbXBvbmVudCxcbiAgICAgICAgICAgIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdG9yOiBcImNkcy1wbGFjZWhvbGRlciwgaWJtLXBsYWNlaG9sZGVyXCIsXG4gICAgICAgICAgICAgICAgICAgIHRlbXBsYXRlOiBgPGRpdiAjcGxhY2Vob2xkZXI+PC9kaXY+YFxuICAgICAgICAgICAgICAgIH1dXG4gICAgICAgIH1dLCBjdG9yUGFyYW1ldGVyczogZnVuY3Rpb24gKCkgeyByZXR1cm4gW3sgdHlwZTogUGxhY2Vob2xkZXJTZXJ2aWNlIH1dOyB9LCBwcm9wRGVjb3JhdG9yczogeyBpZDogW3tcbiAgICAgICAgICAgICAgICB0eXBlOiBJbnB1dFxuICAgICAgICAgICAgfV0sIHZpZXdDb250YWluZXJSZWY6IFt7XG4gICAgICAgICAgICAgICAgdHlwZTogVmlld0NoaWxkLFxuICAgICAgICAgICAgICAgIGFyZ3M6IFtcInBsYWNlaG9sZGVyXCIsIHsgcmVhZDogVmlld0NvbnRhaW5lclJlZiwgc3RhdGljOiB0cnVlIH1dXG4gICAgICAgICAgICB9XSB9IH0pO1xuXG4vLyBtb2R1bGVzXG4vLyBlaXRoZXIgcHJvdmlkZXMgYSBuZXcgaW5zdGFuY2Ugb2YgUGxhY2Vob2xkZXJTZXJ2aWNlLCBvciByZXR1cm5zIHRoZSBwYXJlbnRcbmZ1bmN0aW9uIFBMQUNFSE9MREVSX1NFUlZJQ0VfUFJPVklERVJfRkFDVE9SWShwYXJlbnRTZXJ2aWNlKSB7XG4gICAgcmV0dXJuIHBhcmVudFNlcnZpY2UgfHwgbmV3IFBsYWNlaG9sZGVyU2VydmljZSgpO1xufVxuLy8gcGxhY2Vob2xkZXIgc2VydmljZSAqbXVzdCogYmUgYSBzaW5nbGV0b24gdG8gZW5zdXJlIHRoZSBwbGFjZWhvbGRlciB2aWV3UmVmIGlzIGFjY2Vzc2libGUgZ2xvYmFsbHlcbmNvbnN0IFBMQUNFSE9MREVSX1NFUlZJQ0VfUFJPVklERVIgPSB7XG4gICAgcHJvdmlkZTogUGxhY2Vob2xkZXJTZXJ2aWNlLFxuICAgIGRlcHM6IFtbbmV3IE9wdGlvbmFsKCksIG5ldyBTa2lwU2VsZigpLCBQbGFjZWhvbGRlclNlcnZpY2VdXSxcbiAgICB1c2VGYWN0b3J5OiBQTEFDRUhPTERFUl9TRVJWSUNFX1BST1ZJREVSX0ZBQ1RPUllcbn07XG5jbGFzcyBQbGFjZWhvbGRlck1vZHVsZSB7XG59XG5QbGFjZWhvbGRlck1vZHVsZS7JtWZhYyA9IGkwLsm1ybVuZ0RlY2xhcmVGYWN0b3J5KHsgbWluVmVyc2lvbjogXCIxMi4wLjBcIiwgdmVyc2lvbjogXCIxNC4zLjBcIiwgbmdJbXBvcnQ6IGkwLCB0eXBlOiBQbGFjZWhvbGRlck1vZHVsZSwgZGVwczogW10sIHRhcmdldDogaTAuybXJtUZhY3RvcnlUYXJnZXQuTmdNb2R1bGUgfSk7XG5QbGFjZWhvbGRlck1vZHVsZS7JtW1vZCA9IGkwLsm1ybVuZ0RlY2xhcmVOZ01vZHVsZSh7IG1pblZlcnNpb246IFwiMTQuMC4wXCIsIHZlcnNpb246IFwiMTQuMy4wXCIsIG5nSW1wb3J0OiBpMCwgdHlwZTogUGxhY2Vob2xkZXJNb2R1bGUsIGRlY2xhcmF0aW9uczogW1BsYWNlaG9sZGVyXSwgaW1wb3J0czogW0NvbW1vbk1vZHVsZV0sIGV4cG9ydHM6IFtQbGFjZWhvbGRlcl0gfSk7XG5QbGFjZWhvbGRlck1vZHVsZS7JtWluaiA9IGkwLsm1ybVuZ0RlY2xhcmVJbmplY3Rvcih7IG1pblZlcnNpb246IFwiMTIuMC4wXCIsIHZlcnNpb246IFwiMTQuMy4wXCIsIG5nSW1wb3J0OiBpMCwgdHlwZTogUGxhY2Vob2xkZXJNb2R1bGUsIHByb3ZpZGVyczogW1BMQUNFSE9MREVSX1NFUlZJQ0VfUFJPVklERVJdLCBpbXBvcnRzOiBbQ29tbW9uTW9kdWxlXSB9KTtcbmkwLsm1ybVuZ0RlY2xhcmVDbGFzc01ldGFkYXRhKHsgbWluVmVyc2lvbjogXCIxMi4wLjBcIiwgdmVyc2lvbjogXCIxNC4zLjBcIiwgbmdJbXBvcnQ6IGkwLCB0eXBlOiBQbGFjZWhvbGRlck1vZHVsZSwgZGVjb3JhdG9yczogW3tcbiAgICAgICAgICAgIHR5cGU6IE5nTW9kdWxlLFxuICAgICAgICAgICAgYXJnczogW3tcbiAgICAgICAgICAgICAgICAgICAgZGVjbGFyYXRpb25zOiBbUGxhY2Vob2xkZXJdLFxuICAgICAgICAgICAgICAgICAgICBleHBvcnRzOiBbUGxhY2Vob2xkZXJdLFxuICAgICAgICAgICAgICAgICAgICBwcm92aWRlcnM6IFtQTEFDRUhPTERFUl9TRVJWSUNFX1BST1ZJREVSXSxcbiAgICAgICAgICAgICAgICAgICAgaW1wb3J0czogW0NvbW1vbk1vZHVsZV1cbiAgICAgICAgICAgICAgICB9XVxuICAgICAgICB9XSB9KTtcblxuLyoqXG4gKiBHZW5lcmF0ZWQgYnVuZGxlIGluZGV4LiBEbyBub3QgZWRpdC5cbiAqL1xuXG5leHBvcnQgeyBQTEFDRUhPTERFUl9TRVJWSUNFX1BST1ZJREVSLCBQTEFDRUhPTERFUl9TRVJWSUNFX1BST1ZJREVSX0ZBQ1RPUlksIFBsYWNlaG9sZGVyLCBQbGFjZWhvbGRlck1vZHVsZSwgUGxhY2Vob2xkZXJTZXJ2aWNlIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jYXJib24tY29tcG9uZW50cy1hbmd1bGFyLXBsYWNlaG9sZGVyLm1qcy5tYXBcbiIsImltcG9ydCAqIGFzIGkwIGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgSW5qZWN0YWJsZSwgT3B0aW9uYWwsIFNraXBTZWxmLCBOZ1pvbmUsIE5nTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBTdWJqZWN0LCBmcm9tLCBmcm9tRXZlbnQsIG1lcmdlIGFzIG1lcmdlJDEsIFN1YnNjcmlwdGlvbiwgT2JzZXJ2YWJsZSB9IGZyb20gJ3J4anMnO1xuZXhwb3J0IHsgUExBQ0VNRU5UUywgUG9zaXRpb24sIGRlZmF1bHRQb3NpdGlvbnMsIHBvc2l0aW9uIH0gZnJvbSAnQGNhcmJvbi91dGlscy1wb3NpdGlvbic7XG5pbXBvcnQgeyBtYXAgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5cbmZ1bmN0aW9uIGZpbmRTaWJsaW5nRWxlbSh0YXJnZXQsIGRpcmVjdGlvbikge1xuICAgIGlmICh0YXJnZXRbZGlyZWN0aW9uXSkge1xuICAgICAgICBpZiAodGFyZ2V0W2RpcmVjdGlvbl0uY2xhc3NMaXN0LmNvbnRhaW5zKFwiZGlzYWJsZWRcIikpIHtcbiAgICAgICAgICAgIHJldHVybiBmaW5kU2libGluZ0VsZW0odGFyZ2V0W2RpcmVjdGlvbl0sIGRpcmVjdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRhcmdldFtkaXJlY3Rpb25dO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGZpbmROZXh0RWxlbSh0YXJnZXQpIHtcbiAgICByZXR1cm4gZmluZFNpYmxpbmdFbGVtKHRhcmdldCwgXCJuZXh0RWxlbWVudFNpYmxpbmdcIik7XG59XG5mdW5jdGlvbiBmaW5kUHJldkVsZW0odGFyZ2V0KSB7XG4gICAgcmV0dXJuIGZpbmRTaWJsaW5nRWxlbSh0YXJnZXQsIFwicHJldmlvdXNFbGVtZW50U2libGluZ1wiKTtcbn1cbi8vIGNoZWNrIGZvciBIaWdodCBjb250cmFzdCBtb2RlXG5mdW5jdGlvbiBIY01vZGVDaGVja2VyKCkge1xuICAgIGxldCBjb2xvclRlc3QgPSBcInJnYigyNTUsIDAsIDApXCI7XG4gICAgbGV0IGh0bWxDaGVja2VyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICBodG1sQ2hlY2tlci5jbGFzc0xpc3QuYWRkKFwiaGMtY2hlY2tlclwiKTtcbiAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGh0bWxDaGVja2VyKTtcbiAgICBpZiAod2luZG93LmdldENvbXB1dGVkU3R5bGUoaHRtbENoZWNrZXIpLmJhY2tncm91bmRDb2xvci50b1N0cmluZygpICE9PSBjb2xvclRlc3QpIHtcbiAgICAgICAgZG9jdW1lbnQuYm9keS5jbGFzc0xpc3QuYWRkKFwiYTExeVwiKTtcbiAgICB9XG4gICAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChodG1sQ2hlY2tlcik7XG59XG5mdW5jdGlvbiBmb2N1c05leHRUcmVlKGVsZW0sIHJvb3RFbGVtID0gbnVsbCkge1xuICAgIGlmIChlbGVtKSB7XG4gICAgICAgIGxldCBmb2N1c2FibGUgPSBlbGVtLnF1ZXJ5U2VsZWN0b3IoXCJbdGFiaW5kZXg9JzAnXVwiKTtcbiAgICAgICAgaWYgKGZvY3VzYWJsZSkge1xuICAgICAgICAgICAgZm9jdXNhYmxlLmZvY3VzKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmb2N1c05leHRFbGVtKGVsZW0sIHJvb3RFbGVtKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIGZvY3VzTmV4dEVsZW0oZWxlbSwgcm9vdEVsZW0gPSBudWxsKSB7XG4gICAgaWYgKGVsZW0pIHtcbiAgICAgICAgbGV0IG5leHRFbGVtID0gZWxlbS5uZXh0RWxlbWVudFNpYmxpbmc7XG4gICAgICAgIGlmIChuZXh0RWxlbSkge1xuICAgICAgICAgICAgbGV0IGZvY3VzYWJsZUVsZW0gPSBuZXh0RWxlbS5xdWVyeVNlbGVjdG9yKFwiW3RhYmluZGV4PScwJ11cIik7XG4gICAgICAgICAgICBpZiAoZm9jdXNhYmxlRWxlbSkge1xuICAgICAgICAgICAgICAgIGZvY3VzYWJsZUVsZW0uZm9jdXMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGZvY3VzTmV4dEVsZW0obmV4dEVsZW0sIHJvb3RFbGVtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChyb290RWxlbSkge1xuICAgICAgICAgICAgICAgIGxldCBuZXh0Um9vdEVsZW0gPSByb290RWxlbS5uZXh0RWxlbWVudFNpYmxpbmc7XG4gICAgICAgICAgICAgICAgaWYgKG5leHRSb290RWxlbSkge1xuICAgICAgICAgICAgICAgICAgICBmb2N1c05leHRUcmVlKG5leHRSb290RWxlbSwgcm9vdEVsZW0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIGZvY3VzUHJldkVsZW0oZWxlbSwgcGFyZW50UmVmID0gbnVsbCkge1xuICAgIGlmIChlbGVtKSB7XG4gICAgICAgIGxldCBwcmV2RWxlbSA9IGVsZW0ucHJldmlvdXNFbGVtZW50U2libGluZztcbiAgICAgICAgaWYgKHByZXZFbGVtKSB7XG4gICAgICAgICAgICBsZXQgZm9jdXNhYmxlRWxlbSA9IHByZXZFbGVtLnF1ZXJ5U2VsZWN0b3IoXCJbdGFiaW5kZXg9JzAnXVwiKTtcbiAgICAgICAgICAgIGlmIChmb2N1c2FibGVFbGVtKSB7XG4gICAgICAgICAgICAgICAgaWYgKGZvY3VzYWJsZUVsZW0uZ2V0QXR0cmlidXRlKFwiYXJpYS1leHBhbmRlZFwiKSA9PT0gXCJ0cnVlXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGxhc3RGb2NFbG1zID0gcHJldkVsZW0ucXVlcnlTZWxlY3RvckFsbChcIlt0YWJpbmRleD0nMCddXCIpO1xuICAgICAgICAgICAgICAgICAgICBsZXQgYXJyTGVuID0gbGFzdEZvY0VsbXMubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IGFyckxlbjsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghIShsYXN0Rm9jRWxtc1tpXS5vZmZzZXRXaWR0aCB8fCBsYXN0Rm9jRWxtc1tpXS5vZmZzZXRIZWlnaHQgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYXN0Rm9jRWxtc1tpXS5nZXRDbGllbnRSZWN0cygpLmxlbmd0aCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb2N1c2FibGVFbGVtID0gbGFzdEZvY0VsbXNbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9jdXNhYmxlRWxlbS5mb2N1cygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZm9jdXNQcmV2RWxlbShwcmV2RWxlbSwgcGFyZW50UmVmKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChwYXJlbnRSZWYpIHtcbiAgICAgICAgICAgICAgICBwYXJlbnRSZWYucXVlcnlTZWxlY3RvcihcIlt0YWJpbmRleD0nMCddXCIpLmZvY3VzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmNsYXNzIEFuaW1hdGlvbkZyYW1lU2VydmljZVNpbmdsZXRvbiB7XG4gICAgY29uc3RydWN0b3Iobmdab25lKSB7XG4gICAgICAgIHRoaXMubmdab25lID0gbmdab25lO1xuICAgICAgICB0aGlzLmZyYW1lU291cmNlID0gbmV3IFN1YmplY3QoKTtcbiAgICAgICAgdGhpcy50aWNrID0gdGhpcy5mcmFtZVNvdXJjZS5hc09ic2VydmFibGUoKTtcbiAgICAgICAgdGhpcy5uZ1pvbmUucnVuT3V0c2lkZUFuZ3VsYXIoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5hbmltYXRpb25GcmFtZUlkID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHRoaXMuZG9UaWNrLmJpbmQodGhpcykpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgbmdPbkRlc3Ryb3koKSB7XG4gICAgICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMuYW5pbWF0aW9uRnJhbWVJZCk7XG4gICAgfVxuICAgIGRvVGljayhmcmFtZSkge1xuICAgICAgICB0aGlzLmZyYW1lU291cmNlLm5leHQoZnJhbWUpO1xuICAgICAgICB0aGlzLm5nWm9uZS5ydW5PdXRzaWRlQW5ndWxhcigoKSA9PiB7XG4gICAgICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUodGhpcy5kb1RpY2suYmluZCh0aGlzKSk7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbkFuaW1hdGlvbkZyYW1lU2VydmljZVNpbmdsZXRvbi7JtWZhYyA9IGkwLsm1ybVuZ0RlY2xhcmVGYWN0b3J5KHsgbWluVmVyc2lvbjogXCIxMi4wLjBcIiwgdmVyc2lvbjogXCIxNC4zLjBcIiwgbmdJbXBvcnQ6IGkwLCB0eXBlOiBBbmltYXRpb25GcmFtZVNlcnZpY2VTaW5nbGV0b24sIGRlcHM6IFt7IHRva2VuOiBpMC5OZ1pvbmUgfV0sIHRhcmdldDogaTAuybXJtUZhY3RvcnlUYXJnZXQuSW5qZWN0YWJsZSB9KTtcbkFuaW1hdGlvbkZyYW1lU2VydmljZVNpbmdsZXRvbi7JtXByb3YgPSBpMC7Jtcm1bmdEZWNsYXJlSW5qZWN0YWJsZSh7IG1pblZlcnNpb246IFwiMTIuMC4wXCIsIHZlcnNpb246IFwiMTQuMy4wXCIsIG5nSW1wb3J0OiBpMCwgdHlwZTogQW5pbWF0aW9uRnJhbWVTZXJ2aWNlU2luZ2xldG9uIH0pO1xuaTAuybXJtW5nRGVjbGFyZUNsYXNzTWV0YWRhdGEoeyBtaW5WZXJzaW9uOiBcIjEyLjAuMFwiLCB2ZXJzaW9uOiBcIjE0LjMuMFwiLCBuZ0ltcG9ydDogaTAsIHR5cGU6IEFuaW1hdGlvbkZyYW1lU2VydmljZVNpbmdsZXRvbiwgZGVjb3JhdG9yczogW3tcbiAgICAgICAgICAgIHR5cGU6IEluamVjdGFibGVcbiAgICAgICAgfV0sIGN0b3JQYXJhbWV0ZXJzOiBmdW5jdGlvbiAoKSB7IHJldHVybiBbeyB0eXBlOiBpMC5OZ1pvbmUgfV07IH0gfSk7XG5jbGFzcyBBbmltYXRpb25GcmFtZVNlcnZpY2Uge1xuICAgIGNvbnN0cnVjdG9yKHNpbmdsZXRvbikge1xuICAgICAgICB0aGlzLnNpbmdsZXRvbiA9IHNpbmdsZXRvbjtcbiAgICAgICAgdGhpcy50aWNrID0gZnJvbSh0aGlzLnNpbmdsZXRvbi50aWNrKTtcbiAgICB9XG59XG5BbmltYXRpb25GcmFtZVNlcnZpY2UuybVmYWMgPSBpMC7Jtcm1bmdEZWNsYXJlRmFjdG9yeSh7IG1pblZlcnNpb246IFwiMTIuMC4wXCIsIHZlcnNpb246IFwiMTQuMy4wXCIsIG5nSW1wb3J0OiBpMCwgdHlwZTogQW5pbWF0aW9uRnJhbWVTZXJ2aWNlLCBkZXBzOiBbeyB0b2tlbjogQW5pbWF0aW9uRnJhbWVTZXJ2aWNlU2luZ2xldG9uIH1dLCB0YXJnZXQ6IGkwLsm1ybVGYWN0b3J5VGFyZ2V0LkluamVjdGFibGUgfSk7XG5BbmltYXRpb25GcmFtZVNlcnZpY2UuybVwcm92ID0gaTAuybXJtW5nRGVjbGFyZUluamVjdGFibGUoeyBtaW5WZXJzaW9uOiBcIjEyLjAuMFwiLCB2ZXJzaW9uOiBcIjE0LjMuMFwiLCBuZ0ltcG9ydDogaTAsIHR5cGU6IEFuaW1hdGlvbkZyYW1lU2VydmljZSB9KTtcbmkwLsm1ybVuZ0RlY2xhcmVDbGFzc01ldGFkYXRhKHsgbWluVmVyc2lvbjogXCIxMi4wLjBcIiwgdmVyc2lvbjogXCIxNC4zLjBcIiwgbmdJbXBvcnQ6IGkwLCB0eXBlOiBBbmltYXRpb25GcmFtZVNlcnZpY2UsIGRlY29yYXRvcnM6IFt7XG4gICAgICAgICAgICB0eXBlOiBJbmplY3RhYmxlXG4gICAgICAgIH1dLCBjdG9yUGFyYW1ldGVyczogZnVuY3Rpb24gKCkgeyByZXR1cm4gW3sgdHlwZTogQW5pbWF0aW9uRnJhbWVTZXJ2aWNlU2luZ2xldG9uIH1dOyB9IH0pO1xuXG4vLyBjdXN0b20gZGVlcCBvYmplY3QgbWVyZ2VcbmNvbnN0IG1lcmdlID0gKHRhcmdldCwgLi4ub2JqZWN0cykgPT4ge1xuICAgIGZvciAoY29uc3Qgb2JqZWN0IG9mIG9iamVjdHMpIHtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gb2JqZWN0KSB7XG4gICAgICAgICAgICBpZiAob2JqZWN0Lmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgICAgICAvLyBzaW5jZSB3ZSdyZSBkZWFsaW5nIGp1c3Qgd2l0aCBKU09OIHRoaXMgc2ltcGxlIGNoZWNrIHNob3VsZCBiZSBlbm91Z2hcbiAgICAgICAgICAgICAgICBpZiAob2JqZWN0W2tleV0gaW5zdGFuY2VvZiBPYmplY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0YXJnZXRba2V5XSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0W2tleV0gPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyByZWN1cnNpdmVseSBtZXJnZSBpbnRvIHRoZSB0YXJnZXRcbiAgICAgICAgICAgICAgICAgICAgLy8gbW9zdCB0cmFuc2xhdGlvbnMgb25seSBydW4gMyBvciA0IGxldmVscyBkZWVwLCBzbyBubyBzdGFjayBleHBsb3Npb25zXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldFtrZXldID0gbWVyZ2UodGFyZ2V0W2tleV0sIG9iamVjdFtrZXldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldFtrZXldID0gb2JqZWN0W2tleV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0YXJnZXQ7XG59O1xuXG4vKipcbiAqIENoZWNrcyBpZiBhIGdpdmVuIGVsZW1lbnQgaXMgc2Nyb2xsYWJsZS5cbiAqIElmIHRoZSBlbGVtZW50IGhhcyBhbiBvdmVyZmxvdyBzZXQgYXMgcGFydCBvZiBpdHMgY29tcHV0ZWQgc3R5bGUgaXQgY2FuIHNjcm9sbC5cbiAqIEBwYXJhbSBlbGVtZW50IHRoZSBlbGVtZW50IHRvIGNoZWNrIHNjcm9sbGFiaWxpdHlcbiAqL1xuY29uc3QgaXNTY3JvbGxhYmxlRWxlbWVudCA9IChlbGVtZW50KSA9PiB7XG4gICAgY29uc3QgY29tcHV0ZWRTdHlsZSA9IGdldENvbXB1dGVkU3R5bGUoZWxlbWVudCk7XG4gICAgcmV0dXJuIChjb21wdXRlZFN0eWxlLm92ZXJmbG93ID09PSBcImF1dG9cIiB8fFxuICAgICAgICBjb21wdXRlZFN0eWxlLm92ZXJmbG93ID09PSBcInNjcm9sbFwiIHx8XG4gICAgICAgIGNvbXB1dGVkU3R5bGVbXCJvdmVyZmxvdy15XCJdID09PSBcImF1dG9cIiB8fFxuICAgICAgICBjb21wdXRlZFN0eWxlW1wib3ZlcmZsb3cteVwiXSA9PT0gXCJzY3JvbGxcIiB8fFxuICAgICAgICBjb21wdXRlZFN0eWxlW1wib3ZlcmZsb3cteFwiXSA9PT0gXCJhdXRvXCIgfHxcbiAgICAgICAgY29tcHV0ZWRTdHlsZVtcIm92ZXJmbG93LXhcIl0gPT09IFwic2Nyb2xsXCIpO1xufTtcbi8qKlxuICogQ2hlY2tzIGlmIGFuIGVsZW1lbnQgaXMgdmlzaWJsZSB3aXRoaW4gYSBjb250YWluZXJcbiAqIEBwYXJhbSBlbGVtZW50IHRoZSBlbGVtZW50IHRvIGNoZWNrXG4gKiBAcGFyYW0gY29udGFpbmVyIHRoZSBjb250YWluZXIgdG8gY2hlY2tcbiAqL1xuY29uc3QgaXNWaXNpYmxlSW5Db250YWluZXIgPSAoZWxlbWVudCwgY29udGFpbmVyKSA9PiB7XG4gICAgY29uc3QgZWxlbWVudFJlY3QgPSBlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIGNvbnN0IGNvbnRhaW5lclJlY3QgPSBjb250YWluZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgLy8gSWYgdGhlcmUgZXhpc3RzIGBoZWlnaHQ6IDEwMCVgIG9uIHRoZSBgaHRtbGAgb3IgYGJvZHlgIHRhZyBvZiBhbiBhcHBsaWNhdGlvbixcbiAgICAvLyBpdCBjYXVzZXMgdGhlIGNhbGN1bGF0aW9uIHRvIHJldHVybiB0cnVlIGlmIHlvdSBuZWVkIHRvIHNjcm9sbCBiZWZvcmUgdGhlIGVsZW1lbnQgaXMgc2Vlbi5cbiAgICAvLyBJbiB0aGF0IGNhc2Ugd2UgY2FsY3VsYXRlIGl0cyB2aXNpYmlsaXR5IGJhc2VkIG9uIHRoZSB3aW5kb3cgdmlld3BvcnQuXG4gICAgaWYgKGNvbnRhaW5lci50YWdOYW1lID09PSBcIkJPRFlcIiB8fCBjb250YWluZXIudGFnTmFtZSA9PT0gXCJIVE1MXCIpIHtcbiAgICAgICAgLy8gVGhpcyBjaGVja3MgaWYgZWxlbWVudCBpcyB3aXRoaW4gdGhlIHRvcCwgYm90dG9tLCBsZWZ0IGFuZCByaWdodCBvZiB2aWV3cG9ydCwgaWUuIGlmIHRoZSBlbGVtZW50IGlzIHZpc2libGUgaW5cbiAgICAgICAgLy8gdGhlIHNjcmVlbi4gVGhpcyBhbHNvIHRha2VzIGludG8gYWNjb3VudCBwYXJ0aWFsIHZpc2liaWxpdHkgb2YgYW4gZWxlbWVudC5cbiAgICAgICAgY29uc3QgaXNBYm92ZVZpZXdwb3J0ID0gZWxlbWVudFJlY3QudG9wIDwgMCAmJiAoZWxlbWVudFJlY3QudG9wICsgZWxlbWVudC5jbGllbnRIZWlnaHQpIDwgMDtcbiAgICAgICAgY29uc3QgaXNMZWZ0T2ZWaWV3cG9ydCA9IGVsZW1lbnRSZWN0LmxlZnQgPCAwO1xuICAgICAgICBjb25zdCBpc0JlbG93Vmlld3BvcnQgPSAoZWxlbWVudFJlY3QuYm90dG9tIC0gZWxlbWVudC5jbGllbnRIZWlnaHQpID4gKHdpbmRvdy5pbm5lckhlaWdodCB8fCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50SGVpZ2h0KTtcbiAgICAgICAgY29uc3QgaXNSaWdodE9mVmlld3BvcnQgPSBlbGVtZW50UmVjdC5yaWdodCA+ICh3aW5kb3cuaW5uZXJXaWR0aCB8fCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50V2lkdGgpO1xuICAgICAgICBjb25zdCBpc1Zpc2libGVJblZpZXdwb3J0ID0gIShpc0Fib3ZlVmlld3BvcnQgfHwgaXNCZWxvd1ZpZXdwb3J0IHx8IGlzTGVmdE9mVmlld3BvcnQgfHwgaXNSaWdodE9mVmlld3BvcnQpO1xuICAgICAgICByZXR1cm4gaXNWaXNpYmxlSW5WaWV3cG9ydDtcbiAgICB9XG4gICAgcmV0dXJuIChcbiAgICAvLyBUaGlzIGFsc28gYWNjb3VudHMgZm9yIHBhcnRpYWwgdmlzaWJpbGl0eS4gSXQgd2lsbCBzdGlsbCByZXR1cm4gdHJ1ZSBpZiB0aGUgZWxlbWVudCBpcyBwYXJ0aWFsbHkgdmlzaWJsZSBpbnNpZGUgdGhlIGNvbnRhaW5lci5cbiAgICAoZWxlbWVudFJlY3QuYm90dG9tIC0gZWxlbWVudC5jbGllbnRIZWlnaHQpIDw9IChjb250YWluZXJSZWN0LmJvdHRvbSArIChjb250YWluZXIub2Zmc2V0SGVpZ2h0IC0gY29udGFpbmVyLmNsaWVudEhlaWdodCkgLyAyKSAmJlxuICAgICAgICBlbGVtZW50UmVjdC50b3AgPj0gKC1lbGVtZW50LmNsaWVudEhlaWdodCkpO1xufTtcbmNvbnN0IGdldFNjcm9sbGFibGVQYXJlbnRzID0gKG5vZGUpID0+IHtcbiAgICBjb25zdCBlbGVtZW50cyA9IFtkb2N1bWVudC5ib2R5XTtcbiAgICB3aGlsZSAobm9kZS5wYXJlbnRFbGVtZW50ICYmIG5vZGUgIT09IGRvY3VtZW50LmJvZHkpIHtcbiAgICAgICAgaWYgKGlzU2Nyb2xsYWJsZUVsZW1lbnQobm9kZSkpIHtcbiAgICAgICAgICAgIGVsZW1lbnRzLnB1c2gobm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgbm9kZSA9IG5vZGUucGFyZW50RWxlbWVudDtcbiAgICB9XG4gICAgcmV0dXJuIGVsZW1lbnRzO1xufTtcbmNvbnN0IGhhc1Njcm9sbGFibGVQYXJlbnRzID0gKG5vZGUpID0+IHtcbiAgICB3aGlsZSAobm9kZS5wYXJlbnRFbGVtZW50ICYmIG5vZGUgIT09IGRvY3VtZW50LmJvZHkpIHtcbiAgICAgICAgaWYgKGlzU2Nyb2xsYWJsZUVsZW1lbnQobm9kZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIG5vZGUgPSBub2RlLnBhcmVudEVsZW1lbnQ7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn07XG4vKipcbiAqIFJldHVybnMgYW4gb2JzZXJ2YWJsZSB0aGF0IGVtaXRzIHdoZW5ldmVyIGFueSBzY3JvbGxhYmxlIHBhcmVudCBlbGVtZW50IHNjcm9sbHNcbiAqXG4gKiBAcGFyYW0gbm9kZSByb290IGVsZW1lbnQgdG8gc3RhcnQgZmluZGluZyBzY3JvbGxpbmcgcGFyZW50cyBmcm9tXG4gKi9cbmNvbnN0IHNjcm9sbGFibGVQYXJlbnRzT2JzZXJ2YWJsZSA9IChub2RlKSA9PiB7XG4gICAgY29uc3Qgd2luZG93U2Nyb2xsID0gZnJvbUV2ZW50KHdpbmRvdywgXCJzY3JvbGxcIiwgeyBwYXNzaXZlOiB0cnVlIH0pLnBpcGUobWFwKGV2ZW50ID0+IFxuICAgIC8vIHVwZGF0ZSB0aGUgZXZlbnQgdGFyZ2V0IHRvIGJlIHNvbWV0aGluZyB1c2VmdWwuIEluIHRoaXMgY2FzZSBgYm9keWAgaXMgYSBzZW5zaWJsZSByZXBsYWNlbWVudFxuICAgIE9iamVjdC5hc3NpZ24oe30sIGV2ZW50LCB7IHRhcmdldDogZG9jdW1lbnQuYm9keSB9KSkpO1xuICAgIGxldCBvYnNlcnZhYmxlcyA9IFt3aW5kb3dTY3JvbGxdO1xuICAgIC8vIHdhbGsgdGhlIHBhcmVudHMgYW5kIHN1YnNjcmliZSB0byBhbGwgdGhlIHNjcm9sbCBldmVudHMgd2UgY2FuXG4gICAgd2hpbGUgKG5vZGUucGFyZW50RWxlbWVudCAmJiBub2RlICE9PSBkb2N1bWVudC5ib2R5KSB7XG4gICAgICAgIGlmIChpc1Njcm9sbGFibGVFbGVtZW50KG5vZGUpKSB7XG4gICAgICAgICAgICBvYnNlcnZhYmxlcy5wdXNoKGZyb21FdmVudChub2RlLCBcInNjcm9sbFwiLCB7IHBhc3NpdmU6IHRydWUgfSkpO1xuICAgICAgICB9XG4gICAgICAgIG5vZGUgPSBub2RlLnBhcmVudEVsZW1lbnQ7XG4gICAgfVxuICAgIHJldHVybiBtZXJnZSQxKC4uLm9ic2VydmFibGVzKTtcbn07XG5cbmZ1bmN0aW9uIGNsb25lKG9iaikge1xuICAgIHJldHVybiBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KG9iaikpO1xufVxuZnVuY3Rpb24gbWF0Y2hlc0F0dHIoZWwsIGF0dHIsIHZhbCkge1xuICAgIGNvbnN0IHN0eWxlcyA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsKTtcbiAgICByZXR1cm4gdmFsLmluY2x1ZGVzKHN0eWxlc1thdHRyXSk7XG59XG5mdW5jdGlvbiBjbG9zZXN0QXR0cihzLCB0LCBlbGVtZW50KSB7XG4gICAgbGV0IGVsID0gZWxlbWVudDtcbiAgICBpZiAoIWVsZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGRvIHtcbiAgICAgICAgaWYgKG1hdGNoZXNBdHRyKGVsLCBzLCB0KSkge1xuICAgICAgICAgICAgcmV0dXJuIGVsO1xuICAgICAgICB9XG4gICAgICAgIGVsID0gZWwucGFyZW50RWxlbWVudCB8fCBlbC5wYXJlbnROb2RlO1xuICAgIH0gd2hpbGUgKGVsICE9PSBudWxsICYmIGVsLm5vZGVUeXBlID09PSAxKTtcbiAgICByZXR1cm4gbnVsbDtcbn1cblxuY2xhc3MgRWxlbWVudFNlcnZpY2Uge1xuICAgIGNvbnN0cnVjdG9yKHNpbmdsZXRvbikge1xuICAgICAgICB0aGlzLnNpbmdsZXRvbiA9IHNpbmdsZXRvbjtcbiAgICAgICAgdGhpcy50aWNrID0gZnJvbSh0aGlzLnNpbmdsZXRvbi50aWNrKTtcbiAgICB9XG4gICAgdmlzaWJpbGl0eSh0YXJnZXQsIHBhcmVudEVsZW1lbnQgPSB0YXJnZXQpIHtcbiAgICAgICAgY29uc3Qgc2Nyb2xsYWJsZVBhcmVudHMgPSBnZXRTY3JvbGxhYmxlUGFyZW50cyhwYXJlbnRFbGVtZW50KTtcbiAgICAgICAgcmV0dXJuIHRoaXMudGljay5waXBlKG1hcCgoKSA9PiB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHBhcmVudCBvZiBzY3JvbGxhYmxlUGFyZW50cykge1xuICAgICAgICAgICAgICAgIGlmICghaXNWaXNpYmxlSW5Db250YWluZXIodGFyZ2V0LCBwYXJlbnQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2aXNpYmxlOiBmYWxzZVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdmlzaWJsZTogdHJ1ZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSkpO1xuICAgIH1cbn1cbkVsZW1lbnRTZXJ2aWNlLsm1ZmFjID0gaTAuybXJtW5nRGVjbGFyZUZhY3RvcnkoeyBtaW5WZXJzaW9uOiBcIjEyLjAuMFwiLCB2ZXJzaW9uOiBcIjE0LjMuMFwiLCBuZ0ltcG9ydDogaTAsIHR5cGU6IEVsZW1lbnRTZXJ2aWNlLCBkZXBzOiBbeyB0b2tlbjogQW5pbWF0aW9uRnJhbWVTZXJ2aWNlU2luZ2xldG9uIH1dLCB0YXJnZXQ6IGkwLsm1ybVGYWN0b3J5VGFyZ2V0LkluamVjdGFibGUgfSk7XG5FbGVtZW50U2VydmljZS7JtXByb3YgPSBpMC7Jtcm1bmdEZWNsYXJlSW5qZWN0YWJsZSh7IG1pblZlcnNpb246IFwiMTIuMC4wXCIsIHZlcnNpb246IFwiMTQuMy4wXCIsIG5nSW1wb3J0OiBpMCwgdHlwZTogRWxlbWVudFNlcnZpY2UgfSk7XG5pMC7Jtcm1bmdEZWNsYXJlQ2xhc3NNZXRhZGF0YSh7IG1pblZlcnNpb246IFwiMTIuMC4wXCIsIHZlcnNpb246IFwiMTQuMy4wXCIsIG5nSW1wb3J0OiBpMCwgdHlwZTogRWxlbWVudFNlcnZpY2UsIGRlY29yYXRvcnM6IFt7XG4gICAgICAgICAgICB0eXBlOiBJbmplY3RhYmxlXG4gICAgICAgIH1dLCBjdG9yUGFyYW1ldGVyczogZnVuY3Rpb24gKCkgeyByZXR1cm4gW3sgdHlwZTogQW5pbWF0aW9uRnJhbWVTZXJ2aWNlU2luZ2xldG9uIH1dOyB9IH0pO1xuXG5jb25zdCBnZXRFdmVudE9ic2VydmFibGUgPSAodGFyZ2V0RWxlbWVudCwgZXZlbnRUeXBlKSA9PiB7XG4gICAgc3dpdGNoIChldmVudFR5cGUpIHtcbiAgICAgICAgY2FzZSBcInNjcm9sbFwiOlxuICAgICAgICBjYXNlIFwicmVzaXplXCI6XG4gICAgICAgIGNhc2UgXCJ0b3VjaHN0YXJ0XCI6XG4gICAgICAgIGNhc2UgXCJ0b3VjaG1vdmVcIjpcbiAgICAgICAgY2FzZSBcInRvdWNoZW5kXCI6XG4gICAgICAgICAgICByZXR1cm4gZnJvbUV2ZW50KHRhcmdldEVsZW1lbnQsIGV2ZW50VHlwZSwgeyBwYXNzaXZlOiB0cnVlIH0pO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIGZyb21FdmVudCh0YXJnZXRFbGVtZW50LCBldmVudFR5cGUpO1xuICAgIH1cbn07XG5cbmNsYXNzIERvY3VtZW50U2VydmljZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuZ2xvYmFsRXZlbnRzID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLmRvY3VtZW50UmVmID0gZG9jdW1lbnQ7XG4gICAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucyA9IG5ldyBTdWJzY3JpcHRpb24oKTtcbiAgICB9XG4gICAgaGFuZGxlRXZlbnQoZXZlbnRUeXBlLCBjYWxsYmFjaykge1xuICAgICAgICBpZiAoIXRoaXMuZ2xvYmFsRXZlbnRzLmhhcyhldmVudFR5cGUpKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5kb2N1bWVudFJlZikge1xuICAgICAgICAgICAgICAgIHRoaXMuZ2xvYmFsRXZlbnRzLnNldChldmVudFR5cGUsIGdldEV2ZW50T2JzZXJ2YWJsZSh0aGlzLmRvY3VtZW50UmVmLCBldmVudFR5cGUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuZ2xvYmFsRXZlbnRzLnNldChldmVudFR5cGUsIG5ldyBPYnNlcnZhYmxlKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG9ic2VydmFibGUgPSB0aGlzLmdsb2JhbEV2ZW50cy5nZXQoZXZlbnRUeXBlKTtcbiAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25zLmFkZChvYnNlcnZhYmxlLnN1YnNjcmliZShjYWxsYmFjaykpO1xuICAgIH1cbiAgICBoYW5kbGVDbGljayhjYWxsYmFjaykge1xuICAgICAgICB0aGlzLmhhbmRsZUV2ZW50KFwiY2xpY2tcIiwgY2FsbGJhY2spO1xuICAgIH1cbiAgICBuZ09uRGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25zLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgIHRoaXMuZ2xvYmFsRXZlbnRzID0gbnVsbDtcbiAgICB9XG59XG5Eb2N1bWVudFNlcnZpY2UuybVmYWMgPSBpMC7Jtcm1bmdEZWNsYXJlRmFjdG9yeSh7IG1pblZlcnNpb246IFwiMTIuMC4wXCIsIHZlcnNpb246IFwiMTQuMy4wXCIsIG5nSW1wb3J0OiBpMCwgdHlwZTogRG9jdW1lbnRTZXJ2aWNlLCBkZXBzOiBbXSwgdGFyZ2V0OiBpMC7Jtcm1RmFjdG9yeVRhcmdldC5JbmplY3RhYmxlIH0pO1xuRG9jdW1lbnRTZXJ2aWNlLsm1cHJvdiA9IGkwLsm1ybVuZ0RlY2xhcmVJbmplY3RhYmxlKHsgbWluVmVyc2lvbjogXCIxMi4wLjBcIiwgdmVyc2lvbjogXCIxNC4zLjBcIiwgbmdJbXBvcnQ6IGkwLCB0eXBlOiBEb2N1bWVudFNlcnZpY2UgfSk7XG5pMC7Jtcm1bmdEZWNsYXJlQ2xhc3NNZXRhZGF0YSh7IG1pblZlcnNpb246IFwiMTIuMC4wXCIsIHZlcnNpb246IFwiMTQuMy4wXCIsIG5nSW1wb3J0OiBpMCwgdHlwZTogRG9jdW1lbnRTZXJ2aWNlLCBkZWNvcmF0b3JzOiBbe1xuICAgICAgICAgICAgdHlwZTogSW5qZWN0YWJsZVxuICAgICAgICB9XSB9KTtcblxuY2xhc3MgRXZlbnRTZXJ2aWNlIHtcbiAgICBjb25zdHJ1Y3Rvcihkb2N1bWVudFNlcnZpY2UpIHtcbiAgICAgICAgdGhpcy5kb2N1bWVudFNlcnZpY2UgPSBkb2N1bWVudFNlcnZpY2U7XG4gICAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucyA9IG5ldyBTdWJzY3JpcHRpb24oKTtcbiAgICAgICAgdGhpcy50YXJnZXRzID0gbmV3IFdlYWtNYXAoKTtcbiAgICB9XG4gICAgb24odGFyZ2V0RWxlbWVudCwgZXZlbnRUeXBlLCBjYWxsYmFjaykge1xuICAgICAgICBpZiAoIXRoaXMudGFyZ2V0cy5oYXModGFyZ2V0RWxlbWVudCkpIHtcbiAgICAgICAgICAgIHRoaXMudGFyZ2V0cy5zZXQodGFyZ2V0RWxlbWVudCwgbmV3IE1hcCgpKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBldmVudE1hcCA9IHRoaXMudGFyZ2V0cy5nZXQodGFyZ2V0RWxlbWVudCk7XG4gICAgICAgIGlmICghZXZlbnRNYXAuaGFzKGV2ZW50VHlwZSkpIHtcbiAgICAgICAgICAgIGV2ZW50TWFwLnNldChldmVudFR5cGUsIGdldEV2ZW50T2JzZXJ2YWJsZSh0YXJnZXRFbGVtZW50LCBldmVudFR5cGUpKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzdWJzY3JpcHRpb24gPSBldmVudE1hcC5nZXQoZXZlbnRUeXBlKS5zdWJzY3JpYmUoY2FsbGJhY2spO1xuICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbnMuYWRkKHN1YnNjcmlwdGlvbik7XG4gICAgfVxuICAgIG9uRG9jdW1lbnQoZXZlbnRUeXBlLCBjYWxsYmFjaykge1xuICAgICAgICB0aGlzLmRvY3VtZW50U2VydmljZS5oYW5kbGVFdmVudChldmVudFR5cGUsIGNhbGxiYWNrKTtcbiAgICB9XG4gICAgbmdPbkRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucy51bnN1YnNjcmliZSgpO1xuICAgIH1cbn1cbkV2ZW50U2VydmljZS7JtWZhYyA9IGkwLsm1ybVuZ0RlY2xhcmVGYWN0b3J5KHsgbWluVmVyc2lvbjogXCIxMi4wLjBcIiwgdmVyc2lvbjogXCIxNC4zLjBcIiwgbmdJbXBvcnQ6IGkwLCB0eXBlOiBFdmVudFNlcnZpY2UsIGRlcHM6IFt7IHRva2VuOiBEb2N1bWVudFNlcnZpY2UgfV0sIHRhcmdldDogaTAuybXJtUZhY3RvcnlUYXJnZXQuSW5qZWN0YWJsZSB9KTtcbkV2ZW50U2VydmljZS7JtXByb3YgPSBpMC7Jtcm1bmdEZWNsYXJlSW5qZWN0YWJsZSh7IG1pblZlcnNpb246IFwiMTIuMC4wXCIsIHZlcnNpb246IFwiMTQuMy4wXCIsIG5nSW1wb3J0OiBpMCwgdHlwZTogRXZlbnRTZXJ2aWNlIH0pO1xuaTAuybXJtW5nRGVjbGFyZUNsYXNzTWV0YWRhdGEoeyBtaW5WZXJzaW9uOiBcIjEyLjAuMFwiLCB2ZXJzaW9uOiBcIjE0LjMuMFwiLCBuZ0ltcG9ydDogaTAsIHR5cGU6IEV2ZW50U2VydmljZSwgZGVjb3JhdG9yczogW3tcbiAgICAgICAgICAgIHR5cGU6IEluamVjdGFibGVcbiAgICAgICAgfV0sIGN0b3JQYXJhbWV0ZXJzOiBmdW5jdGlvbiAoKSB7IHJldHVybiBbeyB0eXBlOiBEb2N1bWVudFNlcnZpY2UgfV07IH0gfSk7XG5cbi8vIGVpdGhlciBwcm92aWRlcyBhIG5ldyBpbnN0YW5jZSBvZiBEb2N1bWVudFNlcnZpY2UsIG9yIHJldHVybnMgdGhlIHBhcmVudFxuZnVuY3Rpb24gRE9DVU1FTlRfU0VSVklDRV9QUk9WSURFUl9GQUNUT1JZKHBhcmVudFNlcnZpY2UpIHtcbiAgICByZXR1cm4gcGFyZW50U2VydmljZSB8fCBuZXcgRG9jdW1lbnRTZXJ2aWNlKCk7XG59XG4vLyBEb2N1bWVudFNlcnZpY2UgKm11c3QqIGJlIGEgc2luZ2xldG9uIHRvIGVuc3VyZSB0aGF0IHdlIGhhbmRsZSBldmVudHMgYW5kIG90aGVyIGRvY3VtZW50IGxldmVsIHNldHRpbmdzIG9uY2UgKGFuZCBvbmx5IG9uY2UpXG5jb25zdCBET0NVTUVOVF9TRVJWSUNFX1BST1ZJREVSID0ge1xuICAgIHByb3ZpZGU6IERvY3VtZW50U2VydmljZSxcbiAgICBkZXBzOiBbW25ldyBPcHRpb25hbCgpLCBuZXcgU2tpcFNlbGYoKSwgRG9jdW1lbnRTZXJ2aWNlXV0sXG4gICAgdXNlRmFjdG9yeTogRE9DVU1FTlRfU0VSVklDRV9QUk9WSURFUl9GQUNUT1JZXG59O1xuLy8gZWl0aGVyIHByb3ZpZGVzIGEgbmV3IGluc3RhbmNlIG9mIEFuaW1hdGlvbkZyYW1lU2VydmljZVNpbmdsZXRvbiwgb3IgcmV0dXJucyB0aGUgcGFyZW50XG5mdW5jdGlvbiBBTklNQVRJT05fRlJBTUVfU0VSVklDRV9TSU5HTEVUT05fUFJPVklERVJfRkFDVE9SWShwYXJlbnRTZXJ2aWNlLCBuZ1pvbmUpIHtcbiAgICByZXR1cm4gcGFyZW50U2VydmljZSB8fCBuZXcgQW5pbWF0aW9uRnJhbWVTZXJ2aWNlU2luZ2xldG9uKG5nWm9uZSk7XG59XG4vLyBBbmltYXRpb25GcmFtZVNlcnZpY2VTaW5nbGV0b24gaXMgYSBzaW5nbGV0b24gc28gd2UgZG9uJ3QgaGF2ZSBhIHRvbiBvZiBkdXBsaWNhdGUgUkFGcyBmaXJpbmcgKGJldHRlciBmb3Igc2NoZWR1bGluZylcbmNvbnN0IEFOSU1BVElPTl9GUkFNRV9TRVJWSUNFX1NJTkdMRVRPTl9QUk9WSURFUiA9IHtcbiAgICBwcm92aWRlOiBBbmltYXRpb25GcmFtZVNlcnZpY2VTaW5nbGV0b24sXG4gICAgZGVwczogW1tuZXcgT3B0aW9uYWwoKSwgbmV3IFNraXBTZWxmKCksIEFuaW1hdGlvbkZyYW1lU2VydmljZVNpbmdsZXRvbl0sIE5nWm9uZV0sXG4gICAgdXNlRmFjdG9yeTogQU5JTUFUSU9OX0ZSQU1FX1NFUlZJQ0VfU0lOR0xFVE9OX1BST1ZJREVSX0ZBQ1RPUllcbn07XG5jbGFzcyBVdGlsc01vZHVsZSB7XG59XG5VdGlsc01vZHVsZS7JtWZhYyA9IGkwLsm1ybVuZ0RlY2xhcmVGYWN0b3J5KHsgbWluVmVyc2lvbjogXCIxMi4wLjBcIiwgdmVyc2lvbjogXCIxNC4zLjBcIiwgbmdJbXBvcnQ6IGkwLCB0eXBlOiBVdGlsc01vZHVsZSwgZGVwczogW10sIHRhcmdldDogaTAuybXJtUZhY3RvcnlUYXJnZXQuTmdNb2R1bGUgfSk7XG5VdGlsc01vZHVsZS7JtW1vZCA9IGkwLsm1ybVuZ0RlY2xhcmVOZ01vZHVsZSh7IG1pblZlcnNpb246IFwiMTQuMC4wXCIsIHZlcnNpb246IFwiMTQuMy4wXCIsIG5nSW1wb3J0OiBpMCwgdHlwZTogVXRpbHNNb2R1bGUgfSk7XG5VdGlsc01vZHVsZS7JtWluaiA9IGkwLsm1ybVuZ0RlY2xhcmVJbmplY3Rvcih7IG1pblZlcnNpb246IFwiMTIuMC4wXCIsIHZlcnNpb246IFwiMTQuMy4wXCIsIG5nSW1wb3J0OiBpMCwgdHlwZTogVXRpbHNNb2R1bGUsIHByb3ZpZGVyczogW1xuICAgICAgICBET0NVTUVOVF9TRVJWSUNFX1BST1ZJREVSLFxuICAgICAgICBBTklNQVRJT05fRlJBTUVfU0VSVklDRV9TSU5HTEVUT05fUFJPVklERVIsXG4gICAgICAgIEFuaW1hdGlvbkZyYW1lU2VydmljZVNpbmdsZXRvbixcbiAgICAgICAgRG9jdW1lbnRTZXJ2aWNlLFxuICAgICAgICBBbmltYXRpb25GcmFtZVNlcnZpY2UsXG4gICAgICAgIEVsZW1lbnRTZXJ2aWNlLFxuICAgICAgICBFdmVudFNlcnZpY2VcbiAgICBdIH0pO1xuaTAuybXJtW5nRGVjbGFyZUNsYXNzTWV0YWRhdGEoeyBtaW5WZXJzaW9uOiBcIjEyLjAuMFwiLCB2ZXJzaW9uOiBcIjE0LjMuMFwiLCBuZ0ltcG9ydDogaTAsIHR5cGU6IFV0aWxzTW9kdWxlLCBkZWNvcmF0b3JzOiBbe1xuICAgICAgICAgICAgdHlwZTogTmdNb2R1bGUsXG4gICAgICAgICAgICBhcmdzOiBbe1xuICAgICAgICAgICAgICAgICAgICBwcm92aWRlcnM6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIERPQ1VNRU5UX1NFUlZJQ0VfUFJPVklERVIsXG4gICAgICAgICAgICAgICAgICAgICAgICBBTklNQVRJT05fRlJBTUVfU0VSVklDRV9TSU5HTEVUT05fUFJPVklERVIsXG4gICAgICAgICAgICAgICAgICAgICAgICBBbmltYXRpb25GcmFtZVNlcnZpY2VTaW5nbGV0b24sXG4gICAgICAgICAgICAgICAgICAgICAgICBEb2N1bWVudFNlcnZpY2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBBbmltYXRpb25GcmFtZVNlcnZpY2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBFbGVtZW50U2VydmljZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIEV2ZW50U2VydmljZVxuICAgICAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICAgfV1cbiAgICAgICAgfV0gfSk7XG5cbmxldCBfc2Nyb2xsYmFyV2lkdGggPSAtMTtcbmZ1bmN0aW9uIGdldFNjcm9sbGJhcldpZHRoKCkge1xuICAgIC8vIGxldHMgbm90IHJlY3JlYXRlIHRoaXMgd2hvbGUgdGhpbmcgZXZlcnkgdGltZVxuICAgIGlmIChfc2Nyb2xsYmFyV2lkdGggPj0gMCkge1xuICAgICAgICByZXR1cm4gX3Njcm9sbGJhcldpZHRoO1xuICAgIH1cbiAgICAvLyBkbyB0aGUgY2FsY3VsYXRpb25zIHRoZSBmaXJzdCB0aW1lXG4gICAgY29uc3Qgb3V0ZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgIG91dGVyLnN0eWxlLnZpc2liaWxpdHkgPSBcImhpZGRlblwiO1xuICAgIG91dGVyLnN0eWxlLndpZHRoID0gXCIxMDBweFwiO1xuICAgIG91dGVyLnN0eWxlW1wibXNPdmVyZmxvd1N0eWxlXCJdID0gXCJzY3JvbGxiYXJcIjsgLy8gbmVlZGVkIGZvciBXaW5KUyBhcHBzXG4gICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChvdXRlcik7XG4gICAgY29uc3Qgd2lkdGhOb1Njcm9sbCA9IG91dGVyLm9mZnNldFdpZHRoO1xuICAgIC8vIGZvcmNlIHNjcm9sbGJhcnNcbiAgICBvdXRlci5zdHlsZS5vdmVyZmxvdyA9IFwic2Nyb2xsXCI7XG4gICAgLy8gYWRkIGlubmVyZGl2XG4gICAgY29uc3QgaW5uZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgIGlubmVyLnN0eWxlLndpZHRoID0gXCIxMDAlXCI7XG4gICAgb3V0ZXIuYXBwZW5kQ2hpbGQoaW5uZXIpO1xuICAgIGNvbnN0IHdpZHRoV2l0aFNjcm9sbCA9IGlubmVyLm9mZnNldFdpZHRoO1xuICAgIC8vIHJlbW92ZSBkaXZzXG4gICAgb3V0ZXIucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChvdXRlcik7XG4gICAgX3Njcm9sbGJhcldpZHRoID0gd2lkdGhOb1Njcm9sbCAtIHdpZHRoV2l0aFNjcm9sbDtcbiAgICByZXR1cm4gX3Njcm9sbGJhcldpZHRoO1xufVxuXG4vKipcbiAqIEdlbmVyYXRlZCBidW5kbGUgaW5kZXguIERvIG5vdCBlZGl0LlxuICovXG5cbmV4cG9ydCB7IEFOSU1BVElPTl9GUkFNRV9TRVJWSUNFX1NJTkdMRVRPTl9QUk9WSURFUiwgQU5JTUFUSU9OX0ZSQU1FX1NFUlZJQ0VfU0lOR0xFVE9OX1BST1ZJREVSX0ZBQ1RPUlksIEFuaW1hdGlvbkZyYW1lU2VydmljZSwgQW5pbWF0aW9uRnJhbWVTZXJ2aWNlU2luZ2xldG9uLCBET0NVTUVOVF9TRVJWSUNFX1BST1ZJREVSLCBET0NVTUVOVF9TRVJWSUNFX1BST1ZJREVSX0ZBQ1RPUlksIERvY3VtZW50U2VydmljZSwgRWxlbWVudFNlcnZpY2UsIEV2ZW50U2VydmljZSwgSGNNb2RlQ2hlY2tlciwgVXRpbHNNb2R1bGUsIGNsb25lLCBjbG9zZXN0QXR0ciwgZmluZE5leHRFbGVtLCBmaW5kUHJldkVsZW0sIGZvY3VzTmV4dEVsZW0sIGZvY3VzTmV4dFRyZWUsIGZvY3VzUHJldkVsZW0sIGdldEV2ZW50T2JzZXJ2YWJsZSwgZ2V0U2Nyb2xsYWJsZVBhcmVudHMsIGdldFNjcm9sbGJhcldpZHRoLCBoYXNTY3JvbGxhYmxlUGFyZW50cywgaXNTY3JvbGxhYmxlRWxlbWVudCwgaXNWaXNpYmxlSW5Db250YWluZXIsIG1lcmdlLCBzY3JvbGxhYmxlUGFyZW50c09ic2VydmFibGUgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNhcmJvbi1jb21wb25lbnRzLWFuZ3VsYXItdXRpbHMubWpzLm1hcFxuIiwiLy8gVGhlIG1vZHVsZSBjYWNoZVxudmFyIF9fd2VicGFja19tb2R1bGVfY2FjaGVfXyA9IHt9O1xuXG4vLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcblx0dmFyIGNhY2hlZE1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF07XG5cdGlmIChjYWNoZWRNb2R1bGUgIT09IHVuZGVmaW5lZCkge1xuXHRcdHJldHVybiBjYWNoZWRNb2R1bGUuZXhwb3J0cztcblx0fVxuXHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuXHR2YXIgbW9kdWxlID0gX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXSA9IHtcblx0XHQvLyBubyBtb2R1bGUuaWQgbmVlZGVkXG5cdFx0Ly8gbm8gbW9kdWxlLmxvYWRlZCBuZWVkZWRcblx0XHRleHBvcnRzOiB7fVxuXHR9O1xuXG5cdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuXHRfX3dlYnBhY2tfbW9kdWxlc19fW21vZHVsZUlkXShtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuXHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuXHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG59XG5cbiIsIi8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXG5fX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSAobW9kdWxlKSA9PiB7XG5cdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuXHRcdCgpID0+IChtb2R1bGVbJ2RlZmF1bHQnXSkgOlxuXHRcdCgpID0+IChtb2R1bGUpO1xuXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCB7IGE6IGdldHRlciB9KTtcblx0cmV0dXJuIGdldHRlcjtcbn07IiwidmFyIGdldFByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mID8gKG9iaikgPT4gKE9iamVjdC5nZXRQcm90b3R5cGVPZihvYmopKSA6IChvYmopID0+IChvYmouX19wcm90b19fKTtcbnZhciBsZWFmUHJvdG90eXBlcztcbi8vIGNyZWF0ZSBhIGZha2UgbmFtZXNwYWNlIG9iamVjdFxuLy8gbW9kZSAmIDE6IHZhbHVlIGlzIGEgbW9kdWxlIGlkLCByZXF1aXJlIGl0XG4vLyBtb2RlICYgMjogbWVyZ2UgYWxsIHByb3BlcnRpZXMgb2YgdmFsdWUgaW50byB0aGUgbnNcbi8vIG1vZGUgJiA0OiByZXR1cm4gdmFsdWUgd2hlbiBhbHJlYWR5IG5zIG9iamVjdFxuLy8gbW9kZSAmIDE2OiByZXR1cm4gdmFsdWUgd2hlbiBpdCdzIFByb21pc2UtbGlrZVxuLy8gbW9kZSAmIDh8MTogYmVoYXZlIGxpa2UgcmVxdWlyZVxuX193ZWJwYWNrX3JlcXVpcmVfXy50ID0gZnVuY3Rpb24odmFsdWUsIG1vZGUpIHtcblx0aWYobW9kZSAmIDEpIHZhbHVlID0gdGhpcyh2YWx1ZSk7XG5cdGlmKG1vZGUgJiA4KSByZXR1cm4gdmFsdWU7XG5cdGlmKHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUpIHtcblx0XHRpZigobW9kZSAmIDQpICYmIHZhbHVlLl9fZXNNb2R1bGUpIHJldHVybiB2YWx1ZTtcblx0XHRpZigobW9kZSAmIDE2KSAmJiB0eXBlb2YgdmFsdWUudGhlbiA9PT0gJ2Z1bmN0aW9uJykgcmV0dXJuIHZhbHVlO1xuXHR9XG5cdHZhciBucyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cdF9fd2VicGFja19yZXF1aXJlX18ucihucyk7XG5cdHZhciBkZWYgPSB7fTtcblx0bGVhZlByb3RvdHlwZXMgPSBsZWFmUHJvdG90eXBlcyB8fCBbbnVsbCwgZ2V0UHJvdG8oe30pLCBnZXRQcm90byhbXSksIGdldFByb3RvKGdldFByb3RvKV07XG5cdGZvcih2YXIgY3VycmVudCA9IG1vZGUgJiAyICYmIHZhbHVlOyB0eXBlb2YgY3VycmVudCA9PSAnb2JqZWN0JyAmJiAhfmxlYWZQcm90b3R5cGVzLmluZGV4T2YoY3VycmVudCk7IGN1cnJlbnQgPSBnZXRQcm90byhjdXJyZW50KSkge1xuXHRcdE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGN1cnJlbnQpLmZvckVhY2goKGtleSkgPT4gKGRlZltrZXldID0gKCkgPT4gKHZhbHVlW2tleV0pKSk7XG5cdH1cblx0ZGVmWydkZWZhdWx0J10gPSAoKSA9PiAodmFsdWUpO1xuXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQobnMsIGRlZik7XG5cdHJldHVybiBucztcbn07IiwiLy8gZGVmaW5lIGdldHRlciBmdW5jdGlvbnMgZm9yIGhhcm1vbnkgZXhwb3J0c1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kID0gKGV4cG9ydHMsIGRlZmluaXRpb24pID0+IHtcblx0Zm9yKHZhciBrZXkgaW4gZGVmaW5pdGlvbikge1xuXHRcdGlmKF9fd2VicGFja19yZXF1aXJlX18ubyhkZWZpbml0aW9uLCBrZXkpICYmICFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywga2V5KSkge1xuXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGRlZmluaXRpb25ba2V5XSB9KTtcblx0XHR9XG5cdH1cbn07IiwiX193ZWJwYWNrX3JlcXVpcmVfXy5vID0gKG9iaiwgcHJvcCkgPT4gKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApKSIsIi8vIGRlZmluZSBfX2VzTW9kdWxlIG9uIGV4cG9ydHNcbl9fd2VicGFja19yZXF1aXJlX18uciA9IChleHBvcnRzKSA9PiB7XG5cdGlmKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC50b1N0cmluZ1RhZykge1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6ICdNb2R1bGUnIH0pO1xuXHR9XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG59OyIsIi8qXG4gKiBDb3B5cmlnaHQgMjAxNS0yMDI0LiBSaXRlbnNlIEJWLCB0aGUgTmV0aGVybGFuZHMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgRVVQTCwgVmVyc2lvbiAxLjIgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwczovL2pvaW51cC5lYy5ldXJvcGEuZXUvY29sbGVjdGlvbi9ldXBsL2V1cGwtdGV4dC1ldXBsLTEyXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIGJhc2lzLFxuICpcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXJcbiAqIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqL1xuXG4vKlxuICogUHVibGljIEFQSSBTdXJmYWNlIG9mIHNsYWNrXG4gKi9cblxuZXhwb3J0ICogZnJvbSAnLi9saWIvbW9kZWxzJztcbmV4cG9ydCAqIGZyb20gJy4vbGliL3Nwb3RsZXItcGx1Z2luLW1vZHVsZSc7XG5leHBvcnQgKiBmcm9tICcuL2xpYi9zcG90bGVyLXBsdWdpbi5zcGVjaWZpY2F0aW9uJztcbmV4cG9ydCAqIGZyb20gJy4vbGliL2NvbXBvbmVudHMvcGx1Z2luLWNvbmZpZ3VyYXRpb24vc3BvdGxlci1wbHVnaW4tY29uZmlndXJhdGlvbi5jb21wb25lbnQnO1xuZXhwb3J0ICogZnJvbSAnLi9saWIvY29tcG9uZW50cy9zZW5kLW1haWwtY29uZmlndXJhdGlvbi9zZW5kLW1haWwtYWN0aW9uLWNvbmZpZ3VyYXRpb24uY29tcG9uZW50JztcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==