/******/ var __webpack_modules__ = ({

/***/ "../../../node_modules/rxjs/dist/esm5/internal/NotificationFactories.js":
/*!******************************************************************************!*\
  !*** ../../../node_modules/rxjs/dist/esm5/internal/NotificationFactories.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   COMPLETE_NOTIFICATION: () => (/* binding */ COMPLETE_NOTIFICATION),
/* harmony export */   createNotification: () => (/* binding */ createNotification),
/* harmony export */   errorNotification: () => (/* binding */ errorNotification),
/* harmony export */   nextNotification: () => (/* binding */ nextNotification)
/* harmony export */ });
var COMPLETE_NOTIFICATION = (function () { return createNotification('C', undefined, undefined); })();
function errorNotification(error) {
    return createNotification('E', undefined, error);
}
function nextNotification(value) {
    return createNotification('N', value, undefined);
}
function createNotification(kind, value, error) {
    return {
        kind: kind,
        value: value,
        error: error,
    };
}
//# sourceMappingURL=NotificationFactories.js.map

/***/ }),

/***/ "../../../node_modules/rxjs/dist/esm5/internal/Subscriber.js":
/*!*******************************************************************!*\
  !*** ../../../node_modules/rxjs/dist/esm5/internal/Subscriber.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   EMPTY_OBSERVER: () => (/* binding */ EMPTY_OBSERVER),
/* harmony export */   SafeSubscriber: () => (/* binding */ SafeSubscriber),
/* harmony export */   Subscriber: () => (/* binding */ Subscriber)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "tslib");
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(tslib__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _util_isFunction__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./util/isFunction */ "../../../node_modules/rxjs/dist/esm5/internal/util/isFunction.js");
/* harmony import */ var _Subscription__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Subscription */ "../../../node_modules/rxjs/dist/esm5/internal/Subscription.js");
/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./config */ "../../../node_modules/rxjs/dist/esm5/internal/config.js");
/* harmony import */ var _util_reportUnhandledError__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./util/reportUnhandledError */ "../../../node_modules/rxjs/dist/esm5/internal/util/reportUnhandledError.js");
/* harmony import */ var _util_noop__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./util/noop */ "../../../node_modules/rxjs/dist/esm5/internal/util/noop.js");
/* harmony import */ var _NotificationFactories__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./NotificationFactories */ "../../../node_modules/rxjs/dist/esm5/internal/NotificationFactories.js");
/* harmony import */ var _scheduler_timeoutProvider__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./scheduler/timeoutProvider */ "../../../node_modules/rxjs/dist/esm5/internal/scheduler/timeoutProvider.js");
/* harmony import */ var _util_errorContext__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./util/errorContext */ "../../../node_modules/rxjs/dist/esm5/internal/util/errorContext.js");









var Subscriber = (function (_super) {
    (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__extends)(Subscriber, _super);
    function Subscriber(destination) {
        var _this = _super.call(this) || this;
        _this.isStopped = false;
        if (destination) {
            _this.destination = destination;
            if ((0,_Subscription__WEBPACK_IMPORTED_MODULE_1__.isSubscription)(destination)) {
                destination.add(_this);
            }
        }
        else {
            _this.destination = EMPTY_OBSERVER;
        }
        return _this;
    }
    Subscriber.create = function (next, error, complete) {
        return new SafeSubscriber(next, error, complete);
    };
    Subscriber.prototype.next = function (value) {
        if (this.isStopped) {
            handleStoppedNotification((0,_NotificationFactories__WEBPACK_IMPORTED_MODULE_2__.nextNotification)(value), this);
        }
        else {
            this._next(value);
        }
    };
    Subscriber.prototype.error = function (err) {
        if (this.isStopped) {
            handleStoppedNotification((0,_NotificationFactories__WEBPACK_IMPORTED_MODULE_2__.errorNotification)(err), this);
        }
        else {
            this.isStopped = true;
            this._error(err);
        }
    };
    Subscriber.prototype.complete = function () {
        if (this.isStopped) {
            handleStoppedNotification(_NotificationFactories__WEBPACK_IMPORTED_MODULE_2__.COMPLETE_NOTIFICATION, this);
        }
        else {
            this.isStopped = true;
            this._complete();
        }
    };
    Subscriber.prototype.unsubscribe = function () {
        if (!this.closed) {
            this.isStopped = true;
            _super.prototype.unsubscribe.call(this);
            this.destination = null;
        }
    };
    Subscriber.prototype._next = function (value) {
        this.destination.next(value);
    };
    Subscriber.prototype._error = function (err) {
        try {
            this.destination.error(err);
        }
        finally {
            this.unsubscribe();
        }
    };
    Subscriber.prototype._complete = function () {
        try {
            this.destination.complete();
        }
        finally {
            this.unsubscribe();
        }
    };
    return Subscriber;
}(_Subscription__WEBPACK_IMPORTED_MODULE_1__.Subscription));

var _bind = Function.prototype.bind;
function bind(fn, thisArg) {
    return _bind.call(fn, thisArg);
}
var ConsumerObserver = (function () {
    function ConsumerObserver(partialObserver) {
        this.partialObserver = partialObserver;
    }
    ConsumerObserver.prototype.next = function (value) {
        var partialObserver = this.partialObserver;
        if (partialObserver.next) {
            try {
                partialObserver.next(value);
            }
            catch (error) {
                handleUnhandledError(error);
            }
        }
    };
    ConsumerObserver.prototype.error = function (err) {
        var partialObserver = this.partialObserver;
        if (partialObserver.error) {
            try {
                partialObserver.error(err);
            }
            catch (error) {
                handleUnhandledError(error);
            }
        }
        else {
            handleUnhandledError(err);
        }
    };
    ConsumerObserver.prototype.complete = function () {
        var partialObserver = this.partialObserver;
        if (partialObserver.complete) {
            try {
                partialObserver.complete();
            }
            catch (error) {
                handleUnhandledError(error);
            }
        }
    };
    return ConsumerObserver;
}());
var SafeSubscriber = (function (_super) {
    (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__extends)(SafeSubscriber, _super);
    function SafeSubscriber(observerOrNext, error, complete) {
        var _this = _super.call(this) || this;
        var partialObserver;
        if ((0,_util_isFunction__WEBPACK_IMPORTED_MODULE_3__.isFunction)(observerOrNext) || !observerOrNext) {
            partialObserver = {
                next: (observerOrNext !== null && observerOrNext !== void 0 ? observerOrNext : undefined),
                error: error !== null && error !== void 0 ? error : undefined,
                complete: complete !== null && complete !== void 0 ? complete : undefined,
            };
        }
        else {
            var context_1;
            if (_this && _config__WEBPACK_IMPORTED_MODULE_4__.config.useDeprecatedNextContext) {
                context_1 = Object.create(observerOrNext);
                context_1.unsubscribe = function () { return _this.unsubscribe(); };
                partialObserver = {
                    next: observerOrNext.next && bind(observerOrNext.next, context_1),
                    error: observerOrNext.error && bind(observerOrNext.error, context_1),
                    complete: observerOrNext.complete && bind(observerOrNext.complete, context_1),
                };
            }
            else {
                partialObserver = observerOrNext;
            }
        }
        _this.destination = new ConsumerObserver(partialObserver);
        return _this;
    }
    return SafeSubscriber;
}(Subscriber));

function handleUnhandledError(error) {
    if (_config__WEBPACK_IMPORTED_MODULE_4__.config.useDeprecatedSynchronousErrorHandling) {
        (0,_util_errorContext__WEBPACK_IMPORTED_MODULE_5__.captureError)(error);
    }
    else {
        (0,_util_reportUnhandledError__WEBPACK_IMPORTED_MODULE_6__.reportUnhandledError)(error);
    }
}
function defaultErrorHandler(err) {
    throw err;
}
function handleStoppedNotification(notification, subscriber) {
    var onStoppedNotification = _config__WEBPACK_IMPORTED_MODULE_4__.config.onStoppedNotification;
    onStoppedNotification && _scheduler_timeoutProvider__WEBPACK_IMPORTED_MODULE_7__.timeoutProvider.setTimeout(function () { return onStoppedNotification(notification, subscriber); });
}
var EMPTY_OBSERVER = {
    closed: true,
    next: _util_noop__WEBPACK_IMPORTED_MODULE_8__.noop,
    error: defaultErrorHandler,
    complete: _util_noop__WEBPACK_IMPORTED_MODULE_8__.noop,
};
//# sourceMappingURL=Subscriber.js.map

/***/ }),

/***/ "../../../node_modules/rxjs/dist/esm5/internal/Subscription.js":
/*!*********************************************************************!*\
  !*** ../../../node_modules/rxjs/dist/esm5/internal/Subscription.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   EMPTY_SUBSCRIPTION: () => (/* binding */ EMPTY_SUBSCRIPTION),
/* harmony export */   Subscription: () => (/* binding */ Subscription),
/* harmony export */   isSubscription: () => (/* binding */ isSubscription)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "tslib");
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(tslib__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _util_isFunction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./util/isFunction */ "../../../node_modules/rxjs/dist/esm5/internal/util/isFunction.js");
/* harmony import */ var _util_UnsubscriptionError__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./util/UnsubscriptionError */ "../../../node_modules/rxjs/dist/esm5/internal/util/UnsubscriptionError.js");
/* harmony import */ var _util_arrRemove__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./util/arrRemove */ "../../../node_modules/rxjs/dist/esm5/internal/util/arrRemove.js");




var Subscription = (function () {
    function Subscription(initialTeardown) {
        this.initialTeardown = initialTeardown;
        this.closed = false;
        this._parentage = null;
        this._finalizers = null;
    }
    Subscription.prototype.unsubscribe = function () {
        var e_1, _a, e_2, _b;
        var errors;
        if (!this.closed) {
            this.closed = true;
            var _parentage = this._parentage;
            if (_parentage) {
                this._parentage = null;
                if (Array.isArray(_parentage)) {
                    try {
                        for (var _parentage_1 = (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__values)(_parentage), _parentage_1_1 = _parentage_1.next(); !_parentage_1_1.done; _parentage_1_1 = _parentage_1.next()) {
                            var parent_1 = _parentage_1_1.value;
                            parent_1.remove(this);
                        }
                    }
                    catch (e_1_1) { e_1 = { error: e_1_1 }; }
                    finally {
                        try {
                            if (_parentage_1_1 && !_parentage_1_1.done && (_a = _parentage_1.return)) _a.call(_parentage_1);
                        }
                        finally { if (e_1) throw e_1.error; }
                    }
                }
                else {
                    _parentage.remove(this);
                }
            }
            var initialFinalizer = this.initialTeardown;
            if ((0,_util_isFunction__WEBPACK_IMPORTED_MODULE_1__.isFunction)(initialFinalizer)) {
                try {
                    initialFinalizer();
                }
                catch (e) {
                    errors = e instanceof _util_UnsubscriptionError__WEBPACK_IMPORTED_MODULE_2__.UnsubscriptionError ? e.errors : [e];
                }
            }
            var _finalizers = this._finalizers;
            if (_finalizers) {
                this._finalizers = null;
                try {
                    for (var _finalizers_1 = (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__values)(_finalizers), _finalizers_1_1 = _finalizers_1.next(); !_finalizers_1_1.done; _finalizers_1_1 = _finalizers_1.next()) {
                        var finalizer = _finalizers_1_1.value;
                        try {
                            execFinalizer(finalizer);
                        }
                        catch (err) {
                            errors = errors !== null && errors !== void 0 ? errors : [];
                            if (err instanceof _util_UnsubscriptionError__WEBPACK_IMPORTED_MODULE_2__.UnsubscriptionError) {
                                errors = (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__spreadArray)((0,tslib__WEBPACK_IMPORTED_MODULE_0__.__spreadArray)([], (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__read)(errors)), (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__read)(err.errors));
                            }
                            else {
                                errors.push(err);
                            }
                        }
                    }
                }
                catch (e_2_1) { e_2 = { error: e_2_1 }; }
                finally {
                    try {
                        if (_finalizers_1_1 && !_finalizers_1_1.done && (_b = _finalizers_1.return)) _b.call(_finalizers_1);
                    }
                    finally { if (e_2) throw e_2.error; }
                }
            }
            if (errors) {
                throw new _util_UnsubscriptionError__WEBPACK_IMPORTED_MODULE_2__.UnsubscriptionError(errors);
            }
        }
    };
    Subscription.prototype.add = function (teardown) {
        var _a;
        if (teardown && teardown !== this) {
            if (this.closed) {
                execFinalizer(teardown);
            }
            else {
                if (teardown instanceof Subscription) {
                    if (teardown.closed || teardown._hasParent(this)) {
                        return;
                    }
                    teardown._addParent(this);
                }
                (this._finalizers = (_a = this._finalizers) !== null && _a !== void 0 ? _a : []).push(teardown);
            }
        }
    };
    Subscription.prototype._hasParent = function (parent) {
        var _parentage = this._parentage;
        return _parentage === parent || (Array.isArray(_parentage) && _parentage.includes(parent));
    };
    Subscription.prototype._addParent = function (parent) {
        var _parentage = this._parentage;
        this._parentage = Array.isArray(_parentage) ? (_parentage.push(parent), _parentage) : _parentage ? [_parentage, parent] : parent;
    };
    Subscription.prototype._removeParent = function (parent) {
        var _parentage = this._parentage;
        if (_parentage === parent) {
            this._parentage = null;
        }
        else if (Array.isArray(_parentage)) {
            (0,_util_arrRemove__WEBPACK_IMPORTED_MODULE_3__.arrRemove)(_parentage, parent);
        }
    };
    Subscription.prototype.remove = function (teardown) {
        var _finalizers = this._finalizers;
        _finalizers && (0,_util_arrRemove__WEBPACK_IMPORTED_MODULE_3__.arrRemove)(_finalizers, teardown);
        if (teardown instanceof Subscription) {
            teardown._removeParent(this);
        }
    };
    Subscription.EMPTY = (function () {
        var empty = new Subscription();
        empty.closed = true;
        return empty;
    })();
    return Subscription;
}());

var EMPTY_SUBSCRIPTION = Subscription.EMPTY;
function isSubscription(value) {
    return (value instanceof Subscription ||
        (value && 'closed' in value && (0,_util_isFunction__WEBPACK_IMPORTED_MODULE_1__.isFunction)(value.remove) && (0,_util_isFunction__WEBPACK_IMPORTED_MODULE_1__.isFunction)(value.add) && (0,_util_isFunction__WEBPACK_IMPORTED_MODULE_1__.isFunction)(value.unsubscribe)));
}
function execFinalizer(finalizer) {
    if ((0,_util_isFunction__WEBPACK_IMPORTED_MODULE_1__.isFunction)(finalizer)) {
        finalizer();
    }
    else {
        finalizer.unsubscribe();
    }
}
//# sourceMappingURL=Subscription.js.map

/***/ }),

/***/ "../../../node_modules/rxjs/dist/esm5/internal/config.js":
/*!***************************************************************!*\
  !*** ../../../node_modules/rxjs/dist/esm5/internal/config.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   config: () => (/* binding */ config)
/* harmony export */ });
var config = {
    onUnhandledError: null,
    onStoppedNotification: null,
    Promise: undefined,
    useDeprecatedSynchronousErrorHandling: false,
    useDeprecatedNextContext: false,
};
//# sourceMappingURL=config.js.map

/***/ }),

/***/ "../../../node_modules/rxjs/dist/esm5/internal/operators/OperatorSubscriber.js":
/*!*************************************************************************************!*\
  !*** ../../../node_modules/rxjs/dist/esm5/internal/operators/OperatorSubscriber.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   OperatorSubscriber: () => (/* binding */ OperatorSubscriber),
/* harmony export */   createOperatorSubscriber: () => (/* binding */ createOperatorSubscriber)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "tslib");
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(tslib__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _Subscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Subscriber */ "../../../node_modules/rxjs/dist/esm5/internal/Subscriber.js");


function createOperatorSubscriber(destination, onNext, onComplete, onError, onFinalize) {
    return new OperatorSubscriber(destination, onNext, onComplete, onError, onFinalize);
}
var OperatorSubscriber = (function (_super) {
    (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__extends)(OperatorSubscriber, _super);
    function OperatorSubscriber(destination, onNext, onComplete, onError, onFinalize, shouldUnsubscribe) {
        var _this = _super.call(this, destination) || this;
        _this.onFinalize = onFinalize;
        _this.shouldUnsubscribe = shouldUnsubscribe;
        _this._next = onNext
            ? function (value) {
                try {
                    onNext(value);
                }
                catch (err) {
                    destination.error(err);
                }
            }
            : _super.prototype._next;
        _this._error = onError
            ? function (err) {
                try {
                    onError(err);
                }
                catch (err) {
                    destination.error(err);
                }
                finally {
                    this.unsubscribe();
                }
            }
            : _super.prototype._error;
        _this._complete = onComplete
            ? function () {
                try {
                    onComplete();
                }
                catch (err) {
                    destination.error(err);
                }
                finally {
                    this.unsubscribe();
                }
            }
            : _super.prototype._complete;
        return _this;
    }
    OperatorSubscriber.prototype.unsubscribe = function () {
        var _a;
        if (!this.shouldUnsubscribe || this.shouldUnsubscribe()) {
            var closed_1 = this.closed;
            _super.prototype.unsubscribe.call(this);
            !closed_1 && ((_a = this.onFinalize) === null || _a === void 0 ? void 0 : _a.call(this));
        }
    };
    return OperatorSubscriber;
}(_Subscriber__WEBPACK_IMPORTED_MODULE_1__.Subscriber));

//# sourceMappingURL=OperatorSubscriber.js.map

/***/ }),

/***/ "../../../node_modules/rxjs/dist/esm5/internal/operators/map.js":
/*!**********************************************************************!*\
  !*** ../../../node_modules/rxjs/dist/esm5/internal/operators/map.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   map: () => (/* binding */ map)
/* harmony export */ });
/* harmony import */ var _util_lift__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/lift */ "../../../node_modules/rxjs/dist/esm5/internal/util/lift.js");
/* harmony import */ var _OperatorSubscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./OperatorSubscriber */ "../../../node_modules/rxjs/dist/esm5/internal/operators/OperatorSubscriber.js");


function map(project, thisArg) {
    return (0,_util_lift__WEBPACK_IMPORTED_MODULE_0__.operate)(function (source, subscriber) {
        var index = 0;
        source.subscribe((0,_OperatorSubscriber__WEBPACK_IMPORTED_MODULE_1__.createOperatorSubscriber)(subscriber, function (value) {
            subscriber.next(project.call(thisArg, value, index++));
        }));
    });
}
//# sourceMappingURL=map.js.map

/***/ }),

/***/ "../../../node_modules/rxjs/dist/esm5/internal/scheduler/timeoutProvider.js":
/*!**********************************************************************************!*\
  !*** ../../../node_modules/rxjs/dist/esm5/internal/scheduler/timeoutProvider.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   timeoutProvider: () => (/* binding */ timeoutProvider)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "tslib");
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(tslib__WEBPACK_IMPORTED_MODULE_0__);

var timeoutProvider = {
    setTimeout: function (handler, timeout) {
        var args = [];
        for (var _i = 2; _i < arguments.length; _i++) {
            args[_i - 2] = arguments[_i];
        }
        var delegate = timeoutProvider.delegate;
        if (delegate === null || delegate === void 0 ? void 0 : delegate.setTimeout) {
            return delegate.setTimeout.apply(delegate, (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__spreadArray)([handler, timeout], (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__read)(args)));
        }
        return setTimeout.apply(void 0, (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__spreadArray)([handler, timeout], (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__read)(args)));
    },
    clearTimeout: function (handle) {
        var delegate = timeoutProvider.delegate;
        return ((delegate === null || delegate === void 0 ? void 0 : delegate.clearTimeout) || clearTimeout)(handle);
    },
    delegate: undefined,
};
//# sourceMappingURL=timeoutProvider.js.map

/***/ }),

/***/ "../../../node_modules/rxjs/dist/esm5/internal/util/UnsubscriptionError.js":
/*!*********************************************************************************!*\
  !*** ../../../node_modules/rxjs/dist/esm5/internal/util/UnsubscriptionError.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   UnsubscriptionError: () => (/* binding */ UnsubscriptionError)
/* harmony export */ });
/* harmony import */ var _createErrorClass__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./createErrorClass */ "../../../node_modules/rxjs/dist/esm5/internal/util/createErrorClass.js");

var UnsubscriptionError = (0,_createErrorClass__WEBPACK_IMPORTED_MODULE_0__.createErrorClass)(function (_super) {
    return function UnsubscriptionErrorImpl(errors) {
        _super(this);
        this.message = errors
            ? errors.length + " errors occurred during unsubscription:\n" + errors.map(function (err, i) { return i + 1 + ") " + err.toString(); }).join('\n  ')
            : '';
        this.name = 'UnsubscriptionError';
        this.errors = errors;
    };
});
//# sourceMappingURL=UnsubscriptionError.js.map

/***/ }),

/***/ "../../../node_modules/rxjs/dist/esm5/internal/util/arrRemove.js":
/*!***********************************************************************!*\
  !*** ../../../node_modules/rxjs/dist/esm5/internal/util/arrRemove.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   arrRemove: () => (/* binding */ arrRemove)
/* harmony export */ });
function arrRemove(arr, item) {
    if (arr) {
        var index = arr.indexOf(item);
        0 <= index && arr.splice(index, 1);
    }
}
//# sourceMappingURL=arrRemove.js.map

/***/ }),

/***/ "../../../node_modules/rxjs/dist/esm5/internal/util/createErrorClass.js":
/*!******************************************************************************!*\
  !*** ../../../node_modules/rxjs/dist/esm5/internal/util/createErrorClass.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   createErrorClass: () => (/* binding */ createErrorClass)
/* harmony export */ });
function createErrorClass(createImpl) {
    var _super = function (instance) {
        Error.call(instance);
        instance.stack = new Error().stack;
    };
    var ctorFunc = createImpl(_super);
    ctorFunc.prototype = Object.create(Error.prototype);
    ctorFunc.prototype.constructor = ctorFunc;
    return ctorFunc;
}
//# sourceMappingURL=createErrorClass.js.map

/***/ }),

/***/ "../../../node_modules/rxjs/dist/esm5/internal/util/errorContext.js":
/*!**************************************************************************!*\
  !*** ../../../node_modules/rxjs/dist/esm5/internal/util/errorContext.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   captureError: () => (/* binding */ captureError),
/* harmony export */   errorContext: () => (/* binding */ errorContext)
/* harmony export */ });
/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../config */ "../../../node_modules/rxjs/dist/esm5/internal/config.js");

var context = null;
function errorContext(cb) {
    if (_config__WEBPACK_IMPORTED_MODULE_0__.config.useDeprecatedSynchronousErrorHandling) {
        var isRoot = !context;
        if (isRoot) {
            context = { errorThrown: false, error: null };
        }
        cb();
        if (isRoot) {
            var _a = context, errorThrown = _a.errorThrown, error = _a.error;
            context = null;
            if (errorThrown) {
                throw error;
            }
        }
    }
    else {
        cb();
    }
}
function captureError(err) {
    if (_config__WEBPACK_IMPORTED_MODULE_0__.config.useDeprecatedSynchronousErrorHandling && context) {
        context.errorThrown = true;
        context.error = err;
    }
}
//# sourceMappingURL=errorContext.js.map

/***/ }),

/***/ "../../../node_modules/rxjs/dist/esm5/internal/util/isFunction.js":
/*!************************************************************************!*\
  !*** ../../../node_modules/rxjs/dist/esm5/internal/util/isFunction.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   isFunction: () => (/* binding */ isFunction)
/* harmony export */ });
function isFunction(value) {
    return typeof value === 'function';
}
//# sourceMappingURL=isFunction.js.map

/***/ }),

/***/ "../../../node_modules/rxjs/dist/esm5/internal/util/lift.js":
/*!******************************************************************!*\
  !*** ../../../node_modules/rxjs/dist/esm5/internal/util/lift.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   hasLift: () => (/* binding */ hasLift),
/* harmony export */   operate: () => (/* binding */ operate)
/* harmony export */ });
/* harmony import */ var _isFunction__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./isFunction */ "../../../node_modules/rxjs/dist/esm5/internal/util/isFunction.js");

function hasLift(source) {
    return (0,_isFunction__WEBPACK_IMPORTED_MODULE_0__.isFunction)(source === null || source === void 0 ? void 0 : source.lift);
}
function operate(init) {
    return function (source) {
        if (hasLift(source)) {
            return source.lift(function (liftedSource) {
                try {
                    return init(liftedSource, this);
                }
                catch (err) {
                    this.error(err);
                }
            });
        }
        throw new TypeError('Unable to lift unknown Observable type');
    };
}
//# sourceMappingURL=lift.js.map

/***/ }),

/***/ "../../../node_modules/rxjs/dist/esm5/internal/util/noop.js":
/*!******************************************************************!*\
  !*** ../../../node_modules/rxjs/dist/esm5/internal/util/noop.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   noop: () => (/* binding */ noop)
/* harmony export */ });
function noop() { }
//# sourceMappingURL=noop.js.map

/***/ }),

/***/ "../../../node_modules/rxjs/dist/esm5/internal/util/reportUnhandledError.js":
/*!**********************************************************************************!*\
  !*** ../../../node_modules/rxjs/dist/esm5/internal/util/reportUnhandledError.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   reportUnhandledError: () => (/* binding */ reportUnhandledError)
/* harmony export */ });
/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../config */ "../../../node_modules/rxjs/dist/esm5/internal/config.js");
/* harmony import */ var _scheduler_timeoutProvider__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../scheduler/timeoutProvider */ "../../../node_modules/rxjs/dist/esm5/internal/scheduler/timeoutProvider.js");


function reportUnhandledError(err) {
    _scheduler_timeoutProvider__WEBPACK_IMPORTED_MODULE_0__.timeoutProvider.setTimeout(function () {
        var onUnhandledError = _config__WEBPACK_IMPORTED_MODULE_1__.config.onUnhandledError;
        if (onUnhandledError) {
            onUnhandledError(err);
        }
        else {
            throw err;
        }
    });
}
//# sourceMappingURL=reportUnhandledError.js.map

/***/ }),

/***/ "./src/lib/assets/berkelybridge-textgeneration-plugin-logo.ts":
/*!********************************************************************!*\
  !*** ./src/lib/assets/berkelybridge-textgeneration-plugin-logo.ts ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BERKELYBRIDGE_TEXTGENERATION_PLUGIN_LOGO_BASE64: () => (/* binding */ BERKELYBRIDGE_TEXTGENERATION_PLUGIN_LOGO_BASE64)
/* harmony export */ });
/*
 * Copyright 2015-2024. Ritense BV, the Netherlands.
 *
 * Licensed under EUPL, Version 1.2 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * https://joinup.ec.europa.eu/collection/eupl/eupl-text-eupl-12
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" basis,
 *
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
const BERKELYBRIDGE_TEXTGENERATION_PLUGIN_LOGO_BASE64 = 'data:image/png;base64,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';



/***/ }),

/***/ "./src/lib/berkelybridge-textgenerator-plugin-module.ts":
/*!**************************************************************!*\
  !*** ./src/lib/berkelybridge-textgenerator-plugin-module.ts ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BerkelybridgeTextgeneratorPluginModule: () => (/* binding */ BerkelybridgeTextgeneratorPluginModule)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "tslib");
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(tslib__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @angular/core */ "@angular/core");
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_angular_core__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _angular_common__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @angular/common */ "@angular/common");
/* harmony import */ var _angular_common__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_angular_common__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _valtimo_plugin__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @valtimo/plugin */ "@valtimo/plugin");
/* harmony import */ var _valtimo_plugin__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_valtimo_plugin__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _angular_forms__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @angular/forms */ "../../../node_modules/@angular/forms/fesm2022/forms.mjs");
/* harmony import */ var _valtimo_components__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @valtimo/components */ "@valtimo/components");
/* harmony import */ var _valtimo_components__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_valtimo_components__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _components_text_generation_text_generation_configuration_component__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./components/text-generation/text-generation-configuration.component */ "./src/lib/components/text-generation/text-generation-configuration.component.ts");
/* harmony import */ var _components_berkelybridge_textgenerator_configuration_berkelybridge_textgenerator_configuration_component__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./components/berkelybridge-textgenerator-configuration/berkelybridge-textgenerator-configuration.component */ "./src/lib/components/berkelybridge-textgenerator-configuration/berkelybridge-textgenerator-configuration.component.ts");
/* harmony import */ var _berkelybridge_textgenerator_plugin_specification__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./berkelybridge-textgenerator-plugin.specification */ "./src/lib/berkelybridge-textgenerator-plugin.specification.ts");
/*
 * Copyright 2015-2024. Ritense BV, the Netherlands.
 *
 * Licensed under EUPL, Version 1.2 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * https://joinup.ec.europa.eu/collection/eupl/eupl-text-eupl-12
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" basis,
 *
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */









let BerkelybridgeTextgeneratorPluginModule = class BerkelybridgeTextgeneratorPluginModule {
};
BerkelybridgeTextgeneratorPluginModule = (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__decorate)([
    (0,_angular_core__WEBPACK_IMPORTED_MODULE_1__.NgModule)({
        declarations: [
            _components_berkelybridge_textgenerator_configuration_berkelybridge_textgenerator_configuration_component__WEBPACK_IMPORTED_MODULE_6__.BerkelybridgeTextgeneratorConfigurationComponent,
            _components_text_generation_text_generation_configuration_component__WEBPACK_IMPORTED_MODULE_5__.TextGenerationConfigurationComponent
        ],
        imports: [_angular_common__WEBPACK_IMPORTED_MODULE_2__.CommonModule, _valtimo_plugin__WEBPACK_IMPORTED_MODULE_3__.PluginTranslatePipeModule,
            _valtimo_components__WEBPACK_IMPORTED_MODULE_4__.FormModule, _valtimo_components__WEBPACK_IMPORTED_MODULE_4__.InputModule, _angular_forms__WEBPACK_IMPORTED_MODULE_8__.FormsModule, _valtimo_plugin__WEBPACK_IMPORTED_MODULE_3__.PluginTranslatePipeModule, _valtimo_components__WEBPACK_IMPORTED_MODULE_4__.CarbonMultiInputModule,],
        exports: [
            _components_berkelybridge_textgenerator_configuration_berkelybridge_textgenerator_configuration_component__WEBPACK_IMPORTED_MODULE_6__.BerkelybridgeTextgeneratorConfigurationComponent,
            _components_text_generation_text_generation_configuration_component__WEBPACK_IMPORTED_MODULE_5__.TextGenerationConfigurationComponent
        ],
        providers: [
            {
                provide: _valtimo_plugin__WEBPACK_IMPORTED_MODULE_3__.PLUGINS_TOKEN,
                useValue: [
                    _berkelybridge_textgenerator_plugin_specification__WEBPACK_IMPORTED_MODULE_7__.berkelybridgeTextgeneratorPluginSpecification,
                ]
            }
        ]
    })
], BerkelybridgeTextgeneratorPluginModule);



/***/ }),

/***/ "./src/lib/berkelybridge-textgenerator-plugin.specification.ts":
/*!*********************************************************************!*\
  !*** ./src/lib/berkelybridge-textgenerator-plugin.specification.ts ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   berkelybridgeTextgeneratorPluginSpecification: () => (/* binding */ berkelybridgeTextgeneratorPluginSpecification)
/* harmony export */ });
/* harmony import */ var _components_berkelybridge_textgenerator_configuration_berkelybridge_textgenerator_configuration_component__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./components/berkelybridge-textgenerator-configuration/berkelybridge-textgenerator-configuration.component */ "./src/lib/components/berkelybridge-textgenerator-configuration/berkelybridge-textgenerator-configuration.component.ts");
/* harmony import */ var _components_text_generation_text_generation_configuration_component__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./components/text-generation/text-generation-configuration.component */ "./src/lib/components/text-generation/text-generation-configuration.component.ts");
/* harmony import */ var _assets_berkelybridge_textgeneration_plugin_logo__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./assets/berkelybridge-textgeneration-plugin-logo */ "./src/lib/assets/berkelybridge-textgeneration-plugin-logo.ts");
/*
 * Copyright 2015-2024. Ritense BV, the Netherlands.
 *
 * Licensed under EUPL, Version 1.2 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * https://joinup.ec.europa.eu/collection/eupl/eupl-text-eupl-12
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" basis,
 *
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */



const berkelybridgeTextgeneratorPluginSpecification = {
    pluginId: 'bbtextgenerator',
    pluginConfigurationComponent: _components_berkelybridge_textgenerator_configuration_berkelybridge_textgenerator_configuration_component__WEBPACK_IMPORTED_MODULE_0__.BerkelybridgeTextgeneratorConfigurationComponent,
    pluginLogoBase64: _assets_berkelybridge_textgeneration_plugin_logo__WEBPACK_IMPORTED_MODULE_2__.BERKELYBRIDGE_TEXTGENERATION_PLUGIN_LOGO_BASE64,
    functionConfigurationComponents: {
        'genereer-tekst': _components_text_generation_text_generation_configuration_component__WEBPACK_IMPORTED_MODULE_1__.TextGenerationConfigurationComponent
    },
    pluginTranslations: {
        nl: {
            'genereer-tekst': 'Genereer tekst',
            title: 'Berkely Bridge tekst en PDF generator',
            description: 'Met de Berkely Bridge tekst en PDF generator plugin kun je in een process tekst of PDF\'s genereren',
            configurationTitle: 'Configuratienaam',
            configurationTitleTooltip: 'Onder deze naam zal de plugin te herkennen zijn in de rest van de applicatie',
            berkelybridgeBaseUrl: 'Berkely Bridge base url',
            berkelybridgeBaseUrlTooltip: 'Vul hier url in waarop Berkely Bridge is te bereiken.',
            modelId: 'Model ID',
            modelIdTooltip: 'Vul het Berkely Bridge model ID in',
            templateId: 'Template ID',
            templateIdTooltip: 'Vul het template ID in om een tekst of PDF te genereren',
            naam: 'Naam',
            nameTooltip: 'Vul hier de naam in van de te genereren file.',
            format: "Formaat",
            formatTooltip: 'Vul hier het formaat in van de te genereren tekst of file',
            parameters: "Parameters",
            parametersTooltip: 'Vul hier de parameters die worden gebruikt in de template',
            variabeleNaam: 'Naam process variabele',
            variabeleNaamTooltip: 'Naam van de process variabele die de tekst bevat',
            addParameter: 'Voeg een parameter toe',
        },
        en: {
            'genereer-tekst': 'Generate text',
            title: 'Berkely Bridge text and PDF generator',
            description: 'With the Berkely Bridge tekst and PDF generator plugin you can generate a text or PDF in a process step',
            configurationTitle: 'Configuration name',
            configurationTitleTooltip: 'Under this name, the plugin will be recognizable in the rest of the application',
            berkelybridgeBaseUrl: 'Berkely Bridge base url',
            berkelybridgeBaseUrlTooltip: 'Enter the URL here where Berkely Bridge can be reached.',
            modelId: 'Model ID',
            modelIdTooltip: 'Enter the Berkely Bridge model ID',
            templateId: 'Template ID',
            templateIdTooltip: 'Enter the template ID to generate a text or PDF',
            naam: 'Naam',
            nameTooltip: 'Enter the name of the file to be generated here.',
            format: "Format",
            formatTooltip: 'Enter the format of the text or file to be generated here',
            parameters: "Parameters",
            parametersTooltip: 'Enter the parameters used in the template here',
            variabeleNaam: 'Process variable name',
            variabeleNaamTooltip: 'Name of the process variable containing the text',
            addParameter: 'Add a parameter',
        },
        de: {
            'genereer-tekst': 'Generate text',
            title: 'Berkely Bridge tekst en PDF generator',
            description: 'Met de Berkely Bridge tekst en PDF generator plugin kun je in een process tekst of PDF\'s genereren',
            configurationTitle: 'Konfigurationsname',
            configurationTitleTooltip: 'Unter diesem Namen wird das Plugin im Rest der Anwendung erkennbar sein',
            berkelybridgeBaseUrl: 'Berkely Bridge base url',
            berkelybridgeBaseUrlTooltip: 'Vul hier url in waarop Berkely Bridge is te bereiken.',
            modelId: 'Model ID',
            modelIdTooltip: 'Vul het Berkely Bridge model ID in',
            templateId: 'Template ID',
            templateIdTooltip: 'Geben Sie die Vorlagen-ID ein, um einen Text oder ein PDF zu generieren',
            naam: 'Name',
            nameTooltip: 'Geben Sie hier den Namen der zu generierenden Datei ein.',
            format: "Format",
            formatTooltip: 'Geben Sie hier das Format des zu generierenden Textes oder der Datei ein',
            parameters: "Parameters",
            parametersTooltip: 'Geben Sie hier die in der Vorlage verwendeten Parameter ein',
            variabeleNaam: 'Name der Prozessvariablen',
            variabeleNaamTooltip: 'Name der Prozessvariablen, die den Text enthlt',
            addParameter: 'Fgen Sie einen Parameter hinzu',
        },
    },
};



/***/ }),

/***/ "./src/lib/components/berkelybridge-textgenerator-configuration/berkelybridge-textgenerator-configuration.component.ts":
/*!*****************************************************************************************************************************!*\
  !*** ./src/lib/components/berkelybridge-textgenerator-configuration/berkelybridge-textgenerator-configuration.component.ts ***!
  \*****************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BerkelybridgeTextgeneratorConfigurationComponent: () => (/* binding */ BerkelybridgeTextgeneratorConfigurationComponent)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "tslib");
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(tslib__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @angular/core */ "@angular/core");
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_angular_core__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! rxjs */ "rxjs");
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(rxjs__WEBPACK_IMPORTED_MODULE_2__);
/*
 * Copyright 2015-2024. Ritense BV, the Netherlands.
 *
 * Licensed under EUPL, Version 1.2 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * https://joinup.ec.europa.eu/collection/eupl/eupl-text-eupl-12
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" basis,
 *
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */



let BerkelybridgeTextgeneratorConfigurationComponent = class BerkelybridgeTextgeneratorConfigurationComponent {
    constructor() {
        this.valid = new _angular_core__WEBPACK_IMPORTED_MODULE_1__.EventEmitter();
        this.configuration = new _angular_core__WEBPACK_IMPORTED_MODULE_1__.EventEmitter();
        this.formValue$ = new rxjs__WEBPACK_IMPORTED_MODULE_2__.BehaviorSubject(null);
        this.valid$ = new rxjs__WEBPACK_IMPORTED_MODULE_2__.BehaviorSubject(false);
    }
    ngOnInit() {
        this.openSaveSubscription();
    }
    ngOnDestroy() {
        this.saveSubscription?.unsubscribe();
    }
    formValueChange(formValue) {
        this.formValue$.next(formValue);
        this.handleValid(formValue);
    }
    handleValid(formValue) {
        const valid = !!(formValue.configurationTitle
            && formValue.berkelybridgeBaseUrl);
        this.valid$.next(valid);
        this.valid.emit(valid);
    }
    openSaveSubscription() {
        this.saveSubscription = this.save$?.subscribe(save => {
            (0,rxjs__WEBPACK_IMPORTED_MODULE_2__.combineLatest)([this.formValue$, this.valid$])
                .pipe((0,rxjs__WEBPACK_IMPORTED_MODULE_2__.take)(1))
                .subscribe(([formValue, valid]) => {
                if (valid) {
                    this.configuration.emit(formValue);
                }
            });
        });
    }
};
(0,tslib__WEBPACK_IMPORTED_MODULE_0__.__decorate)([
    (0,_angular_core__WEBPACK_IMPORTED_MODULE_1__.Input)()
], BerkelybridgeTextgeneratorConfigurationComponent.prototype, "save$", void 0);
(0,tslib__WEBPACK_IMPORTED_MODULE_0__.__decorate)([
    (0,_angular_core__WEBPACK_IMPORTED_MODULE_1__.Input)()
], BerkelybridgeTextgeneratorConfigurationComponent.prototype, "disabled$", void 0);
(0,tslib__WEBPACK_IMPORTED_MODULE_0__.__decorate)([
    (0,_angular_core__WEBPACK_IMPORTED_MODULE_1__.Input)()
], BerkelybridgeTextgeneratorConfigurationComponent.prototype, "pluginId", void 0);
(0,tslib__WEBPACK_IMPORTED_MODULE_0__.__decorate)([
    (0,_angular_core__WEBPACK_IMPORTED_MODULE_1__.Input)()
], BerkelybridgeTextgeneratorConfigurationComponent.prototype, "prefillConfiguration$", void 0);
(0,tslib__WEBPACK_IMPORTED_MODULE_0__.__decorate)([
    (0,_angular_core__WEBPACK_IMPORTED_MODULE_1__.Output)()
], BerkelybridgeTextgeneratorConfigurationComponent.prototype, "valid", void 0);
(0,tslib__WEBPACK_IMPORTED_MODULE_0__.__decorate)([
    (0,_angular_core__WEBPACK_IMPORTED_MODULE_1__.Output)()
], BerkelybridgeTextgeneratorConfigurationComponent.prototype, "configuration", void 0);
BerkelybridgeTextgeneratorConfigurationComponent = (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__decorate)([
    (0,_angular_core__WEBPACK_IMPORTED_MODULE_1__.Component)({
        selector: 'valtimo-berkelybridge-textgenerator-configuration',
        template: __webpack_require__(/*! ./berkelybridge-textgenerator-configuration.component.html */ "./src/lib/components/berkelybridge-textgenerator-configuration/berkelybridge-textgenerator-configuration.component.html"),
        styles: [__webpack_require__(/*! ./berkelybridge-textgenerator-configuration.component.scss */ "./src/lib/components/berkelybridge-textgenerator-configuration/berkelybridge-textgenerator-configuration.component.scss")],
    })
], BerkelybridgeTextgeneratorConfigurationComponent);



/***/ }),

/***/ "./src/lib/components/text-generation/text-generation-configuration.component.ts":
/*!***************************************************************************************!*\
  !*** ./src/lib/components/text-generation/text-generation-configuration.component.ts ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   TextGenerationConfigurationComponent: () => (/* binding */ TextGenerationConfigurationComponent)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "tslib");
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(tslib__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @angular/core */ "@angular/core");
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_angular_core__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! rxjs */ "rxjs");
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(rxjs__WEBPACK_IMPORTED_MODULE_2__);
/*
 * Copyright 2015-2024. Ritense BV, the Netherlands.
 *
 * Licensed under EUPL, Version 1.2 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * https://joinup.ec.europa.eu/collection/eupl/eupl-text-eupl-12
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" basis,
 *
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */



let TextGenerationConfigurationComponent = class TextGenerationConfigurationComponent {
    constructor() {
        this.configuration = new _angular_core__WEBPACK_IMPORTED_MODULE_1__.EventEmitter();
        this.valid = new _angular_core__WEBPACK_IMPORTED_MODULE_1__.EventEmitter();
        this.formValue$ = new rxjs__WEBPACK_IMPORTED_MODULE_2__.BehaviorSubject(null);
        this.valid$ = new rxjs__WEBPACK_IMPORTED_MODULE_2__.BehaviorSubject(false);
    }
    ngOnInit() {
        this.openSaveSubscription();
    }
    ngOnDestroy() {
        this.saveSubscription?.unsubscribe();
    }
    formValueChange(formValue) {
        this.formValue$.next(formValue);
        this.handleValid(formValue);
    }
    handleValid(formValue) {
        const valid = !!(formValue.modelId)
            && !!(formValue.templateId);
        this.valid$.next(valid);
        this.valid.emit(valid);
    }
    openSaveSubscription() {
        this.saveSubscription = this.save$?.subscribe(save => {
            (0,rxjs__WEBPACK_IMPORTED_MODULE_2__.combineLatest)([this.formValue$, this.valid$])
                .pipe((0,rxjs__WEBPACK_IMPORTED_MODULE_2__.take)(1))
                .subscribe(([formValue, valid]) => {
                if (valid) {
                    this.configuration.emit(formValue);
                }
            });
        });
    }
};
(0,tslib__WEBPACK_IMPORTED_MODULE_0__.__decorate)([
    (0,_angular_core__WEBPACK_IMPORTED_MODULE_1__.Input)()
], TextGenerationConfigurationComponent.prototype, "disabled$", void 0);
(0,tslib__WEBPACK_IMPORTED_MODULE_0__.__decorate)([
    (0,_angular_core__WEBPACK_IMPORTED_MODULE_1__.Input)()
], TextGenerationConfigurationComponent.prototype, "pluginId", void 0);
(0,tslib__WEBPACK_IMPORTED_MODULE_0__.__decorate)([
    (0,_angular_core__WEBPACK_IMPORTED_MODULE_1__.Input)()
], TextGenerationConfigurationComponent.prototype, "prefillConfiguration$", void 0);
(0,tslib__WEBPACK_IMPORTED_MODULE_0__.__decorate)([
    (0,_angular_core__WEBPACK_IMPORTED_MODULE_1__.Input)()
], TextGenerationConfigurationComponent.prototype, "save$", void 0);
(0,tslib__WEBPACK_IMPORTED_MODULE_0__.__decorate)([
    (0,_angular_core__WEBPACK_IMPORTED_MODULE_1__.Output)()
], TextGenerationConfigurationComponent.prototype, "configuration", void 0);
(0,tslib__WEBPACK_IMPORTED_MODULE_0__.__decorate)([
    (0,_angular_core__WEBPACK_IMPORTED_MODULE_1__.Output)()
], TextGenerationConfigurationComponent.prototype, "valid", void 0);
TextGenerationConfigurationComponent = (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__decorate)([
    (0,_angular_core__WEBPACK_IMPORTED_MODULE_1__.Component)({
        selector: 'valtimo-text-generation-configuration',
        template: __webpack_require__(/*! ./text-generation-configuration.component.html */ "./src/lib/components/text-generation/text-generation-configuration.component.html"),
        styles: [__webpack_require__(/*! ./text-generation-configuration.component.scss */ "./src/lib/components/text-generation/text-generation-configuration.component.scss")],
    })
], TextGenerationConfigurationComponent);



/***/ }),

/***/ "./src/lib/models/config.ts":
/*!**********************************!*\
  !*** ./src/lib/models/config.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/*
 * Copyright 2015-2024. Ritense BV, the Netherlands.
 *
 * Licensed under EUPL, Version 1.2 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * https://joinup.ec.europa.eu/collection/eupl/eupl-text-eupl-12
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" basis,
 *
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */



/***/ }),

/***/ "./src/lib/models/index.ts":
/*!*********************************!*\
  !*** ./src/lib/models/index.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./config */ "./src/lib/models/config.ts");
/*
 * Copyright 2015-2024. Ritense BV, the Netherlands.
 *
 * Licensed under EUPL, Version 1.2 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * https://joinup.ec.europa.eu/collection/eupl/eupl-text-eupl-12
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" basis,
 *
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */



/***/ }),

/***/ "./src/lib/components/berkelybridge-textgenerator-configuration/berkelybridge-textgenerator-configuration.component.html":
/*!*******************************************************************************************************************************!*\
  !*** ./src/lib/components/berkelybridge-textgenerator-configuration/berkelybridge-textgenerator-configuration.component.html ***!
  \*******************************************************************************************************************************/
/***/ ((module) => {

module.exports = "<!--\n  ~ Copyright 2015-2024. Ritense BV, the Netherlands.\n  ~\n  ~ Licensed under EUPL, Version 1.2 (the \"License\");\n  ~ you may not use this file except in compliance with the License.\n  ~ You may obtain a copy of the License at\n  ~\n  ~ https://joinup.ec.europa.eu/collection/eupl/eupl-text-eupl-12\n  ~\n  ~ Unless required by applicable law or agreed to in writing, software\n  ~ distributed under the License is distributed on an \"AS IS\" basis,\n  ~\n  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n  ~ express or implied.\n  ~ See the License for the specific language governing permissions and\n  ~ limitations under the License.\n  ~\n  -->\n\n<v-form\n        (valueChange)=\"formValueChange($event)\"\n        *ngIf=\"{\n    disabled: disabled$ | async,\n    prefill: prefillConfiguration$ ? (prefillConfiguration$ | async) : null\n  } as obs\"\n>\n  <v-input\n          name=\"configurationTitle\"\n          [title]=\"'configurationTitle' | pluginTranslate: pluginId | async\"\n          [margin]=\"true\"\n          [disabled]=\"obs.disabled\"\n          [defaultValue]=\"obs.prefill?.configurationTitle\"\n          [widthPx]=\"350\"\n          [required]=\"true\"\n          [tooltip]=\"'configurationTitleTooltip' | pluginTranslate: pluginId | async\"\n          placeholder=\"Berkely Bridge plugin\"\n  >\n  </v-input>\n  <v-input\n          name=\"berkelybridgeBaseUrl\"\n          [title]=\"'berkelybridgeBaseUrl' | pluginTranslate: pluginId | async\"\n          [margin]=\"true\"\n          [disabled]=\"obs.disabled\"\n          [defaultValue]=\"obs.prefill?.berkelybridgeBaseUrl\"\n          [widthPx]=\"350\"\n          [required]=\"true\"\n          [tooltip]=\"'berkelybridgeBaseUrlTooltip' | pluginTranslate: pluginId | async\"\n          placeholder=\"Vul Berkely Bridge url in\"\n  >\n  </v-input>\n</v-form>\n";

/***/ }),

/***/ "./src/lib/components/berkelybridge-textgenerator-configuration/berkelybridge-textgenerator-configuration.component.scss":
/*!*******************************************************************************************************************************!*\
  !*** ./src/lib/components/berkelybridge-textgenerator-configuration/berkelybridge-textgenerator-configuration.component.scss ***!
  \*******************************************************************************************************************************/
/***/ ((module) => {

module.exports = "/*!\n * Copyright 2015-2024. Ritense BV, the Netherlands.\n *\n * Licensed under EUPL, Version 1.2 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * https://joinup.ec.europa.eu/collection/eupl/eupl-text-eupl-12\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" basis,\n *\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n * express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n";

/***/ }),

/***/ "./src/lib/components/text-generation/text-generation-configuration.component.html":
/*!*****************************************************************************************!*\
  !*** ./src/lib/components/text-generation/text-generation-configuration.component.html ***!
  \*****************************************************************************************/
/***/ ((module) => {

module.exports = "<!--\n  ~ Copyright 2015-2024. Ritense BV, the Netherlands.\n  ~\n  ~ Licensed under EUPL, Version 1.2 (the \"License\");\n  ~ you may not use this file except in compliance with the License.\n  ~ You may obtain a copy of the License at\n  ~\n  ~ https://joinup.ec.europa.eu/collection/eupl/eupl-text-eupl-12\n  ~\n  ~ Unless required by applicable law or agreed to in writing, software\n  ~ distributed under the License is distributed on an \"AS IS\" basis,\n  ~\n  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n  ~ express or implied.\n  ~ See the License for the specific language governing permissions and\n  ~ limitations under the License.\n  ~\n  -->\n\n<v-form\n  (valueChange)=\"formValueChange($event)\"\n  *ngIf=\"{\n    disabled: disabled$ | async,\n    prefill: prefillConfiguration$ ? (prefillConfiguration$ | async) : null\n  } as obs\"\n>\n  <v-input\n          name=\"modelId\"\n          [title]=\"'modelId' | pluginTranslate: pluginId | async\"\n          [margin]=\"true\"\n          [defaultValue]=\"obs.prefill?.modelId\"\n          [disabled]=\"obs.disabled\"\n          [tooltip]=\"'modelIdTooltip' | pluginTranslate: pluginId | async\"\n          [required]=\"true\"\n  >\n  </v-input>\n  <v-input\n          name=\"templateId\"\n          [title]=\"'templateId' | pluginTranslate: pluginId | async\"\n          [margin]=\"true\"\n          [defaultValue]=\"obs.prefill?.templateId\"\n          [disabled]=\"obs.disabled\"\n          [tooltip]=\"'templateIdTooltip' | pluginTranslate: pluginId | async\"\n          [required]=\"true\"\n  >\n  </v-input>\n  <v-input\n          name=\"naam\"\n          [title]=\"'naam' | pluginTranslate: pluginId | async\"\n          [margin]=\"true\"\n          [defaultValue]=\"obs.prefill?.naam\"\n          [disabled]=\"obs.disabled\"\n          [tooltip]=\"'nameTooltip' | pluginTranslate: pluginId | async\"\n          [required]=\"false\"\n  >\n  </v-input>\n  <v-input\n          name=\"format\"\n          [title]=\"'format' | pluginTranslate: pluginId | async\"\n          [margin]=\"true\"\n          [defaultValue]=\"obs.prefill?.format\"\n          [disabled]=\"obs.disabled\"\n          [tooltip]=\"'formatTooltip' | pluginTranslate: pluginId | async\"\n          [required]=\"true\"\n  >\n  </v-input>\n  <v-input\n          name=\"variabeleNaam\"\n          [title]=\"'variabeleNaam' | pluginTranslate: pluginId | async\"\n          [margin]=\"true\"\n          [defaultValue]=\"obs.prefill?.variabeleNaam\"\n          [disabled]=\"obs.disabled\"\n          [tooltip]=\"'variabeleNaamTooltip' | pluginTranslate: pluginId | async\"\n          [required]=\"true\"\n  >\n  </v-input>\n  <valtimo-carbon-multi-input\n          name=\"parameters\"\n          [title]=\"'parameters' | pluginTranslate: pluginId | async\"\n          type=\"keyValue\"\n          [required]=\"false\"\n          [margin]=\"true\"\n          [disabled]=\"obs.disabled\"\n          [tooltip]=\"'parametersTooltip' | pluginTranslate: pluginId | async\"\n          [initialAmountOfRows]=\"0\"\n          [minimumAmountOfRows]=\"0\"\n          [addRowText]=\"'addParameter' | pluginTranslate: pluginId | async\"\n          [defaultValues]=\"obs.prefill?.parameters\"\n  >\n  </valtimo-carbon-multi-input>\n</v-form>\n";

/***/ }),

/***/ "./src/lib/components/text-generation/text-generation-configuration.component.scss":
/*!*****************************************************************************************!*\
  !*** ./src/lib/components/text-generation/text-generation-configuration.component.scss ***!
  \*****************************************************************************************/
/***/ ((module) => {

module.exports = "/*!\n * Copyright 2015-2024. Ritense BV, the Netherlands.\n *\n * Licensed under EUPL, Version 1.2 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * https://joinup.ec.europa.eu/collection/eupl/eupl-text-eupl-12\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" basis,\n *\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n * express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n";

/***/ }),

/***/ "@angular/common":
/*!**********************************!*\
  !*** external "@angular/common" ***!
  \**********************************/
/***/ ((module) => {

module.exports = window["@angular/common"];

/***/ }),

/***/ "@angular/core":
/*!********************************!*\
  !*** external "@angular/core" ***!
  \********************************/
/***/ ((module) => {

module.exports = window["@angular/core"];

/***/ }),

/***/ "@valtimo/components":
/*!**************************************!*\
  !*** external "@valtimo/components" ***!
  \**************************************/
/***/ ((module) => {

module.exports = window["@valtimo/components"];

/***/ }),

/***/ "@valtimo/plugin":
/*!**********************************!*\
  !*** external "@valtimo/plugin" ***!
  \**********************************/
/***/ ((module) => {

module.exports = window["@valtimo/plugin"];

/***/ }),

/***/ "rxjs":
/*!***********************!*\
  !*** external "rxjs" ***!
  \***********************/
/***/ ((module) => {

module.exports = window["rxjs"];

/***/ }),

/***/ "tslib":
/*!************************!*\
  !*** external "tslib" ***!
  \************************/
/***/ ((module) => {

module.exports = window["tslib"];

/***/ }),

/***/ "../../../node_modules/@angular/forms/fesm2022/forms.mjs":
/*!***************************************************************!*\
  !*** ../../../node_modules/@angular/forms/fesm2022/forms.mjs ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

var _angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache;
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AbstractControl: () => (/* binding */ AbstractControl),
/* harmony export */   AbstractControlDirective: () => (/* binding */ AbstractControlDirective),
/* harmony export */   AbstractFormGroupDirective: () => (/* binding */ AbstractFormGroupDirective),
/* harmony export */   COMPOSITION_BUFFER_MODE: () => (/* binding */ COMPOSITION_BUFFER_MODE),
/* harmony export */   CheckboxControlValueAccessor: () => (/* binding */ CheckboxControlValueAccessor),
/* harmony export */   CheckboxRequiredValidator: () => (/* binding */ CheckboxRequiredValidator),
/* harmony export */   ControlContainer: () => (/* binding */ ControlContainer),
/* harmony export */   DefaultValueAccessor: () => (/* binding */ DefaultValueAccessor),
/* harmony export */   EmailValidator: () => (/* binding */ EmailValidator),
/* harmony export */   FormArray: () => (/* binding */ FormArray),
/* harmony export */   FormArrayName: () => (/* binding */ FormArrayName),
/* harmony export */   FormBuilder: () => (/* binding */ FormBuilder),
/* harmony export */   FormControl: () => (/* binding */ FormControl),
/* harmony export */   FormControlDirective: () => (/* binding */ FormControlDirective),
/* harmony export */   FormControlName: () => (/* binding */ FormControlName),
/* harmony export */   FormGroup: () => (/* binding */ FormGroup),
/* harmony export */   FormGroupDirective: () => (/* binding */ FormGroupDirective),
/* harmony export */   FormGroupName: () => (/* binding */ FormGroupName),
/* harmony export */   FormRecord: () => (/* binding */ FormRecord),
/* harmony export */   FormsModule: () => (/* binding */ FormsModule),
/* harmony export */   MaxLengthValidator: () => (/* binding */ MaxLengthValidator),
/* harmony export */   MaxValidator: () => (/* binding */ MaxValidator),
/* harmony export */   MinLengthValidator: () => (/* binding */ MinLengthValidator),
/* harmony export */   MinValidator: () => (/* binding */ MinValidator),
/* harmony export */   NG_ASYNC_VALIDATORS: () => (/* binding */ NG_ASYNC_VALIDATORS),
/* harmony export */   NG_VALIDATORS: () => (/* binding */ NG_VALIDATORS),
/* harmony export */   NG_VALUE_ACCESSOR: () => (/* binding */ NG_VALUE_ACCESSOR),
/* harmony export */   NgControl: () => (/* binding */ NgControl),
/* harmony export */   NgControlStatus: () => (/* binding */ NgControlStatus),
/* harmony export */   NgControlStatusGroup: () => (/* binding */ NgControlStatusGroup),
/* harmony export */   NgForm: () => (/* binding */ NgForm),
/* harmony export */   NgModel: () => (/* binding */ NgModel),
/* harmony export */   NgModelGroup: () => (/* binding */ NgModelGroup),
/* harmony export */   NgSelectOption: () => (/* binding */ NgSelectOption),
/* harmony export */   NonNullableFormBuilder: () => (/* binding */ NonNullableFormBuilder),
/* harmony export */   NumberValueAccessor: () => (/* binding */ NumberValueAccessor),
/* harmony export */   PatternValidator: () => (/* binding */ PatternValidator),
/* harmony export */   RadioControlValueAccessor: () => (/* binding */ RadioControlValueAccessor),
/* harmony export */   RangeValueAccessor: () => (/* binding */ RangeValueAccessor),
/* harmony export */   ReactiveFormsModule: () => (/* binding */ ReactiveFormsModule),
/* harmony export */   RequiredValidator: () => (/* binding */ RequiredValidator),
/* harmony export */   SelectControlValueAccessor: () => (/* binding */ SelectControlValueAccessor),
/* harmony export */   SelectMultipleControlValueAccessor: () => (/* binding */ SelectMultipleControlValueAccessor),
/* harmony export */   UntypedFormArray: () => (/* binding */ UntypedFormArray),
/* harmony export */   UntypedFormBuilder: () => (/* binding */ UntypedFormBuilder),
/* harmony export */   UntypedFormControl: () => (/* binding */ UntypedFormControl),
/* harmony export */   UntypedFormGroup: () => (/* binding */ UntypedFormGroup),
/* harmony export */   VERSION: () => (/* binding */ VERSION),
/* harmony export */   Validators: () => (/* binding */ Validators),
/* harmony export */   isFormArray: () => (/* binding */ isFormArray),
/* harmony export */   isFormControl: () => (/* binding */ isFormControl),
/* harmony export */   isFormGroup: () => (/* binding */ isFormGroup),
/* harmony export */   isFormRecord: () => (/* binding */ isFormRecord),
/* harmony export */   "InternalFormsSharedModule": () => (/* binding */ InternalFormsSharedModule),
/* harmony export */   "NgNoValidate": () => (/* binding */ NgNoValidate),
/* harmony export */   "NgSelectMultipleOption": () => (/* binding */ NgSelectMultipleOption)
/* harmony export */ });
/* harmony import */ var _angular_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @angular/core */ "@angular/core");
/* harmony import */ var _angular_common__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @angular/common */ "@angular/common");
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! rxjs */ "rxjs");
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! rxjs/operators */ "../../../node_modules/rxjs/dist/esm5/internal/operators/map.js");
/**
 * @license Angular v17.3.12
 * (c) 2010-2024 Google LLC. https://angular.io/
 * License: MIT
 */







/**
 * Base class for all ControlValueAccessor classes defined in Forms package.
 * Contains common logic and utility functions.
 *
 * Note: this is an *internal-only* class and should not be extended or used directly in
 * applications code.
 */
class BaseControlValueAccessor {
    constructor(_renderer, _elementRef) {
        this._renderer = _renderer;
        this._elementRef = _elementRef;
        /**
         * The registered callback function called when a change or input event occurs on the input
         * element.
         * @nodoc
         */
        this.onChange = (_) => { };
        /**
         * The registered callback function called when a blur event occurs on the input element.
         * @nodoc
         */
        this.onTouched = () => { };
    }
    /**
     * Helper method that sets a property on a target element using the current Renderer
     * implementation.
     * @nodoc
     */
    setProperty(key, value) {
        this._renderer.setProperty(this._elementRef.nativeElement, key, value);
    }
    /**
     * Registers a function called when the control is touched.
     * @nodoc
     */
    registerOnTouched(fn) {
        this.onTouched = fn;
    }
    /**
     * Registers a function called when the control value changes.
     * @nodoc
     */
    registerOnChange(fn) {
        this.onChange = fn;
    }
    /**
     * Sets the "disabled" property on the range input element.
     * @nodoc
     */
    setDisabledState(isDisabled) {
        this.setProperty('disabled', isDisabled);
    }
    static { this.fac = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareFactory"]({ minVersion: "12.0.0", version: "17.3.12", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: BaseControlValueAccessor, deps: [{ token: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Renderer2 }, { token: _angular_core__WEBPACK_IMPORTED_MODULE_0__.ElementRef }], target: _angular_core__WEBPACK_IMPORTED_MODULE_0__["FactoryTarget"].Directive }); }
    static { this.dir = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareDirective"]({ minVersion: "14.0.0", version: "17.3.12", type: BaseControlValueAccessor, ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))) }); }
}
_angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareClassMetadata"]({ minVersion: "12.0.0", version: "17.3.12", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: BaseControlValueAccessor, decorators: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Directive
        }], ctorParameters: () => [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Renderer2 }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.ElementRef }] });
/**
 * Base class for all built-in ControlValueAccessor classes (except DefaultValueAccessor, which is
 * used in case no other CVAs can be found). We use this class to distinguish between default CVA,
 * built-in CVAs and custom CVAs, so that Forms logic can recognize built-in CVAs and treat custom
 * ones with higher priority (when both built-in and custom CVAs are present).
 *
 * Note: this is an *internal-only* class and should not be extended or used directly in
 * applications code.
 */
class BuiltInControlValueAccessor extends BaseControlValueAccessor {
    static { this.fac = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareFactory"]({ minVersion: "12.0.0", version: "17.3.12", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: BuiltInControlValueAccessor, deps: null, target: _angular_core__WEBPACK_IMPORTED_MODULE_0__["FactoryTarget"].Directive }); }
    static { this.dir = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareDirective"]({ minVersion: "14.0.0", version: "17.3.12", type: BuiltInControlValueAccessor, usesInheritance: true, ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))) }); }
}
_angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareClassMetadata"]({ minVersion: "12.0.0", version: "17.3.12", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: BuiltInControlValueAccessor, decorators: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Directive
        }] });
/**
 * Used to provide a `ControlValueAccessor` for form controls.
 *
 * See `DefaultValueAccessor` for how to implement one.
 *
 * @publicApi
 */
const NG_VALUE_ACCESSOR = new _angular_core__WEBPACK_IMPORTED_MODULE_0__.InjectionToken(ngDevMode ? 'NgValueAccessor' : '');

const CHECKBOX_VALUE_ACCESSOR = {
    provide: NG_VALUE_ACCESSOR,
    useExisting: (0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(() => CheckboxControlValueAccessor),
    multi: true,
};
/**
 * @description
 * A `ControlValueAccessor` for writing a value and listening to changes on a checkbox input
 * element.
 *
 * @usageNotes
 *
 * ### Using a checkbox with a reactive form.
 *
 * The following example shows how to use a checkbox with a reactive form.
 *
 * ```ts
 * const rememberLoginControl = new FormControl();
 * ```
 *
 * ```
 * <input type="checkbox" [formControl]="rememberLoginControl">
 * ```
 *
 * @ngModule ReactiveFormsModule
 * @ngModule FormsModule
 * @publicApi
 */
class CheckboxControlValueAccessor extends BuiltInControlValueAccessor {
    /**
     * Sets the "checked" property on the input element.
     * @nodoc
     */
    writeValue(value) {
        this.setProperty('checked', value);
    }
    static { this.fac = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareFactory"]({ minVersion: "12.0.0", version: "17.3.12", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: CheckboxControlValueAccessor, deps: null, target: _angular_core__WEBPACK_IMPORTED_MODULE_0__["FactoryTarget"].Directive }); }
    static { this.dir = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareDirective"]({ minVersion: "14.0.0", version: "17.3.12", type: CheckboxControlValueAccessor, selector: "input[type=checkbox][formControlName],input[type=checkbox][formControl],input[type=checkbox][ngModel]", host: { listeners: { "change": "onChange($event.target.checked)", "blur": "onTouched()" } }, providers: [CHECKBOX_VALUE_ACCESSOR], usesInheritance: true, ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))) }); }
}
_angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareClassMetadata"]({ minVersion: "12.0.0", version: "17.3.12", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: CheckboxControlValueAccessor, decorators: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Directive,
            args: [{
                    selector: 'input[type=checkbox][formControlName],input[type=checkbox][formControl],input[type=checkbox][ngModel]',
                    host: { '(change)': 'onChange($event.target.checked)', '(blur)': 'onTouched()' },
                    providers: [CHECKBOX_VALUE_ACCESSOR]
                }]
        }] });

const DEFAULT_VALUE_ACCESSOR = {
    provide: NG_VALUE_ACCESSOR,
    useExisting: (0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(() => DefaultValueAccessor),
    multi: true
};
/**
 * We must check whether the agent is Android because composition events
 * behave differently between iOS and Android.
 */
function _isAndroid() {
    const userAgent = (0,_angular_common__WEBPACK_IMPORTED_MODULE_1__["getDOM"])() ? (0,_angular_common__WEBPACK_IMPORTED_MODULE_1__["getDOM"])().getUserAgent() : '';
    return /android (\d+)/.test(userAgent.toLowerCase());
}
/**
 * @description
 * Provide this token to control if form directives buffer IME input until
 * the "compositionend" event occurs.
 * @publicApi
 */
const COMPOSITION_BUFFER_MODE = new _angular_core__WEBPACK_IMPORTED_MODULE_0__.InjectionToken(ngDevMode ? 'CompositionEventMode' : '');
/**
 * The default `ControlValueAccessor` for writing a value and listening to changes on input
 * elements. The accessor is used by the `FormControlDirective`, `FormControlName`, and
 * `NgModel` directives.
 *
 * {@searchKeywords ngDefaultControl}
 *
 * @usageNotes
 *
 * ### Using the default value accessor
 *
 * The following example shows how to use an input element that activates the default value accessor
 * (in this case, a text field).
 *
 * ```ts
 * const firstNameControl = new FormControl();
 * ```
 *
 * ```
 * <input type="text" [formControl]="firstNameControl">
 * ```
 *
 * This value accessor is used by default for `<input type="text">` and `<textarea>` elements, but
 * you could also use it for custom components that have similar behavior and do not require special
 * processing. In order to attach the default value accessor to a custom element, add the
 * `ngDefaultControl` attribute as shown below.
 *
 * ```
 * <custom-input-component ngDefaultControl [(ngModel)]="value"></custom-input-component>
 * ```
 *
 * @ngModule ReactiveFormsModule
 * @ngModule FormsModule
 * @publicApi
 */
class DefaultValueAccessor extends BaseControlValueAccessor {
    constructor(renderer, elementRef, _compositionMode) {
        super(renderer, elementRef);
        this._compositionMode = _compositionMode;
        /** Whether the user is creating a composition string (IME events). */
        this._composing = false;
        if (this._compositionMode == null) {
            this._compositionMode = !_isAndroid();
        }
    }
    /**
     * Sets the "value" property on the input element.
     * @nodoc
     */
    writeValue(value) {
        const normalizedValue = value == null ? '' : value;
        this.setProperty('value', normalizedValue);
    }
    /** @internal */
    _handleInput(value) {
        if (!this._compositionMode || (this._compositionMode && !this._composing)) {
            this.onChange(value);
        }
    }
    /** @internal */
    _compositionStart() {
        this._composing = true;
    }
    /** @internal */
    _compositionEnd(value) {
        this._composing = false;
        this._compositionMode && this.onChange(value);
    }
    static { this.fac = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareFactory"]({ minVersion: "12.0.0", version: "17.3.12", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: DefaultValueAccessor, deps: [{ token: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Renderer2 }, { token: _angular_core__WEBPACK_IMPORTED_MODULE_0__.ElementRef }, { token: COMPOSITION_BUFFER_MODE, optional: true }], target: _angular_core__WEBPACK_IMPORTED_MODULE_0__["FactoryTarget"].Directive }); }
    static { this.dir = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareDirective"]({ minVersion: "14.0.0", version: "17.3.12", type: DefaultValueAccessor, selector: "input:not([type=checkbox])[formControlName],textarea[formControlName],input:not([type=checkbox])[formControl],textarea[formControl],input:not([type=checkbox])[ngModel],textarea[ngModel],[ngDefaultControl]", host: { listeners: { "input": "$any(this)._handleInput($event.target.value)", "blur": "onTouched()", "compositionstart": "$any(this)._compositionStart()", "compositionend": "$any(this)._compositionEnd($event.target.value)" } }, providers: [DEFAULT_VALUE_ACCESSOR], usesInheritance: true, ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))) }); }
}
_angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareClassMetadata"]({ minVersion: "12.0.0", version: "17.3.12", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: DefaultValueAccessor, decorators: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Directive,
            args: [{
                    selector: 'input:not([type=checkbox])[formControlName],textarea[formControlName],input:not([type=checkbox])[formControl],textarea[formControl],input:not([type=checkbox])[ngModel],textarea[ngModel],[ngDefaultControl]',
                    // TODO: vsavkin replace the above selector with the one below it once
                    // https://github.com/angular/angular/issues/3011 is implemented
                    // selector: '[ngModel],[formControl],[formControlName]',
                    host: {
                        '(input)': '$any(this)._handleInput($event.target.value)',
                        '(blur)': 'onTouched()',
                        '(compositionstart)': '$any(this)._compositionStart()',
                        '(compositionend)': '$any(this)._compositionEnd($event.target.value)'
                    },
                    providers: [DEFAULT_VALUE_ACCESSOR]
                }]
        }], ctorParameters: () => [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Renderer2 }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.ElementRef }, { type: undefined, decorators: [{
                    type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Optional
                }, {
                    type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Inject,
                    args: [COMPOSITION_BUFFER_MODE]
                }] }] });

function isEmptyInputValue(value) {
    /**
     * Check if the object is a string or array before evaluating the length attribute.
     * This avoids falsely rejecting objects that contain a custom length attribute.
     * For example, the object {id: 1, length: 0, width: 0} should not be returned as empty.
     */
    return value == null ||
        ((typeof value === 'string' || Array.isArray(value)) && value.length === 0);
}
function hasValidLength(value) {
    // non-strict comparison is intentional, to check for both `null` and `undefined` values
    return value != null && typeof value.length === 'number';
}
/**
 * @description
 * An `InjectionToken` for registering additional synchronous validators used with
 * `AbstractControl`s.
 *
 * @see {@link NG_ASYNC_VALIDATORS}
 *
 * @usageNotes
 *
 * ### Providing a custom validator
 *
 * The following example registers a custom validator directive. Adding the validator to the
 * existing collection of validators requires the `multi: true` option.
 *
 * ```typescript
 * @Directive({
 *   selector: '[customValidator]',
 *   providers: [{provide: NG_VALIDATORS, useExisting: CustomValidatorDirective, multi: true}]
 * })
 * class CustomValidatorDirective implements Validator {
 *   validate(control: AbstractControl): ValidationErrors | null {
 *     return { 'custom': true };
 *   }
 * }
 * ```
 *
 * @publicApi
 */
const NG_VALIDATORS = new _angular_core__WEBPACK_IMPORTED_MODULE_0__.InjectionToken(ngDevMode ? 'NgValidators' : '');
/**
 * @description
 * An `InjectionToken` for registering additional asynchronous validators used with
 * `AbstractControl`s.
 *
 * @see {@link NG_VALIDATORS}
 *
 * @usageNotes
 *
 * ### Provide a custom async validator directive
 *
 * The following example implements the `AsyncValidator` interface to create an
 * async validator directive with a custom error key.
 *
 * ```typescript
 * @Directive({
 *   selector: '[customAsyncValidator]',
 *   providers: [{provide: NG_ASYNC_VALIDATORS, useExisting: CustomAsyncValidatorDirective, multi:
 * true}]
 * })
 * class CustomAsyncValidatorDirective implements AsyncValidator {
 *   validate(control: AbstractControl): Promise<ValidationErrors|null> {
 *     return Promise.resolve({'custom': true});
 *   }
 * }
 * ```
 *
 * @publicApi
 */
const NG_ASYNC_VALIDATORS = new _angular_core__WEBPACK_IMPORTED_MODULE_0__.InjectionToken(ngDevMode ? 'NgAsyncValidators' : '');
/**
 * A regular expression that matches valid e-mail addresses.
 *
 * At a high level, this regexp matches e-mail addresses of the format `local-part@tld`, where:
 * - `local-part` consists of one or more of the allowed characters (alphanumeric and some
 *   punctuation symbols).
 * - `local-part` cannot begin or end with a period (`.`).
 * - `local-part` cannot be longer than 64 characters.
 * - `tld` consists of one or more `labels` separated by periods (`.`). For example `localhost` or
 *   `foo.com`.
 * - A `label` consists of one or more of the allowed characters (alphanumeric, dashes (`-`) and
 *   periods (`.`)).
 * - A `label` cannot begin or end with a dash (`-`) or a period (`.`).
 * - A `label` cannot be longer than 63 characters.
 * - The whole address cannot be longer than 254 characters.
 *
 * ## Implementation background
 *
 * This regexp was ported over from AngularJS (see there for git history):
 * https://github.com/angular/angular.js/blob/c133ef836/src/ng/directive/input.js#L27
 * It is based on the
 * [WHATWG version](https://html.spec.whatwg.org/multipage/input.html#valid-e-mail-address) with
 * some enhancements to incorporate more RFC rules (such as rules related to domain names and the
 * lengths of different parts of the address). The main differences from the WHATWG version are:
 *   - Disallow `local-part` to begin or end with a period (`.`).
 *   - Disallow `local-part` length to exceed 64 characters.
 *   - Disallow total address length to exceed 254 characters.
 *
 * See [this commit](https://github.com/angular/angular.js/commit/f3f5cf72e) for more details.
 */
const EMAIL_REGEXP = /^(?=.{1,254}$)(?=.{1,64}@)[a-zA-Z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-zA-Z0-9!#$%&'*+/=?^_`{|}~-]+)*@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;
/**
 * @description
 * Provides a set of built-in validators that can be used by form controls.
 *
 * A validator is a function that processes a `FormControl` or collection of
 * controls and returns an error map or null. A null map means that validation has passed.
 *
 * @see [Form Validation](/guide/form-validation)
 *
 * @publicApi
 */
class Validators {
    /**
     * @description
     * Validator that requires the control's value to be greater than or equal to the provided number.
     *
     * @usageNotes
     *
     * ### Validate against a minimum of 3
     *
     * ```typescript
     * const control = new FormControl(2, Validators.min(3));
     *
     * console.log(control.errors); // {min: {min: 3, actual: 2}}
     * ```
     *
     * @returns A validator function that returns an error map with the
     * `min` property if the validation check fails, otherwise `null`.
     *
     * @see {@link updateValueAndValidity()}
     *
     */
    static min(min) {
        return minValidator(min);
    }
    /**
     * @description
     * Validator that requires the control's value to be less than or equal to the provided number.
     *
     * @usageNotes
     *
     * ### Validate against a maximum of 15
     *
     * ```typescript
     * const control = new FormControl(16, Validators.max(15));
     *
     * console.log(control.errors); // {max: {max: 15, actual: 16}}
     * ```
     *
     * @returns A validator function that returns an error map with the
     * `max` property if the validation check fails, otherwise `null`.
     *
     * @see {@link updateValueAndValidity()}
     *
     */
    static max(max) {
        return maxValidator(max);
    }
    /**
     * @description
     * Validator that requires the control have a non-empty value.
     *
     * @usageNotes
     *
     * ### Validate that the field is non-empty
     *
     * ```typescript
     * const control = new FormControl('', Validators.required);
     *
     * console.log(control.errors); // {required: true}
     * ```
     *
     * @returns An error map with the `required` property
     * if the validation check fails, otherwise `null`.
     *
     * @see {@link updateValueAndValidity()}
     *
     */
    static required(control) {
        return requiredValidator(control);
    }
    /**
     * @description
     * Validator that requires the control's value be true. This validator is commonly
     * used for required checkboxes.
     *
     * @usageNotes
     *
     * ### Validate that the field value is true
     *
     * ```typescript
     * const control = new FormControl('some value', Validators.requiredTrue);
     *
     * console.log(control.errors); // {required: true}
     * ```
     *
     * @returns An error map that contains the `required` property
     * set to `true` if the validation check fails, otherwise `null`.
     *
     * @see {@link updateValueAndValidity()}
     *
     */
    static requiredTrue(control) {
        return requiredTrueValidator(control);
    }
    /**
     * @description
     * Validator that requires the control's value pass an email validation test.
     *
     * Tests the value using a [regular
     * expression](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions)
     * pattern suitable for common use cases. The pattern is based on the definition of a valid email
     * address in the [WHATWG HTML
     * specification](https://html.spec.whatwg.org/multipage/input.html#valid-e-mail-address) with
     * some enhancements to incorporate more RFC rules (such as rules related to domain names and the
     * lengths of different parts of the address).
     *
     * The differences from the WHATWG version include:
     * - Disallow `local-part` (the part before the `@` symbol) to begin or end with a period (`.`).
     * - Disallow `local-part` to be longer than 64 characters.
     * - Disallow the whole address to be longer than 254 characters.
     *
     * If this pattern does not satisfy your business needs, you can use `Validators.pattern()` to
     * validate the value against a different pattern.
     *
     * @usageNotes
     *
     * ### Validate that the field matches a valid email pattern
     *
     * ```typescript
     * const control = new FormControl('bad@', Validators.email);
     *
     * console.log(control.errors); // {email: true}
     * ```
     *
     * @returns An error map with the `email` property
     * if the validation check fails, otherwise `null`.
     *
     * @see {@link updateValueAndValidity()}
     *
     */
    static email(control) {
        return emailValidator(control);
    }
    /**
     * @description
     * Validator that requires the length of the control's value to be greater than or equal
     * to the provided minimum length. This validator is also provided by default if you use the
     * the HTML5 `minlength` attribute. Note that the `minLength` validator is intended to be used
     * only for types that have a numeric `length` property, such as strings or arrays. The
     * `minLength` validator logic is also not invoked for values when their `length` property is 0
     * (for example in case of an empty string or an empty array), to support optional controls. You
     * can use the standard `required` validator if empty values should not be considered valid.
     *
     * @usageNotes
     *
     * ### Validate that the field has a minimum of 3 characters
     *
     * ```typescript
     * const control = new FormControl('ng', Validators.minLength(3));
     *
     * console.log(control.errors); // {minlength: {requiredLength: 3, actualLength: 2}}
     * ```
     *
     * ```html
     * <input minlength="5">
     * ```
     *
     * @returns A validator function that returns an error map with the
     * `minlength` property if the validation check fails, otherwise `null`.
     *
     * @see {@link updateValueAndValidity()}
     *
     */
    static minLength(minLength) {
        return minLengthValidator(minLength);
    }
    /**
     * @description
     * Validator that requires the length of the control's value to be less than or equal
     * to the provided maximum length. This validator is also provided by default if you use the
     * the HTML5 `maxlength` attribute. Note that the `maxLength` validator is intended to be used
     * only for types that have a numeric `length` property, such as strings or arrays.
     *
     * @usageNotes
     *
     * ### Validate that the field has maximum of 5 characters
     *
     * ```typescript
     * const control = new FormControl('Angular', Validators.maxLength(5));
     *
     * console.log(control.errors); // {maxlength: {requiredLength: 5, actualLength: 7}}
     * ```
     *
     * ```html
     * <input maxlength="5">
     * ```
     *
     * @returns A validator function that returns an error map with the
     * `maxlength` property if the validation check fails, otherwise `null`.
     *
     * @see {@link updateValueAndValidity()}
     *
     */
    static maxLength(maxLength) {
        return maxLengthValidator(maxLength);
    }
    /**
     * @description
     * Validator that requires the control's value to match a regex pattern. This validator is also
     * provided by default if you use the HTML5 `pattern` attribute.
     *
     * @usageNotes
     *
     * ### Validate that the field only contains letters or spaces
     *
     * ```typescript
     * const control = new FormControl('1', Validators.pattern('[a-zA-Z ]*'));
     *
     * console.log(control.errors); // {pattern: {requiredPattern: '^[a-zA-Z ]*$', actualValue: '1'}}
     * ```
     *
     * ```html
     * <input pattern="[a-zA-Z ]*">
     * ```
     *
     * ### Pattern matching with the global or sticky flag
     *
     * `RegExp` objects created with the `g` or `y` flags that are passed into `Validators.pattern`
     * can produce different results on the same input when validations are run consecutively. This is
     * due to how the behavior of `RegExp.prototype.test` is
     * specified in [ECMA-262](https://tc39.es/ecma262/#sec-regexpbuiltinexec)
     * (`RegExp` preserves the index of the last match when the global or sticky flag is used).
     * Due to this behavior, it is recommended that when using
     * `Validators.pattern` you **do not** pass in a `RegExp` object with either the global or sticky
     * flag enabled.
     *
     * ```typescript
     * // Not recommended (since the `g` flag is used)
     * const controlOne = new FormControl('1', Validators.pattern(/foo/g));
     *
     * // Good
     * const controlTwo = new FormControl('1', Validators.pattern(/foo/));
     * ```
     *
     * @param pattern A regular expression to be used as is to test the values, or a string.
     * If a string is passed, the `^` character is prepended and the `$` character is
     * appended to the provided string (if not already present), and the resulting regular
     * expression is used to test the values.
     *
     * @returns A validator function that returns an error map with the
     * `pattern` property if the validation check fails, otherwise `null`.
     *
     * @see {@link updateValueAndValidity()}
     *
     */
    static pattern(pattern) {
        return patternValidator(pattern);
    }
    /**
     * @description
     * Validator that performs no operation.
     *
     * @see {@link updateValueAndValidity()}
     *
     */
    static nullValidator(control) {
        return nullValidator(control);
    }
    static compose(validators) {
        return compose(validators);
    }
    /**
     * @description
     * Compose multiple async validators into a single function that returns the union
     * of the individual error objects for the provided control.
     *
     * @returns A validator function that returns an error map with the
     * merged error objects of the async validators if the validation check fails, otherwise `null`.
     *
     * @see {@link updateValueAndValidity()}
     *
     */
    static composeAsync(validators) {
        return composeAsync(validators);
    }
}
/**
 * Validator that requires the control's value to be greater than or equal to the provided number.
 * See `Validators.min` for additional information.
 */
function minValidator(min) {
    return (control) => {
        if (isEmptyInputValue(control.value) || isEmptyInputValue(min)) {
            return null; // don't validate empty values to allow optional controls
        }
        const value = parseFloat(control.value);
        // Controls with NaN values after parsing should be treated as not having a
        // minimum, per the HTML forms spec: https://www.w3.org/TR/html5/forms.html#attr-input-min
        return !isNaN(value) && value < min ? { 'min': { 'min': min, 'actual': control.value } } : null;
    };
}
/**
 * Validator that requires the control's value to be less than or equal to the provided number.
 * See `Validators.max` for additional information.
 */
function maxValidator(max) {
    return (control) => {
        if (isEmptyInputValue(control.value) || isEmptyInputValue(max)) {
            return null; // don't validate empty values to allow optional controls
        }
        const value = parseFloat(control.value);
        // Controls with NaN values after parsing should be treated as not having a
        // maximum, per the HTML forms spec: https://www.w3.org/TR/html5/forms.html#attr-input-max
        return !isNaN(value) && value > max ? { 'max': { 'max': max, 'actual': control.value } } : null;
    };
}
/**
 * Validator that requires the control have a non-empty value.
 * See `Validators.required` for additional information.
 */
function requiredValidator(control) {
    return isEmptyInputValue(control.value) ? { 'required': true } : null;
}
/**
 * Validator that requires the control's value be true. This validator is commonly
 * used for required checkboxes.
 * See `Validators.requiredTrue` for additional information.
 */
function requiredTrueValidator(control) {
    return control.value === true ? null : { 'required': true };
}
/**
 * Validator that requires the control's value pass an email validation test.
 * See `Validators.email` for additional information.
 */
function emailValidator(control) {
    if (isEmptyInputValue(control.value)) {
        return null; // don't validate empty values to allow optional controls
    }
    return EMAIL_REGEXP.test(control.value) ? null : { 'email': true };
}
/**
 * Validator that requires the length of the control's value to be greater than or equal
 * to the provided minimum length. See `Validators.minLength` for additional information.
 */
function minLengthValidator(minLength) {
    return (control) => {
        if (isEmptyInputValue(control.value) || !hasValidLength(control.value)) {
            // don't validate empty values to allow optional controls
            // don't validate values without `length` property
            return null;
        }
        return control.value.length < minLength ?
            { 'minlength': { 'requiredLength': minLength, 'actualLength': control.value.length } } :
            null;
    };
}
/**
 * Validator that requires the length of the control's value to be less than or equal
 * to the provided maximum length. See `Validators.maxLength` for additional information.
 */
function maxLengthValidator(maxLength) {
    return (control) => {
        return hasValidLength(control.value) && control.value.length > maxLength ?
            { 'maxlength': { 'requiredLength': maxLength, 'actualLength': control.value.length } } :
            null;
    };
}
/**
 * Validator that requires the control's value to match a regex pattern.
 * See `Validators.pattern` for additional information.
 */
function patternValidator(pattern) {
    if (!pattern)
        return nullValidator;
    let regex;
    let regexStr;
    if (typeof pattern === 'string') {
        regexStr = '';
        if (pattern.charAt(0) !== '^')
            regexStr += '^';
        regexStr += pattern;
        if (pattern.charAt(pattern.length - 1) !== '$')
            regexStr += '$';
        regex = new RegExp(regexStr);
    }
    else {
        regexStr = pattern.toString();
        regex = pattern;
    }
    return (control) => {
        if (isEmptyInputValue(control.value)) {
            return null; // don't validate empty values to allow optional controls
        }
        const value = control.value;
        return regex.test(value) ? null :
            { 'pattern': { 'requiredPattern': regexStr, 'actualValue': value } };
    };
}
/**
 * Function that has `ValidatorFn` shape, but performs no operation.
 */
function nullValidator(control) {
    return null;
}
function isPresent(o) {
    return o != null;
}
function toObservable(value) {
    const obs = (0,_angular_core__WEBPACK_IMPORTED_MODULE_0__["isPromise"])(value) ? (0,rxjs__WEBPACK_IMPORTED_MODULE_2__.from)(value) : value;
    if ((typeof ngDevMode === 'undefined' || ngDevMode) && !((0,_angular_core__WEBPACK_IMPORTED_MODULE_0__["isSubscribable"])(obs))) {
        let errorMessage = `Expected async validator to return Promise or Observable.`;
        // A synchronous validator will return object or null.
        if (typeof value === 'object') {
            errorMessage +=
                ' Are you using a synchronous validator where an async validator is expected?';
        }
        throw new _angular_core__WEBPACK_IMPORTED_MODULE_0__["RuntimeError"](-1101 /* RuntimeErrorCode.WRONG_VALIDATOR_RETURN_TYPE */, errorMessage);
    }
    return obs;
}
function mergeErrors(arrayOfErrors) {
    let res = {};
    arrayOfErrors.forEach((errors) => {
        res = errors != null ? { ...res, ...errors } : res;
    });
    return Object.keys(res).length === 0 ? null : res;
}
function executeValidators(control, validators) {
    return validators.map(validator => validator(control));
}
function isValidatorFn(validator) {
    return !validator.validate;
}
/**
 * Given the list of validators that may contain both functions as well as classes, return the list
 * of validator functions (convert validator classes into validator functions). This is needed to
 * have consistent structure in validators list before composing them.
 *
 * @param validators The set of validators that may contain validators both in plain function form
 *     as well as represented as a validator class.
 */
function normalizeValidators(validators) {
    return validators.map(validator => {
        return isValidatorFn(validator) ?
            validator :
            ((c) => validator.validate(c));
    });
}
/**
 * Merges synchronous validators into a single validator function.
 * See `Validators.compose` for additional information.
 */
function compose(validators) {
    if (!validators)
        return null;
    const presentValidators = validators.filter(isPresent);
    if (presentValidators.length == 0)
        return null;
    return function (control) {
        return mergeErrors(executeValidators(control, presentValidators));
    };
}
/**
 * Accepts a list of validators of different possible shapes (`Validator` and `ValidatorFn`),
 * normalizes the list (converts everything to `ValidatorFn`) and merges them into a single
 * validator function.
 */
function composeValidators(validators) {
    return validators != null ? compose(normalizeValidators(validators)) : null;
}
/**
 * Merges asynchronous validators into a single validator function.
 * See `Validators.composeAsync` for additional information.
 */
function composeAsync(validators) {
    if (!validators)
        return null;
    const presentValidators = validators.filter(isPresent);
    if (presentValidators.length == 0)
        return null;
    return function (control) {
        const observables = executeValidators(control, presentValidators).map(toObservable);
        return (0,rxjs__WEBPACK_IMPORTED_MODULE_2__.forkJoin)(observables).pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_3__.map)(mergeErrors));
    };
}
/**
 * Accepts a list of async validators of different possible shapes (`AsyncValidator` and
 * `AsyncValidatorFn`), normalizes the list (converts everything to `AsyncValidatorFn`) and merges
 * them into a single validator function.
 */
function composeAsyncValidators(validators) {
    return validators != null ? composeAsync(normalizeValidators(validators)) :
        null;
}
/**
 * Merges raw control validators with a given directive validator and returns the combined list of
 * validators as an array.
 */
function mergeValidators(controlValidators, dirValidator) {
    if (controlValidators === null)
        return [dirValidator];
    return Array.isArray(controlValidators) ? [...controlValidators, dirValidator] :
        [controlValidators, dirValidator];
}
/**
 * Retrieves the list of raw synchronous validators attached to a given control.
 */
function getControlValidators(control) {
    return control._rawValidators;
}
/**
 * Retrieves the list of raw asynchronous validators attached to a given control.
 */
function getControlAsyncValidators(control) {
    return control._rawAsyncValidators;
}
/**
 * Accepts a singleton validator, an array, or null, and returns an array type with the provided
 * validators.
 *
 * @param validators A validator, validators, or null.
 * @returns A validators array.
 */
function makeValidatorsArray(validators) {
    if (!validators)
        return [];
    return Array.isArray(validators) ? validators : [validators];
}
/**
 * Determines whether a validator or validators array has a given validator.
 *
 * @param validators The validator or validators to compare against.
 * @param validator The validator to check.
 * @returns Whether the validator is present.
 */
function hasValidator(validators, validator) {
    return Array.isArray(validators) ? validators.includes(validator) : validators === validator;
}
/**
 * Combines two arrays of validators into one. If duplicates are provided, only one will be added.
 *
 * @param validators The new validators.
 * @param currentValidators The base array of current validators.
 * @returns An array of validators.
 */
function addValidators(validators, currentValidators) {
    const current = makeValidatorsArray(currentValidators);
    const validatorsToAdd = makeValidatorsArray(validators);
    validatorsToAdd.forEach((v) => {
        // Note: if there are duplicate entries in the new validators array,
        // only the first one would be added to the current list of validators.
        // Duplicate ones would be ignored since `hasValidator` would detect
        // the presence of a validator function and we update the current list in place.
        if (!hasValidator(current, v)) {
            current.push(v);
        }
    });
    return current;
}
function removeValidators(validators, currentValidators) {
    return makeValidatorsArray(currentValidators).filter(v => !hasValidator(validators, v));
}

/**
 * @description
 * Base class for control directives.
 *
 * This class is only used internally in the `ReactiveFormsModule` and the `FormsModule`.
 *
 * @publicApi
 */
class AbstractControlDirective {
    constructor() {
        /**
         * Set of synchronous validators as they were provided while calling `setValidators` function.
         * @internal
         */
        this._rawValidators = [];
        /**
         * Set of asynchronous validators as they were provided while calling `setAsyncValidators`
         * function.
         * @internal
         */
        this._rawAsyncValidators = [];
        /*
         * The set of callbacks to be invoked when directive instance is being destroyed.
         */
        this._onDestroyCallbacks = [];
    }
    /**
     * @description
     * Reports the value of the control if it is present, otherwise null.
     */
    get value() {
        return this.control ? this.control.value : null;
    }
    /**
     * @description
     * Reports whether the control is valid. A control is considered valid if no
     * validation errors exist with the current value.
     * If the control is not present, null is returned.
     */
    get valid() {
        return this.control ? this.control.valid : null;
    }
    /**
     * @description
     * Reports whether the control is invalid, meaning that an error exists in the input value.
     * If the control is not present, null is returned.
     */
    get invalid() {
        return this.control ? this.control.invalid : null;
    }
    /**
     * @description
     * Reports whether a control is pending, meaning that async validation is occurring and
     * errors are not yet available for the input value. If the control is not present, null is
     * returned.
     */
    get pending() {
        return this.control ? this.control.pending : null;
    }
    /**
     * @description
     * Reports whether the control is disabled, meaning that the control is disabled
     * in the UI and is exempt from validation checks and excluded from aggregate
     * values of ancestor controls. If the control is not present, null is returned.
     */
    get disabled() {
        return this.control ? this.control.disabled : null;
    }
    /**
     * @description
     * Reports whether the control is enabled, meaning that the control is included in ancestor
     * calculations of validity or value. If the control is not present, null is returned.
     */
    get enabled() {
        return this.control ? this.control.enabled : null;
    }
    /**
     * @description
     * Reports the control's validation errors. If the control is not present, null is returned.
     */
    get errors() {
        return this.control ? this.control.errors : null;
    }
    /**
     * @description
     * Reports whether the control is pristine, meaning that the user has not yet changed
     * the value in the UI. If the control is not present, null is returned.
     */
    get pristine() {
        return this.control ? this.control.pristine : null;
    }
    /**
     * @description
     * Reports whether the control is dirty, meaning that the user has changed
     * the value in the UI. If the control is not present, null is returned.
     */
    get dirty() {
        return this.control ? this.control.dirty : null;
    }
    /**
     * @description
     * Reports whether the control is touched, meaning that the user has triggered
     * a `blur` event on it. If the control is not present, null is returned.
     */
    get touched() {
        return this.control ? this.control.touched : null;
    }
    /**
     * @description
     * Reports the validation status of the control. Possible values include:
     * 'VALID', 'INVALID', 'DISABLED', and 'PENDING'.
     * If the control is not present, null is returned.
     */
    get status() {
        return this.control ? this.control.status : null;
    }
    /**
     * @description
     * Reports whether the control is untouched, meaning that the user has not yet triggered
     * a `blur` event on it. If the control is not present, null is returned.
     */
    get untouched() {
        return this.control ? this.control.untouched : null;
    }
    /**
     * @description
     * Returns a multicasting observable that emits a validation status whenever it is
     * calculated for the control. If the control is not present, null is returned.
     */
    get statusChanges() {
        return this.control ? this.control.statusChanges : null;
    }
    /**
     * @description
     * Returns a multicasting observable of value changes for the control that emits every time the
     * value of the control changes in the UI or programmatically.
     * If the control is not present, null is returned.
     */
    get valueChanges() {
        return this.control ? this.control.valueChanges : null;
    }
    /**
     * @description
     * Returns an array that represents the path from the top-level form to this control.
     * Each index is the string name of the control on that level.
     */
    get path() {
        return null;
    }
    /**
     * Sets synchronous validators for this directive.
     * @internal
     */
    _setValidators(validators) {
        this._rawValidators = validators || [];
        this._composedValidatorFn = composeValidators(this._rawValidators);
    }
    /**
     * Sets asynchronous validators for this directive.
     * @internal
     */
    _setAsyncValidators(validators) {
        this._rawAsyncValidators = validators || [];
        this._composedAsyncValidatorFn = composeAsyncValidators(this._rawAsyncValidators);
    }
    /**
     * @description
     * Synchronous validator function composed of all the synchronous validators registered with this
     * directive.
     */
    get validator() {
        return this._composedValidatorFn || null;
    }
    /**
     * @description
     * Asynchronous validator function composed of all the asynchronous validators registered with
     * this directive.
     */
    get asyncValidator() {
        return this._composedAsyncValidatorFn || null;
    }
    /**
     * Internal function to register callbacks that should be invoked
     * when directive instance is being destroyed.
     * @internal
     */
    _registerOnDestroy(fn) {
        this._onDestroyCallbacks.push(fn);
    }
    /**
     * Internal function to invoke all registered "on destroy" callbacks.
     * Note: calling this function also clears the list of callbacks.
     * @internal
     */
    _invokeOnDestroyCallbacks() {
        this._onDestroyCallbacks.forEach(fn => fn());
        this._onDestroyCallbacks = [];
    }
    /**
     * @description
     * Resets the control with the provided value if the control is present.
     */
    reset(value = undefined) {
        if (this.control)
            this.control.reset(value);
    }
    /**
     * @description
     * Reports whether the control with the given path has the error specified.
     *
     * @param errorCode The code of the error to check
     * @param path A list of control names that designates how to move from the current control
     * to the control that should be queried for errors.
     *
     * @usageNotes
     * For example, for the following `FormGroup`:
     *
     * ```
     * form = new FormGroup({
     *   address: new FormGroup({ street: new FormControl() })
     * });
     * ```
     *
     * The path to the 'street' control from the root form would be 'address' -> 'street'.
     *
     * It can be provided to this method in one of two formats:
     *
     * 1. An array of string control names, e.g. `['address', 'street']`
     * 1. A period-delimited list of control names in one string, e.g. `'address.street'`
     *
     * If no path is given, this method checks for the error on the current control.
     *
     * @returns whether the given error is present in the control at the given path.
     *
     * If the control is not present, false is returned.
     */
    hasError(errorCode, path) {
        return this.control ? this.control.hasError(errorCode, path) : false;
    }
    /**
     * @description
     * Reports error data for the control with the given path.
     *
     * @param errorCode The code of the error to check
     * @param path A list of control names that designates how to move from the current control
     * to the control that should be queried for errors.
     *
     * @usageNotes
     * For example, for the following `FormGroup`:
     *
     * ```
     * form = new FormGroup({
     *   address: new FormGroup({ street: new FormControl() })
     * });
     * ```
     *
     * The path to the 'street' control from the root form would be 'address' -> 'street'.
     *
     * It can be provided to this method in one of two formats:
     *
     * 1. An array of string control names, e.g. `['address', 'street']`
     * 1. A period-delimited list of control names in one string, e.g. `'address.street'`
     *
     * @returns error data for that particular error. If the control or error is not present,
     * null is returned.
     */
    getError(errorCode, path) {
        return this.control ? this.control.getError(errorCode, path) : null;
    }
}

/**
 * @description
 * A base class for directives that contain multiple registered instances of `NgControl`.
 * Only used by the forms module.
 *
 * @publicApi
 */
class ControlContainer extends AbstractControlDirective {
    /**
     * @description
     * The top-level form directive for the control.
     */
    get formDirective() {
        return null;
    }
    /**
     * @description
     * The path to this group.
     */
    get path() {
        return null;
    }
}

/**
 * @description
 * A base class that all `FormControl`-based directives extend. It binds a `FormControl`
 * object to a DOM element.
 *
 * @publicApi
 */
class NgControl extends AbstractControlDirective {
    constructor() {
        super(...arguments);
        /**
         * @description
         * The parent form for the control.
         *
         * @internal
         */
        this._parent = null;
        /**
         * @description
         * The name for the control
         */
        this.name = null;
        /**
         * @description
         * The value accessor for the control
         */
        this.valueAccessor = null;
    }
}

// DO NOT REFACTOR!
// Each status is represented by a separate function to make sure that
// advanced Closure Compiler optimizations related to property renaming
// can work correctly.
class AbstractControlStatus {
    constructor(cd) {
        this._cd = cd;
    }
    get isTouched() {
        return !!this._cd?.control?.touched;
    }
    get isUntouched() {
        return !!this._cd?.control?.untouched;
    }
    get isPristine() {
        return !!this._cd?.control?.pristine;
    }
    get isDirty() {
        return !!this._cd?.control?.dirty;
    }
    get isValid() {
        return !!this._cd?.control?.valid;
    }
    get isInvalid() {
        return !!this._cd?.control?.invalid;
    }
    get isPending() {
        return !!this._cd?.control?.pending;
    }
    get isSubmitted() {
        // We check for the `submitted` field from `NgForm` and `FormGroupDirective` classes, but
        // we avoid instanceof checks to prevent non-tree-shakable references to those types.
        return !!this._cd?.submitted;
    }
}
const ngControlStatusHost = {
    '[class.ng-untouched]': 'isUntouched',
    '[class.ng-touched]': 'isTouched',
    '[class.ng-pristine]': 'isPristine',
    '[class.ng-dirty]': 'isDirty',
    '[class.ng-valid]': 'isValid',
    '[class.ng-invalid]': 'isInvalid',
    '[class.ng-pending]': 'isPending',
};
const ngGroupStatusHost = {
    ...ngControlStatusHost,
    '[class.ng-submitted]': 'isSubmitted',
};
/**
 * @description
 * Directive automatically applied to Angular form controls that sets CSS classes
 * based on control status.
 *
 * @usageNotes
 *
 * ### CSS classes applied
 *
 * The following classes are applied as the properties become true:
 *
 * * ng-valid
 * * ng-invalid
 * * ng-pending
 * * ng-pristine
 * * ng-dirty
 * * ng-untouched
 * * ng-touched
 *
 * @ngModule ReactiveFormsModule
 * @ngModule FormsModule
 * @publicApi
 */
class NgControlStatus extends AbstractControlStatus {
    constructor(cd) {
        super(cd);
    }
    static { this.fac = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareFactory"]({ minVersion: "12.0.0", version: "17.3.12", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: NgControlStatus, deps: [{ token: NgControl, self: true }], target: _angular_core__WEBPACK_IMPORTED_MODULE_0__["FactoryTarget"].Directive }); }
    static { this.dir = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareDirective"]({ minVersion: "14.0.0", version: "17.3.12", type: NgControlStatus, selector: "[formControlName],[ngModel],[formControl]", host: { properties: { "class.ng-untouched": "isUntouched", "class.ng-touched": "isTouched", "class.ng-pristine": "isPristine", "class.ng-dirty": "isDirty", "class.ng-valid": "isValid", "class.ng-invalid": "isInvalid", "class.ng-pending": "isPending" } }, usesInheritance: true, ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))) }); }
}
_angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareClassMetadata"]({ minVersion: "12.0.0", version: "17.3.12", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: NgControlStatus, decorators: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Directive,
            args: [{ selector: '[formControlName],[ngModel],[formControl]', host: ngControlStatusHost }]
        }], ctorParameters: () => [{ type: NgControl, decorators: [{
                    type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Self
                }] }] });
/**
 * @description
 * Directive automatically applied to Angular form groups that sets CSS classes
 * based on control status (valid/invalid/dirty/etc). On groups, this includes the additional
 * class ng-submitted.
 *
 * @see {@link NgControlStatus}
 *
 * @ngModule ReactiveFormsModule
 * @ngModule FormsModule
 * @publicApi
 */
class NgControlStatusGroup extends AbstractControlStatus {
    constructor(cd) {
        super(cd);
    }
    static { this.fac = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareFactory"]({ minVersion: "12.0.0", version: "17.3.12", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: NgControlStatusGroup, deps: [{ token: ControlContainer, optional: true, self: true }], target: _angular_core__WEBPACK_IMPORTED_MODULE_0__["FactoryTarget"].Directive }); }
    static { this.dir = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareDirective"]({ minVersion: "14.0.0", version: "17.3.12", type: NgControlStatusGroup, selector: "[formGroupName],[formArrayName],[ngModelGroup],[formGroup],form:not([ngNoForm]),[ngForm]", host: { properties: { "class.ng-untouched": "isUntouched", "class.ng-touched": "isTouched", "class.ng-pristine": "isPristine", "class.ng-dirty": "isDirty", "class.ng-valid": "isValid", "class.ng-invalid": "isInvalid", "class.ng-pending": "isPending", "class.ng-submitted": "isSubmitted" } }, usesInheritance: true, ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))) }); }
}
_angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareClassMetadata"]({ minVersion: "12.0.0", version: "17.3.12", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: NgControlStatusGroup, decorators: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Directive,
            args: [{
                    selector: '[formGroupName],[formArrayName],[ngModelGroup],[formGroup],form:not([ngNoForm]),[ngForm]',
                    host: ngGroupStatusHost
                }]
        }], ctorParameters: () => [{ type: ControlContainer, decorators: [{
                    type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Optional
                }, {
                    type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Self
                }] }] });

const formControlNameExample = `
  <div [formGroup]="myGroup">
    <input formControlName="firstName">
  </div>

  In your class:

  this.myGroup = new FormGroup({
      firstName: new FormControl()
  });`;
const formGroupNameExample = `
  <div [formGroup]="myGroup">
      <div formGroupName="person">
        <input formControlName="firstName">
      </div>
  </div>

  In your class:

  this.myGroup = new FormGroup({
      person: new FormGroup({ firstName: new FormControl() })
  });`;
const formArrayNameExample = `
  <div [formGroup]="myGroup">
    <div formArrayName="cities">
      <div *ngFor="let city of cityArray.controls; index as i">
        <input [formControlName]="i">
      </div>
    </div>
  </div>

  In your class:

  this.cityArray = new FormArray([new FormControl('SF')]);
  this.myGroup = new FormGroup({
    cities: this.cityArray
  });`;
const ngModelGroupExample = `
  <form>
      <div ngModelGroup="person">
        <input [(ngModel)]="person.name" name="firstName">
      </div>
  </form>`;
const ngModelWithFormGroupExample = `
  <div [formGroup]="myGroup">
      <input formControlName="firstName">
      <input [(ngModel)]="showMoreControls" [ngModelOptions]="{standalone: true}">
  </div>
`;

function controlParentException() {
    return new _angular_core__WEBPACK_IMPORTED_MODULE_0__["RuntimeError"](1050 /* RuntimeErrorCode.FORM_CONTROL_NAME_MISSING_PARENT */, `formControlName must be used with a parent formGroup directive.  You'll want to add a formGroup
      directive and pass it an existing FormGroup instance (you can create one in your class).

    Example:

    ${formControlNameExample}`);
}
function ngModelGroupException() {
    return new _angular_core__WEBPACK_IMPORTED_MODULE_0__["RuntimeError"](1051 /* RuntimeErrorCode.FORM_CONTROL_NAME_INSIDE_MODEL_GROUP */, `formControlName cannot be used with an ngModelGroup parent. It is only compatible with parents
      that also have a "form" prefix: formGroupName, formArrayName, or formGroup.

      Option 1:  Update the parent to be formGroupName (reactive form strategy)

      ${formGroupNameExample}

      Option 2: Use ngModel instead of formControlName (template-driven strategy)

      ${ngModelGroupExample}`);
}
function missingFormException() {
    return new _angular_core__WEBPACK_IMPORTED_MODULE_0__["RuntimeError"](1052 /* RuntimeErrorCode.FORM_GROUP_MISSING_INSTANCE */, `formGroup expects a FormGroup instance. Please pass one in.

      Example:

      ${formControlNameExample}`);
}
function groupParentException() {
    return new _angular_core__WEBPACK_IMPORTED_MODULE_0__["RuntimeError"](1053 /* RuntimeErrorCode.FORM_GROUP_NAME_MISSING_PARENT */, `formGroupName must be used with a parent formGroup directive.  You'll want to add a formGroup
    directive and pass it an existing FormGroup instance (you can create one in your class).

    Example:

    ${formGroupNameExample}`);
}
function arrayParentException() {
    return new _angular_core__WEBPACK_IMPORTED_MODULE_0__["RuntimeError"](1054 /* RuntimeErrorCode.FORM_ARRAY_NAME_MISSING_PARENT */, `formArrayName must be used with a parent formGroup directive.  You'll want to add a formGroup
      directive and pass it an existing FormGroup instance (you can create one in your class).

      Example:

      ${formArrayNameExample}`);
}
const disabledAttrWarning = `
  It looks like you're using the disabled attribute with a reactive form directive. If you set disabled to true
  when you set up this control in your component class, the disabled attribute will actually be set in the DOM for
  you. We recommend using this approach to avoid 'changed after checked' errors.

  Example:
  // Specify the \`disabled\` property at control creation time:
  form = new FormGroup({
    first: new FormControl({value: 'Nancy', disabled: true}, Validators.required),
    last: new FormControl('Drew', Validators.required)
  });

  // Controls can also be enabled/disabled after creation:
  form.get('first')?.enable();
  form.get('last')?.disable();
`;
const asyncValidatorsDroppedWithOptsWarning = `
  It looks like you're constructing using a FormControl with both an options argument and an
  async validators argument. Mixing these arguments will cause your async validators to be dropped.
  You should either put all your validators in the options object, or in separate validators
  arguments. For example:

  // Using validators arguments
  fc = new FormControl(42, Validators.required, myAsyncValidator);

  // Using AbstractControlOptions
  fc = new FormControl(42, {validators: Validators.required, asyncValidators: myAV});

  // Do NOT mix them: async validators will be dropped!
  fc = new FormControl(42, {validators: Validators.required}, /* Oops! */ myAsyncValidator);
`;
function ngModelWarning(directiveName) {
    return `
  It looks like you're using ngModel on the same form field as ${directiveName}.
  Support for using the ngModel input property and ngModelChange event with
  reactive form directives has been deprecated in Angular v6 and will be removed
  in a future version of Angular.

  For more information on this, see our API docs here:
  https://angular.io/api/forms/${directiveName === 'formControl' ? 'FormControlDirective' : 'FormControlName'}#use-with-ngmodel
  `;
}
function describeKey(isFormGroup, key) {
    return isFormGroup ? `with name: '${key}'` : `at index: ${key}`;
}
function noControlsError(isFormGroup) {
    return `
    There are no form controls registered with this ${isFormGroup ? 'group' : 'array'} yet. If you're using ngModel,
    you may want to check next tick (e.g. use setTimeout).
  `;
}
function missingControlError(isFormGroup, key) {
    return `Cannot find form control ${describeKey(isFormGroup, key)}`;
}
function missingControlValueError(isFormGroup, key) {
    return `Must supply a value for form control ${describeKey(isFormGroup, key)}`;
}

/**
 * Reports that a control is valid, meaning that no errors exist in the input value.
 *
 * @see {@link status}
 */
const VALID = 'VALID';
/**
 * Reports that a control is invalid, meaning that an error exists in the input value.
 *
 * @see {@link status}
 */
const INVALID = 'INVALID';
/**
 * Reports that a control is pending, meaning that async validation is occurring and
 * errors are not yet available for the input value.
 *
 * @see {@link markAsPending}
 * @see {@link status}
 */
const PENDING = 'PENDING';
/**
 * Reports that a control is disabled, meaning that the control is exempt from ancestor
 * calculations of validity or value.
 *
 * @see {@link markAsDisabled}
 * @see {@link status}
 */
const DISABLED = 'DISABLED';
/**
 * Gets validators from either an options object or given validators.
 */
function pickValidators(validatorOrOpts) {
    return (isOptionsObj(validatorOrOpts) ? validatorOrOpts.validators : validatorOrOpts) || null;
}
/**
 * Creates validator function by combining provided validators.
 */
function coerceToValidator(validator) {
    return Array.isArray(validator) ? composeValidators(validator) : validator || null;
}
/**
 * Gets async validators from either an options object or given validators.
 */
function pickAsyncValidators(asyncValidator, validatorOrOpts) {
    if (typeof ngDevMode === 'undefined' || ngDevMode) {
        if (isOptionsObj(validatorOrOpts) && asyncValidator) {
            console.warn(asyncValidatorsDroppedWithOptsWarning);
        }
    }
    return (isOptionsObj(validatorOrOpts) ? validatorOrOpts.asyncValidators : asyncValidator) || null;
}
/**
 * Creates async validator function by combining provided async validators.
 */
function coerceToAsyncValidator(asyncValidator) {
    return Array.isArray(asyncValidator) ? composeAsyncValidators(asyncValidator) :
        asyncValidator || null;
}
function isOptionsObj(validatorOrOpts) {
    return validatorOrOpts != null && !Array.isArray(validatorOrOpts) &&
        typeof validatorOrOpts === 'object';
}
function assertControlPresent(parent, isGroup, key) {
    const controls = parent.controls;
    const collection = isGroup ? Object.keys(controls) : controls;
    if (!collection.length) {
        throw new _angular_core__WEBPACK_IMPORTED_MODULE_0__["RuntimeError"](1000 /* RuntimeErrorCode.NO_CONTROLS */, (typeof ngDevMode === 'undefined' || ngDevMode) ? noControlsError(isGroup) : '');
    }
    if (!controls[key]) {
        throw new _angular_core__WEBPACK_IMPORTED_MODULE_0__["RuntimeError"](1001 /* RuntimeErrorCode.MISSING_CONTROL */, (typeof ngDevMode === 'undefined' || ngDevMode) ? missingControlError(isGroup, key) : '');
    }
}
function assertAllValuesPresent(control, isGroup, value) {
    control._forEachChild((_, key) => {
        if (value[key] === undefined) {
            throw new _angular_core__WEBPACK_IMPORTED_MODULE_0__["RuntimeError"](1002 /* RuntimeErrorCode.MISSING_CONTROL_VALUE */, (typeof ngDevMode === 'undefined' || ngDevMode) ? missingControlValueError(isGroup, key) :
                '');
        }
    });
}
// clang-format on
/**
 * This is the base class for `FormControl`, `FormGroup`, and `FormArray`.
 *
 * It provides some of the shared behavior that all controls and groups of controls have, like
 * running validators, calculating status, and resetting state. It also defines the properties
 * that are shared between all sub-classes, like `value`, `valid`, and `dirty`. It shouldn't be
 * instantiated directly.
 *
 * The first type parameter TValue represents the value type of the control (`control.value`).
 * The optional type parameter TRawValue  represents the raw value type (`control.getRawValue()`).
 *
 * @see [Forms Guide](/guide/forms)
 * @see [Reactive Forms Guide](/guide/reactive-forms)
 * @see [Dynamic Forms Guide](/guide/dynamic-form)
 *
 * @publicApi
 */
class AbstractControl {
    /**
     * Initialize the AbstractControl instance.
     *
     * @param validators The function or array of functions that is used to determine the validity of
     *     this control synchronously.
     * @param asyncValidators The function or array of functions that is used to determine validity of
     *     this control asynchronously.
     */
    constructor(validators, asyncValidators) {
        /** @internal */
        this._pendingDirty = false;
        /**
         * Indicates that a control has its own pending asynchronous validation in progress.
         *
         * @internal
         */
        this._hasOwnPendingAsyncValidator = false;
        /** @internal */
        this._pendingTouched = false;
        /** @internal */
        this._onCollectionChange = () => { };
        this._parent = null;
        /**
         * A control is `pristine` if the user has not yet changed
         * the value in the UI.
         *
         * @returns True if the user has not yet changed the value in the UI; compare `dirty`.
         * Programmatic changes to a control's value do not mark it dirty.
         */
        this.pristine = true;
        /**
         * True if the control is marked as `touched`.
         *
         * A control is marked `touched` once the user has triggered
         * a `blur` event on it.
         */
        this.touched = false;
        /** @internal */
        this._onDisabledChange = [];
        this._assignValidators(validators);
        this._assignAsyncValidators(asyncValidators);
    }
    /**
     * Returns the function that is used to determine the validity of this control synchronously.
     * If multiple validators have been added, this will be a single composed function.
     * See `Validators.compose()` for additional information.
     */
    get validator() {
        return this._composedValidatorFn;
    }
    set validator(validatorFn) {
        this._rawValidators = this._composedValidatorFn = validatorFn;
    }
    /**
     * Returns the function that is used to determine the validity of this control asynchronously.
     * If multiple validators have been added, this will be a single composed function.
     * See `Validators.compose()` for additional information.
     */
    get asyncValidator() {
        return this._composedAsyncValidatorFn;
    }
    set asyncValidator(asyncValidatorFn) {
        this._rawAsyncValidators = this._composedAsyncValidatorFn = asyncValidatorFn;
    }
    /**
     * The parent control.
     */
    get parent() {
        return this._parent;
    }
    /**
     * A control is `valid` when its `status` is `VALID`.
     *
     * @see {@link AbstractControl.status}
     *
     * @returns True if the control has passed all of its validation tests,
     * false otherwise.
     */
    get valid() {
        return this.status === VALID;
    }
    /**
     * A control is `invalid` when its `status` is `INVALID`.
     *
     * @see {@link AbstractControl.status}
     *
     * @returns True if this control has failed one or more of its validation checks,
     * false otherwise.
     */
    get invalid() {
        return this.status === INVALID;
    }
    /**
     * A control is `pending` when its `status` is `PENDING`.
     *
     * @see {@link AbstractControl.status}
     *
     * @returns True if this control is in the process of conducting a validation check,
     * false otherwise.
     */
    get pending() {
        return this.status == PENDING;
    }
    /**
     * A control is `disabled` when its `status` is `DISABLED`.
     *
     * Disabled controls are exempt from validation checks and
     * are not included in the aggregate value of their ancestor
     * controls.
     *
     * @see {@link AbstractControl.status}
     *
     * @returns True if the control is disabled, false otherwise.
     */
    get disabled() {
        return this.status === DISABLED;
    }
    /**
     * A control is `enabled` as long as its `status` is not `DISABLED`.
     *
     * @returns True if the control has any status other than 'DISABLED',
     * false if the status is 'DISABLED'.
     *
     * @see {@link AbstractControl.status}
     *
     */
    get enabled() {
        return this.status !== DISABLED;
    }
    /**
     * A control is `dirty` if the user has changed the value
     * in the UI.
     *
     * @returns True if the user has changed the value of this control in the UI; compare `pristine`.
     * Programmatic changes to a control's value do not mark it dirty.
     */
    get dirty() {
        return !this.pristine;
    }
    /**
     * True if the control has not been marked as touched
     *
     * A control is `untouched` if the user has not yet triggered
     * a `blur` event on it.
     */
    get untouched() {
        return !this.touched;
    }
    /**
     * Reports the update strategy of the `AbstractControl` (meaning
     * the event on which the control updates itself).
     * Possible values: `'change'` | `'blur'` | `'submit'`
     * Default value: `'change'`
     */
    get updateOn() {
        return this._updateOn ? this._updateOn : (this.parent ? this.parent.updateOn : 'change');
    }
    /**
     * Sets the synchronous validators that are active on this control.  Calling
     * this overwrites any existing synchronous validators.
     *
     * When you add or remove a validator at run time, you must call
     * `updateValueAndValidity()` for the new validation to take effect.
     *
     * If you want to add a new validator without affecting existing ones, consider
     * using `addValidators()` method instead.
     */
    setValidators(validators) {
        this._assignValidators(validators);
    }
    /**
     * Sets the asynchronous validators that are active on this control. Calling this
     * overwrites any existing asynchronous validators.
     *
     * When you add or remove a validator at run time, you must call
     * `updateValueAndValidity()` for the new validation to take effect.
     *
     * If you want to add a new validator without affecting existing ones, consider
     * using `addAsyncValidators()` method instead.
     */
    setAsyncValidators(validators) {
        this._assignAsyncValidators(validators);
    }
    /**
     * Add a synchronous validator or validators to this control, without affecting other validators.
     *
     * When you add or remove a validator at run time, you must call
     * `updateValueAndValidity()` for the new validation to take effect.
     *
     * Adding a validator that already exists will have no effect. If duplicate validator functions
     * are present in the `validators` array, only the first instance would be added to a form
     * control.
     *
     * @param validators The new validator function or functions to add to this control.
     */
    addValidators(validators) {
        this.setValidators(addValidators(validators, this._rawValidators));
    }
    /**
     * Add an asynchronous validator or validators to this control, without affecting other
     * validators.
     *
     * When you add or remove a validator at run time, you must call
     * `updateValueAndValidity()` for the new validation to take effect.
     *
     * Adding a validator that already exists will have no effect.
     *
     * @param validators The new asynchronous validator function or functions to add to this control.
     */
    addAsyncValidators(validators) {
        this.setAsyncValidators(addValidators(validators, this._rawAsyncValidators));
    }
    /**
     * Remove a synchronous validator from this control, without affecting other validators.
     * Validators are compared by function reference; you must pass a reference to the exact same
     * validator function as the one that was originally set. If a provided validator is not found,
     * it is ignored.
     *
     * @usageNotes
     *
     * ### Reference to a ValidatorFn
     *
     * ```
     * // Reference to the RequiredValidator
     * const ctrl = new FormControl<string | null>('', Validators.required);
     * ctrl.removeValidators(Validators.required);
     *
     * // Reference to anonymous function inside MinValidator
     * const minValidator = Validators.min(3);
     * const ctrl = new FormControl<string | null>('', minValidator);
     * expect(ctrl.hasValidator(minValidator)).toEqual(true)
     * expect(ctrl.hasValidator(Validators.min(3))).toEqual(false)
     *
     * ctrl.removeValidators(minValidator);
     * ```
     *
     * When you add or remove a validator at run time, you must call
     * `updateValueAndValidity()` for the new validation to take effect.
     *
     * @param validators The validator or validators to remove.
     */
    removeValidators(validators) {
        this.setValidators(removeValidators(validators, this._rawValidators));
    }
    /**
     * Remove an asynchronous validator from this control, without affecting other validators.
     * Validators are compared by function reference; you must pass a reference to the exact same
     * validator function as the one that was originally set. If a provided validator is not found, it
     * is ignored.
     *
     * When you add or remove a validator at run time, you must call
     * `updateValueAndValidity()` for the new validation to take effect.
     *
     * @param validators The asynchronous validator or validators to remove.
     */
    removeAsyncValidators(validators) {
        this.setAsyncValidators(removeValidators(validators, this._rawAsyncValidators));
    }
    /**
     * Check whether a synchronous validator function is present on this control. The provided
     * validator must be a reference to the exact same function that was provided.
     *
     * @usageNotes
     *
     * ### Reference to a ValidatorFn
     *
     * ```
     * // Reference to the RequiredValidator
     * const ctrl = new FormControl<number | null>(0, Validators.required);
     * expect(ctrl.hasValidator(Validators.required)).toEqual(true)
     *
     * // Reference to anonymous function inside MinValidator
     * const minValidator = Validators.min(3);
     * const ctrl = new FormControl<number | null>(0, minValidator);
     * expect(ctrl.hasValidator(minValidator)).toEqual(true)
     * expect(ctrl.hasValidator(Validators.min(3))).toEqual(false)
     * ```
     *
     * @param validator The validator to check for presence. Compared by function reference.
     * @returns Whether the provided validator was found on this control.
     */
    hasValidator(validator) {
        return hasValidator(this._rawValidators, validator);
    }
    /**
     * Check whether an asynchronous validator function is present on this control. The provided
     * validator must be a reference to the exact same function that was provided.
     *
     * @param validator The asynchronous validator to check for presence. Compared by function
     *     reference.
     * @returns Whether the provided asynchronous validator was found on this control.
     */
    hasAsyncValidator(validator) {
        return hasValidator(this._rawAsyncValidators, validator);
    }
    /**
     * Empties out the synchronous validator list.
     *
     * When you add or remove a validator at run time, you must call
     * `updateValueAndValidity()` for the new validation to take effect.
     *
     */
    clearValidators() {
        this.validator = null;
    }
    /**
     * Empties out the async validator list.
     *
     * When you add or remove a validator at run time, you must call
     * `updateValueAndValidity()` for the new validation to take effect.
     *
     */
    clearAsyncValidators() {
        this.asyncValidator = null;
    }
    /**
     * Marks the control as `touched`. A control is touched by focus and
     * blur events that do not change the value.
     *
     * @see {@link markAsUntouched()}
     * @see {@link markAsDirty()}
     * @see {@link markAsPristine()}
     *
     * @param opts Configuration options that determine how the control propagates changes
     * and emits events after marking is applied.
     * * `onlySelf`: When true, mark only this control. When false or not supplied,
     * marks all direct ancestors. Default is false.
     */
    markAsTouched(opts = {}) {
        this.touched = true;
        if (this._parent && !opts.onlySelf) {
            this._parent.markAsTouched(opts);
        }
    }
    /**
     * Marks the control and all its descendant controls as `touched`.
     * @see {@link markAsTouched()}
     */
    markAllAsTouched() {
        this.markAsTouched({ onlySelf: true });
        this._forEachChild((control) => control.markAllAsTouched());
    }
    /**
     * Marks the control as `untouched`.
     *
     * If the control has any children, also marks all children as `untouched`
     * and recalculates the `touched` status of all parent controls.
     *
     * @see {@link markAsTouched()}
     * @see {@link markAsDirty()}
     * @see {@link markAsPristine()}
     *
     * @param opts Configuration options that determine how the control propagates changes
     * and emits events after the marking is applied.
     * * `onlySelf`: When true, mark only this control. When false or not supplied,
     * marks all direct ancestors. Default is false.
     */
    markAsUntouched(opts = {}) {
        this.touched = false;
        this._pendingTouched = false;
        this._forEachChild((control) => {
            control.markAsUntouched({ onlySelf: true });
        });
        if (this._parent && !opts.onlySelf) {
            this._parent._updateTouched(opts);
        }
    }
    /**
     * Marks the control as `dirty`. A control becomes dirty when
     * the control's value is changed through the UI; compare `markAsTouched`.
     *
     * @see {@link markAsTouched()}
     * @see {@link markAsUntouched()}
     * @see {@link markAsPristine()}
     *
     * @param opts Configuration options that determine how the control propagates changes
     * and emits events after marking is applied.
     * * `onlySelf`: When true, mark only this control. When false or not supplied,
     * marks all direct ancestors. Default is false.
     */
    markAsDirty(opts = {}) {
        this.pristine = false;
        if (this._parent && !opts.onlySelf) {
            this._parent.markAsDirty(opts);
        }
    }
    /**
     * Marks the control as `pristine`.
     *
     * If the control has any children, marks all children as `pristine`,
     * and recalculates the `pristine` status of all parent
     * controls.
     *
     * @see {@link markAsTouched()}
     * @see {@link markAsUntouched()}
     * @see {@link markAsDirty()}
     *
     * @param opts Configuration options that determine how the control emits events after
     * marking is applied.
     * * `onlySelf`: When true, mark only this control. When false or not supplied,
     * marks all direct ancestors. Default is false.
     */
    markAsPristine(opts = {}) {
        this.pristine = true;
        this._pendingDirty = false;
        this._forEachChild((control) => {
            control.markAsPristine({ onlySelf: true });
        });
        if (this._parent && !opts.onlySelf) {
            this._parent._updatePristine(opts);
        }
    }
    /**
     * Marks the control as `pending`.
     *
     * A control is pending while the control performs async validation.
     *
     * @see {@link AbstractControl.status}
     *
     * @param opts Configuration options that determine how the control propagates changes and
     * emits events after marking is applied.
     * * `onlySelf`: When true, mark only this control. When false or not supplied,
     * marks all direct ancestors. Default is false.
     * * `emitEvent`: When true or not supplied (the default), the `statusChanges`
     * observable emits an event with the latest status the control is marked pending.
     * When false, no events are emitted.
     *
     */
    markAsPending(opts = {}) {
        this.status = PENDING;
        if (opts.emitEvent !== false) {
            this.statusChanges.emit(this.status);
        }
        if (this._parent && !opts.onlySelf) {
            this._parent.markAsPending(opts);
        }
    }
    /**
     * Disables the control. This means the control is exempt from validation checks and
     * excluded from the aggregate value of any parent. Its status is `DISABLED`.
     *
     * If the control has children, all children are also disabled.
     *
     * @see {@link AbstractControl.status}
     *
     * @param opts Configuration options that determine how the control propagates
     * changes and emits events after the control is disabled.
     * * `onlySelf`: When true, mark only this control. When false or not supplied,
     * marks all direct ancestors. Default is false.
     * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and
     * `valueChanges`
     * observables emit events with the latest status and value when the control is disabled.
     * When false, no events are emitted.
     */
    disable(opts = {}) {
        // If parent has been marked artificially dirty we don't want to re-calculate the
        // parent's dirtiness based on the children.
        const skipPristineCheck = this._parentMarkedDirty(opts.onlySelf);
        this.status = DISABLED;
        this.errors = null;
        this._forEachChild((control) => {
            control.disable({ ...opts, onlySelf: true });
        });
        this._updateValue();
        if (opts.emitEvent !== false) {
            this.valueChanges.emit(this.value);
            this.statusChanges.emit(this.status);
        }
        this._updateAncestors({ ...opts, skipPristineCheck });
        this._onDisabledChange.forEach((changeFn) => changeFn(true));
    }
    /**
     * Enables the control. This means the control is included in validation checks and
     * the aggregate value of its parent. Its status recalculates based on its value and
     * its validators.
     *
     * By default, if the control has children, all children are enabled.
     *
     * @see {@link AbstractControl.status}
     *
     * @param opts Configure options that control how the control propagates changes and
     * emits events when marked as untouched
     * * `onlySelf`: When true, mark only this control. When false or not supplied,
     * marks all direct ancestors. Default is false.
     * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and
     * `valueChanges`
     * observables emit events with the latest status and value when the control is enabled.
     * When false, no events are emitted.
     */
    enable(opts = {}) {
        // If parent has been marked artificially dirty we don't want to re-calculate the
        // parent's dirtiness based on the children.
        const skipPristineCheck = this._parentMarkedDirty(opts.onlySelf);
        this.status = VALID;
        this._forEachChild((control) => {
            control.enable({ ...opts, onlySelf: true });
        });
        this.updateValueAndValidity({ onlySelf: true, emitEvent: opts.emitEvent });
        this._updateAncestors({ ...opts, skipPristineCheck });
        this._onDisabledChange.forEach((changeFn) => changeFn(false));
    }
    _updateAncestors(opts) {
        if (this._parent && !opts.onlySelf) {
            this._parent.updateValueAndValidity(opts);
            if (!opts.skipPristineCheck) {
                this._parent._updatePristine();
            }
            this._parent._updateTouched();
        }
    }
    /**
     * Sets the parent of the control
     *
     * @param parent The new parent.
     */
    setParent(parent) {
        this._parent = parent;
    }
    /**
     * The raw value of this control. For most control implementations, the raw value will include
     * disabled children.
     */
    getRawValue() {
        return this.value;
    }
    /**
     * Recalculates the value and validation status of the control.
     *
     * By default, it also updates the value and validity of its ancestors.
     *
     * @param opts Configuration options determine how the control propagates changes and emits events
     * after updates and validity checks are applied.
     * * `onlySelf`: When true, only update this control. When false or not supplied,
     * update all direct ancestors. Default is false.
     * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and
     * `valueChanges`
     * observables emit events with the latest status and value when the control is updated.
     * When false, no events are emitted.
     */
    updateValueAndValidity(opts = {}) {
        this._setInitialStatus();
        this._updateValue();
        if (this.enabled) {
            this._cancelExistingSubscription();
            this.errors = this._runValidator();
            this.status = this._calculateStatus();
            if (this.status === VALID || this.status === PENDING) {
                this._runAsyncValidator(opts.emitEvent);
            }
        }
        if (opts.emitEvent !== false) {
            this.valueChanges.emit(this.value);
            this.statusChanges.emit(this.status);
        }
        if (this._parent && !opts.onlySelf) {
            this._parent.updateValueAndValidity(opts);
        }
    }
    /** @internal */
    _updateTreeValidity(opts = { emitEvent: true }) {
        this._forEachChild((ctrl) => ctrl._updateTreeValidity(opts));
        this.updateValueAndValidity({ onlySelf: true, emitEvent: opts.emitEvent });
    }
    _setInitialStatus() {
        this.status = this._allControlsDisabled() ? DISABLED : VALID;
    }
    _runValidator() {
        return this.validator ? this.validator(this) : null;
    }
    _runAsyncValidator(emitEvent) {
        if (this.asyncValidator) {
            this.status = PENDING;
            this._hasOwnPendingAsyncValidator = true;
            const obs = toObservable(this.asyncValidator(this));
            this._asyncValidationSubscription = obs.subscribe((errors) => {
                this._hasOwnPendingAsyncValidator = false;
                // This will trigger the recalculation of the validation status, which depends on
                // the state of the asynchronous validation (whether it is in progress or not). So, it is
                // necessary that we have updated the `_hasOwnPendingAsyncValidator` boolean flag first.
                this.setErrors(errors, { emitEvent });
            });
        }
    }
    _cancelExistingSubscription() {
        if (this._asyncValidationSubscription) {
            this._asyncValidationSubscription.unsubscribe();
            this._hasOwnPendingAsyncValidator = false;
        }
    }
    /**
     * Sets errors on a form control when running validations manually, rather than automatically.
     *
     * Calling `setErrors` also updates the validity of the parent control.
     *
     * @param opts Configuration options that determine how the control propagates
     * changes and emits events after the control errors are set.
     * * `emitEvent`: When true or not supplied (the default), the `statusChanges`
     * observable emits an event after the errors are set.
     *
     * @usageNotes
     *
     * ### Manually set the errors for a control
     *
     * ```
     * const login = new FormControl('someLogin');
     * login.setErrors({
     *   notUnique: true
     * });
     *
     * expect(login.valid).toEqual(false);
     * expect(login.errors).toEqual({ notUnique: true });
     *
     * login.setValue('someOtherLogin');
     *
     * expect(login.valid).toEqual(true);
     * ```
     */
    setErrors(errors, opts = {}) {
        this.errors = errors;
        this._updateControlsErrors(opts.emitEvent !== false);
    }
    /**
     * Retrieves a child control given the control's name or path.
     *
     * @param path A dot-delimited string or array of string/number values that define the path to the
     * control. If a string is provided, passing it as a string literal will result in improved type
     * information. Likewise, if an array is provided, passing it `as const` will cause improved type
     * information to be available.
     *
     * @usageNotes
     * ### Retrieve a nested control
     *
     * For example, to get a `name` control nested within a `person` sub-group:
     *
     * * `this.form.get('person.name');`
     *
     * -OR-
     *
     * * `this.form.get(['person', 'name'] as const);` // `as const` gives improved typings
     *
     * ### Retrieve a control in a FormArray
     *
     * When accessing an element inside a FormArray, you can use an element index.
     * For example, to get a `price` control from the first element in an `items` array you can use:
     *
     * * `this.form.get('items.0.price');`
     *
     * -OR-
     *
     * * `this.form.get(['items', 0, 'price']);`
     */
    get(path) {
        let currPath = path;
        if (currPath == null)
            return null;
        if (!Array.isArray(currPath))
            currPath = currPath.split('.');
        if (currPath.length === 0)
            return null;
        return currPath.reduce((control, name) => control && control._find(name), this);
    }
    /**
     * @description
     * Reports error data for the control with the given path.
     *
     * @param errorCode The code of the error to check
     * @param path A list of control names that designates how to move from the current control
     * to the control that should be queried for errors.
     *
     * @usageNotes
     * For example, for the following `FormGroup`:
     *
     * ```
     * form = new FormGroup({
     *   address: new FormGroup({ street: new FormControl() })
     * });
     * ```
     *
     * The path to the 'street' control from the root form would be 'address' -> 'street'.
     *
     * It can be provided to this method in one of two formats:
     *
     * 1. An array of string control names, e.g. `['address', 'street']`
     * 1. A period-delimited list of control names in one string, e.g. `'address.street'`
     *
     * @returns error data for that particular error. If the control or error is not present,
     * null is returned.
     */
    getError(errorCode, path) {
        const control = path ? this.get(path) : this;
        return control && control.errors ? control.errors[errorCode] : null;
    }
    /**
     * @description
     * Reports whether the control with the given path has the error specified.
     *
     * @param errorCode The code of the error to check
     * @param path A list of control names that designates how to move from the current control
     * to the control that should be queried for errors.
     *
     * @usageNotes
     * For example, for the following `FormGroup`:
     *
     * ```
     * form = new FormGroup({
     *   address: new FormGroup({ street: new FormControl() })
     * });
     * ```
     *
     * The path to the 'street' control from the root form would be 'address' -> 'street'.
     *
     * It can be provided to this method in one of two formats:
     *
     * 1. An array of string control names, e.g. `['address', 'street']`
     * 1. A period-delimited list of control names in one string, e.g. `'address.street'`
     *
     * If no path is given, this method checks for the error on the current control.
     *
     * @returns whether the given error is present in the control at the given path.
     *
     * If the control is not present, false is returned.
     */
    hasError(errorCode, path) {
        return !!this.getError(errorCode, path);
    }
    /**
     * Retrieves the top-level ancestor of this control.
     */
    get root() {
        let x = this;
        while (x._parent) {
            x = x._parent;
        }
        return x;
    }
    /** @internal */
    _updateControlsErrors(emitEvent) {
        this.status = this._calculateStatus();
        if (emitEvent) {
            this.statusChanges.emit(this.status);
        }
        if (this._parent) {
            this._parent._updateControlsErrors(emitEvent);
        }
    }
    /** @internal */
    _initObservables() {
        this.valueChanges = new _angular_core__WEBPACK_IMPORTED_MODULE_0__.EventEmitter();
        this.statusChanges = new _angular_core__WEBPACK_IMPORTED_MODULE_0__.EventEmitter();
    }
    _calculateStatus() {
        if (this._allControlsDisabled())
            return DISABLED;
        if (this.errors)
            return INVALID;
        if (this._hasOwnPendingAsyncValidator || this._anyControlsHaveStatus(PENDING))
            return PENDING;
        if (this._anyControlsHaveStatus(INVALID))
            return INVALID;
        return VALID;
    }
    /** @internal */
    _anyControlsHaveStatus(status) {
        return this._anyControls((control) => control.status === status);
    }
    /** @internal */
    _anyControlsDirty() {
        return this._anyControls((control) => control.dirty);
    }
    /** @internal */
    _anyControlsTouched() {
        return this._anyControls((control) => control.touched);
    }
    /** @internal */
    _updatePristine(opts = {}) {
        this.pristine = !this._anyControlsDirty();
        if (this._parent && !opts.onlySelf) {
            this._parent._updatePristine(opts);
        }
    }
    /** @internal */
    _updateTouched(opts = {}) {
        this.touched = this._anyControlsTouched();
        if (this._parent && !opts.onlySelf) {
            this._parent._updateTouched(opts);
        }
    }
    /** @internal */
    _registerOnCollectionChange(fn) {
        this._onCollectionChange = fn;
    }
    /** @internal */
    _setUpdateStrategy(opts) {
        if (isOptionsObj(opts) && opts.updateOn != null) {
            this._updateOn = opts.updateOn;
        }
    }
    /**
     * Check to see if parent has been marked artificially dirty.
     *
     * @internal
     */
    _parentMarkedDirty(onlySelf) {
        const parentDirty = this._parent && this._parent.dirty;
        return !onlySelf && !!parentDirty && !this._parent._anyControlsDirty();
    }
    /** @internal */
    _find(name) {
        return null;
    }
    /**
     * Internal implementation of the `setValidators` method. Needs to be separated out into a
     * different method, because it is called in the constructor and it can break cases where
     * a control is extended.
     */
    _assignValidators(validators) {
        this._rawValidators = Array.isArray(validators) ? validators.slice() : validators;
        this._composedValidatorFn = coerceToValidator(this._rawValidators);
    }
    /**
     * Internal implementation of the `setAsyncValidators` method. Needs to be separated out into a
     * different method, because it is called in the constructor and it can break cases where
     * a control is extended.
     */
    _assignAsyncValidators(validators) {
        this._rawAsyncValidators = Array.isArray(validators) ? validators.slice() : validators;
        this._composedAsyncValidatorFn = coerceToAsyncValidator(this._rawAsyncValidators);
    }
}

/**
 * Tracks the value and validity state of a group of `FormControl` instances.
 *
 * A `FormGroup` aggregates the values of each child `FormControl` into one object,
 * with each control name as the key.  It calculates its status by reducing the status values
 * of its children. For example, if one of the controls in a group is invalid, the entire
 * group becomes invalid.
 *
 * `FormGroup` is one of the four fundamental building blocks used to define forms in Angular,
 * along with `FormControl`, `FormArray`, and `FormRecord`.
 *
 * When instantiating a `FormGroup`, pass in a collection of child controls as the first
 * argument. The key for each child registers the name for the control.
 *
 * `FormGroup` is intended for use cases where the keys are known ahead of time.
 * If you need to dynamically add and remove controls, use {@link FormRecord} instead.
 *
 * `FormGroup` accepts an optional type parameter `TControl`, which is an object type with inner
 * control types as values.
 *
 * @usageNotes
 *
 * ### Create a form group with 2 controls
 *
 * ```
 * const form = new FormGroup({
 *   first: new FormControl('Nancy', Validators.minLength(2)),
 *   last: new FormControl('Drew'),
 * });
 *
 * console.log(form.value);   // {first: 'Nancy', last; 'Drew'}
 * console.log(form.status);  // 'VALID'
 * ```
 *
 * ### The type argument, and optional controls
 *
 * `FormGroup` accepts one generic argument, which is an object containing its inner controls.
 * This type will usually be inferred automatically, but you can always specify it explicitly if you
 * wish.
 *
 * If you have controls that are optional (i.e. they can be removed, you can use the `?` in the
 * type):
 *
 * ```
 * const form = new FormGroup<{
 *   first: FormControl<string|null>,
 *   middle?: FormControl<string|null>, // Middle name is optional.
 *   last: FormControl<string|null>,
 * }>({
 *   first: new FormControl('Nancy'),
 *   last: new FormControl('Drew'),
 * });
 * ```
 *
 * ### Create a form group with a group-level validator
 *
 * You include group-level validators as the second arg, or group-level async
 * validators as the third arg. These come in handy when you want to perform validation
 * that considers the value of more than one child control.
 *
 * ```
 * const form = new FormGroup({
 *   password: new FormControl('', Validators.minLength(2)),
 *   passwordConfirm: new FormControl('', Validators.minLength(2)),
 * }, passwordMatchValidator);
 *
 *
 * function passwordMatchValidator(g: FormGroup) {
 *    return g.get('password').value === g.get('passwordConfirm').value
 *       ? null : {'mismatch': true};
 * }
 * ```
 *
 * Like `FormControl` instances, you choose to pass in
 * validators and async validators as part of an options object.
 *
 * ```
 * const form = new FormGroup({
 *   password: new FormControl('')
 *   passwordConfirm: new FormControl('')
 * }, { validators: passwordMatchValidator, asyncValidators: otherValidator });
 * ```
 *
 * ### Set the updateOn property for all controls in a form group
 *
 * The options object is used to set a default value for each child
 * control's `updateOn` property. If you set `updateOn` to `'blur'` at the
 * group level, all child controls default to 'blur', unless the child
 * has explicitly specified a different `updateOn` value.
 *
 * ```ts
 * const c = new FormGroup({
 *   one: new FormControl()
 * }, { updateOn: 'blur' });
 * ```
 *
 * ### Using a FormGroup with optional controls
 *
 * It is possible to have optional controls in a FormGroup. An optional control can be removed later
 * using `removeControl`, and can be omitted when calling `reset`. Optional controls must be
 * declared optional in the group's type.
 *
 * ```ts
 * const c = new FormGroup<{one?: FormControl<string>}>({
 *   one: new FormControl('')
 * });
 * ```
 *
 * Notice that `c.value.one` has type `string|null|undefined`. This is because calling `c.reset({})`
 * without providing the optional key `one` will cause it to become `null`.
 *
 * @publicApi
 */
class FormGroup extends AbstractControl {
    /**
     * Creates a new `FormGroup` instance.
     *
     * @param controls A collection of child controls. The key for each child is the name
     * under which it is registered.
     *
     * @param validatorOrOpts A synchronous validator function, or an array of
     * such functions, or an `AbstractControlOptions` object that contains validation functions
     * and a validation trigger.
     *
     * @param asyncValidator A single async validator or array of async validator functions
     *
     */
    constructor(controls, validatorOrOpts, asyncValidator) {
        super(pickValidators(validatorOrOpts), pickAsyncValidators(asyncValidator, validatorOrOpts));
        (typeof ngDevMode === 'undefined' || ngDevMode) && validateFormGroupControls(controls);
        this.controls = controls;
        this._initObservables();
        this._setUpdateStrategy(validatorOrOpts);
        this._setUpControls();
        this.updateValueAndValidity({
            onlySelf: true,
            // If `asyncValidator` is present, it will trigger control status change from `PENDING` to
            // `VALID` or `INVALID`. The status should be broadcasted via the `statusChanges` observable,
            // so we set `emitEvent` to `true` to allow that during the control creation process.
            emitEvent: !!this.asyncValidator
        });
    }
    registerControl(name, control) {
        if (this.controls[name])
            return this.controls[name];
        this.controls[name] = control;
        control.setParent(this);
        control._registerOnCollectionChange(this._onCollectionChange);
        return control;
    }
    addControl(name, control, options = {}) {
        this.registerControl(name, control);
        this.updateValueAndValidity({ emitEvent: options.emitEvent });
        this._onCollectionChange();
    }
    /**
     * Remove a control from this group. In a strongly-typed group, required controls cannot be
     * removed.
     *
     * This method also updates the value and validity of the control.
     *
     * @param name The control name to remove from the collection
     * @param options Specifies whether this FormGroup instance should emit events after a
     *     control is removed.
     * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and
     * `valueChanges` observables emit events with the latest status and value when the control is
     * removed. When false, no events are emitted.
     */
    removeControl(name, options = {}) {
        if (this.controls[name])
            this.controls[name]._registerOnCollectionChange(() => { });
        delete (this.controls[name]);
        this.updateValueAndValidity({ emitEvent: options.emitEvent });
        this._onCollectionChange();
    }
    setControl(name, control, options = {}) {
        if (this.controls[name])
            this.controls[name]._registerOnCollectionChange(() => { });
        delete (this.controls[name]);
        if (control)
            this.registerControl(name, control);
        this.updateValueAndValidity({ emitEvent: options.emitEvent });
        this._onCollectionChange();
    }
    contains(controlName) {
        return this.controls.hasOwnProperty(controlName) && this.controls[controlName].enabled;
    }
    /**
     * Sets the value of the `FormGroup`. It accepts an object that matches
     * the structure of the group, with control names as keys.
     *
     * @usageNotes
     * ### Set the complete value for the form group
     *
     * ```
     * const form = new FormGroup({
     *   first: new FormControl(),
     *   last: new FormControl()
     * });
     *
     * console.log(form.value);   // {first: null, last: null}
     *
     * form.setValue({first: 'Nancy', last: 'Drew'});
     * console.log(form.value);   // {first: 'Nancy', last: 'Drew'}
     * ```
     *
     * @throws When strict checks fail, such as setting the value of a control
     * that doesn't exist or if you exclude a value of a control that does exist.
     *
     * @param value The new value for the control that matches the structure of the group.
     * @param options Configuration options that determine how the control propagates changes
     * and emits events after the value changes.
     * The configuration options are passed to the {@link AbstractControl#updateValueAndValidity
     * updateValueAndValidity} method.
     *
     * * `onlySelf`: When true, each change only affects this control, and not its parent. Default is
     * false.
     * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and
     * `valueChanges`
     * observables emit events with the latest status and value when the control value is updated.
     * When false, no events are emitted.
     */
    setValue(value, options = {}) {
        assertAllValuesPresent(this, true, value);
        Object.keys(value).forEach(name => {
            assertControlPresent(this, true, name);
            this.controls[name].setValue(value[name], { onlySelf: true, emitEvent: options.emitEvent });
        });
        this.updateValueAndValidity(options);
    }
    /**
     * Patches the value of the `FormGroup`. It accepts an object with control
     * names as keys, and does its best to match the values to the correct controls
     * in the group.
     *
     * It accepts both super-sets and sub-sets of the group without throwing an error.
     *
     * @usageNotes
     * ### Patch the value for a form group
     *
     * ```
     * const form = new FormGroup({
     *    first: new FormControl(),
     *    last: new FormControl()
     * });
     * console.log(form.value);   // {first: null, last: null}
     *
     * form.patchValue({first: 'Nancy'});
     * console.log(form.value);   // {first: 'Nancy', last: null}
     * ```
     *
     * @param value The object that matches the structure of the group.
     * @param options Configuration options that determine how the control propagates changes and
     * emits events after the value is patched.
     * * `onlySelf`: When true, each change only affects this control and not its parent. Default is
     * true.
     * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and
     * `valueChanges` observables emit events with the latest status and value when the control value
     * is updated. When false, no events are emitted. The configuration options are passed to
     * the {@link AbstractControl#updateValueAndValidity updateValueAndValidity} method.
     */
    patchValue(value, options = {}) {
        // Even though the `value` argument type doesn't allow `null` and `undefined` values, the
        // `patchValue` can be called recursively and inner data structures might have these values, so
        // we just ignore such cases when a field containing FormGroup instance receives `null` or
        // `undefined` as a value.
        if (value == null /* both `null` and `undefined` */)
            return;
        Object.keys(value).forEach(name => {
            // The compiler cannot see through the uninstantiated conditional type of `this.controls`, so
            // `as any` is required.
            const control = this.controls[name];
            if (control) {
                control.patchValue(
                /* Guaranteed to be present, due to the outer forEach. */ value[name], { onlySelf: true, emitEvent: options.emitEvent });
            }
        });
        this.updateValueAndValidity(options);
    }
    /**
     * Resets the `FormGroup`, marks all descendants `pristine` and `untouched` and sets
     * the value of all descendants to their default values, or null if no defaults were provided.
     *
     * You reset to a specific form state by passing in a map of states
     * that matches the structure of your form, with control names as keys. The state
     * is a standalone value or a form state object with both a value and a disabled
     * status.
     *
     * @param value Resets the control with an initial value,
     * or an object that defines the initial value and disabled state.
     *
     * @param options Configuration options that determine how the control propagates changes
     * and emits events when the group is reset.
     * * `onlySelf`: When true, each change only affects this control, and not its parent. Default is
     * false.
     * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and
     * `valueChanges`
     * observables emit events with the latest status and value when the control is reset.
     * When false, no events are emitted.
     * The configuration options are passed to the {@link AbstractControl#updateValueAndValidity
     * updateValueAndValidity} method.
     *
     * @usageNotes
     *
     * ### Reset the form group values
     *
     * ```ts
     * const form = new FormGroup({
     *   first: new FormControl('first name'),
     *   last: new FormControl('last name')
     * });
     *
     * console.log(form.value);  // {first: 'first name', last: 'last name'}
     *
     * form.reset({ first: 'name', last: 'last name' });
     *
     * console.log(form.value);  // {first: 'name', last: 'last name'}
     * ```
     *
     * ### Reset the form group values and disabled status
     *
     * ```
     * const form = new FormGroup({
     *   first: new FormControl('first name'),
     *   last: new FormControl('last name')
     * });
     *
     * form.reset({
     *   first: {value: 'name', disabled: true},
     *   last: 'last'
     * });
     *
     * console.log(form.value);  // {last: 'last'}
     * console.log(form.get('first').status);  // 'DISABLED'
     * ```
     */
    reset(value = {}, options = {}) {
        this._forEachChild((control, name) => {
            control.reset(value ? value[name] : null, { onlySelf: true, emitEvent: options.emitEvent });
        });
        this._updatePristine(options);
        this._updateTouched(options);
        this.updateValueAndValidity(options);
    }
    /**
     * The aggregate value of the `FormGroup`, including any disabled controls.
     *
     * Retrieves all values regardless of disabled status.
     */
    getRawValue() {
        return this._reduceChildren({}, (acc, control, name) => {
            acc[name] = control.getRawValue();
            return acc;
        });
    }
    /** @internal */
    _syncPendingControls() {
        let subtreeUpdated = this._reduceChildren(false, (updated, child) => {
            return child._syncPendingControls() ? true : updated;
        });
        if (subtreeUpdated)
            this.updateValueAndValidity({ onlySelf: true });
        return subtreeUpdated;
    }
    /** @internal */
    _forEachChild(cb) {
        Object.keys(this.controls).forEach(key => {
            // The list of controls can change (for ex. controls might be removed) while the loop
            // is running (as a result of invoking Forms API in `valueChanges` subscription), so we
            // have to null check before invoking the callback.
            const control = this.controls[key];
            control && cb(control, key);
        });
    }
    /** @internal */
    _setUpControls() {
        this._forEachChild((control) => {
            control.setParent(this);
            control._registerOnCollectionChange(this._onCollectionChange);
        });
    }
    /** @internal */
    _updateValue() {
        this.value = this._reduceValue();
    }
    /** @internal */
    _anyControls(condition) {
        for (const [controlName, control] of Object.entries(this.controls)) {
            if (this.contains(controlName) && condition(control)) {
                return true;
            }
        }
        return false;
    }
    /** @internal */
    _reduceValue() {
        let acc = {};
        return this._reduceChildren(acc, (acc, control, name) => {
            if (control.enabled || this.disabled) {
                acc[name] = control.value;
            }
            return acc;
        });
    }
    /** @internal */
    _reduceChildren(initValue, fn) {
        let res = initValue;
        this._forEachChild((control, name) => {
            res = fn(res, control, name);
        });
        return res;
    }
    /** @internal */
    _allControlsDisabled() {
        for (const controlName of Object.keys(this.controls)) {
            if (this.controls[controlName].enabled) {
                return false;
            }
        }
        return Object.keys(this.controls).length > 0 || this.disabled;
    }
    /** @internal */
    _find(name) {
        return this.controls.hasOwnProperty(name) ?
            this.controls[name] :
            null;
    }
}
/**
 * Will validate that none of the controls has a key with a dot
 * Throws other wise
 */
function validateFormGroupControls(controls) {
    const invalidKeys = Object.keys(controls).filter(key => key.includes('.'));
    if (invalidKeys.length > 0) {
        // TODO: make this an error once there are no more uses in G3
        console.warn(`FormGroup keys cannot include \`.\`, please replace the keys for: ${invalidKeys.join(',')}.`);
    }
}
const UntypedFormGroup = FormGroup;
/**
 * @description
 * Asserts that the given control is an instance of `FormGroup`
 *
 * @publicApi
 */
const isFormGroup = (control) => control instanceof FormGroup;
/**
 * Tracks the value and validity state of a collection of `FormControl` instances, each of which has
 * the same value type.
 *
 * `FormRecord` is very similar to {@link FormGroup}, except it can be used with a dynamic keys,
 * with controls added and removed as needed.
 *
 * `FormRecord` accepts one generic argument, which describes the type of the controls it contains.
 *
 * @usageNotes
 *
 * ```
 * let numbers = new FormRecord({bill: new FormControl('415-123-456')});
 * numbers.addControl('bob', new FormControl('415-234-567'));
 * numbers.removeControl('bill');
 * ```
 *
 * @publicApi
 */
class FormRecord extends FormGroup {
}
/**
 * @description
 * Asserts that the given control is an instance of `FormRecord`
 *
 * @publicApi
 */
const isFormRecord = (control) => control instanceof FormRecord;

/**
 * Token to provide to allow SetDisabledState to always be called when a CVA is added, regardless of
 * whether the control is disabled or enabled.
 *
 * @see {@link FormsModule#withconfig}
 */
const CALL_SET_DISABLED_STATE = new _angular_core__WEBPACK_IMPORTED_MODULE_0__.InjectionToken('CallSetDisabledState', { providedIn: 'root', factory: () => setDisabledStateDefault });
/**
 * Whether to use the fixed setDisabledState behavior by default.
 */
const setDisabledStateDefault = 'always';
function controlPath(name, parent) {
    return [...parent.path, name];
}
/**
 * Links a Form control and a Form directive by setting up callbacks (such as `onChange`) on both
 * instances. This function is typically invoked when form directive is being initialized.
 *
 * @param control Form control instance that should be linked.
 * @param dir Directive that should be linked with a given control.
 */
function setUpControl(control, dir, callSetDisabledState = setDisabledStateDefault) {
    if (typeof ngDevMode === 'undefined' || ngDevMode) {
        if (!control)
            _throwError(dir, 'Cannot find control with');
        if (!dir.valueAccessor)
            _throwMissingValueAccessorError(dir);
    }
    setUpValidators(control, dir);
    dir.valueAccessor.writeValue(control.value);
    // The legacy behavior only calls the CVA's `setDisabledState` if the control is disabled.
    // If the `callSetDisabledState` option is set to `always`, then this bug is fixed and
    // the method is always called.
    if (control.disabled || callSetDisabledState === 'always') {
        dir.valueAccessor.setDisabledState?.(control.disabled);
    }
    setUpViewChangePipeline(control, dir);
    setUpModelChangePipeline(control, dir);
    setUpBlurPipeline(control, dir);
    setUpDisabledChangeHandler(control, dir);
}
/**
 * Reverts configuration performed by the `setUpControl` control function.
 * Effectively disconnects form control with a given form directive.
 * This function is typically invoked when corresponding form directive is being destroyed.
 *
 * @param control Form control which should be cleaned up.
 * @param dir Directive that should be disconnected from a given control.
 * @param validateControlPresenceOnChange Flag that indicates whether onChange handler should
 *     contain asserts to verify that it's not called once directive is destroyed. We need this flag
 *     to avoid potentially breaking changes caused by better control cleanup introduced in #39235.
 */
function cleanUpControl(control, dir, validateControlPresenceOnChange = true) {
    const noop = () => {
        if (validateControlPresenceOnChange && (typeof ngDevMode === 'undefined' || ngDevMode)) {
            _noControlError(dir);
        }
    };
    // The `valueAccessor` field is typically defined on FromControl and FormControlName directive
    // instances and there is a logic in `selectValueAccessor` function that throws if it's not the
    // case. We still check the presence of `valueAccessor` before invoking its methods to make sure
    // that cleanup works correctly if app code or tests are setup to ignore the error thrown from
    // `selectValueAccessor`. See https://github.com/angular/angular/issues/40521.
    if (dir.valueAccessor) {
        dir.valueAccessor.registerOnChange(noop);
        dir.valueAccessor.registerOnTouched(noop);
    }
    cleanUpValidators(control, dir);
    if (control) {
        dir._invokeOnDestroyCallbacks();
        control._registerOnCollectionChange(() => { });
    }
}
function registerOnValidatorChange(validators, onChange) {
    validators.forEach((validator) => {
        if (validator.registerOnValidatorChange)
            validator.registerOnValidatorChange(onChange);
    });
}
/**
 * Sets up disabled change handler function on a given form control if ControlValueAccessor
 * associated with a given directive instance supports the `setDisabledState` call.
 *
 * @param control Form control where disabled change handler should be setup.
 * @param dir Corresponding directive instance associated with this control.
 */
function setUpDisabledChangeHandler(control, dir) {
    if (dir.valueAccessor.setDisabledState) {
        const onDisabledChange = (isDisabled) => {
            dir.valueAccessor.setDisabledState(isDisabled);
        };
        control.registerOnDisabledChange(onDisabledChange);
        // Register a callback function to cleanup disabled change handler
        // from a control instance when a directive is destroyed.
        dir._registerOnDestroy(() => {
            control._unregisterOnDisabledChange(onDisabledChange);
        });
    }
}
/**
 * Sets up sync and async directive validators on provided form control.
 * This function merges validators from the directive into the validators of the control.
 *
 * @param control Form control where directive validators should be setup.
 * @param dir Directive instance that contains validators to be setup.
 */
function setUpValidators(control, dir) {
    const validators = getControlValidators(control);
    if (dir.validator !== null) {
        control.setValidators(mergeValidators(validators, dir.validator));
    }
    else if (typeof validators === 'function') {
        // If sync validators are represented by a single validator function, we force the
        // `Validators.compose` call to happen by executing the `setValidators` function with
        // an array that contains that function. We need this to avoid possible discrepancies in
        // validators behavior, so sync validators are always processed by the `Validators.compose`.
        // Note: we should consider moving this logic inside the `setValidators` function itself, so we
        // have consistent behavior on AbstractControl API level. The same applies to the async
        // validators logic below.
        control.setValidators([validators]);
    }
    const asyncValidators = getControlAsyncValidators(control);
    if (dir.asyncValidator !== null) {
        control.setAsyncValidators(mergeValidators(asyncValidators, dir.asyncValidator));
    }
    else if (typeof asyncValidators === 'function') {
        control.setAsyncValidators([asyncValidators]);
    }
    // Re-run validation when validator binding changes, e.g. minlength=3 -> minlength=4
    const onValidatorChange = () => control.updateValueAndValidity();
    registerOnValidatorChange(dir._rawValidators, onValidatorChange);
    registerOnValidatorChange(dir._rawAsyncValidators, onValidatorChange);
}
/**
 * Cleans up sync and async directive validators on provided form control.
 * This function reverts the setup performed by the `setUpValidators` function, i.e.
 * removes directive-specific validators from a given control instance.
 *
 * @param control Form control from where directive validators should be removed.
 * @param dir Directive instance that contains validators to be removed.
 * @returns true if a control was updated as a result of this action.
 */
function cleanUpValidators(control, dir) {
    let isControlUpdated = false;
    if (control !== null) {
        if (dir.validator !== null) {
            const validators = getControlValidators(control);
            if (Array.isArray(validators) && validators.length > 0) {
                // Filter out directive validator function.
                const updatedValidators = validators.filter((validator) => validator !== dir.validator);
                if (updatedValidators.length !== validators.length) {
                    isControlUpdated = true;
                    control.setValidators(updatedValidators);
                }
            }
        }
        if (dir.asyncValidator !== null) {
            const asyncValidators = getControlAsyncValidators(control);
            if (Array.isArray(asyncValidators) && asyncValidators.length > 0) {
                // Filter out directive async validator function.
                const updatedAsyncValidators = asyncValidators.filter((asyncValidator) => asyncValidator !== dir.asyncValidator);
                if (updatedAsyncValidators.length !== asyncValidators.length) {
                    isControlUpdated = true;
                    control.setAsyncValidators(updatedAsyncValidators);
                }
            }
        }
    }
    // Clear onValidatorChange callbacks by providing a noop function.
    const noop = () => { };
    registerOnValidatorChange(dir._rawValidators, noop);
    registerOnValidatorChange(dir._rawAsyncValidators, noop);
    return isControlUpdated;
}
function setUpViewChangePipeline(control, dir) {
    dir.valueAccessor.registerOnChange((newValue) => {
        control._pendingValue = newValue;
        control._pendingChange = true;
        control._pendingDirty = true;
        if (control.updateOn === 'change')
            updateControl(control, dir);
    });
}
function setUpBlurPipeline(control, dir) {
    dir.valueAccessor.registerOnTouched(() => {
        control._pendingTouched = true;
        if (control.updateOn === 'blur' && control._pendingChange)
            updateControl(control, dir);
        if (control.updateOn !== 'submit')
            control.markAsTouched();
    });
}
function updateControl(control, dir) {
    if (control._pendingDirty)
        control.markAsDirty();
    control.setValue(control._pendingValue, { emitModelToViewChange: false });
    dir.viewToModelUpdate(control._pendingValue);
    control._pendingChange = false;
}
function setUpModelChangePipeline(control, dir) {
    const onChange = (newValue, emitModelEvent) => {
        // control -> view
        dir.valueAccessor.writeValue(newValue);
        // control -> ngModel
        if (emitModelEvent)
            dir.viewToModelUpdate(newValue);
    };
    control.registerOnChange(onChange);
    // Register a callback function to cleanup onChange handler
    // from a control instance when a directive is destroyed.
    dir._registerOnDestroy(() => {
        control._unregisterOnChange(onChange);
    });
}
/**
 * Links a FormGroup or FormArray instance and corresponding Form directive by setting up validators
 * present in the view.
 *
 * @param control FormGroup or FormArray instance that should be linked.
 * @param dir Directive that provides view validators.
 */
function setUpFormContainer(control, dir) {
    if (control == null && (typeof ngDevMode === 'undefined' || ngDevMode))
        _throwError(dir, 'Cannot find control with');
    setUpValidators(control, dir);
}
/**
 * Reverts the setup performed by the `setUpFormContainer` function.
 *
 * @param control FormGroup or FormArray instance that should be cleaned up.
 * @param dir Directive that provided view validators.
 * @returns true if a control was updated as a result of this action.
 */
function cleanUpFormContainer(control, dir) {
    return cleanUpValidators(control, dir);
}
function _noControlError(dir) {
    return _throwError(dir, 'There is no FormControl instance attached to form control element with');
}
function _throwError(dir, message) {
    const messageEnd = _describeControlLocation(dir);
    throw new Error(`${message} ${messageEnd}`);
}
function _describeControlLocation(dir) {
    const path = dir.path;
    if (path && path.length > 1)
        return `path: '${path.join(' -> ')}'`;
    if (path?.[0])
        return `name: '${path}'`;
    return 'unspecified name attribute';
}
function _throwMissingValueAccessorError(dir) {
    const loc = _describeControlLocation(dir);
    throw new _angular_core__WEBPACK_IMPORTED_MODULE_0__["RuntimeError"](-1203 /* RuntimeErrorCode.NG_MISSING_VALUE_ACCESSOR */, `No value accessor for form control ${loc}.`);
}
function _throwInvalidValueAccessorError(dir) {
    const loc = _describeControlLocation(dir);
    throw new _angular_core__WEBPACK_IMPORTED_MODULE_0__["RuntimeError"](1200 /* RuntimeErrorCode.NG_VALUE_ACCESSOR_NOT_PROVIDED */, `Value accessor was not provided as an array for form control with ${loc}. ` +
        `Check that the \`NG_VALUE_ACCESSOR\` token is configured as a \`multi: true\` provider.`);
}
function isPropertyUpdated(changes, viewModel) {
    if (!changes.hasOwnProperty('model'))
        return false;
    const change = changes['model'];
    if (change.isFirstChange())
        return true;
    return !Object.is(viewModel, change.currentValue);
}
function isBuiltInAccessor(valueAccessor) {
    // Check if a given value accessor is an instance of a class that directly extends
    // `BuiltInControlValueAccessor` one.
    return Object.getPrototypeOf(valueAccessor.constructor) === BuiltInControlValueAccessor;
}
function syncPendingControls(form, directives) {
    form._syncPendingControls();
    directives.forEach((dir) => {
        const control = dir.control;
        if (control.updateOn === 'submit' && control._pendingChange) {
            dir.viewToModelUpdate(control._pendingValue);
            control._pendingChange = false;
        }
    });
}
// TODO: vsavkin remove it once https://github.com/angular/angular/issues/3011 is implemented
function selectValueAccessor(dir, valueAccessors) {
    if (!valueAccessors)
        return null;
    if (!Array.isArray(valueAccessors) && (typeof ngDevMode === 'undefined' || ngDevMode))
        _throwInvalidValueAccessorError(dir);
    let defaultAccessor = undefined;
    let builtinAccessor = undefined;
    let customAccessor = undefined;
    valueAccessors.forEach((v) => {
        if (v.constructor === DefaultValueAccessor) {
            defaultAccessor = v;
        }
        else if (isBuiltInAccessor(v)) {
            if (builtinAccessor && (typeof ngDevMode === 'undefined' || ngDevMode))
                _throwError(dir, 'More than one built-in value accessor matches form control with');
            builtinAccessor = v;
        }
        else {
            if (customAccessor && (typeof ngDevMode === 'undefined' || ngDevMode))
                _throwError(dir, 'More than one custom value accessor matches form control with');
            customAccessor = v;
        }
    });
    if (customAccessor)
        return customAccessor;
    if (builtinAccessor)
        return builtinAccessor;
    if (defaultAccessor)
        return defaultAccessor;
    if (typeof ngDevMode === 'undefined' || ngDevMode) {
        _throwError(dir, 'No valid value accessor for form control with');
    }
    return null;
}
function removeListItem$1(list, el) {
    const index = list.indexOf(el);
    if (index > -1)
        list.splice(index, 1);
}
// TODO(kara): remove after deprecation period
function _ngModelWarning(name, type, instance, warningConfig) {
    if (warningConfig === 'never')
        return;
    if (((warningConfig === null || warningConfig === 'once') && !type._ngModelWarningSentOnce) ||
        (warningConfig === 'always' && !instance._ngModelWarningSent)) {
        console.warn(ngModelWarning(name));
        type._ngModelWarningSentOnce = true;
        instance._ngModelWarningSent = true;
    }
}

const formDirectiveProvider$1 = {
    provide: ControlContainer,
    useExisting: (0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(() => NgForm)
};
const resolvedPromise$1 = (() => Promise.resolve())();
/**
 * @description
 * Creates a top-level `FormGroup` instance and binds it to a form
 * to track aggregate form value and validation status.
 *
 * As soon as you import the `FormsModule`, this directive becomes active by default on
 * all `<form>` tags.  You don't need to add a special selector.
 *
 * You optionally export the directive into a local template variable using `ngForm` as the key
 * (ex: `#myForm="ngForm"`). This is optional, but useful.  Many properties from the underlying
 * `FormGroup` instance are duplicated on the directive itself, so a reference to it
 * gives you access to the aggregate value and validity status of the form, as well as
 * user interaction properties like `dirty` and `touched`.
 *
 * To register child controls with the form, use `NgModel` with a `name`
 * attribute. You may use `NgModelGroup` to create sub-groups within the form.
 *
 * If necessary, listen to the directive's `ngSubmit` event to be notified when the user has
 * triggered a form submission. The `ngSubmit` event emits the original form
 * submission event.
 *
 * In template driven forms, all `<form>` tags are automatically tagged as `NgForm`.
 * To import the `FormsModule` but skip its usage in some forms,
 * for example, to use native HTML5 validation, add the `ngNoForm` and the `<form>`
 * tags won't create an `NgForm` directive. In reactive forms, using `ngNoForm` is
 * unnecessary because the `<form>` tags are inert. In that case, you would
 * refrain from using the `formGroup` directive.
 *
 * @usageNotes
 *
 * ### Listening for form submission
 *
 * The following example shows how to capture the form values from the "ngSubmit" event.
 *
 * {@example forms/ts/simpleForm/simple_form_example.ts region='Component'}
 *
 * ### Setting the update options
 *
 * The following example shows you how to change the "updateOn" option from its default using
 * ngFormOptions.
 *
 * ```html
 * <form [ngFormOptions]="{updateOn: 'blur'}">
 *    <input name="one" ngModel>  <!-- this ngModel will update on blur -->
 * </form>
 * ```
 *
 * ### Native DOM validation UI
 *
 * In order to prevent the native DOM form validation UI from interfering with Angular's form
 * validation, Angular automatically adds the `novalidate` attribute on any `<form>` whenever
 * `FormModule` or `ReactiveFormModule` are imported into the application.
 * If you want to explicitly enable native DOM validation UI with Angular forms, you can add the
 * `ngNativeValidate` attribute to the `<form>` element:
 *
 * ```html
 * <form ngNativeValidate>
 *   ...
 * </form>
 * ```
 *
 * @ngModule FormsModule
 * @publicApi
 */
class NgForm extends ControlContainer {
    constructor(validators, asyncValidators, callSetDisabledState) {
        super();
        this.callSetDisabledState = callSetDisabledState;
        /**
         * @description
         * Returns whether the form submission has been triggered.
         */
        this.submitted = false;
        this._directives = new Set();
        /**
         * @description
         * Event emitter for the "ngSubmit" event
         */
        this.ngSubmit = new _angular_core__WEBPACK_IMPORTED_MODULE_0__.EventEmitter();
        this.form =
            new FormGroup({}, composeValidators(validators), composeAsyncValidators(asyncValidators));
    }
    /** @nodoc */
    ngAfterViewInit() {
        this._setUpdateStrategy();
    }
    /**
     * @description
     * The directive instance.
     */
    get formDirective() {
        return this;
    }
    /**
     * @description
     * The internal `FormGroup` instance.
     */
    get control() {
        return this.form;
    }
    /**
     * @description
     * Returns an array representing the path to this group. Because this directive
     * always lives at the top level of a form, it is always an empty array.
     */
    get path() {
        return [];
    }
    /**
     * @description
     * Returns a map of the controls in this group.
     */
    get controls() {
        return this.form.controls;
    }
    /**
     * @description
     * Method that sets up the control directive in this group, re-calculates its value
     * and validity, and adds the instance to the internal list of directives.
     *
     * @param dir The `NgModel` directive instance.
     */
    addControl(dir) {
        resolvedPromise$1.then(() => {
            const container = this._findContainer(dir.path);
            dir.control =
                container.registerControl(dir.name, dir.control);
            setUpControl(dir.control, dir, this.callSetDisabledState);
            dir.control.updateValueAndValidity({ emitEvent: false });
            this._directives.add(dir);
        });
    }
    /**
     * @description
     * Retrieves the `FormControl` instance from the provided `NgModel` directive.
     *
     * @param dir The `NgModel` directive instance.
     */
    getControl(dir) {
        return this.form.get(dir.path);
    }
    /**
     * @description
     * Removes the `NgModel` instance from the internal list of directives
     *
     * @param dir The `NgModel` directive instance.
     */
    removeControl(dir) {
        resolvedPromise$1.then(() => {
            const container = this._findContainer(dir.path);
            if (container) {
                container.removeControl(dir.name);
            }
            this._directives.delete(dir);
        });
    }
    /**
     * @description
     * Adds a new `NgModelGroup` directive instance to the form.
     *
     * @param dir The `NgModelGroup` directive instance.
     */
    addFormGroup(dir) {
        resolvedPromise$1.then(() => {
            const container = this._findContainer(dir.path);
            const group = new FormGroup({});
            setUpFormContainer(group, dir);
            container.registerControl(dir.name, group);
            group.updateValueAndValidity({ emitEvent: false });
        });
    }
    /**
     * @description
     * Removes the `NgModelGroup` directive instance from the form.
     *
     * @param dir The `NgModelGroup` directive instance.
     */
    removeFormGroup(dir) {
        resolvedPromise$1.then(() => {
            const container = this._findContainer(dir.path);
            if (container) {
                container.removeControl(dir.name);
            }
        });
    }
    /**
     * @description
     * Retrieves the `FormGroup` for a provided `NgModelGroup` directive instance
     *
     * @param dir The `NgModelGroup` directive instance.
     */
    getFormGroup(dir) {
        return this.form.get(dir.path);
    }
    /**
     * Sets the new value for the provided `NgControl` directive.
     *
     * @param dir The `NgControl` directive instance.
     * @param value The new value for the directive's control.
     */
    updateModel(dir, value) {
        resolvedPromise$1.then(() => {
            const ctrl = this.form.get(dir.path);
            ctrl.setValue(value);
        });
    }
    /**
     * @description
     * Sets the value for this `FormGroup`.
     *
     * @param value The new value
     */
    setValue(value) {
        this.control.setValue(value);
    }
    /**
     * @description
     * Method called when the "submit" event is triggered on the form.
     * Triggers the `ngSubmit` emitter to emit the "submit" event as its payload.
     *
     * @param $event The "submit" event object
     */
    onSubmit($event) {
        this.submitted = true;
        syncPendingControls(this.form, this._directives);
        this.ngSubmit.emit($event);
        // Forms with `method="dialog"` have some special behavior
        // that won't reload the page and that shouldn't be prevented.
        return $event?.target?.method === 'dialog';
    }
    /**
     * @description
     * Method called when the "reset" event is triggered on the form.
     */
    onReset() {
        this.resetForm();
    }
    /**
     * @description
     * Resets the form to an initial value and resets its submitted status.
     *
     * @param value The new value for the form.
     */
    resetForm(value = undefined) {
        this.form.reset(value);
        this.submitted = false;
    }
    _setUpdateStrategy() {
        if (this.options && this.options.updateOn != null) {
            this.form._updateOn = this.options.updateOn;
        }
    }
    _findContainer(path) {
        path.pop();
        return path.length ? this.form.get(path) : this.form;
    }
    static { this.fac = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareFactory"]({ minVersion: "12.0.0", version: "17.3.12", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: NgForm, deps: [{ token: NG_VALIDATORS, optional: true, self: true }, { token: NG_ASYNC_VALIDATORS, optional: true, self: true }, { token: CALL_SET_DISABLED_STATE, optional: true }], target: _angular_core__WEBPACK_IMPORTED_MODULE_0__["FactoryTarget"].Directive }); }
    static { this.dir = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareDirective"]({ minVersion: "14.0.0", version: "17.3.12", type: NgForm, selector: "form:not([ngNoForm]):not([formGroup]),ng-form,[ngForm]", inputs: { options: ["ngFormOptions", "options"] }, outputs: { ngSubmit: "ngSubmit" }, host: { listeners: { "submit": "onSubmit($event)", "reset": "onReset()" } }, providers: [formDirectiveProvider$1], exportAs: ["ngForm"], usesInheritance: true, ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))) }); }
}
_angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareClassMetadata"]({ minVersion: "12.0.0", version: "17.3.12", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: NgForm, decorators: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Directive,
            args: [{
                    selector: 'form:not([ngNoForm]):not([formGroup]),ng-form,[ngForm]',
                    providers: [formDirectiveProvider$1],
                    host: { '(submit)': 'onSubmit($event)', '(reset)': 'onReset()' },
                    outputs: ['ngSubmit'],
                    exportAs: 'ngForm'
                }]
        }], ctorParameters: () => [{ type: undefined, decorators: [{
                    type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Optional
                }, {
                    type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Self
                }, {
                    type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Inject,
                    args: [NG_VALIDATORS]
                }] }, { type: undefined, decorators: [{
                    type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Optional
                }, {
                    type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Self
                }, {
                    type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Inject,
                    args: [NG_ASYNC_VALIDATORS]
                }] }, { type: undefined, decorators: [{
                    type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Optional
                }, {
                    type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Inject,
                    args: [CALL_SET_DISABLED_STATE]
                }] }], propDecorators: { options: [{
                type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input,
                args: ['ngFormOptions']
            }] } });

function removeListItem(list, el) {
    const index = list.indexOf(el);
    if (index > -1)
        list.splice(index, 1);
}

function isFormControlState(formState) {
    return typeof formState === 'object' && formState !== null &&
        Object.keys(formState).length === 2 && 'value' in formState && 'disabled' in formState;
}
const FormControl = (class FormControl extends AbstractControl {
    constructor(
    // formState and defaultValue will only be null if T is nullable
    formState = null, validatorOrOpts, asyncValidator) {
        super(pickValidators(validatorOrOpts), pickAsyncValidators(asyncValidator, validatorOrOpts));
        /** @publicApi */
        this.defaultValue = null;
        /** @internal */
        this._onChange = [];
        /** @internal */
        this._pendingChange = false;
        this._applyFormState(formState);
        this._setUpdateStrategy(validatorOrOpts);
        this._initObservables();
        this.updateValueAndValidity({
            onlySelf: true,
            // If `asyncValidator` is present, it will trigger control status change from `PENDING` to
            // `VALID` or `INVALID`.
            // The status should be broadcasted via the `statusChanges` observable, so we set
            // `emitEvent` to `true` to allow that during the control creation process.
            emitEvent: !!this.asyncValidator
        });
        if (isOptionsObj(validatorOrOpts) &&
            (validatorOrOpts.nonNullable || validatorOrOpts.initialValueIsDefault)) {
            if (isFormControlState(formState)) {
                this.defaultValue = formState.value;
            }
            else {
                this.defaultValue = formState;
            }
        }
    }
    setValue(value, options = {}) {
        this.value = this._pendingValue = value;
        if (this._onChange.length && options.emitModelToViewChange !== false) {
            this._onChange.forEach((changeFn) => changeFn(this.value, options.emitViewToModelChange !== false));
        }
        this.updateValueAndValidity(options);
    }
    patchValue(value, options = {}) {
        this.setValue(value, options);
    }
    reset(formState = this.defaultValue, options = {}) {
        this._applyFormState(formState);
        this.markAsPristine(options);
        this.markAsUntouched(options);
        this.setValue(this.value, options);
        this._pendingChange = false;
    }
    /**  @internal */
    _updateValue() { }
    /**  @internal */
    _anyControls(condition) {
        return false;
    }
    /**  @internal */
    _allControlsDisabled() {
        return this.disabled;
    }
    registerOnChange(fn) {
        this._onChange.push(fn);
    }
    /** @internal */
    _unregisterOnChange(fn) {
        removeListItem(this._onChange, fn);
    }
    registerOnDisabledChange(fn) {
        this._onDisabledChange.push(fn);
    }
    /** @internal */
    _unregisterOnDisabledChange(fn) {
        removeListItem(this._onDisabledChange, fn);
    }
    /** @internal */
    _forEachChild(cb) { }
    /** @internal */
    _syncPendingControls() {
        if (this.updateOn === 'submit') {
            if (this._pendingDirty)
                this.markAsDirty();
            if (this._pendingTouched)
                this.markAsTouched();
            if (this._pendingChange) {
                this.setValue(this._pendingValue, { onlySelf: true, emitModelToViewChange: false });
                return true;
            }
        }
        return false;
    }
    _applyFormState(formState) {
        if (isFormControlState(formState)) {
            this.value = this._pendingValue = formState.value;
            formState.disabled ? this.disable({ onlySelf: true, emitEvent: false }) :
                this.enable({ onlySelf: true, emitEvent: false });
        }
        else {
            this.value = this._pendingValue = formState;
        }
    }
});
const UntypedFormControl = FormControl;
/**
 * @description
 * Asserts that the given control is an instance of `FormControl`
 *
 * @publicApi
 */
const isFormControl = (control) => control instanceof FormControl;

/**
 * @description
 * A base class for code shared between the `NgModelGroup` and `FormGroupName` directives.
 *
 * @publicApi
 */
class AbstractFormGroupDirective extends ControlContainer {
    /** @nodoc */
    ngOnInit() {
        this._checkParentType();
        // Register the group with its parent group.
        this.formDirective.addFormGroup(this);
    }
    /** @nodoc */
    ngOnDestroy() {
        if (this.formDirective) {
            // Remove the group from its parent group.
            this.formDirective.removeFormGroup(this);
        }
    }
    /**
     * @description
     * The `FormGroup` bound to this directive.
     */
    get control() {
        return this.formDirective.getFormGroup(this);
    }
    /**
     * @description
     * The path to this group from the top-level directive.
     */
    get path() {
        return controlPath(this.name == null ? this.name : this.name.toString(), this._parent);
    }
    /**
     * @description
     * The top-level directive for this group if present, otherwise null.
     */
    get formDirective() {
        return this._parent ? this._parent.formDirective : null;
    }
    /** @internal */
    _checkParentType() { }
    static { this.fac = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareFactory"]({ minVersion: "12.0.0", version: "17.3.12", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: AbstractFormGroupDirective, deps: null, target: _angular_core__WEBPACK_IMPORTED_MODULE_0__["FactoryTarget"].Directive }); }
    static { this.dir = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareDirective"]({ minVersion: "14.0.0", version: "17.3.12", type: AbstractFormGroupDirective, usesInheritance: true, ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))) }); }
}
_angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareClassMetadata"]({ minVersion: "12.0.0", version: "17.3.12", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: AbstractFormGroupDirective, decorators: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Directive
        }] });

function modelParentException() {
    return new _angular_core__WEBPACK_IMPORTED_MODULE_0__["RuntimeError"](1350 /* RuntimeErrorCode.NGMODEL_IN_FORM_GROUP */, `
    ngModel cannot be used to register form controls with a parent formGroup directive.  Try using
    formGroup's partner directive "formControlName" instead.  Example:

    ${formControlNameExample}

    Or, if you'd like to avoid registering this form control, indicate that it's standalone in ngModelOptions:

    Example:

    ${ngModelWithFormGroupExample}`);
}
function formGroupNameException() {
    return new _angular_core__WEBPACK_IMPORTED_MODULE_0__["RuntimeError"](1351 /* RuntimeErrorCode.NGMODEL_IN_FORM_GROUP_NAME */, `
    ngModel cannot be used to register form controls with a parent formGroupName or formArrayName directive.

    Option 1: Use formControlName instead of ngModel (reactive strategy):

    ${formGroupNameExample}

    Option 2:  Update ngModel's parent be ngModelGroup (template-driven strategy):

    ${ngModelGroupExample}`);
}
function missingNameException() {
    return new _angular_core__WEBPACK_IMPORTED_MODULE_0__["RuntimeError"](1352 /* RuntimeErrorCode.NGMODEL_WITHOUT_NAME */, `If ngModel is used within a form tag, either the name attribute must be set or the form
    control must be defined as 'standalone' in ngModelOptions.

    Example 1: <input [(ngModel)]="person.firstName" name="first">
    Example 2: <input [(ngModel)]="person.firstName" [ngModelOptions]="{standalone: true}">`);
}
function modelGroupParentException() {
    return new _angular_core__WEBPACK_IMPORTED_MODULE_0__["RuntimeError"](1353 /* RuntimeErrorCode.NGMODELGROUP_IN_FORM_GROUP */, `
    ngModelGroup cannot be used with a parent formGroup directive.

    Option 1: Use formGroupName instead of ngModelGroup (reactive strategy):

    ${formGroupNameExample}

    Option 2:  Use a regular form tag instead of the formGroup directive (template-driven strategy):

    ${ngModelGroupExample}`);
}

const modelGroupProvider = {
    provide: ControlContainer,
    useExisting: (0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(() => NgModelGroup)
};
/**
 * @description
 * Creates and binds a `FormGroup` instance to a DOM element.
 *
 * This directive can only be used as a child of `NgForm` (within `<form>` tags).
 *
 * Use this directive to validate a sub-group of your form separately from the
 * rest of your form, or if some values in your domain model make more sense
 * to consume together in a nested object.
 *
 * Provide a name for the sub-group and it will become the key
 * for the sub-group in the form's full value. If you need direct access, export the directive into
 * a local template variable using `ngModelGroup` (ex: `#myGroup="ngModelGroup"`).
 *
 * @usageNotes
 *
 * ### Consuming controls in a grouping
 *
 * The following example shows you how to combine controls together in a sub-group
 * of the form.
 *
 * {@example forms/ts/ngModelGroup/ng_model_group_example.ts region='Component'}
 *
 * @ngModule FormsModule
 * @publicApi
 */
class NgModelGroup extends AbstractFormGroupDirective {
    constructor(parent, validators, asyncValidators) {
        super();
        /**
         * @description
         * Tracks the name of the `NgModelGroup` bound to the directive. The name corresponds
         * to a key in the parent `NgForm`.
         */
        this.name = '';
        this._parent = parent;
        this._setValidators(validators);
        this._setAsyncValidators(asyncValidators);
    }
    /** @internal */
    _checkParentType() {
        if (!(this._parent instanceof NgModelGroup) && !(this._parent instanceof NgForm) &&
            (typeof ngDevMode === 'undefined' || ngDevMode)) {
            throw modelGroupParentException();
        }
    }
    static { this.fac = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareFactory"]({ minVersion: "12.0.0", version: "17.3.12", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: NgModelGroup, deps: [{ token: ControlContainer, host: true, skipSelf: true }, { token: NG_VALIDATORS, optional: true, self: true }, { token: NG_ASYNC_VALIDATORS, optional: true, self: true }], target: _angular_core__WEBPACK_IMPORTED_MODULE_0__["FactoryTarget"].Directive }); }
    static { this.dir = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareDirective"]({ minVersion: "14.0.0", version: "17.3.12", type: NgModelGroup, selector: "[ngModelGroup]", inputs: { name: ["ngModelGroup", "name"] }, providers: [modelGroupProvider], exportAs: ["ngModelGroup"], usesInheritance: true, ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))) }); }
}
_angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareClassMetadata"]({ minVersion: "12.0.0", version: "17.3.12", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: NgModelGroup, decorators: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Directive,
            args: [{ selector: '[ngModelGroup]', providers: [modelGroupProvider], exportAs: 'ngModelGroup' }]
        }], ctorParameters: () => [{ type: ControlContainer, decorators: [{
                    type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Host
                }, {
                    type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.SkipSelf
                }] }, { type: undefined, decorators: [{
                    type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Optional
                }, {
                    type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Self
                }, {
                    type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Inject,
                    args: [NG_VALIDATORS]
                }] }, { type: undefined, decorators: [{
                    type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Optional
                }, {
                    type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Self
                }, {
                    type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Inject,
                    args: [NG_ASYNC_VALIDATORS]
                }] }], propDecorators: { name: [{
                type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input,
                args: ['ngModelGroup']
            }] } });

const formControlBinding$1 = {
    provide: NgControl,
    useExisting: (0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(() => NgModel)
};
/**
 * `ngModel` forces an additional change detection run when its inputs change:
 * E.g.:
 * ```
 * <div>{{myModel.valid}}</div>
 * <input [(ngModel)]="myValue" #myModel="ngModel">
 * ```
 * I.e. `ngModel` can export itself on the element and then be used in the template.
 * Normally, this would result in expressions before the `input` that use the exported directive
 * to have an old value as they have been
 * dirty checked before. As this is a very common case for `ngModel`, we added this second change
 * detection run.
 *
 * Notes:
 * - this is just one extra run no matter how many `ngModel`s have been changed.
 * - this is a general problem when using `exportAs` for directives!
 */
const resolvedPromise = (() => Promise.resolve())();
/**
 * @description
 * Creates a `FormControl` instance from a [domain
 * model](https://en.wikipedia.org/wiki/Domain_model) and binds it to a form control element.
 *
 * The `FormControl` instance tracks the value, user interaction, and
 * validation status of the control and keeps the view synced with the model. If used
 * within a parent form, the directive also registers itself with the form as a child
 * control.
 *
 * This directive is used by itself or as part of a larger form. Use the
 * `ngModel` selector to activate it.
 *
 * It accepts a domain model as an optional `Input`. If you have a one-way binding
 * to `ngModel` with `[]` syntax, changing the domain model's value in the component
 * class sets the value in the view. If you have a two-way binding with `[()]` syntax
 * (also known as 'banana-in-a-box syntax'), the value in the UI always syncs back to
 * the domain model in your class.
 *
 * To inspect the properties of the associated `FormControl` (like the validity state),
 * export the directive into a local template variable using `ngModel` as the key (ex:
 * `#myVar="ngModel"`). You can then access the control using the directive's `control` property.
 * However, the most commonly used properties (like `valid` and `dirty`) also exist on the control
 * for direct access. See a full list of properties directly available in
 * `AbstractControlDirective`.
 *
 * @see {@link RadioControlValueAccessor}
 * @see {@link SelectControlValueAccessor}
 *
 * @usageNotes
 *
 * ### Using ngModel on a standalone control
 *
 * The following examples show a simple standalone control using `ngModel`:
 *
 * {@example forms/ts/simpleNgModel/simple_ng_model_example.ts region='Component'}
 *
 * When using the `ngModel` within `<form>` tags, you'll also need to supply a `name` attribute
 * so that the control can be registered with the parent form under that name.
 *
 * In the context of a parent form, it's often unnecessary to include one-way or two-way binding,
 * as the parent form syncs the value for you. You access its properties by exporting it into a
 * local template variable using `ngForm` such as (`#f="ngForm"`). Use the variable where
 * needed on form submission.
 *
 * If you do need to populate initial values into your form, using a one-way binding for
 * `ngModel` tends to be sufficient as long as you use the exported form's value rather
 * than the domain model's value on submit.
 *
 * ### Using ngModel within a form
 *
 * The following example shows controls using `ngModel` within a form:
 *
 * {@example forms/ts/simpleForm/simple_form_example.ts region='Component'}
 *
 * ### Using a standalone ngModel within a group
 *
 * The following example shows you how to use a standalone ngModel control
 * within a form. This controls the display of the form, but doesn't contain form data.
 *
 * ```html
 * <form>
 *   <input name="login" ngModel placeholder="Login">
 *   <input type="checkbox" ngModel [ngModelOptions]="{standalone: true}"> Show more options?
 * </form>
 * <!-- form value: {login: ''} -->
 * ```
 *
 * ### Setting the ngModel `name` attribute through options
 *
 * The following example shows you an alternate way to set the name attribute. Here,
 * an attribute identified as name is used within a custom form control component. To still be able
 * to specify the NgModel's name, you must specify it using the `ngModelOptions` input instead.
 *
 * ```html
 * <form>
 *   <my-custom-form-control name="Nancy" ngModel [ngModelOptions]="{name: 'user'}">
 *   </my-custom-form-control>
 * </form>
 * <!-- form value: {user: ''} -->
 * ```
 *
 * @ngModule FormsModule
 * @publicApi
 */
class NgModel extends NgControl {
    constructor(parent, validators, asyncValidators, valueAccessors, _changeDetectorRef, callSetDisabledState) {
        super();
        this._changeDetectorRef = _changeDetectorRef;
        this.callSetDisabledState = callSetDisabledState;
        this.control = new FormControl();
        /** @internal */
        this._registered = false;
        /**
         * @description
         * Tracks the name bound to the directive. If a parent form exists, it
         * uses this name as a key to retrieve this control's value.
         */
        this.name = '';
        /**
         * @description
         * Event emitter for producing the `ngModelChange` event after
         * the view model updates.
         */
        this.update = new _angular_core__WEBPACK_IMPORTED_MODULE_0__.EventEmitter();
        this._parent = parent;
        this._setValidators(validators);
        this._setAsyncValidators(asyncValidators);
        this.valueAccessor = selectValueAccessor(this, valueAccessors);
    }
    /** @nodoc */
    ngOnChanges(changes) {
        this._checkForErrors();
        if (!this._registered || 'name' in changes) {
            if (this._registered) {
                this._checkName();
                if (this.formDirective) {
                    // We can't call `formDirective.removeControl(this)`, because the `name` has already been
                    // changed. We also can't reset the name temporarily since the logic in `removeControl`
                    // is inside a promise and it won't run immediately. We work around it by giving it an
                    // object with the same shape instead.
                    const oldName = changes['name'].previousValue;
                    this.formDirective.removeControl({ name: oldName, path: this._getPath(oldName) });
                }
            }
            this._setUpControl();
        }
        if ('isDisabled' in changes) {
            this._updateDisabled(changes);
        }
        if (isPropertyUpdated(changes, this.viewModel)) {
            this._updateValue(this.model);
            this.viewModel = this.model;
        }
    }
    /** @nodoc */
    ngOnDestroy() {
        this.formDirective && this.formDirective.removeControl(this);
    }
    /**
     * @description
     * Returns an array that represents the path from the top-level form to this control.
     * Each index is the string name of the control on that level.
     */
    get path() {
        return this._getPath(this.name);
    }
    /**
     * @description
     * The top-level directive for this control if present, otherwise null.
     */
    get formDirective() {
        return this._parent ? this._parent.formDirective : null;
    }
    /**
     * @description
     * Sets the new value for the view model and emits an `ngModelChange` event.
     *
     * @param newValue The new value emitted by `ngModelChange`.
     */
    viewToModelUpdate(newValue) {
        this.viewModel = newValue;
        this.update.emit(newValue);
    }
    _setUpControl() {
        this._setUpdateStrategy();
        this._isStandalone() ? this._setUpStandalone() : this.formDirective.addControl(this);
        this._registered = true;
    }
    _setUpdateStrategy() {
        if (this.options && this.options.updateOn != null) {
            this.control._updateOn = this.options.updateOn;
        }
    }
    _isStandalone() {
        return !this._parent || !!(this.options && this.options.standalone);
    }
    _setUpStandalone() {
        setUpControl(this.control, this, this.callSetDisabledState);
        this.control.updateValueAndValidity({ emitEvent: false });
    }
    _checkForErrors() {
        if (!this._isStandalone()) {
            this._checkParentType();
        }
        this._checkName();
    }
    _checkParentType() {
        if (typeof ngDevMode === 'undefined' || ngDevMode) {
            if (!(this._parent instanceof NgModelGroup) &&
                this._parent instanceof AbstractFormGroupDirective) {
                throw formGroupNameException();
            }
            else if (!(this._parent instanceof NgModelGroup) && !(this._parent instanceof NgForm)) {
                throw modelParentException();
            }
        }
    }
    _checkName() {
        if (this.options && this.options.name)
            this.name = this.options.name;
        if (!this._isStandalone() && !this.name && (typeof ngDevMode === 'undefined' || ngDevMode)) {
            throw missingNameException();
        }
    }
    _updateValue(value) {
        resolvedPromise.then(() => {
            this.control.setValue(value, { emitViewToModelChange: false });
            this._changeDetectorRef?.markForCheck();
        });
    }
    _updateDisabled(changes) {
        const disabledValue = changes['isDisabled'].currentValue;
        // checking for 0 to avoid breaking change
        const isDisabled = disabledValue !== 0 && (0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.booleanAttribute)(disabledValue);
        resolvedPromise.then(() => {
            if (isDisabled && !this.control.disabled) {
                this.control.disable();
            }
            else if (!isDisabled && this.control.disabled) {
                this.control.enable();
            }
            this._changeDetectorRef?.markForCheck();
        });
    }
    _getPath(controlName) {
        return this._parent ? controlPath(controlName, this._parent) : [controlName];
    }
    static { this.fac = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareFactory"]({ minVersion: "12.0.0", version: "17.3.12", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: NgModel, deps: [{ token: ControlContainer, host: true, optional: true }, { token: NG_VALIDATORS, optional: true, self: true }, { token: NG_ASYNC_VALIDATORS, optional: true, self: true }, { token: NG_VALUE_ACCESSOR, optional: true, self: true }, { token: _angular_core__WEBPACK_IMPORTED_MODULE_0__.ChangeDetectorRef, optional: true }, { token: CALL_SET_DISABLED_STATE, optional: true }], target: _angular_core__WEBPACK_IMPORTED_MODULE_0__["FactoryTarget"].Directive }); }
    static { this.dir = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareDirective"]({ minVersion: "14.0.0", version: "17.3.12", type: NgModel, selector: "[ngModel]:not([formControlName]):not([formControl])", inputs: { name: "name", isDisabled: ["disabled", "isDisabled"], model: ["ngModel", "model"], options: ["ngModelOptions", "options"] }, outputs: { update: "ngModelChange" }, providers: [formControlBinding$1], exportAs: ["ngModel"], usesInheritance: true, usesOnChanges: true, ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))) }); }
}
_angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareClassMetadata"]({ minVersion: "12.0.0", version: "17.3.12", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: NgModel, decorators: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Directive,
            args: [{
                    selector: '[ngModel]:not([formControlName]):not([formControl])',
                    providers: [formControlBinding$1],
                    exportAs: 'ngModel'
                }]
        }], ctorParameters: () => [{ type: ControlContainer, decorators: [{
                    type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Optional
                }, {
                    type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Host
                }] }, { type: undefined, decorators: [{
                    type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Optional
                }, {
                    type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Self
                }, {
                    type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Inject,
                    args: [NG_VALIDATORS]
                }] }, { type: undefined, decorators: [{
                    type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Optional
                }, {
                    type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Self
                }, {
                    type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Inject,
                    args: [NG_ASYNC_VALIDATORS]
                }] }, { type: undefined, decorators: [{
                    type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Optional
                }, {
                    type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Self
                }, {
                    type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Inject,
                    args: [NG_VALUE_ACCESSOR]
                }] }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.ChangeDetectorRef, decorators: [{
                    type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Optional
                }, {
                    type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Inject,
                    args: [_angular_core__WEBPACK_IMPORTED_MODULE_0__.ChangeDetectorRef]
                }] }, { type: undefined, decorators: [{
                    type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Optional
                }, {
                    type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Inject,
                    args: [CALL_SET_DISABLED_STATE]
                }] }], propDecorators: { name: [{
                type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input
            }], isDisabled: [{
                type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input,
                args: ['disabled']
            }], model: [{
                type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input,
                args: ['ngModel']
            }], options: [{
                type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input,
                args: ['ngModelOptions']
            }], update: [{
                type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Output,
                args: ['ngModelChange']
            }] } });

/**
 * @description
 *
 * Adds `novalidate` attribute to all forms by default.
 *
 * `novalidate` is used to disable browser's native form validation.
 *
 * If you want to use native validation with Angular forms, just add `ngNativeValidate` attribute:
 *
 * ```
 * <form ngNativeValidate></form>
 * ```
 *
 * @publicApi
 * @ngModule ReactiveFormsModule
 * @ngModule FormsModule
 */
class NgNoValidate {
    static { this.fac = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareFactory"]({ minVersion: "12.0.0", version: "17.3.12", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: NgNoValidate, deps: [], target: _angular_core__WEBPACK_IMPORTED_MODULE_0__["FactoryTarget"].Directive }); }
    static { this.dir = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareDirective"]({ minVersion: "14.0.0", version: "17.3.12", type: NgNoValidate, selector: "form:not([ngNoForm]):not([ngNativeValidate])", host: { attributes: { "novalidate": "" } }, ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))) }); }
}
_angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareClassMetadata"]({ minVersion: "12.0.0", version: "17.3.12", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: NgNoValidate, decorators: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Directive,
            args: [{
                    selector: 'form:not([ngNoForm]):not([ngNativeValidate])',
                    host: { 'novalidate': '' },
                }]
        }] });

const NUMBER_VALUE_ACCESSOR = {
    provide: NG_VALUE_ACCESSOR,
    useExisting: (0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(() => NumberValueAccessor),
    multi: true
};
/**
 * @description
 * The `ControlValueAccessor` for writing a number value and listening to number input changes.
 * The value accessor is used by the `FormControlDirective`, `FormControlName`, and `NgModel`
 * directives.
 *
 * @usageNotes
 *
 * ### Using a number input with a reactive form.
 *
 * The following example shows how to use a number input with a reactive form.
 *
 * ```ts
 * const totalCountControl = new FormControl();
 * ```
 *
 * ```
 * <input type="number" [formControl]="totalCountControl">
 * ```
 *
 * @ngModule ReactiveFormsModule
 * @ngModule FormsModule
 * @publicApi
 */
class NumberValueAccessor extends BuiltInControlValueAccessor {
    /**
     * Sets the "value" property on the input element.
     * @nodoc
     */
    writeValue(value) {
        // The value needs to be normalized for IE9, otherwise it is set to 'null' when null
        const normalizedValue = value == null ? '' : value;
        this.setProperty('value', normalizedValue);
    }
    /**
     * Registers a function called when the control value changes.
     * @nodoc
     */
    registerOnChange(fn) {
        this.onChange = (value) => {
            fn(value == '' ? null : parseFloat(value));
        };
    }
    static { this.fac = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareFactory"]({ minVersion: "12.0.0", version: "17.3.12", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: NumberValueAccessor, deps: null, target: _angular_core__WEBPACK_IMPORTED_MODULE_0__["FactoryTarget"].Directive }); }
    static { this.dir = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareDirective"]({ minVersion: "14.0.0", version: "17.3.12", type: NumberValueAccessor, selector: "input[type=number][formControlName],input[type=number][formControl],input[type=number][ngModel]", host: { listeners: { "input": "onChange($event.target.value)", "blur": "onTouched()" } }, providers: [NUMBER_VALUE_ACCESSOR], usesInheritance: true, ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))) }); }
}
_angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareClassMetadata"]({ minVersion: "12.0.0", version: "17.3.12", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: NumberValueAccessor, decorators: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Directive,
            args: [{
                    selector: 'input[type=number][formControlName],input[type=number][formControl],input[type=number][ngModel]',
                    host: { '(input)': 'onChange($event.target.value)', '(blur)': 'onTouched()' },
                    providers: [NUMBER_VALUE_ACCESSOR]
                }]
        }] });

const RADIO_VALUE_ACCESSOR = {
    provide: NG_VALUE_ACCESSOR,
    useExisting: (0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(() => RadioControlValueAccessor),
    multi: true
};
function throwNameError() {
    throw new _angular_core__WEBPACK_IMPORTED_MODULE_0__["RuntimeError"](1202 /* RuntimeErrorCode.NAME_AND_FORM_CONTROL_NAME_MUST_MATCH */, `
      If you define both a name and a formControlName attribute on your radio button, their values
      must match. Ex: <input type="radio" formControlName="food" name="food">
    `);
}
/**
 * @description
 * Class used by Angular to track radio buttons. For internal use only.
 */
class RadioControlRegistry {
    constructor() {
        this._accessors = [];
    }
    /**
     * @description
     * Adds a control to the internal registry. For internal use only.
     */
    add(control, accessor) {
        this._accessors.push([control, accessor]);
    }
    /**
     * @description
     * Removes a control from the internal registry. For internal use only.
     */
    remove(accessor) {
        for (let i = this._accessors.length - 1; i >= 0; --i) {
            if (this._accessors[i][1] === accessor) {
                this._accessors.splice(i, 1);
                return;
            }
        }
    }
    /**
     * @description
     * Selects a radio button. For internal use only.
     */
    select(accessor) {
        this._accessors.forEach((c) => {
            if (this._isSameGroup(c, accessor) && c[1] !== accessor) {
                c[1].fireUncheck(accessor.value);
            }
        });
    }
    _isSameGroup(controlPair, accessor) {
        if (!controlPair[0].control)
            return false;
        return controlPair[0]._parent === accessor._control._parent &&
            controlPair[1].name === accessor.name;
    }
    static { this.fac = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareFactory"]({ minVersion: "12.0.0", version: "17.3.12", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: RadioControlRegistry, deps: [], target: _angular_core__WEBPACK_IMPORTED_MODULE_0__["FactoryTarget"].Injectable }); }
    static { this.prov = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareInjectable"]({ minVersion: "12.0.0", version: "17.3.12", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: RadioControlRegistry, providedIn: 'root' }); }
}
_angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareClassMetadata"]({ minVersion: "12.0.0", version: "17.3.12", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: RadioControlRegistry, decorators: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Injectable,
            args: [{ providedIn: 'root' }]
        }] });
/**
 * @description
 * The `ControlValueAccessor` for writing radio control values and listening to radio control
 * changes. The value accessor is used by the `FormControlDirective`, `FormControlName`, and
 * `NgModel` directives.
 *
 * @usageNotes
 *
 * ### Using radio buttons with reactive form directives
 *
 * The follow example shows how to use radio buttons in a reactive form. When using radio buttons in
 * a reactive form, radio buttons in the same group should have the same `formControlName`.
 * Providing a `name` attribute is optional.
 *
 * {@example forms/ts/reactiveRadioButtons/reactive_radio_button_example.ts region='Reactive'}
 *
 * @ngModule ReactiveFormsModule
 * @ngModule FormsModule
 * @publicApi
 */
class RadioControlValueAccessor extends BuiltInControlValueAccessor {
    constructor(renderer, elementRef, _registry, _injector) {
        super(renderer, elementRef);
        this._registry = _registry;
        this._injector = _injector;
        this.setDisabledStateFired = false;
        /**
         * The registered callback function called when a change event occurs on the input element.
         * Note: we declare `onChange` here (also used as host listener) as a function with no arguments
         * to override the `onChange` function (which expects 1 argument) in the parent
         * `BaseControlValueAccessor` class.
         * @nodoc
         */
        this.onChange = () => { };
        this.callSetDisabledState = (0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.inject)(CALL_SET_DISABLED_STATE, { optional: true }) ?? setDisabledStateDefault;
    }
    /** @nodoc */
    ngOnInit() {
        this._control = this._injector.get(NgControl);
        this._checkName();
        this._registry.add(this._control, this);
    }
    /** @nodoc */
    ngOnDestroy() {
        this._registry.remove(this);
    }
    /**
     * Sets the "checked" property value on the radio input element.
     * @nodoc
     */
    writeValue(value) {
        this._state = value === this.value;
        this.setProperty('checked', this._state);
    }
    /**
     * Registers a function called when the control value changes.
     * @nodoc
     */
    registerOnChange(fn) {
        this._fn = fn;
        this.onChange = () => {
            fn(this.value);
            this._registry.select(this);
        };
    }
    /** @nodoc */
    setDisabledState(isDisabled) {
        /**
         * `setDisabledState` is supposed to be called whenever the disabled state of a control changes,
         * including upon control creation. However, a longstanding bug caused the method to not fire
         * when an *enabled* control was attached. This bug was fixed in v15 in #47576.
         *
         * This had a side effect: previously, it was possible to instantiate a reactive form control
         * with `[attr.disabled]=true`, even though the corresponding control was enabled in the
         * model. This resulted in a mismatch between the model and the DOM. Now, because
         * `setDisabledState` is always called, the value in the DOM will be immediately overwritten
         * with the "correct" enabled value.
         *
         * However, the fix also created an exceptional case: radio buttons. Because Reactive Forms
         * models the entire group of radio buttons as a single `FormControl`, there is no way to
         * control the disabled state for individual radios, so they can no longer be configured as
         * disabled. Thus, we keep the old behavior for radio buttons, so that `[attr.disabled]`
         * continues to work. Specifically, we drop the first call to `setDisabledState` if `disabled`
         * is `false`, and we are not in legacy mode.
         */
        if (this.setDisabledStateFired || isDisabled ||
            this.callSetDisabledState === 'whenDisabledForLegacyCode') {
            this.setProperty('disabled', isDisabled);
        }
        this.setDisabledStateFired = true;
    }
    /**
     * Sets the "value" on the radio input element and unchecks it.
     *
     * @param value
     */
    fireUncheck(value) {
        this.writeValue(value);
    }
    _checkName() {
        if (this.name && this.formControlName && this.name !== this.formControlName &&
            (typeof ngDevMode === 'undefined' || ngDevMode)) {
            throwNameError();
        }
        if (!this.name && this.formControlName)
            this.name = this.formControlName;
    }
    static { this.fac = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareFactory"]({ minVersion: "12.0.0", version: "17.3.12", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: RadioControlValueAccessor, deps: [{ token: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Renderer2 }, { token: _angular_core__WEBPACK_IMPORTED_MODULE_0__.ElementRef }, { token: RadioControlRegistry }, { token: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Injector }], target: _angular_core__WEBPACK_IMPORTED_MODULE_0__["FactoryTarget"].Directive }); }
    static { this.dir = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareDirective"]({ minVersion: "14.0.0", version: "17.3.12", type: RadioControlValueAccessor, selector: "input[type=radio][formControlName],input[type=radio][formControl],input[type=radio][ngModel]", inputs: { name: "name", formControlName: "formControlName", value: "value" }, host: { listeners: { "change": "onChange()", "blur": "onTouched()" } }, providers: [RADIO_VALUE_ACCESSOR], usesInheritance: true, ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))) }); }
}
_angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareClassMetadata"]({ minVersion: "12.0.0", version: "17.3.12", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: RadioControlValueAccessor, decorators: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Directive,
            args: [{
                    selector: 'input[type=radio][formControlName],input[type=radio][formControl],input[type=radio][ngModel]',
                    host: { '(change)': 'onChange()', '(blur)': 'onTouched()' },
                    providers: [RADIO_VALUE_ACCESSOR]
                }]
        }], ctorParameters: () => [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Renderer2 }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.ElementRef }, { type: RadioControlRegistry }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Injector }], propDecorators: { name: [{
                type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input
            }], formControlName: [{
                type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input
            }], value: [{
                type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input
            }] } });

const RANGE_VALUE_ACCESSOR = {
    provide: NG_VALUE_ACCESSOR,
    useExisting: (0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(() => RangeValueAccessor),
    multi: true
};
/**
 * @description
 * The `ControlValueAccessor` for writing a range value and listening to range input changes.
 * The value accessor is used by the `FormControlDirective`, `FormControlName`, and  `NgModel`
 * directives.
 *
 * @usageNotes
 *
 * ### Using a range input with a reactive form
 *
 * The following example shows how to use a range input with a reactive form.
 *
 * ```ts
 * const ageControl = new FormControl();
 * ```
 *
 * ```
 * <input type="range" [formControl]="ageControl">
 * ```
 *
 * @ngModule ReactiveFormsModule
 * @ngModule FormsModule
 * @publicApi
 */
class RangeValueAccessor extends BuiltInControlValueAccessor {
    /**
     * Sets the "value" property on the input element.
     * @nodoc
     */
    writeValue(value) {
        this.setProperty('value', parseFloat(value));
    }
    /**
     * Registers a function called when the control value changes.
     * @nodoc
     */
    registerOnChange(fn) {
        this.onChange = (value) => {
            fn(value == '' ? null : parseFloat(value));
        };
    }
    static { this.fac = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareFactory"]({ minVersion: "12.0.0", version: "17.3.12", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: RangeValueAccessor, deps: null, target: _angular_core__WEBPACK_IMPORTED_MODULE_0__["FactoryTarget"].Directive }); }
    static { this.dir = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareDirective"]({ minVersion: "14.0.0", version: "17.3.12", type: RangeValueAccessor, selector: "input[type=range][formControlName],input[type=range][formControl],input[type=range][ngModel]", host: { listeners: { "change": "onChange($event.target.value)", "input": "onChange($event.target.value)", "blur": "onTouched()" } }, providers: [RANGE_VALUE_ACCESSOR], usesInheritance: true, ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))) }); }
}
_angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareClassMetadata"]({ minVersion: "12.0.0", version: "17.3.12", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: RangeValueAccessor, decorators: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Directive,
            args: [{
                    selector: 'input[type=range][formControlName],input[type=range][formControl],input[type=range][ngModel]',
                    host: {
                        '(change)': 'onChange($event.target.value)',
                        '(input)': 'onChange($event.target.value)',
                        '(blur)': 'onTouched()'
                    },
                    providers: [RANGE_VALUE_ACCESSOR]
                }]
        }] });

/**
 * Token to provide to turn off the ngModel warning on formControl and formControlName.
 */
const NG_MODEL_WITH_FORM_CONTROL_WARNING = new _angular_core__WEBPACK_IMPORTED_MODULE_0__.InjectionToken(ngDevMode ? 'NgModelWithFormControlWarning' : '');
const formControlBinding = {
    provide: NgControl,
    useExisting: (0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(() => FormControlDirective)
};
/**
 * @description
 * Synchronizes a standalone `FormControl` instance to a form control element.
 *
 * Note that support for using the `ngModel` input property and `ngModelChange` event with reactive
 * form directives was deprecated in Angular v6 and is scheduled for removal in
 * a future version of Angular.
 * For details, see [Deprecated features](guide/deprecations#ngmodel-with-reactive-forms).
 *
 * @see [Reactive Forms Guide](guide/reactive-forms)
 * @see {@link FormControl}
 * @see {@link AbstractControl}
 *
 * @usageNotes
 *
 * The following example shows how to register a standalone control and set its value.
 *
 * {@example forms/ts/simpleFormControl/simple_form_control_example.ts region='Component'}
 *
 * @ngModule ReactiveFormsModule
 * @publicApi
 */
class FormControlDirective extends NgControl {
    /**
     * @description
     * Triggers a warning in dev mode that this input should not be used with reactive forms.
     */
    set isDisabled(isDisabled) {
        if (typeof ngDevMode === 'undefined' || ngDevMode) {
            console.warn(disabledAttrWarning);
        }
    }
    /**
     * @description
     * Static property used to track whether any ngModel warnings have been sent across
     * all instances of FormControlDirective. Used to support warning config of "once".
     *
     * @internal
     */
    static { this._ngModelWarningSentOnce = false; }
    constructor(validators, asyncValidators, valueAccessors, _ngModelWarningConfig, callSetDisabledState) {
        super();
        this._ngModelWarningConfig = _ngModelWarningConfig;
        this.callSetDisabledState = callSetDisabledState;
        /** @deprecated as of v6 */
        this.update = new _angular_core__WEBPACK_IMPORTED_MODULE_0__.EventEmitter();
        /**
         * @description
         * Instance property used to track whether an ngModel warning has been sent out for this
         * particular `FormControlDirective` instance. Used to support warning config of "always".
         *
         * @internal
         */
        this._ngModelWarningSent = false;
        this._setValidators(validators);
        this._setAsyncValidators(asyncValidators);
        this.valueAccessor = selectValueAccessor(this, valueAccessors);
    }
    /** @nodoc */
    ngOnChanges(changes) {
        if (this._isControlChanged(changes)) {
            const previousForm = changes['form'].previousValue;
            if (previousForm) {
                cleanUpControl(previousForm, this, /* validateControlPresenceOnChange */ false);
            }
            setUpControl(this.form, this, this.callSetDisabledState);
            this.form.updateValueAndValidity({ emitEvent: false });
        }
        if (isPropertyUpdated(changes, this.viewModel)) {
            if (typeof ngDevMode === 'undefined' || ngDevMode) {
                _ngModelWarning('formControl', FormControlDirective, this, this._ngModelWarningConfig);
            }
            this.form.setValue(this.model);
            this.viewModel = this.model;
        }
    }
    /** @nodoc */
    ngOnDestroy() {
        if (this.form) {
            cleanUpControl(this.form, this, /* validateControlPresenceOnChange */ false);
        }
    }
    /**
     * @description
     * Returns an array that represents the path from the top-level form to this control.
     * Each index is the string name of the control on that level.
     */
    get path() {
        return [];
    }
    /**
     * @description
     * The `FormControl` bound to this directive.
     */
    get control() {
        return this.form;
    }
    /**
     * @description
     * Sets the new value for the view model and emits an `ngModelChange` event.
     *
     * @param newValue The new value for the view model.
     */
    viewToModelUpdate(newValue) {
        this.viewModel = newValue;
        this.update.emit(newValue);
    }
    _isControlChanged(changes) {
        return changes.hasOwnProperty('form');
    }
    static { this.fac = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareFactory"]({ minVersion: "12.0.0", version: "17.3.12", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: FormControlDirective, deps: [{ token: NG_VALIDATORS, optional: true, self: true }, { token: NG_ASYNC_VALIDATORS, optional: true, self: true }, { token: NG_VALUE_ACCESSOR, optional: true, self: true }, { token: NG_MODEL_WITH_FORM_CONTROL_WARNING, optional: true }, { token: CALL_SET_DISABLED_STATE, optional: true }], target: _angular_core__WEBPACK_IMPORTED_MODULE_0__["FactoryTarget"].Directive }); }
    static { this.dir = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareDirective"]({ minVersion: "14.0.0", version: "17.3.12", type: FormControlDirective, selector: "[formControl]", inputs: { form: ["formControl", "form"], isDisabled: ["disabled", "isDisabled"], model: ["ngModel", "model"] }, outputs: { update: "ngModelChange" }, providers: [formControlBinding], exportAs: ["ngForm"], usesInheritance: true, usesOnChanges: true, ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))) }); }
}
_angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareClassMetadata"]({ minVersion: "12.0.0", version: "17.3.12", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: FormControlDirective, decorators: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Directive,
            args: [{ selector: '[formControl]', providers: [formControlBinding], exportAs: 'ngForm' }]
        }], ctorParameters: () => [{ type: undefined, decorators: [{
                    type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Optional
                }, {
                    type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Self
                }, {
                    type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Inject,
                    args: [NG_VALIDATORS]
                }] }, { type: undefined, decorators: [{
                    type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Optional
                }, {
                    type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Self
                }, {
                    type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Inject,
                    args: [NG_ASYNC_VALIDATORS]
                }] }, { type: undefined, decorators: [{
                    type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Optional
                }, {
                    type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Self
                }, {
                    type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Inject,
                    args: [NG_VALUE_ACCESSOR]
                }] }, { type: undefined, decorators: [{
                    type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Optional
                }, {
                    type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Inject,
                    args: [NG_MODEL_WITH_FORM_CONTROL_WARNING]
                }] }, { type: undefined, decorators: [{
                    type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Optional
                }, {
                    type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Inject,
                    args: [CALL_SET_DISABLED_STATE]
                }] }], propDecorators: { form: [{
                type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input,
                args: ['formControl']
            }], isDisabled: [{
                type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input,
                args: ['disabled']
            }], model: [{
                type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input,
                args: ['ngModel']
            }], update: [{
                type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Output,
                args: ['ngModelChange']
            }] } });

const formDirectiveProvider = {
    provide: ControlContainer,
    useExisting: (0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(() => FormGroupDirective)
};
/**
 * @description
 *
 * Binds an existing `FormGroup` or `FormRecord` to a DOM element.
 *
 * This directive accepts an existing `FormGroup` instance. It will then use this
 * `FormGroup` instance to match any child `FormControl`, `FormGroup`/`FormRecord`,
 * and `FormArray` instances to child `FormControlName`, `FormGroupName`,
 * and `FormArrayName` directives.
 *
 * @see [Reactive Forms Guide](guide/reactive-forms)
 * @see {@link AbstractControl}
 *
 * @usageNotes
 * ### Register Form Group
 *
 * The following example registers a `FormGroup` with first name and last name controls,
 * and listens for the *ngSubmit* event when the button is clicked.
 *
 * {@example forms/ts/simpleFormGroup/simple_form_group_example.ts region='Component'}
 *
 * @ngModule ReactiveFormsModule
 * @publicApi
 */
class FormGroupDirective extends ControlContainer {
    constructor(validators, asyncValidators, callSetDisabledState) {
        super();
        this.callSetDisabledState = callSetDisabledState;
        /**
         * @description
         * Reports whether the form submission has been triggered.
         */
        this.submitted = false;
        /**
         * Callback that should be invoked when controls in FormGroup or FormArray collection change
         * (added or removed). This callback triggers corresponding DOM updates.
         */
        this._onCollectionChange = () => this._updateDomValue();
        /**
         * @description
         * Tracks the list of added `FormControlName` instances
         */
        this.directives = [];
        /**
         * @description
         * Tracks the `FormGroup` bound to this directive.
         */
        this.form = null;
        /**
         * @description
         * Emits an event when the form submission has been triggered.
         */
        this.ngSubmit = new _angular_core__WEBPACK_IMPORTED_MODULE_0__.EventEmitter();
        this._setValidators(validators);
        this._setAsyncValidators(asyncValidators);
    }
    /** @nodoc */
    ngOnChanges(changes) {
        this._checkFormPresent();
        if (changes.hasOwnProperty('form')) {
            this._updateValidators();
            this._updateDomValue();
            this._updateRegistrations();
            this._oldForm = this.form;
        }
    }
    /** @nodoc */
    ngOnDestroy() {
        if (this.form) {
            cleanUpValidators(this.form, this);
            // Currently the `onCollectionChange` callback is rewritten each time the
            // `_registerOnCollectionChange` function is invoked. The implication is that cleanup should
            // happen *only* when the `onCollectionChange` callback was set by this directive instance.
            // Otherwise it might cause overriding a callback of some other directive instances. We should
            // consider updating this logic later to make it similar to how `onChange` callbacks are
            // handled, see https://github.com/angular/angular/issues/39732 for additional info.
            if (this.form._onCollectionChange === this._onCollectionChange) {
                this.form._registerOnCollectionChange(() => { });
            }
        }
    }
    /**
     * @description
     * Returns this directive's instance.
     */
    get formDirective() {
        return this;
    }
    /**
     * @description
     * Returns the `FormGroup` bound to this directive.
     */
    get control() {
        return this.form;
    }
    /**
     * @description
     * Returns an array representing the path to this group. Because this directive
     * always lives at the top level of a form, it always an empty array.
     */
    get path() {
        return [];
    }
    /**
     * @description
     * Method that sets up the control directive in this group, re-calculates its value
     * and validity, and adds the instance to the internal list of directives.
     *
     * @param dir The `FormControlName` directive instance.
     */
    addControl(dir) {
        const ctrl = this.form.get(dir.path);
        setUpControl(ctrl, dir, this.callSetDisabledState);
        ctrl.updateValueAndValidity({ emitEvent: false });
        this.directives.push(dir);
        return ctrl;
    }
    /**
     * @description
     * Retrieves the `FormControl` instance from the provided `FormControlName` directive
     *
     * @param dir The `FormControlName` directive instance.
     */
    getControl(dir) {
        return this.form.get(dir.path);
    }
    /**
     * @description
     * Removes the `FormControlName` instance from the internal list of directives
     *
     * @param dir The `FormControlName` directive instance.
     */
    removeControl(dir) {
        cleanUpControl(dir.control || null, dir, /* validateControlPresenceOnChange */ false);
        removeListItem$1(this.directives, dir);
    }
    /**
     * Adds a new `FormGroupName` directive instance to the form.
     *
     * @param dir The `FormGroupName` directive instance.
     */
    addFormGroup(dir) {
        this._setUpFormContainer(dir);
    }
    /**
     * Performs the necessary cleanup when a `FormGroupName` directive instance is removed from the
     * view.
     *
     * @param dir The `FormGroupName` directive instance.
     */
    removeFormGroup(dir) {
        this._cleanUpFormContainer(dir);
    }
    /**
     * @description
     * Retrieves the `FormGroup` for a provided `FormGroupName` directive instance
     *
     * @param dir The `FormGroupName` directive instance.
     */
    getFormGroup(dir) {
        return this.form.get(dir.path);
    }
    /**
     * Performs the necessary setup when a `FormArrayName` directive instance is added to the view.
     *
     * @param dir The `FormArrayName` directive instance.
     */
    addFormArray(dir) {
        this._setUpFormContainer(dir);
    }
    /**
     * Performs the necessary cleanup when a `FormArrayName` directive instance is removed from the
     * view.
     *
     * @param dir The `FormArrayName` directive instance.
     */
    removeFormArray(dir) {
        this._cleanUpFormContainer(dir);
    }
    /**
     * @description
     * Retrieves the `FormArray` for a provided `FormArrayName` directive instance.
     *
     * @param dir The `FormArrayName` directive instance.
     */
    getFormArray(dir) {
        return this.form.get(dir.path);
    }
    /**
     * Sets the new value for the provided `FormControlName` directive.
     *
     * @param dir The `FormControlName` directive instance.
     * @param value The new value for the directive's control.
     */
    updateModel(dir, value) {
        const ctrl = this.form.get(dir.path);
        ctrl.setValue(value);
    }
    /**
     * @description
     * Method called with the "submit" event is triggered on the form.
     * Triggers the `ngSubmit` emitter to emit the "submit" event as its payload.
     *
     * @param $event The "submit" event object
     */
    onSubmit($event) {
        this.submitted = true;
        syncPendingControls(this.form, this.directives);
        this.ngSubmit.emit($event);
        // Forms with `method="dialog"` have some special behavior that won't reload the page and that
        // shouldn't be prevented. Note that we need to null check the `event` and the `target`, because
        // some internal apps call this method directly with the wrong arguments.
        return $event?.target?.method === 'dialog';
    }
    /**
     * @description
     * Method called when the "reset" event is triggered on the form.
     */
    onReset() {
        this.resetForm();
    }
    /**
     * @description
     * Resets the form to an initial value and resets its submitted status.
     *
     * @param value The new value for the form.
     */
    resetForm(value = undefined) {
        this.form.reset(value);
        this.submitted = false;
    }
    /** @internal */
    _updateDomValue() {
        this.directives.forEach(dir => {
            const oldCtrl = dir.control;
            const newCtrl = this.form.get(dir.path);
            if (oldCtrl !== newCtrl) {
                // Note: the value of the `dir.control` may not be defined, for example when it's a first
                // `FormControl` that is added to a `FormGroup` instance (via `addControl` call).
                cleanUpControl(oldCtrl || null, dir);
                // Check whether new control at the same location inside the corresponding `FormGroup` is an
                // instance of `FormControl` and perform control setup only if that's the case.
                // Note: we don't need to clear the list of directives (`this.directives`) here, it would be
                // taken care of in the `removeControl` method invoked when corresponding `formControlName`
                // directive instance is being removed (invoked from `FormControlName.ngOnDestroy`).
                if (isFormControl(newCtrl)) {
                    setUpControl(newCtrl, dir, this.callSetDisabledState);
                    dir.control = newCtrl;
                }
            }
        });
        this.form._updateTreeValidity({ emitEvent: false });
    }
    _setUpFormContainer(dir) {
        const ctrl = this.form.get(dir.path);
        setUpFormContainer(ctrl, dir);
        // NOTE: this operation looks unnecessary in case no new validators were added in
        // `setUpFormContainer` call. Consider updating this code to match the logic in
        // `_cleanUpFormContainer` function.
        ctrl.updateValueAndValidity({ emitEvent: false });
    }
    _cleanUpFormContainer(dir) {
        if (this.form) {
            const ctrl = this.form.get(dir.path);
            if (ctrl) {
                const isControlUpdated = cleanUpFormContainer(ctrl, dir);
                if (isControlUpdated) {
                    // Run validity check only in case a control was updated (i.e. view validators were
                    // removed) as removing view validators might cause validity to change.
                    ctrl.updateValueAndValidity({ emitEvent: false });
                }
            }
        }
    }
    _updateRegistrations() {
        this.form._registerOnCollectionChange(this._onCollectionChange);
        if (this._oldForm) {
            this._oldForm._registerOnCollectionChange(() => { });
        }
    }
    _updateValidators() {
        setUpValidators(this.form, this);
        if (this._oldForm) {
            cleanUpValidators(this._oldForm, this);
        }
    }
    _checkFormPresent() {
        if (!this.form && (typeof ngDevMode === 'undefined' || ngDevMode)) {
            throw missingFormException();
        }
    }
    static { this.fac = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareFactory"]({ minVersion: "12.0.0", version: "17.3.12", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: FormGroupDirective, deps: [{ token: NG_VALIDATORS, optional: true, self: true }, { token: NG_ASYNC_VALIDATORS, optional: true, self: true }, { token: CALL_SET_DISABLED_STATE, optional: true }], target: _angular_core__WEBPACK_IMPORTED_MODULE_0__["FactoryTarget"].Directive }); }
    static { this.dir = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareDirective"]({ minVersion: "14.0.0", version: "17.3.12", type: FormGroupDirective, selector: "[formGroup]", inputs: { form: ["formGroup", "form"] }, outputs: { ngSubmit: "ngSubmit" }, host: { listeners: { "submit": "onSubmit($event)", "reset": "onReset()" } }, providers: [formDirectiveProvider], exportAs: ["ngForm"], usesInheritance: true, usesOnChanges: true, ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))) }); }
}
_angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareClassMetadata"]({ minVersion: "12.0.0", version: "17.3.12", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: FormGroupDirective, decorators: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Directive,
            args: [{
                    selector: '[formGroup]',
                    providers: [formDirectiveProvider],
                    host: { '(submit)': 'onSubmit($event)', '(reset)': 'onReset()' },
                    exportAs: 'ngForm'
                }]
        }], ctorParameters: () => [{ type: undefined, decorators: [{
                    type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Optional
                }, {
                    type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Self
                }, {
                    type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Inject,
                    args: [NG_VALIDATORS]
                }] }, { type: undefined, decorators: [{
                    type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Optional
                }, {
                    type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Self
                }, {
                    type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Inject,
                    args: [NG_ASYNC_VALIDATORS]
                }] }, { type: undefined, decorators: [{
                    type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Optional
                }, {
                    type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Inject,
                    args: [CALL_SET_DISABLED_STATE]
                }] }], propDecorators: { form: [{
                type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input,
                args: ['formGroup']
            }], ngSubmit: [{
                type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Output
            }] } });

const formGroupNameProvider = {
    provide: ControlContainer,
    useExisting: (0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(() => FormGroupName)
};
/**
 * @description
 *
 * Syncs a nested `FormGroup` or `FormRecord` to a DOM element.
 *
 * This directive can only be used with a parent `FormGroupDirective`.
 *
 * It accepts the string name of the nested `FormGroup` or `FormRecord` to link, and
 * looks for a `FormGroup` or `FormRecord` registered with that name in the parent
 * `FormGroup` instance you passed into `FormGroupDirective`.
 *
 * Use nested form groups to validate a sub-group of a
 * form separately from the rest or to group the values of certain
 * controls into their own nested object.
 *
 * @see [Reactive Forms Guide](guide/reactive-forms)
 *
 * @usageNotes
 *
 * ### Access the group by name
 *
 * The following example uses the `AbstractControl.get` method to access the
 * associated `FormGroup`
 *
 * ```ts
 *   this.form.get('name');
 * ```
 *
 * ### Access individual controls in the group
 *
 * The following example uses the `AbstractControl.get` method to access
 * individual controls within the group using dot syntax.
 *
 * ```ts
 *   this.form.get('name.first');
 * ```
 *
 * ### Register a nested `FormGroup`.
 *
 * The following example registers a nested *name* `FormGroup` within an existing `FormGroup`,
 * and provides methods to retrieve the nested `FormGroup` and individual controls.
 *
 * {@example forms/ts/nestedFormGroup/nested_form_group_example.ts region='Component'}
 *
 * @ngModule ReactiveFormsModule
 * @publicApi
 */
class FormGroupName extends AbstractFormGroupDirective {
    constructor(parent, validators, asyncValidators) {
        super();
        /**
         * @description
         * Tracks the name of the `FormGroup` bound to the directive. The name corresponds
         * to a key in the parent `FormGroup` or `FormArray`.
         * Accepts a name as a string or a number.
         * The name in the form of a string is useful for individual forms,
         * while the numerical form allows for form groups to be bound
         * to indices when iterating over groups in a `FormArray`.
         */
        this.name = null;
        this._parent = parent;
        this._setValidators(validators);
        this._setAsyncValidators(asyncValidators);
    }
    /** @internal */
    _checkParentType() {
        if (_hasInvalidParent(this._parent) && (typeof ngDevMode === 'undefined' || ngDevMode)) {
            throw groupParentException();
        }
    }
    static { this.fac = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareFactory"]({ minVersion: "12.0.0", version: "17.3.12", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: FormGroupName, deps: [{ token: ControlContainer, host: true, optional: true, skipSelf: true }, { token: NG_VALIDATORS, optional: true, self: true }, { token: NG_ASYNC_VALIDATORS, optional: true, self: true }], target: _angular_core__WEBPACK_IMPORTED_MODULE_0__["FactoryTarget"].Directive }); }
    static { this.dir = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareDirective"]({ minVersion: "14.0.0", version: "17.3.12", type: FormGroupName, selector: "[formGroupName]", inputs: { name: ["formGroupName", "name"] }, providers: [formGroupNameProvider], usesInheritance: true, ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))) }); }
}
_angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareClassMetadata"]({ minVersion: "12.0.0", version: "17.3.12", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: FormGroupName, decorators: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Directive,
            args: [{ selector: '[formGroupName]', providers: [formGroupNameProvider] }]
        }], ctorParameters: () => [{ type: ControlContainer, decorators: [{
                    type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Optional
                }, {
                    type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Host
                }, {
                    type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.SkipSelf
                }] }, { type: undefined, decorators: [{
                    type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Optional
                }, {
                    type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Self
                }, {
                    type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Inject,
                    args: [NG_VALIDATORS]
                }] }, { type: undefined, decorators: [{
                    type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Optional
                }, {
                    type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Self
                }, {
                    type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Inject,
                    args: [NG_ASYNC_VALIDATORS]
                }] }], propDecorators: { name: [{
                type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input,
                args: ['formGroupName']
            }] } });
const formArrayNameProvider = {
    provide: ControlContainer,
    useExisting: (0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(() => FormArrayName)
};
/**
 * @description
 *
 * Syncs a nested `FormArray` to a DOM element.
 *
 * This directive is designed to be used with a parent `FormGroupDirective` (selector:
 * `[formGroup]`).
 *
 * It accepts the string name of the nested `FormArray` you want to link, and
 * will look for a `FormArray` registered with that name in the parent
 * `FormGroup` instance you passed into `FormGroupDirective`.
 *
 * @see [Reactive Forms Guide](guide/reactive-forms)
 * @see {@link AbstractControl}
 *
 * @usageNotes
 *
 * ### Example
 *
 * {@example forms/ts/nestedFormArray/nested_form_array_example.ts region='Component'}
 *
 * @ngModule ReactiveFormsModule
 * @publicApi
 */
class FormArrayName extends ControlContainer {
    constructor(parent, validators, asyncValidators) {
        super();
        /**
         * @description
         * Tracks the name of the `FormArray` bound to the directive. The name corresponds
         * to a key in the parent `FormGroup` or `FormArray`.
         * Accepts a name as a string or a number.
         * The name in the form of a string is useful for individual forms,
         * while the numerical form allows for form arrays to be bound
         * to indices when iterating over arrays in a `FormArray`.
         */
        this.name = null;
        this._parent = parent;
        this._setValidators(validators);
        this._setAsyncValidators(asyncValidators);
    }
    /**
     * A lifecycle method called when the directive's inputs are initialized. For internal use only.
     * @throws If the directive does not have a valid parent.
     * @nodoc
     */
    ngOnInit() {
        this._checkParentType();
        this.formDirective.addFormArray(this);
    }
    /**
     * A lifecycle method called before the directive's instance is destroyed. For internal use only.
     * @nodoc
     */
    ngOnDestroy() {
        if (this.formDirective) {
            this.formDirective.removeFormArray(this);
        }
    }
    /**
     * @description
     * The `FormArray` bound to this directive.
     */
    get control() {
        return this.formDirective.getFormArray(this);
    }
    /**
     * @description
     * The top-level directive for this group if present, otherwise null.
     */
    get formDirective() {
        return this._parent ? this._parent.formDirective : null;
    }
    /**
     * @description
     * Returns an array that represents the path from the top-level form to this control.
     * Each index is the string name of the control on that level.
     */
    get path() {
        return controlPath(this.name == null ? this.name : this.name.toString(), this._parent);
    }
    _checkParentType() {
        if (_hasInvalidParent(this._parent) && (typeof ngDevMode === 'undefined' || ngDevMode)) {
            throw arrayParentException();
        }
    }
    static { this.fac = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareFactory"]({ minVersion: "12.0.0", version: "17.3.12", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: FormArrayName, deps: [{ token: ControlContainer, host: true, optional: true, skipSelf: true }, { token: NG_VALIDATORS, optional: true, self: true }, { token: NG_ASYNC_VALIDATORS, optional: true, self: true }], target: _angular_core__WEBPACK_IMPORTED_MODULE_0__["FactoryTarget"].Directive }); }
    static { this.dir = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareDirective"]({ minVersion: "14.0.0", version: "17.3.12", type: FormArrayName, selector: "[formArrayName]", inputs: { name: ["formArrayName", "name"] }, providers: [formArrayNameProvider], usesInheritance: true, ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))) }); }
}
_angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareClassMetadata"]({ minVersion: "12.0.0", version: "17.3.12", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: FormArrayName, decorators: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Directive,
            args: [{ selector: '[formArrayName]', providers: [formArrayNameProvider] }]
        }], ctorParameters: () => [{ type: ControlContainer, decorators: [{
                    type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Optional
                }, {
                    type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Host
                }, {
                    type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.SkipSelf
                }] }, { type: undefined, decorators: [{
                    type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Optional
                }, {
                    type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Self
                }, {
                    type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Inject,
                    args: [NG_VALIDATORS]
                }] }, { type: undefined, decorators: [{
                    type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Optional
                }, {
                    type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Self
                }, {
                    type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Inject,
                    args: [NG_ASYNC_VALIDATORS]
                }] }], propDecorators: { name: [{
                type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input,
                args: ['formArrayName']
            }] } });
function _hasInvalidParent(parent) {
    return !(parent instanceof FormGroupName) && !(parent instanceof FormGroupDirective) &&
        !(parent instanceof FormArrayName);
}

const controlNameBinding = {
    provide: NgControl,
    useExisting: (0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(() => FormControlName)
};
/**
 * @description
 * Syncs a `FormControl` in an existing `FormGroup` to a form control
 * element by name.
 *
 * @see [Reactive Forms Guide](guide/reactive-forms)
 * @see {@link FormControl}
 * @see {@link AbstractControl}
 *
 * @usageNotes
 *
 * ### Register `FormControl` within a group
 *
 * The following example shows how to register multiple form controls within a form group
 * and set their value.
 *
 * {@example forms/ts/simpleFormGroup/simple_form_group_example.ts region='Component'}
 *
 * To see `formControlName` examples with different form control types, see:
 *
 * * Radio buttons: `RadioControlValueAccessor`
 * * Selects: `SelectControlValueAccessor`
 *
 * ### Use with ngModel is deprecated
 *
 * Support for using the `ngModel` input property and `ngModelChange` event with reactive
 * form directives has been deprecated in Angular v6 and is scheduled for removal in
 * a future version of Angular.
 *
 * For details, see [Deprecated features](guide/deprecations#ngmodel-with-reactive-forms).
 *
 * @ngModule ReactiveFormsModule
 * @publicApi
 */
class FormControlName extends NgControl {
    /**
     * @description
     * Triggers a warning in dev mode that this input should not be used with reactive forms.
     */
    set isDisabled(isDisabled) {
        if (typeof ngDevMode === 'undefined' || ngDevMode) {
            console.warn(disabledAttrWarning);
        }
    }
    /**
     * @description
     * Static property used to track whether any ngModel warnings have been sent across
     * all instances of FormControlName. Used to support warning config of "once".
     *
     * @internal
     */
    static { this._ngModelWarningSentOnce = false; }
    constructor(parent, validators, asyncValidators, valueAccessors, _ngModelWarningConfig) {
        super();
        this._ngModelWarningConfig = _ngModelWarningConfig;
        this._added = false;
        /**
         * @description
         * Tracks the name of the `FormControl` bound to the directive. The name corresponds
         * to a key in the parent `FormGroup` or `FormArray`.
         * Accepts a name as a string or a number.
         * The name in the form of a string is useful for individual forms,
         * while the numerical form allows for form controls to be bound
         * to indices when iterating over controls in a `FormArray`.
         */
        this.name = null;
        /** @deprecated as of v6 */
        this.update = new _angular_core__WEBPACK_IMPORTED_MODULE_0__.EventEmitter();
        /**
         * @description
         * Instance property used to track whether an ngModel warning has been sent out for this
         * particular FormControlName instance. Used to support warning config of "always".
         *
         * @internal
         */
        this._ngModelWarningSent = false;
        this._parent = parent;
        this._setValidators(validators);
        this._setAsyncValidators(asyncValidators);
        this.valueAccessor = selectValueAccessor(this, valueAccessors);
    }
    /** @nodoc */
    ngOnChanges(changes) {
        if (!this._added)
            this._setUpControl();
        if (isPropertyUpdated(changes, this.viewModel)) {
            if (typeof ngDevMode === 'undefined' || ngDevMode) {
                _ngModelWarning('formControlName', FormControlName, this, this._ngModelWarningConfig);
            }
            this.viewModel = this.model;
            this.formDirective.updateModel(this, this.model);
        }
    }
    /** @nodoc */
    ngOnDestroy() {
        if (this.formDirective) {
            this.formDirective.removeControl(this);
        }
    }
    /**
     * @description
     * Sets the new value for the view model and emits an `ngModelChange` event.
     *
     * @param newValue The new value for the view model.
     */
    viewToModelUpdate(newValue) {
        this.viewModel = newValue;
        this.update.emit(newValue);
    }
    /**
     * @description
     * Returns an array that represents the path from the top-level form to this control.
     * Each index is the string name of the control on that level.
     */
    get path() {
        return controlPath(this.name == null ? this.name : this.name.toString(), this._parent);
    }
    /**
     * @description
     * The top-level directive for this group if present, otherwise null.
     */
    get formDirective() {
        return this._parent ? this._parent.formDirective : null;
    }
    _checkParentType() {
        if (typeof ngDevMode === 'undefined' || ngDevMode) {
            if (!(this._parent instanceof FormGroupName) &&
                this._parent instanceof AbstractFormGroupDirective) {
                throw ngModelGroupException();
            }
            else if (!(this._parent instanceof FormGroupName) &&
                !(this._parent instanceof FormGroupDirective) &&
                !(this._parent instanceof FormArrayName)) {
                throw controlParentException();
            }
        }
    }
    _setUpControl() {
        this._checkParentType();
        this.control = this.formDirective.addControl(this);
        this._added = true;
    }
    static { this.fac = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareFactory"]({ minVersion: "12.0.0", version: "17.3.12", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: FormControlName, deps: [{ token: ControlContainer, host: true, optional: true, skipSelf: true }, { token: NG_VALIDATORS, optional: true, self: true }, { token: NG_ASYNC_VALIDATORS, optional: true, self: true }, { token: NG_VALUE_ACCESSOR, optional: true, self: true }, { token: NG_MODEL_WITH_FORM_CONTROL_WARNING, optional: true }], target: _angular_core__WEBPACK_IMPORTED_MODULE_0__["FactoryTarget"].Directive }); }
    static { this.dir = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareDirective"]({ minVersion: "14.0.0", version: "17.3.12", type: FormControlName, selector: "[formControlName]", inputs: { name: ["formControlName", "name"], isDisabled: ["disabled", "isDisabled"], model: ["ngModel", "model"] }, outputs: { update: "ngModelChange" }, providers: [controlNameBinding], usesInheritance: true, usesOnChanges: true, ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))) }); }
}
_angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareClassMetadata"]({ minVersion: "12.0.0", version: "17.3.12", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: FormControlName, decorators: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Directive,
            args: [{ selector: '[formControlName]', providers: [controlNameBinding] }]
        }], ctorParameters: () => [{ type: ControlContainer, decorators: [{
                    type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Optional
                }, {
                    type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Host
                }, {
                    type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.SkipSelf
                }] }, { type: undefined, decorators: [{
                    type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Optional
                }, {
                    type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Self
                }, {
                    type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Inject,
                    args: [NG_VALIDATORS]
                }] }, { type: undefined, decorators: [{
                    type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Optional
                }, {
                    type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Self
                }, {
                    type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Inject,
                    args: [NG_ASYNC_VALIDATORS]
                }] }, { type: undefined, decorators: [{
                    type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Optional
                }, {
                    type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Self
                }, {
                    type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Inject,
                    args: [NG_VALUE_ACCESSOR]
                }] }, { type: undefined, decorators: [{
                    type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Optional
                }, {
                    type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Inject,
                    args: [NG_MODEL_WITH_FORM_CONTROL_WARNING]
                }] }], propDecorators: { name: [{
                type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input,
                args: ['formControlName']
            }], isDisabled: [{
                type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input,
                args: ['disabled']
            }], model: [{
                type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input,
                args: ['ngModel']
            }], update: [{
                type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Output,
                args: ['ngModelChange']
            }] } });

const SELECT_VALUE_ACCESSOR = {
    provide: NG_VALUE_ACCESSOR,
    useExisting: (0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(() => SelectControlValueAccessor),
    multi: true
};
function _buildValueString$1(id, value) {
    if (id == null)
        return `${value}`;
    if (value && typeof value === 'object')
        value = 'Object';
    return `${id}: ${value}`.slice(0, 50);
}
function _extractId$1(valueString) {
    return valueString.split(':')[0];
}
/**
 * @description
 * The `ControlValueAccessor` for writing select control values and listening to select control
 * changes. The value accessor is used by the `FormControlDirective`, `FormControlName`, and
 * `NgModel` directives.
 *
 * @usageNotes
 *
 * ### Using select controls in a reactive form
 *
 * The following examples show how to use a select control in a reactive form.
 *
 * {@example forms/ts/reactiveSelectControl/reactive_select_control_example.ts region='Component'}
 *
 * ### Using select controls in a template-driven form
 *
 * To use a select in a template-driven form, simply add an `ngModel` and a `name`
 * attribute to the main `<select>` tag.
 *
 * {@example forms/ts/selectControl/select_control_example.ts region='Component'}
 *
 * ### Customizing option selection
 *
 * Angular uses object identity to select option. It's possible for the identities of items
 * to change while the data does not. This can happen, for example, if the items are produced
 * from an RPC to the server, and that RPC is re-run. Even if the data hasn't changed, the
 * second response will produce objects with different identities.
 *
 * To customize the default option comparison algorithm, `<select>` supports `compareWith` input.
 * `compareWith` takes a **function** which has two arguments: `option1` and `option2`.
 * If `compareWith` is given, Angular selects option by the return value of the function.
 *
 * ```ts
 * const selectedCountriesControl = new FormControl();
 * ```
 *
 * ```
 * <select [compareWith]="compareFn"  [formControl]="selectedCountriesControl">
 *     <option *ngFor="let country of countries" [ngValue]="country">
 *         {{country.name}}
 *     </option>
 * </select>
 *
 * compareFn(c1: Country, c2: Country): boolean {
 *     return c1 && c2 ? c1.id === c2.id : c1 === c2;
 * }
 * ```
 *
 * **Note:** We listen to the 'change' event because 'input' events aren't fired
 * for selects in IE, see:
 * https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/input_event#browser_compatibility
 *
 * @ngModule ReactiveFormsModule
 * @ngModule FormsModule
 * @publicApi
 */
class SelectControlValueAccessor extends BuiltInControlValueAccessor {
    constructor() {
        super(...arguments);
        /** @internal */
        this._optionMap = new Map();
        /** @internal */
        this._idCounter = 0;
        this._compareWith = Object.is;
    }
    /**
     * @description
     * Tracks the option comparison algorithm for tracking identities when
     * checking for changes.
     */
    set compareWith(fn) {
        if (typeof fn !== 'function' && (typeof ngDevMode === 'undefined' || ngDevMode)) {
            throw new _angular_core__WEBPACK_IMPORTED_MODULE_0__["RuntimeError"](1201 /* RuntimeErrorCode.COMPAREWITH_NOT_A_FN */, `compareWith must be a function, but received ${JSON.stringify(fn)}`);
        }
        this._compareWith = fn;
    }
    /**
     * Sets the "value" property on the select element.
     * @nodoc
     */
    writeValue(value) {
        this.value = value;
        const id = this._getOptionId(value);
        const valueString = _buildValueString$1(id, value);
        this.setProperty('value', valueString);
    }
    /**
     * Registers a function called when the control value changes.
     * @nodoc
     */
    registerOnChange(fn) {
        this.onChange = (valueString) => {
            this.value = this._getOptionValue(valueString);
            fn(this.value);
        };
    }
    /** @internal */
    _registerOption() {
        return (this._idCounter++).toString();
    }
    /** @internal */
    _getOptionId(value) {
        for (const id of this._optionMap.keys()) {
            if (this._compareWith(this._optionMap.get(id), value))
                return id;
        }
        return null;
    }
    /** @internal */
    _getOptionValue(valueString) {
        const id = _extractId$1(valueString);
        return this._optionMap.has(id) ? this._optionMap.get(id) : valueString;
    }
    static { this.fac = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareFactory"]({ minVersion: "12.0.0", version: "17.3.12", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: SelectControlValueAccessor, deps: null, target: _angular_core__WEBPACK_IMPORTED_MODULE_0__["FactoryTarget"].Directive }); }
    static { this.dir = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareDirective"]({ minVersion: "14.0.0", version: "17.3.12", type: SelectControlValueAccessor, selector: "select:not([multiple])[formControlName],select:not([multiple])[formControl],select:not([multiple])[ngModel]", inputs: { compareWith: "compareWith" }, host: { listeners: { "change": "onChange($event.target.value)", "blur": "onTouched()" } }, providers: [SELECT_VALUE_ACCESSOR], usesInheritance: true, ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))) }); }
}
_angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareClassMetadata"]({ minVersion: "12.0.0", version: "17.3.12", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: SelectControlValueAccessor, decorators: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Directive,
            args: [{
                    selector: 'select:not([multiple])[formControlName],select:not([multiple])[formControl],select:not([multiple])[ngModel]',
                    host: { '(change)': 'onChange($event.target.value)', '(blur)': 'onTouched()' },
                    providers: [SELECT_VALUE_ACCESSOR]
                }]
        }], propDecorators: { compareWith: [{
                type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input
            }] } });
/**
 * @description
 * Marks `<option>` as dynamic, so Angular can be notified when options change.
 *
 * @see {@link SelectControlValueAccessor}
 *
 * @ngModule ReactiveFormsModule
 * @ngModule FormsModule
 * @publicApi
 */
class NgSelectOption {
    constructor(_element, _renderer, _select) {
        this._element = _element;
        this._renderer = _renderer;
        this._select = _select;
        if (this._select)
            this.id = this._select._registerOption();
    }
    /**
     * @description
     * Tracks the value bound to the option element. Unlike the value binding,
     * ngValue supports binding to objects.
     */
    set ngValue(value) {
        if (this._select == null)
            return;
        this._select._optionMap.set(this.id, value);
        this._setElementValue(_buildValueString$1(this.id, value));
        this._select.writeValue(this._select.value);
    }
    /**
     * @description
     * Tracks simple string values bound to the option element.
     * For objects, use the `ngValue` input binding.
     */
    set value(value) {
        this._setElementValue(value);
        if (this._select)
            this._select.writeValue(this._select.value);
    }
    /** @internal */
    _setElementValue(value) {
        this._renderer.setProperty(this._element.nativeElement, 'value', value);
    }
    /** @nodoc */
    ngOnDestroy() {
        if (this._select) {
            this._select._optionMap.delete(this.id);
            this._select.writeValue(this._select.value);
        }
    }
    static { this.fac = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareFactory"]({ minVersion: "12.0.0", version: "17.3.12", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: NgSelectOption, deps: [{ token: _angular_core__WEBPACK_IMPORTED_MODULE_0__.ElementRef }, { token: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Renderer2 }, { token: SelectControlValueAccessor, host: true, optional: true }], target: _angular_core__WEBPACK_IMPORTED_MODULE_0__["FactoryTarget"].Directive }); }
    static { this.dir = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareDirective"]({ minVersion: "14.0.0", version: "17.3.12", type: NgSelectOption, selector: "option", inputs: { ngValue: "ngValue", value: "value" }, ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))) }); }
}
_angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareClassMetadata"]({ minVersion: "12.0.0", version: "17.3.12", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: NgSelectOption, decorators: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Directive,
            args: [{ selector: 'option' }]
        }], ctorParameters: () => [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.ElementRef }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Renderer2 }, { type: SelectControlValueAccessor, decorators: [{
                    type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Optional
                }, {
                    type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Host
                }] }], propDecorators: { ngValue: [{
                type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input,
                args: ['ngValue']
            }], value: [{
                type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input,
                args: ['value']
            }] } });

const SELECT_MULTIPLE_VALUE_ACCESSOR = {
    provide: NG_VALUE_ACCESSOR,
    useExisting: (0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(() => SelectMultipleControlValueAccessor),
    multi: true
};
function _buildValueString(id, value) {
    if (id == null)
        return `${value}`;
    if (typeof value === 'string')
        value = `'${value}'`;
    if (value && typeof value === 'object')
        value = 'Object';
    return `${id}: ${value}`.slice(0, 50);
}
function _extractId(valueString) {
    return valueString.split(':')[0];
}
/** Mock interface for HTMLCollection */
class HTMLCollection {
}
/**
 * @description
 * The `ControlValueAccessor` for writing multi-select control values and listening to multi-select
 * control changes. The value accessor is used by the `FormControlDirective`, `FormControlName`, and
 * `NgModel` directives.
 *
 * @see {@link SelectControlValueAccessor}
 *
 * @usageNotes
 *
 * ### Using a multi-select control
 *
 * The follow example shows you how to use a multi-select control with a reactive form.
 *
 * ```ts
 * const countryControl = new FormControl();
 * ```
 *
 * ```
 * <select multiple name="countries" [formControl]="countryControl">
 *   <option *ngFor="let country of countries" [ngValue]="country">
 *     {{ country.name }}
 *   </option>
 * </select>
 * ```
 *
 * ### Customizing option selection
 *
 * To customize the default option comparison algorithm, `<select>` supports `compareWith` input.
 * See the `SelectControlValueAccessor` for usage.
 *
 * @ngModule ReactiveFormsModule
 * @ngModule FormsModule
 * @publicApi
 */
class SelectMultipleControlValueAccessor extends BuiltInControlValueAccessor {
    constructor() {
        super(...arguments);
        /** @internal */
        this._optionMap = new Map();
        /** @internal */
        this._idCounter = 0;
        this._compareWith = Object.is;
    }
    /**
     * @description
     * Tracks the option comparison algorithm for tracking identities when
     * checking for changes.
     */
    set compareWith(fn) {
        if (typeof fn !== 'function' && (typeof ngDevMode === 'undefined' || ngDevMode)) {
            throw new _angular_core__WEBPACK_IMPORTED_MODULE_0__["RuntimeError"](1201 /* RuntimeErrorCode.COMPAREWITH_NOT_A_FN */, `compareWith must be a function, but received ${JSON.stringify(fn)}`);
        }
        this._compareWith = fn;
    }
    /**
     * Sets the "value" property on one or of more of the select's options.
     * @nodoc
     */
    writeValue(value) {
        this.value = value;
        let optionSelectedStateSetter;
        if (Array.isArray(value)) {
            // convert values to ids
            const ids = value.map((v) => this._getOptionId(v));
            optionSelectedStateSetter = (opt, o) => {
                opt._setSelected(ids.indexOf(o.toString()) > -1);
            };
        }
        else {
            optionSelectedStateSetter = (opt, o) => {
                opt._setSelected(false);
            };
        }
        this._optionMap.forEach(optionSelectedStateSetter);
    }
    /**
     * Registers a function called when the control value changes
     * and writes an array of the selected options.
     * @nodoc
     */
    registerOnChange(fn) {
        this.onChange = (element) => {
            const selected = [];
            const selectedOptions = element.selectedOptions;
            if (selectedOptions !== undefined) {
                const options = selectedOptions;
                for (let i = 0; i < options.length; i++) {
                    const opt = options[i];
                    const val = this._getOptionValue(opt.value);
                    selected.push(val);
                }
            }
            // Degrade to use `options` when `selectedOptions` property is not available.
            // Note: the `selectedOptions` is available in all supported browsers, but the Domino lib
            // doesn't have it currently, see https://github.com/fgnass/domino/issues/177.
            else {
                const options = element.options;
                for (let i = 0; i < options.length; i++) {
                    const opt = options[i];
                    if (opt.selected) {
                        const val = this._getOptionValue(opt.value);
                        selected.push(val);
                    }
                }
            }
            this.value = selected;
            fn(selected);
        };
    }
    /** @internal */
    _registerOption(value) {
        const id = (this._idCounter++).toString();
        this._optionMap.set(id, value);
        return id;
    }
    /** @internal */
    _getOptionId(value) {
        for (const id of this._optionMap.keys()) {
            if (this._compareWith(this._optionMap.get(id)._value, value))
                return id;
        }
        return null;
    }
    /** @internal */
    _getOptionValue(valueString) {
        const id = _extractId(valueString);
        return this._optionMap.has(id) ? this._optionMap.get(id)._value : valueString;
    }
    static { this.fac = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareFactory"]({ minVersion: "12.0.0", version: "17.3.12", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: SelectMultipleControlValueAccessor, deps: null, target: _angular_core__WEBPACK_IMPORTED_MODULE_0__["FactoryTarget"].Directive }); }
    static { this.dir = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareDirective"]({ minVersion: "14.0.0", version: "17.3.12", type: SelectMultipleControlValueAccessor, selector: "select[multiple][formControlName],select[multiple][formControl],select[multiple][ngModel]", inputs: { compareWith: "compareWith" }, host: { listeners: { "change": "onChange($event.target)", "blur": "onTouched()" } }, providers: [SELECT_MULTIPLE_VALUE_ACCESSOR], usesInheritance: true, ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))) }); }
}
_angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareClassMetadata"]({ minVersion: "12.0.0", version: "17.3.12", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: SelectMultipleControlValueAccessor, decorators: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Directive,
            args: [{
                    selector: 'select[multiple][formControlName],select[multiple][formControl],select[multiple][ngModel]',
                    host: { '(change)': 'onChange($event.target)', '(blur)': 'onTouched()' },
                    providers: [SELECT_MULTIPLE_VALUE_ACCESSOR]
                }]
        }], propDecorators: { compareWith: [{
                type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input
            }] } });
/**
 * @description
 * Marks `<option>` as dynamic, so Angular can be notified when options change.
 *
 * @see {@link SelectMultipleControlValueAccessor}
 *
 * @ngModule ReactiveFormsModule
 * @ngModule FormsModule
 * @publicApi
 */
class NgSelectMultipleOption {
    constructor(_element, _renderer, _select) {
        this._element = _element;
        this._renderer = _renderer;
        this._select = _select;
        if (this._select) {
            this.id = this._select._registerOption(this);
        }
    }
    /**
     * @description
     * Tracks the value bound to the option element. Unlike the value binding,
     * ngValue supports binding to objects.
     */
    set ngValue(value) {
        if (this._select == null)
            return;
        this._value = value;
        this._setElementValue(_buildValueString(this.id, value));
        this._select.writeValue(this._select.value);
    }
    /**
     * @description
     * Tracks simple string values bound to the option element.
     * For objects, use the `ngValue` input binding.
     */
    set value(value) {
        if (this._select) {
            this._value = value;
            this._setElementValue(_buildValueString(this.id, value));
            this._select.writeValue(this._select.value);
        }
        else {
            this._setElementValue(value);
        }
    }
    /** @internal */
    _setElementValue(value) {
        this._renderer.setProperty(this._element.nativeElement, 'value', value);
    }
    /** @internal */
    _setSelected(selected) {
        this._renderer.setProperty(this._element.nativeElement, 'selected', selected);
    }
    /** @nodoc */
    ngOnDestroy() {
        if (this._select) {
            this._select._optionMap.delete(this.id);
            this._select.writeValue(this._select.value);
        }
    }
    static { this.fac = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareFactory"]({ minVersion: "12.0.0", version: "17.3.12", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: NgSelectMultipleOption, deps: [{ token: _angular_core__WEBPACK_IMPORTED_MODULE_0__.ElementRef }, { token: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Renderer2 }, { token: SelectMultipleControlValueAccessor, host: true, optional: true }], target: _angular_core__WEBPACK_IMPORTED_MODULE_0__["FactoryTarget"].Directive }); }
    static { this.dir = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareDirective"]({ minVersion: "14.0.0", version: "17.3.12", type: NgSelectMultipleOption, selector: "option", inputs: { ngValue: "ngValue", value: "value" }, ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))) }); }
}
_angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareClassMetadata"]({ minVersion: "12.0.0", version: "17.3.12", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: NgSelectMultipleOption, decorators: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Directive,
            args: [{ selector: 'option' }]
        }], ctorParameters: () => [{ type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.ElementRef }, { type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Renderer2 }, { type: SelectMultipleControlValueAccessor, decorators: [{
                    type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Optional
                }, {
                    type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Host
                }] }], propDecorators: { ngValue: [{
                type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input,
                args: ['ngValue']
            }], value: [{
                type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input,
                args: ['value']
            }] } });

/**
 * Method that updates string to integer if not already a number
 *
 * @param value The value to convert to integer.
 * @returns value of parameter converted to number or integer.
 */
function toInteger(value) {
    return typeof value === 'number' ? value : parseInt(value, 10);
}
/**
 * Method that ensures that provided value is a float (and converts it to float if needed).
 *
 * @param value The value to convert to float.
 * @returns value of parameter converted to number or float.
 */
function toFloat(value) {
    return typeof value === 'number' ? value : parseFloat(value);
}
/**
 * A base class for Validator-based Directives. The class contains common logic shared across such
 * Directives.
 *
 * For internal use only, this class is not intended for use outside of the Forms package.
 */
class AbstractValidatorDirective {
    constructor() {
        this._validator = nullValidator;
    }
    /** @nodoc */
    ngOnChanges(changes) {
        if (this.inputName in changes) {
            const input = this.normalizeInput(changes[this.inputName].currentValue);
            this._enabled = this.enabled(input);
            this._validator = this._enabled ? this.createValidator(input) : nullValidator;
            if (this._onChange) {
                this._onChange();
            }
        }
    }
    /** @nodoc */
    validate(control) {
        return this._validator(control);
    }
    /** @nodoc */
    registerOnValidatorChange(fn) {
        this._onChange = fn;
    }
    /**
     * @description
     * Determines whether this validator should be active or not based on an input.
     * Base class implementation checks whether an input is defined (if the value is different from
     * `null` and `undefined`). Validator classes that extend this base class can override this
     * function with the logic specific to a particular validator directive.
     */
    enabled(input) {
        return input != null /* both `null` and `undefined` */;
    }
    static { this.fac = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareFactory"]({ minVersion: "12.0.0", version: "17.3.12", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: AbstractValidatorDirective, deps: [], target: _angular_core__WEBPACK_IMPORTED_MODULE_0__["FactoryTarget"].Directive }); }
    static { this.dir = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareDirective"]({ minVersion: "14.0.0", version: "17.3.12", type: AbstractValidatorDirective, usesOnChanges: true, ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))) }); }
}
_angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareClassMetadata"]({ minVersion: "12.0.0", version: "17.3.12", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: AbstractValidatorDirective, decorators: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Directive
        }] });
/**
 * @description
 * Provider which adds `MaxValidator` to the `NG_VALIDATORS` multi-provider list.
 */
const MAX_VALIDATOR = {
    provide: NG_VALIDATORS,
    useExisting: (0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(() => MaxValidator),
    multi: true
};
/**
 * A directive which installs the {@link MaxValidator} for any `formControlName`,
 * `formControl`, or control with `ngModel` that also has a `max` attribute.
 *
 * @see [Form Validation](guide/form-validation)
 *
 * @usageNotes
 *
 * ### Adding a max validator
 *
 * The following example shows how to add a max validator to an input attached to an
 * ngModel binding.
 *
 * ```html
 * <input type="number" ngModel max="4">
 * ```
 *
 * @ngModule ReactiveFormsModule
 * @ngModule FormsModule
 * @publicApi
 */
class MaxValidator extends AbstractValidatorDirective {
    constructor() {
        super(...arguments);
        /** @internal */
        this.inputName = 'max';
        /** @internal */
        this.normalizeInput = (input) => toFloat(input);
        /** @internal */
        this.createValidator = (max) => maxValidator(max);
    }
    static { this.fac = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareFactory"]({ minVersion: "12.0.0", version: "17.3.12", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: MaxValidator, deps: null, target: _angular_core__WEBPACK_IMPORTED_MODULE_0__["FactoryTarget"].Directive }); }
    static { this.dir = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareDirective"]({ minVersion: "14.0.0", version: "17.3.12", type: MaxValidator, selector: "input[type=number][max][formControlName],input[type=number][max][formControl],input[type=number][max][ngModel]", inputs: { max: "max" }, host: { properties: { "attr.max": "_enabled ? max : null" } }, providers: [MAX_VALIDATOR], usesInheritance: true, ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))) }); }
}
_angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareClassMetadata"]({ minVersion: "12.0.0", version: "17.3.12", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: MaxValidator, decorators: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Directive,
            args: [{
                    selector: 'input[type=number][max][formControlName],input[type=number][max][formControl],input[type=number][max][ngModel]',
                    providers: [MAX_VALIDATOR],
                    host: { '[attr.max]': '_enabled ? max : null' }
                }]
        }], propDecorators: { max: [{
                type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input
            }] } });
/**
 * @description
 * Provider which adds `MinValidator` to the `NG_VALIDATORS` multi-provider list.
 */
const MIN_VALIDATOR = {
    provide: NG_VALIDATORS,
    useExisting: (0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(() => MinValidator),
    multi: true
};
/**
 * A directive which installs the {@link MinValidator} for any `formControlName`,
 * `formControl`, or control with `ngModel` that also has a `min` attribute.
 *
 * @see [Form Validation](guide/form-validation)
 *
 * @usageNotes
 *
 * ### Adding a min validator
 *
 * The following example shows how to add a min validator to an input attached to an
 * ngModel binding.
 *
 * ```html
 * <input type="number" ngModel min="4">
 * ```
 *
 * @ngModule ReactiveFormsModule
 * @ngModule FormsModule
 * @publicApi
 */
class MinValidator extends AbstractValidatorDirective {
    constructor() {
        super(...arguments);
        /** @internal */
        this.inputName = 'min';
        /** @internal */
        this.normalizeInput = (input) => toFloat(input);
        /** @internal */
        this.createValidator = (min) => minValidator(min);
    }
    static { this.fac = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareFactory"]({ minVersion: "12.0.0", version: "17.3.12", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: MinValidator, deps: null, target: _angular_core__WEBPACK_IMPORTED_MODULE_0__["FactoryTarget"].Directive }); }
    static { this.dir = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareDirective"]({ minVersion: "14.0.0", version: "17.3.12", type: MinValidator, selector: "input[type=number][min][formControlName],input[type=number][min][formControl],input[type=number][min][ngModel]", inputs: { min: "min" }, host: { properties: { "attr.min": "_enabled ? min : null" } }, providers: [MIN_VALIDATOR], usesInheritance: true, ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))) }); }
}
_angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareClassMetadata"]({ minVersion: "12.0.0", version: "17.3.12", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: MinValidator, decorators: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Directive,
            args: [{
                    selector: 'input[type=number][min][formControlName],input[type=number][min][formControl],input[type=number][min][ngModel]',
                    providers: [MIN_VALIDATOR],
                    host: { '[attr.min]': '_enabled ? min : null' }
                }]
        }], propDecorators: { min: [{
                type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input
            }] } });
/**
 * @description
 * Provider which adds `RequiredValidator` to the `NG_VALIDATORS` multi-provider list.
 */
const REQUIRED_VALIDATOR = {
    provide: NG_VALIDATORS,
    useExisting: (0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(() => RequiredValidator),
    multi: true
};
/**
 * @description
 * Provider which adds `CheckboxRequiredValidator` to the `NG_VALIDATORS` multi-provider list.
 */
const CHECKBOX_REQUIRED_VALIDATOR = {
    provide: NG_VALIDATORS,
    useExisting: (0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(() => CheckboxRequiredValidator),
    multi: true
};
/**
 * @description
 * A directive that adds the `required` validator to any controls marked with the
 * `required` attribute. The directive is provided with the `NG_VALIDATORS` multi-provider list.
 *
 * @see [Form Validation](guide/form-validation)
 *
 * @usageNotes
 *
 * ### Adding a required validator using template-driven forms
 *
 * ```
 * <input name="fullName" ngModel required>
 * ```
 *
 * @ngModule FormsModule
 * @ngModule ReactiveFormsModule
 * @publicApi
 */
class RequiredValidator extends AbstractValidatorDirective {
    constructor() {
        super(...arguments);
        /** @internal */
        this.inputName = 'required';
        /** @internal */
        this.normalizeInput = _angular_core__WEBPACK_IMPORTED_MODULE_0__.booleanAttribute;
        /** @internal */
        this.createValidator = (input) => requiredValidator;
    }
    /** @nodoc */
    enabled(input) {
        return input;
    }
    static { this.fac = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareFactory"]({ minVersion: "12.0.0", version: "17.3.12", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: RequiredValidator, deps: null, target: _angular_core__WEBPACK_IMPORTED_MODULE_0__["FactoryTarget"].Directive }); }
    static { this.dir = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareDirective"]({ minVersion: "14.0.0", version: "17.3.12", type: RequiredValidator, selector: ":not([type=checkbox])[required][formControlName],:not([type=checkbox])[required][formControl],:not([type=checkbox])[required][ngModel]", inputs: { required: "required" }, host: { properties: { "attr.required": "_enabled ? \"\" : null" } }, providers: [REQUIRED_VALIDATOR], usesInheritance: true, ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))) }); }
}
_angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareClassMetadata"]({ minVersion: "12.0.0", version: "17.3.12", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: RequiredValidator, decorators: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Directive,
            args: [{
                    selector: ':not([type=checkbox])[required][formControlName],:not([type=checkbox])[required][formControl],:not([type=checkbox])[required][ngModel]',
                    providers: [REQUIRED_VALIDATOR],
                    host: { '[attr.required]': '_enabled ? "" : null' }
                }]
        }], propDecorators: { required: [{
                type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input
            }] } });
/**
 * A Directive that adds the `required` validator to checkbox controls marked with the
 * `required` attribute. The directive is provided with the `NG_VALIDATORS` multi-provider list.
 *
 * @see [Form Validation](guide/form-validation)
 *
 * @usageNotes
 *
 * ### Adding a required checkbox validator using template-driven forms
 *
 * The following example shows how to add a checkbox required validator to an input attached to an
 * ngModel binding.
 *
 * ```
 * <input type="checkbox" name="active" ngModel required>
 * ```
 *
 * @publicApi
 * @ngModule FormsModule
 * @ngModule ReactiveFormsModule
 */
class CheckboxRequiredValidator extends RequiredValidator {
    constructor() {
        super(...arguments);
        /** @internal */
        this.createValidator = (input) => requiredTrueValidator;
    }
    static { this.fac = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareFactory"]({ minVersion: "12.0.0", version: "17.3.12", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: CheckboxRequiredValidator, deps: null, target: _angular_core__WEBPACK_IMPORTED_MODULE_0__["FactoryTarget"].Directive }); }
    static { this.dir = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareDirective"]({ minVersion: "14.0.0", version: "17.3.12", type: CheckboxRequiredValidator, selector: "input[type=checkbox][required][formControlName],input[type=checkbox][required][formControl],input[type=checkbox][required][ngModel]", host: { properties: { "attr.required": "_enabled ? \"\" : null" } }, providers: [CHECKBOX_REQUIRED_VALIDATOR], usesInheritance: true, ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))) }); }
}
_angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareClassMetadata"]({ minVersion: "12.0.0", version: "17.3.12", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: CheckboxRequiredValidator, decorators: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Directive,
            args: [{
                    selector: 'input[type=checkbox][required][formControlName],input[type=checkbox][required][formControl],input[type=checkbox][required][ngModel]',
                    providers: [CHECKBOX_REQUIRED_VALIDATOR],
                    host: { '[attr.required]': '_enabled ? "" : null' }
                }]
        }] });
/**
 * @description
 * Provider which adds `EmailValidator` to the `NG_VALIDATORS` multi-provider list.
 */
const EMAIL_VALIDATOR = {
    provide: NG_VALIDATORS,
    useExisting: (0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(() => EmailValidator),
    multi: true
};
/**
 * A directive that adds the `email` validator to controls marked with the
 * `email` attribute. The directive is provided with the `NG_VALIDATORS` multi-provider list.
 *
 * The email validation is based on the WHATWG HTML specification with some enhancements to
 * incorporate more RFC rules. More information can be found on the [Validators.email
 * page](api/forms/Validators#email).
 *
 * @see [Form Validation](guide/form-validation)
 *
 * @usageNotes
 *
 * ### Adding an email validator
 *
 * The following example shows how to add an email validator to an input attached to an ngModel
 * binding.
 *
 * ```
 * <input type="email" name="email" ngModel email>
 * <input type="email" name="email" ngModel email="true">
 * <input type="email" name="email" ngModel [email]="true">
 * ```
 *
 * @publicApi
 * @ngModule FormsModule
 * @ngModule ReactiveFormsModule
 */
class EmailValidator extends AbstractValidatorDirective {
    constructor() {
        super(...arguments);
        /** @internal */
        this.inputName = 'email';
        /** @internal */
        this.normalizeInput = _angular_core__WEBPACK_IMPORTED_MODULE_0__.booleanAttribute;
        /** @internal */
        this.createValidator = (input) => emailValidator;
    }
    /** @nodoc */
    enabled(input) {
        return input;
    }
    static { this.fac = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareFactory"]({ minVersion: "12.0.0", version: "17.3.12", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: EmailValidator, deps: null, target: _angular_core__WEBPACK_IMPORTED_MODULE_0__["FactoryTarget"].Directive }); }
    static { this.dir = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareDirective"]({ minVersion: "14.0.0", version: "17.3.12", type: EmailValidator, selector: "[email][formControlName],[email][formControl],[email][ngModel]", inputs: { email: "email" }, providers: [EMAIL_VALIDATOR], usesInheritance: true, ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))) }); }
}
_angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareClassMetadata"]({ minVersion: "12.0.0", version: "17.3.12", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: EmailValidator, decorators: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Directive,
            args: [{
                    selector: '[email][formControlName],[email][formControl],[email][ngModel]',
                    providers: [EMAIL_VALIDATOR]
                }]
        }], propDecorators: { email: [{
                type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input
            }] } });
/**
 * @description
 * Provider which adds `MinLengthValidator` to the `NG_VALIDATORS` multi-provider list.
 */
const MIN_LENGTH_VALIDATOR = {
    provide: NG_VALIDATORS,
    useExisting: (0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(() => MinLengthValidator),
    multi: true
};
/**
 * A directive that adds minimum length validation to controls marked with the
 * `minlength` attribute. The directive is provided with the `NG_VALIDATORS` multi-provider list.
 *
 * @see [Form Validation](guide/form-validation)
 *
 * @usageNotes
 *
 * ### Adding a minimum length validator
 *
 * The following example shows how to add a minimum length validator to an input attached to an
 * ngModel binding.
 *
 * ```html
 * <input name="firstName" ngModel minlength="4">
 * ```
 *
 * @ngModule ReactiveFormsModule
 * @ngModule FormsModule
 * @publicApi
 */
class MinLengthValidator extends AbstractValidatorDirective {
    constructor() {
        super(...arguments);
        /** @internal */
        this.inputName = 'minlength';
        /** @internal */
        this.normalizeInput = (input) => toInteger(input);
        /** @internal */
        this.createValidator = (minlength) => minLengthValidator(minlength);
    }
    static { this.fac = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareFactory"]({ minVersion: "12.0.0", version: "17.3.12", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: MinLengthValidator, deps: null, target: _angular_core__WEBPACK_IMPORTED_MODULE_0__["FactoryTarget"].Directive }); }
    static { this.dir = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareDirective"]({ minVersion: "14.0.0", version: "17.3.12", type: MinLengthValidator, selector: "[minlength][formControlName],[minlength][formControl],[minlength][ngModel]", inputs: { minlength: "minlength" }, host: { properties: { "attr.minlength": "_enabled ? minlength : null" } }, providers: [MIN_LENGTH_VALIDATOR], usesInheritance: true, ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))) }); }
}
_angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareClassMetadata"]({ minVersion: "12.0.0", version: "17.3.12", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: MinLengthValidator, decorators: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Directive,
            args: [{
                    selector: '[minlength][formControlName],[minlength][formControl],[minlength][ngModel]',
                    providers: [MIN_LENGTH_VALIDATOR],
                    host: { '[attr.minlength]': '_enabled ? minlength : null' }
                }]
        }], propDecorators: { minlength: [{
                type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input
            }] } });
/**
 * @description
 * Provider which adds `MaxLengthValidator` to the `NG_VALIDATORS` multi-provider list.
 */
const MAX_LENGTH_VALIDATOR = {
    provide: NG_VALIDATORS,
    useExisting: (0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(() => MaxLengthValidator),
    multi: true
};
/**
 * A directive that adds maximum length validation to controls marked with the
 * `maxlength` attribute. The directive is provided with the `NG_VALIDATORS` multi-provider list.
 *
 * @see [Form Validation](guide/form-validation)
 *
 * @usageNotes
 *
 * ### Adding a maximum length validator
 *
 * The following example shows how to add a maximum length validator to an input attached to an
 * ngModel binding.
 *
 * ```html
 * <input name="firstName" ngModel maxlength="25">
 * ```
 *
 * @ngModule ReactiveFormsModule
 * @ngModule FormsModule
 * @publicApi
 */
class MaxLengthValidator extends AbstractValidatorDirective {
    constructor() {
        super(...arguments);
        /** @internal */
        this.inputName = 'maxlength';
        /** @internal */
        this.normalizeInput = (input) => toInteger(input);
        /** @internal */
        this.createValidator = (maxlength) => maxLengthValidator(maxlength);
    }
    static { this.fac = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareFactory"]({ minVersion: "12.0.0", version: "17.3.12", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: MaxLengthValidator, deps: null, target: _angular_core__WEBPACK_IMPORTED_MODULE_0__["FactoryTarget"].Directive }); }
    static { this.dir = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareDirective"]({ minVersion: "14.0.0", version: "17.3.12", type: MaxLengthValidator, selector: "[maxlength][formControlName],[maxlength][formControl],[maxlength][ngModel]", inputs: { maxlength: "maxlength" }, host: { properties: { "attr.maxlength": "_enabled ? maxlength : null" } }, providers: [MAX_LENGTH_VALIDATOR], usesInheritance: true, ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))) }); }
}
_angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareClassMetadata"]({ minVersion: "12.0.0", version: "17.3.12", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: MaxLengthValidator, decorators: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Directive,
            args: [{
                    selector: '[maxlength][formControlName],[maxlength][formControl],[maxlength][ngModel]',
                    providers: [MAX_LENGTH_VALIDATOR],
                    host: { '[attr.maxlength]': '_enabled ? maxlength : null' }
                }]
        }], propDecorators: { maxlength: [{
                type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input
            }] } });
/**
 * @description
 * Provider which adds `PatternValidator` to the `NG_VALIDATORS` multi-provider list.
 */
const PATTERN_VALIDATOR = {
    provide: NG_VALIDATORS,
    useExisting: (0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(() => PatternValidator),
    multi: true
};
/**
 * @description
 * A directive that adds regex pattern validation to controls marked with the
 * `pattern` attribute. The regex must match the entire control value.
 * The directive is provided with the `NG_VALIDATORS` multi-provider list.
 *
 * @see [Form Validation](guide/form-validation)
 *
 * @usageNotes
 *
 * ### Adding a pattern validator
 *
 * The following example shows how to add a pattern validator to an input attached to an
 * ngModel binding.
 *
 * ```html
 * <input name="firstName" ngModel pattern="[a-zA-Z ]*">
 * ```
 *
 * @ngModule ReactiveFormsModule
 * @ngModule FormsModule
 * @publicApi
 */
class PatternValidator extends AbstractValidatorDirective {
    constructor() {
        super(...arguments);
        /** @internal */
        this.inputName = 'pattern';
        /** @internal */
        this.normalizeInput = (input) => input;
        /** @internal */
        this.createValidator = (input) => patternValidator(input);
    }
    static { this.fac = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareFactory"]({ minVersion: "12.0.0", version: "17.3.12", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: PatternValidator, deps: null, target: _angular_core__WEBPACK_IMPORTED_MODULE_0__["FactoryTarget"].Directive }); }
    static { this.dir = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareDirective"]({ minVersion: "14.0.0", version: "17.3.12", type: PatternValidator, selector: "[pattern][formControlName],[pattern][formControl],[pattern][ngModel]", inputs: { pattern: "pattern" }, host: { properties: { "attr.pattern": "_enabled ? pattern : null" } }, providers: [PATTERN_VALIDATOR], usesInheritance: true, ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))) }); }
}
_angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareClassMetadata"]({ minVersion: "12.0.0", version: "17.3.12", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: PatternValidator, decorators: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Directive,
            args: [{
                    selector: '[pattern][formControlName],[pattern][formControl],[pattern][ngModel]',
                    providers: [PATTERN_VALIDATOR],
                    host: { '[attr.pattern]': '_enabled ? pattern : null' }
                }]
        }], propDecorators: { pattern: [{
                type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input
            }] } });

const SHARED_FORM_DIRECTIVES = [
    NgNoValidate,
    NgSelectOption,
    NgSelectMultipleOption,
    DefaultValueAccessor,
    NumberValueAccessor,
    RangeValueAccessor,
    CheckboxControlValueAccessor,
    SelectControlValueAccessor,
    SelectMultipleControlValueAccessor,
    RadioControlValueAccessor,
    NgControlStatus,
    NgControlStatusGroup,
    RequiredValidator,
    MinLengthValidator,
    MaxLengthValidator,
    PatternValidator,
    CheckboxRequiredValidator,
    EmailValidator,
    MinValidator,
    MaxValidator,
];
const TEMPLATE_DRIVEN_DIRECTIVES = [NgModel, NgModelGroup, NgForm];
const REACTIVE_DRIVEN_DIRECTIVES = [FormControlDirective, FormGroupDirective, FormControlName, FormGroupName, FormArrayName];
/**
 * Internal module used for sharing directives between FormsModule and ReactiveFormsModule
 */
class InternalFormsSharedModule {
    static { this.fac = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareFactory"]({ minVersion: "12.0.0", version: "17.3.12", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: InternalFormsSharedModule, deps: [], target: _angular_core__WEBPACK_IMPORTED_MODULE_0__["FactoryTarget"].NgModule }); }
    static { this.mod = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareNgModule"]({ minVersion: "14.0.0", version: "17.3.12", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: InternalFormsSharedModule, declarations: [NgNoValidate,
            NgSelectOption,
            NgSelectMultipleOption,
            DefaultValueAccessor,
            NumberValueAccessor,
            RangeValueAccessor,
            CheckboxControlValueAccessor,
            SelectControlValueAccessor,
            SelectMultipleControlValueAccessor,
            RadioControlValueAccessor,
            NgControlStatus,
            NgControlStatusGroup,
            RequiredValidator,
            MinLengthValidator,
            MaxLengthValidator,
            PatternValidator,
            CheckboxRequiredValidator,
            EmailValidator,
            MinValidator,
            MaxValidator], exports: [NgNoValidate,
            NgSelectOption,
            NgSelectMultipleOption,
            DefaultValueAccessor,
            NumberValueAccessor,
            RangeValueAccessor,
            CheckboxControlValueAccessor,
            SelectControlValueAccessor,
            SelectMultipleControlValueAccessor,
            RadioControlValueAccessor,
            NgControlStatus,
            NgControlStatusGroup,
            RequiredValidator,
            MinLengthValidator,
            MaxLengthValidator,
            PatternValidator,
            CheckboxRequiredValidator,
            EmailValidator,
            MinValidator,
            MaxValidator] }); }
    static { this.inj = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareInjector"]({ minVersion: "12.0.0", version: "17.3.12", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: InternalFormsSharedModule }); }
}
_angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareClassMetadata"]({ minVersion: "12.0.0", version: "17.3.12", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: InternalFormsSharedModule, decorators: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.NgModule,
            args: [{
                    declarations: SHARED_FORM_DIRECTIVES,
                    exports: SHARED_FORM_DIRECTIVES,
                }]
        }] });

/**
 * Tracks the value and validity state of an array of `FormControl`,
 * `FormGroup` or `FormArray` instances.
 *
 * A `FormArray` aggregates the values of each child `FormControl` into an array.
 * It calculates its status by reducing the status values of its children. For example, if one of
 * the controls in a `FormArray` is invalid, the entire array becomes invalid.
 *
 * `FormArray` accepts one generic argument, which is the type of the controls inside.
 * If you need a heterogenous array, use {@link UntypedFormArray}.
 *
 * `FormArray` is one of the four fundamental building blocks used to define forms in Angular,
 * along with `FormControl`, `FormGroup`, and `FormRecord`.
 *
 * @usageNotes
 *
 * ### Create an array of form controls
 *
 * ```
 * const arr = new FormArray([
 *   new FormControl('Nancy', Validators.minLength(2)),
 *   new FormControl('Drew'),
 * ]);
 *
 * console.log(arr.value);   // ['Nancy', 'Drew']
 * console.log(arr.status);  // 'VALID'
 * ```
 *
 * ### Create a form array with array-level validators
 *
 * You include array-level validators and async validators. These come in handy
 * when you want to perform validation that considers the value of more than one child
 * control.
 *
 * The two types of validators are passed in separately as the second and third arg
 * respectively, or together as part of an options object.
 *
 * ```
 * const arr = new FormArray([
 *   new FormControl('Nancy'),
 *   new FormControl('Drew')
 * ], {validators: myValidator, asyncValidators: myAsyncValidator});
 * ```
 *
 * ### Set the updateOn property for all controls in a form array
 *
 * The options object is used to set a default value for each child
 * control's `updateOn` property. If you set `updateOn` to `'blur'` at the
 * array level, all child controls default to 'blur', unless the child
 * has explicitly specified a different `updateOn` value.
 *
 * ```ts
 * const arr = new FormArray([
 *    new FormControl()
 * ], {updateOn: 'blur'});
 * ```
 *
 * ### Adding or removing controls from a form array
 *
 * To change the controls in the array, use the `push`, `insert`, `removeAt` or `clear` methods
 * in `FormArray` itself. These methods ensure the controls are properly tracked in the
 * form's hierarchy. Do not modify the array of `AbstractControl`s used to instantiate
 * the `FormArray` directly, as that result in strange and unexpected behavior such
 * as broken change detection.
 *
 * @publicApi
 */
class FormArray extends AbstractControl {
    /**
     * Creates a new `FormArray` instance.
     *
     * @param controls An array of child controls. Each child control is given an index
     * where it is registered.
     *
     * @param validatorOrOpts A synchronous validator function, or an array of
     * such functions, or an `AbstractControlOptions` object that contains validation functions
     * and a validation trigger.
     *
     * @param asyncValidator A single async validator or array of async validator functions
     *
     */
    constructor(controls, validatorOrOpts, asyncValidator) {
        super(pickValidators(validatorOrOpts), pickAsyncValidators(asyncValidator, validatorOrOpts));
        this.controls = controls;
        this._initObservables();
        this._setUpdateStrategy(validatorOrOpts);
        this._setUpControls();
        this.updateValueAndValidity({
            onlySelf: true,
            // If `asyncValidator` is present, it will trigger control status change from `PENDING` to
            // `VALID` or `INVALID`.
            // The status should be broadcasted via the `statusChanges` observable, so we set `emitEvent`
            // to `true` to allow that during the control creation process.
            emitEvent: !!this.asyncValidator
        });
    }
    /**
     * Get the `AbstractControl` at the given `index` in the array.
     *
     * @param index Index in the array to retrieve the control. If `index` is negative, it will wrap
     *     around from the back, and if index is greatly negative (less than `-length`), the result is
     * undefined. This behavior is the same as `Array.at(index)`.
     */
    at(index) {
        return this.controls[this._adjustIndex(index)];
    }
    /**
     * Insert a new `AbstractControl` at the end of the array.
     *
     * @param control Form control to be inserted
     * @param options Specifies whether this FormArray instance should emit events after a new
     *     control is added.
     * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and
     * `valueChanges` observables emit events with the latest status and value when the control is
     * inserted. When false, no events are emitted.
     */
    push(control, options = {}) {
        this.controls.push(control);
        this._registerControl(control);
        this.updateValueAndValidity({ emitEvent: options.emitEvent });
        this._onCollectionChange();
    }
    /**
     * Insert a new `AbstractControl` at the given `index` in the array.
     *
     * @param index Index in the array to insert the control. If `index` is negative, wraps around
     *     from the back. If `index` is greatly negative (less than `-length`), prepends to the array.
     * This behavior is the same as `Array.splice(index, 0, control)`.
     * @param control Form control to be inserted
     * @param options Specifies whether this FormArray instance should emit events after a new
     *     control is inserted.
     * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and
     * `valueChanges` observables emit events with the latest status and value when the control is
     * inserted. When false, no events are emitted.
     */
    insert(index, control, options = {}) {
        this.controls.splice(index, 0, control);
        this._registerControl(control);
        this.updateValueAndValidity({ emitEvent: options.emitEvent });
    }
    /**
     * Remove the control at the given `index` in the array.
     *
     * @param index Index in the array to remove the control.  If `index` is negative, wraps around
     *     from the back. If `index` is greatly negative (less than `-length`), removes the first
     *     element. This behavior is the same as `Array.splice(index, 1)`.
     * @param options Specifies whether this FormArray instance should emit events after a
     *     control is removed.
     * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and
     * `valueChanges` observables emit events with the latest status and value when the control is
     * removed. When false, no events are emitted.
     */
    removeAt(index, options = {}) {
        // Adjust the index, then clamp it at no less than 0 to prevent undesired underflows.
        let adjustedIndex = this._adjustIndex(index);
        if (adjustedIndex < 0)
            adjustedIndex = 0;
        if (this.controls[adjustedIndex])
            this.controls[adjustedIndex]._registerOnCollectionChange(() => { });
        this.controls.splice(adjustedIndex, 1);
        this.updateValueAndValidity({ emitEvent: options.emitEvent });
    }
    /**
     * Replace an existing control.
     *
     * @param index Index in the array to replace the control. If `index` is negative, wraps around
     *     from the back. If `index` is greatly negative (less than `-length`), replaces the first
     *     element. This behavior is the same as `Array.splice(index, 1, control)`.
     * @param control The `AbstractControl` control to replace the existing control
     * @param options Specifies whether this FormArray instance should emit events after an
     *     existing control is replaced with a new one.
     * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and
     * `valueChanges` observables emit events with the latest status and value when the control is
     * replaced with a new one. When false, no events are emitted.
     */
    setControl(index, control, options = {}) {
        // Adjust the index, then clamp it at no less than 0 to prevent undesired underflows.
        let adjustedIndex = this._adjustIndex(index);
        if (adjustedIndex < 0)
            adjustedIndex = 0;
        if (this.controls[adjustedIndex])
            this.controls[adjustedIndex]._registerOnCollectionChange(() => { });
        this.controls.splice(adjustedIndex, 1);
        if (control) {
            this.controls.splice(adjustedIndex, 0, control);
            this._registerControl(control);
        }
        this.updateValueAndValidity({ emitEvent: options.emitEvent });
        this._onCollectionChange();
    }
    /**
     * Length of the control array.
     */
    get length() {
        return this.controls.length;
    }
    /**
     * Sets the value of the `FormArray`. It accepts an array that matches
     * the structure of the control.
     *
     * This method performs strict checks, and throws an error if you try
     * to set the value of a control that doesn't exist or if you exclude the
     * value of a control.
     *
     * @usageNotes
     * ### Set the values for the controls in the form array
     *
     * ```
     * const arr = new FormArray([
     *   new FormControl(),
     *   new FormControl()
     * ]);
     * console.log(arr.value);   // [null, null]
     *
     * arr.setValue(['Nancy', 'Drew']);
     * console.log(arr.value);   // ['Nancy', 'Drew']
     * ```
     *
     * @param value Array of values for the controls
     * @param options Configure options that determine how the control propagates changes and
     * emits events after the value changes
     *
     * * `onlySelf`: When true, each change only affects this control, and not its parent. Default
     * is false.
     * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and
     * `valueChanges`
     * observables emit events with the latest status and value when the control value is updated.
     * When false, no events are emitted.
     * The configuration options are passed to the {@link AbstractControl#updateValueAndValidity
     * updateValueAndValidity} method.
     */
    setValue(value, options = {}) {
        assertAllValuesPresent(this, false, value);
        value.forEach((newValue, index) => {
            assertControlPresent(this, false, index);
            this.at(index).setValue(newValue, { onlySelf: true, emitEvent: options.emitEvent });
        });
        this.updateValueAndValidity(options);
    }
    /**
     * Patches the value of the `FormArray`. It accepts an array that matches the
     * structure of the control, and does its best to match the values to the correct
     * controls in the group.
     *
     * It accepts both super-sets and sub-sets of the array without throwing an error.
     *
     * @usageNotes
     * ### Patch the values for controls in a form array
     *
     * ```
     * const arr = new FormArray([
     *    new FormControl(),
     *    new FormControl()
     * ]);
     * console.log(arr.value);   // [null, null]
     *
     * arr.patchValue(['Nancy']);
     * console.log(arr.value);   // ['Nancy', null]
     * ```
     *
     * @param value Array of latest values for the controls
     * @param options Configure options that determine how the control propagates changes and
     * emits events after the value changes
     *
     * * `onlySelf`: When true, each change only affects this control, and not its parent. Default
     * is false.
     * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and
     * `valueChanges` observables emit events with the latest status and value when the control
     * value is updated. When false, no events are emitted. The configuration options are passed to
     * the {@link AbstractControl#updateValueAndValidity updateValueAndValidity} method.
     */
    patchValue(value, options = {}) {
        // Even though the `value` argument type doesn't allow `null` and `undefined` values, the
        // `patchValue` can be called recursively and inner data structures might have these values,
        // so we just ignore such cases when a field containing FormArray instance receives `null` or
        // `undefined` as a value.
        if (value == null /* both `null` and `undefined` */)
            return;
        value.forEach((newValue, index) => {
            if (this.at(index)) {
                this.at(index).patchValue(newValue, { onlySelf: true, emitEvent: options.emitEvent });
            }
        });
        this.updateValueAndValidity(options);
    }
    /**
     * Resets the `FormArray` and all descendants are marked `pristine` and `untouched`, and the
     * value of all descendants to null or null maps.
     *
     * You reset to a specific form state by passing in an array of states
     * that matches the structure of the control. The state is a standalone value
     * or a form state object with both a value and a disabled status.
     *
     * @usageNotes
     * ### Reset the values in a form array
     *
     * ```ts
     * const arr = new FormArray([
     *    new FormControl(),
     *    new FormControl()
     * ]);
     * arr.reset(['name', 'last name']);
     *
     * console.log(arr.value);  // ['name', 'last name']
     * ```
     *
     * ### Reset the values in a form array and the disabled status for the first control
     *
     * ```
     * arr.reset([
     *   {value: 'name', disabled: true},
     *   'last'
     * ]);
     *
     * console.log(arr.value);  // ['last']
     * console.log(arr.at(0).status);  // 'DISABLED'
     * ```
     *
     * @param value Array of values for the controls
     * @param options Configure options that determine how the control propagates changes and
     * emits events after the value changes
     *
     * * `onlySelf`: When true, each change only affects this control, and not its parent. Default
     * is false.
     * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and
     * `valueChanges`
     * observables emit events with the latest status and value when the control is reset.
     * When false, no events are emitted.
     * The configuration options are passed to the {@link AbstractControl#updateValueAndValidity
     * updateValueAndValidity} method.
     */
    reset(value = [], options = {}) {
        this._forEachChild((control, index) => {
            control.reset(value[index], { onlySelf: true, emitEvent: options.emitEvent });
        });
        this._updatePristine(options);
        this._updateTouched(options);
        this.updateValueAndValidity(options);
    }
    /**
     * The aggregate value of the array, including any disabled controls.
     *
     * Reports all values regardless of disabled status.
     */
    getRawValue() {
        return this.controls.map((control) => control.getRawValue());
    }
    /**
     * Remove all controls in the `FormArray`.
     *
     * @param options Specifies whether this FormArray instance should emit events after all
     *     controls are removed.
     * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and
     * `valueChanges` observables emit events with the latest status and value when all controls
     * in this FormArray instance are removed. When false, no events are emitted.
     *
     * @usageNotes
     * ### Remove all elements from a FormArray
     *
     * ```ts
     * const arr = new FormArray([
     *    new FormControl(),
     *    new FormControl()
     * ]);
     * console.log(arr.length);  // 2
     *
     * arr.clear();
     * console.log(arr.length);  // 0
     * ```
     *
     * It's a simpler and more efficient alternative to removing all elements one by one:
     *
     * ```ts
     * const arr = new FormArray([
     *    new FormControl(),
     *    new FormControl()
     * ]);
     *
     * while (arr.length) {
     *    arr.removeAt(0);
     * }
     * ```
     */
    clear(options = {}) {
        if (this.controls.length < 1)
            return;
        this._forEachChild((control) => control._registerOnCollectionChange(() => { }));
        this.controls.splice(0);
        this.updateValueAndValidity({ emitEvent: options.emitEvent });
    }
    /**
     * Adjusts a negative index by summing it with the length of the array. For very negative
     * indices, the result may remain negative.
     * @internal
     */
    _adjustIndex(index) {
        return index < 0 ? index + this.length : index;
    }
    /** @internal */
    _syncPendingControls() {
        let subtreeUpdated = this.controls.reduce((updated, child) => {
            return child._syncPendingControls() ? true : updated;
        }, false);
        if (subtreeUpdated)
            this.updateValueAndValidity({ onlySelf: true });
        return subtreeUpdated;
    }
    /** @internal */
    _forEachChild(cb) {
        this.controls.forEach((control, index) => {
            cb(control, index);
        });
    }
    /** @internal */
    _updateValue() {
        this.value =
            this.controls.filter((control) => control.enabled || this.disabled)
                .map((control) => control.value);
    }
    /** @internal */
    _anyControls(condition) {
        return this.controls.some((control) => control.enabled && condition(control));
    }
    /** @internal */
    _setUpControls() {
        this._forEachChild((control) => this._registerControl(control));
    }
    /** @internal */
    _allControlsDisabled() {
        for (const control of this.controls) {
            if (control.enabled)
                return false;
        }
        return this.controls.length > 0 || this.disabled;
    }
    _registerControl(control) {
        control.setParent(this);
        control._registerOnCollectionChange(this._onCollectionChange);
    }
    /** @internal */
    _find(name) {
        return this.at(name) ?? null;
    }
}
const UntypedFormArray = FormArray;
/**
 * @description
 * Asserts that the given control is an instance of `FormArray`
 *
 * @publicApi
 */
const isFormArray = (control) => control instanceof FormArray;

function isAbstractControlOptions(options) {
    return !!options &&
        (options.asyncValidators !== undefined ||
            options.validators !== undefined ||
            options.updateOn !== undefined);
}
// clang-format on
/**
 * @description
 * Creates an `AbstractControl` from a user-specified configuration.
 *
 * The `FormBuilder` provides syntactic sugar that shortens creating instances of a
 * `FormControl`, `FormGroup`, or `FormArray`. It reduces the amount of boilerplate needed to
 * build complex forms.
 *
 * @see [Reactive Forms Guide](guide/reactive-forms)
 *
 * @publicApi
 */
class FormBuilder {
    constructor() {
        this.useNonNullable = false;
    }
    /**
     * @description
     * Returns a FormBuilder in which automatically constructed `FormControl` elements
     * have `{nonNullable: true}` and are non-nullable.
     *
     * **Constructing non-nullable controls**
     *
     * When constructing a control, it will be non-nullable, and will reset to its initial value.
     *
     * ```ts
     * let nnfb = new FormBuilder().nonNullable;
     * let name = nnfb.control('Alex'); // FormControl<string>
     * name.reset();
     * console.log(name); // 'Alex'
     * ```
     *
     * **Constructing non-nullable groups or arrays**
     *
     * When constructing a group or array, all automatically created inner controls will be
     * non-nullable, and will reset to their initial values.
     *
     * ```ts
     * let nnfb = new FormBuilder().nonNullable;
     * let name = nnfb.group({who: 'Alex'}); // FormGroup<{who: FormControl<string>}>
     * name.reset();
     * console.log(name); // {who: 'Alex'}
     * ```
     * **Constructing *nullable* fields on groups or arrays**
     *
     * It is still possible to have a nullable field. In particular, any `FormControl` which is
     * *already* constructed will not be altered. For example:
     *
     * ```ts
     * let nnfb = new FormBuilder().nonNullable;
     * // FormGroup<{who: FormControl<string|null>}>
     * let name = nnfb.group({who: new FormControl('Alex')});
     * name.reset(); console.log(name); // {who: null}
     * ```
     *
     * Because the inner control is constructed explicitly by the caller, the builder has
     * no control over how it is created, and cannot exclude the `null`.
     */
    get nonNullable() {
        const nnfb = new FormBuilder();
        nnfb.useNonNullable = true;
        return nnfb;
    }
    group(controls, options = null) {
        const reducedControls = this._reduceControls(controls);
        let newOptions = {};
        if (isAbstractControlOptions(options)) {
            // `options` are `AbstractControlOptions`
            newOptions = options;
        }
        else if (options !== null) {
            // `options` are legacy form group options
            newOptions.validators = options.validator;
            newOptions.asyncValidators = options.asyncValidator;
        }
        return new FormGroup(reducedControls, newOptions);
    }
    /**
     * @description
     * Constructs a new `FormRecord` instance. Accepts a single generic argument, which is an object
     * containing all the keys and corresponding inner control types.
     *
     * @param controls A collection of child controls. The key for each child is the name
     * under which it is registered.
     *
     * @param options Configuration options object for the `FormRecord`. The object should have the
     * `AbstractControlOptions` type and might contain the following fields:
     * * `validators`: A synchronous validator function, or an array of validator functions.
     * * `asyncValidators`: A single async validator or array of async validator functions.
     * * `updateOn`: The event upon which the control should be updated (options: 'change' | 'blur'
     * | submit').
     */
    record(controls, options = null) {
        const reducedControls = this._reduceControls(controls);
        // Cast to `any` because the inferred types are not as specific as Element.
        return new FormRecord(reducedControls, options);
    }
    /**
     * @description
     * Constructs a new `FormControl` with the given state, validators and options. Sets
     * `{nonNullable: true}` in the options to get a non-nullable control. Otherwise, the
     * control will be nullable. Accepts a single generic argument, which is the type  of the
     * control's value.
     *
     * @param formState Initializes the control with an initial state value, or
     * with an object that contains both a value and a disabled status.
     *
     * @param validatorOrOpts A synchronous validator function, or an array of
     * such functions, or a `FormControlOptions` object that contains
     * validation functions and a validation trigger.
     *
     * @param asyncValidator A single async validator or array of async validator
     * functions.
     *
     * @usageNotes
     *
     * ### Initialize a control as disabled
     *
     * The following example returns a control with an initial value in a disabled state.
     *
     * <code-example path="forms/ts/formBuilder/form_builder_example.ts" region="disabled-control">
     * </code-example>
     */
    control(formState, validatorOrOpts, asyncValidator) {
        let newOptions = {};
        if (!this.useNonNullable) {
            return new FormControl(formState, validatorOrOpts, asyncValidator);
        }
        if (isAbstractControlOptions(validatorOrOpts)) {
            // If the second argument is options, then they are copied.
            newOptions = validatorOrOpts;
        }
        else {
            // If the other arguments are validators, they are copied into an options object.
            newOptions.validators = validatorOrOpts;
            newOptions.asyncValidators = asyncValidator;
        }
        return new FormControl(formState, { ...newOptions, nonNullable: true });
    }
    /**
     * Constructs a new `FormArray` from the given array of configurations,
     * validators and options. Accepts a single generic argument, which is the type of each control
     * inside the array.
     *
     * @param controls An array of child controls or control configs. Each child control is given an
     *     index when it is registered.
     *
     * @param validatorOrOpts A synchronous validator function, or an array of such functions, or an
     *     `AbstractControlOptions` object that contains
     * validation functions and a validation trigger.
     *
     * @param asyncValidator A single async validator or array of async validator functions.
     */
    array(controls, validatorOrOpts, asyncValidator) {
        const createdControls = controls.map(c => this._createControl(c));
        // Cast to `any` because the inferred types are not as specific as Element.
        return new FormArray(createdControls, validatorOrOpts, asyncValidator);
    }
    /** @internal */
    _reduceControls(controls) {
        const createdControls = {};
        Object.keys(controls).forEach(controlName => {
            createdControls[controlName] = this._createControl(controls[controlName]);
        });
        return createdControls;
    }
    /** @internal */
    _createControl(controls) {
        if (controls instanceof FormControl) {
            return controls;
        }
        else if (controls instanceof AbstractControl) { // A control; just return it
            return controls;
        }
        else if (Array.isArray(controls)) { // ControlConfig Tuple
            const value = controls[0];
            const validator = controls.length > 1 ? controls[1] : null;
            const asyncValidator = controls.length > 2 ? controls[2] : null;
            return this.control(value, validator, asyncValidator);
        }
        else { // T or FormControlState<T>
            return this.control(controls);
        }
    }
    static { this.fac = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareFactory"]({ minVersion: "12.0.0", version: "17.3.12", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: FormBuilder, deps: [], target: _angular_core__WEBPACK_IMPORTED_MODULE_0__["FactoryTarget"].Injectable }); }
    static { this.prov = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareInjectable"]({ minVersion: "12.0.0", version: "17.3.12", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: FormBuilder, providedIn: 'root' }); }
}
_angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareClassMetadata"]({ minVersion: "12.0.0", version: "17.3.12", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: FormBuilder, decorators: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Injectable,
            args: [{ providedIn: 'root' }]
        }] });
/**
 * @description
 * `NonNullableFormBuilder` is similar to {@link FormBuilder}, but automatically constructed
 * {@link FormControl} elements have `{nonNullable: true}` and are non-nullable.
 *
 * @publicApi
 */
class NonNullableFormBuilder {
    static { this.fac = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareFactory"]({ minVersion: "12.0.0", version: "17.3.12", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: NonNullableFormBuilder, deps: [], target: _angular_core__WEBPACK_IMPORTED_MODULE_0__["FactoryTarget"].Injectable }); }
    static { this.prov = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareInjectable"]({ minVersion: "12.0.0", version: "17.3.12", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: NonNullableFormBuilder, providedIn: 'root', useFactory: () => (0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.inject)(FormBuilder).nonNullable }); }
}
_angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareClassMetadata"]({ minVersion: "12.0.0", version: "17.3.12", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: NonNullableFormBuilder, decorators: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Injectable,
            args: [{
                    providedIn: 'root',
                    useFactory: () => (0,_angular_core__WEBPACK_IMPORTED_MODULE_0__.inject)(FormBuilder).nonNullable,
                }]
        }] });
/**
 * UntypedFormBuilder is the same as `FormBuilder`, but it provides untyped controls.
 */
class UntypedFormBuilder extends FormBuilder {
    group(controlsConfig, options = null) {
        return super.group(controlsConfig, options);
    }
    /**
     * Like `FormBuilder#control`, except the resulting control is untyped.
     */
    control(formState, validatorOrOpts, asyncValidator) {
        return super.control(formState, validatorOrOpts, asyncValidator);
    }
    /**
     * Like `FormBuilder#array`, except the resulting array is untyped.
     */
    array(controlsConfig, validatorOrOpts, asyncValidator) {
        return super.array(controlsConfig, validatorOrOpts, asyncValidator);
    }
    static { this.fac = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareFactory"]({ minVersion: "12.0.0", version: "17.3.12", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: UntypedFormBuilder, deps: null, target: _angular_core__WEBPACK_IMPORTED_MODULE_0__["FactoryTarget"].Injectable }); }
    static { this.prov = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareInjectable"]({ minVersion: "12.0.0", version: "17.3.12", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: UntypedFormBuilder, providedIn: 'root' }); }
}
_angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareClassMetadata"]({ minVersion: "12.0.0", version: "17.3.12", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: UntypedFormBuilder, decorators: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Injectable,
            args: [{ providedIn: 'root' }]
        }] });

/**
 * @module
 * @description
 * Entry point for all public APIs of the forms package.
 */
/**
 * @publicApi
 */
const VERSION = new _angular_core__WEBPACK_IMPORTED_MODULE_0__.Version('17.3.12');

/**
 * Exports the required providers and directives for template-driven forms,
 * making them available for import by NgModules that import this module.
 *
 * @see [Forms Overview](/guide/forms-overview)
 * @see [Template-driven Forms Guide](/guide/forms)
 *
 * @publicApi
 */
class FormsModule {
    /**
     * @description
     * Provides options for configuring the forms module.
     *
     * @param opts An object of configuration options
     * * `callSetDisabledState` Configures whether to `always` call `setDisabledState`, which is more
     * correct, or to only call it `whenDisabled`, which is the legacy behavior.
     */
    static withConfig(opts) {
        return {
            ngModule: FormsModule,
            providers: [{
                    provide: CALL_SET_DISABLED_STATE,
                    useValue: opts.callSetDisabledState ?? setDisabledStateDefault
                }]
        };
    }
    static { this.fac = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareFactory"]({ minVersion: "12.0.0", version: "17.3.12", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: FormsModule, deps: [], target: _angular_core__WEBPACK_IMPORTED_MODULE_0__["FactoryTarget"].NgModule }); }
    static { this.mod = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareNgModule"]({ minVersion: "14.0.0", version: "17.3.12", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: FormsModule, declarations: [NgModel, NgModelGroup, NgForm], exports: [InternalFormsSharedModule, NgModel, NgModelGroup, NgForm] }); }
    static { this.inj = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareInjector"]({ minVersion: "12.0.0", version: "17.3.12", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: FormsModule, imports: [InternalFormsSharedModule] }); }
}
_angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareClassMetadata"]({ minVersion: "12.0.0", version: "17.3.12", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: FormsModule, decorators: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.NgModule,
            args: [{
                    declarations: TEMPLATE_DRIVEN_DIRECTIVES,
                    exports: [InternalFormsSharedModule, TEMPLATE_DRIVEN_DIRECTIVES]
                }]
        }] });
/**
 * Exports the required infrastructure and directives for reactive forms,
 * making them available for import by NgModules that import this module.
 *
 * @see [Forms Overview](guide/forms-overview)
 * @see [Reactive Forms Guide](guide/reactive-forms)
 *
 * @publicApi
 */
class ReactiveFormsModule {
    /**
     * @description
     * Provides options for configuring the reactive forms module.
     *
     * @param opts An object of configuration options
     * * `warnOnNgModelWithFormControl` Configures when to emit a warning when an `ngModel`
     * binding is used with reactive form directives.
     * * `callSetDisabledState` Configures whether to `always` call `setDisabledState`, which is more
     * correct, or to only call it `whenDisabled`, which is the legacy behavior.
     */
    static withConfig(opts) {
        return {
            ngModule: ReactiveFormsModule,
            providers: [
                {
                    provide: NG_MODEL_WITH_FORM_CONTROL_WARNING,
                    useValue: opts.warnOnNgModelWithFormControl ?? 'always'
                },
                {
                    provide: CALL_SET_DISABLED_STATE,
                    useValue: opts.callSetDisabledState ?? setDisabledStateDefault
                }
            ]
        };
    }
    static { this.fac = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareFactory"]({ minVersion: "12.0.0", version: "17.3.12", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: ReactiveFormsModule, deps: [], target: _angular_core__WEBPACK_IMPORTED_MODULE_0__["FactoryTarget"].NgModule }); }
    static { this.mod = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareNgModule"]({ minVersion: "14.0.0", version: "17.3.12", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: ReactiveFormsModule, declarations: [FormControlDirective, FormGroupDirective, FormControlName, FormGroupName, FormArrayName], exports: [InternalFormsSharedModule, FormControlDirective, FormGroupDirective, FormControlName, FormGroupName, FormArrayName] }); }
    static { this.inj = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareInjector"]({ minVersion: "12.0.0", version: "17.3.12", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: ReactiveFormsModule, imports: [InternalFormsSharedModule] }); }
}
_angular_core__WEBPACK_IMPORTED_MODULE_0__["ngDeclareClassMetadata"]({ minVersion: "12.0.0", version: "17.3.12", ngImport: /*#__PURE__*/ (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_angular_core__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_angular_core__WEBPACK_IMPORTED_MODULE_0__, 2))), type: ReactiveFormsModule, decorators: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.NgModule,
            args: [{
                    declarations: [REACTIVE_DRIVEN_DIRECTIVES],
                    exports: [InternalFormsSharedModule, REACTIVE_DRIVEN_DIRECTIVES]
                }]
        }] });

/**
 * @module
 * @description
 * This module is used for handling user input, by defining and building a `FormGroup` that
 * consists of `FormControl` objects, and mapping them onto the DOM. `FormControl`
 * objects can then be used to read information from the form DOM elements.
 *
 * Forms providers are not included in default providers; you must import these providers
 * explicitly.
 */

/**
 * @module
 * @description
 * Entry point for all public APIs of this package.
 */
// This file only reexports content of the `src` folder. Keep it that way.

// This file is not used to build this module. It is only used during editing

/**
 * Generated bundle index. Do not edit.
 */


//# sourceMappingURL=forms.mjs.map


/***/ })

/******/ });
/************************************************************************/
/******/ // The module cache
/******/ var __webpack_module_cache__ = {};
/******/ 
/******/ // The require function
/******/ function __webpack_require__(moduleId) {
/******/ 	// Check if module is in cache
/******/ 	var cachedModule = __webpack_module_cache__[moduleId];
/******/ 	if (cachedModule !== undefined) {
/******/ 		return cachedModule.exports;
/******/ 	}
/******/ 	// Create a new module (and put it into the cache)
/******/ 	var module = __webpack_module_cache__[moduleId] = {
/******/ 		// no module.id needed
/******/ 		// no module.loaded needed
/******/ 		exports: {}
/******/ 	};
/******/ 
/******/ 	// Execute the module function
/******/ 	__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 
/******/ 	// Return the exports of the module
/******/ 	return module.exports;
/******/ }
/******/ 
/************************************************************************/
/******/ /* webpack/runtime/compat get default export */
/******/ (() => {
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = (module) => {
/******/ 		var getter = module && module.__esModule ?
/******/ 			() => (module['default']) :
/******/ 			() => (module);
/******/ 		__webpack_require__.d(getter, { a: getter });
/******/ 		return getter;
/******/ 	};
/******/ })();
/******/ 
/******/ /* webpack/runtime/create fake namespace object */
/******/ (() => {
/******/ 	var getProto = Object.getPrototypeOf ? (obj) => (Object.getPrototypeOf(obj)) : (obj) => (obj.__proto__);
/******/ 	var leafPrototypes;
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 16: return value when it's Promise-like
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = this(value);
/******/ 		if(mode & 8) return value;
/******/ 		if(typeof value === 'object' && value) {
/******/ 			if((mode & 4) && value.__esModule) return value;
/******/ 			if((mode & 16) && typeof value.then === 'function') return value;
/******/ 		}
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		var def = {};
/******/ 		leafPrototypes = leafPrototypes || [null, getProto({}), getProto([]), getProto(getProto)];
/******/ 		for(var current = mode & 2 && value; typeof current == 'object' && !~leafPrototypes.indexOf(current); current = getProto(current)) {
/******/ 			Object.getOwnPropertyNames(current).forEach((key) => (def[key] = () => (value[key])));
/******/ 		}
/******/ 		def['default'] = () => (value);
/******/ 		__webpack_require__.d(ns, def);
/******/ 		return ns;
/******/ 	};
/******/ })();
/******/ 
/******/ /* webpack/runtime/define property getters */
/******/ (() => {
/******/ 	// define getter functions for harmony exports
/******/ 	__webpack_require__.d = (exports, definition) => {
/******/ 		for(var key in definition) {
/******/ 			if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 				Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 			}
/******/ 		}
/******/ 	};
/******/ })();
/******/ 
/******/ /* webpack/runtime/hasOwnProperty shorthand */
/******/ (() => {
/******/ 	__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ })();
/******/ 
/******/ /* webpack/runtime/make namespace object */
/******/ (() => {
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = (exports) => {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/ })();
/******/ 
/************************************************************************/
var __webpack_exports__ = {};
// This entry needs to be wrapped in an IIFE because it needs to be isolated against other modules in the chunk.
(() => {
/*!***************************!*\
  !*** ./src/public_api.ts ***!
  \***************************/
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BerkelybridgeTextgeneratorConfigurationComponent: () => (/* reexport safe */ _lib_components_berkelybridge_textgenerator_configuration_berkelybridge_textgenerator_configuration_component__WEBPACK_IMPORTED_MODULE_3__.BerkelybridgeTextgeneratorConfigurationComponent),
/* harmony export */   BerkelybridgeTextgeneratorPluginModule: () => (/* reexport safe */ _lib_berkelybridge_textgenerator_plugin_module__WEBPACK_IMPORTED_MODULE_1__.BerkelybridgeTextgeneratorPluginModule),
/* harmony export */   TextGenerationConfigurationComponent: () => (/* reexport safe */ _lib_components_text_generation_text_generation_configuration_component__WEBPACK_IMPORTED_MODULE_4__.TextGenerationConfigurationComponent),
/* harmony export */   berkelybridgeTextgeneratorPluginSpecification: () => (/* reexport safe */ _lib_berkelybridge_textgenerator_plugin_specification__WEBPACK_IMPORTED_MODULE_2__.berkelybridgeTextgeneratorPluginSpecification)
/* harmony export */ });
/* harmony import */ var _lib_models__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lib/models */ "./src/lib/models/index.ts");
/* harmony import */ var _lib_berkelybridge_textgenerator_plugin_module__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./lib/berkelybridge-textgenerator-plugin-module */ "./src/lib/berkelybridge-textgenerator-plugin-module.ts");
/* harmony import */ var _lib_berkelybridge_textgenerator_plugin_specification__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./lib/berkelybridge-textgenerator-plugin.specification */ "./src/lib/berkelybridge-textgenerator-plugin.specification.ts");
/* harmony import */ var _lib_components_berkelybridge_textgenerator_configuration_berkelybridge_textgenerator_configuration_component__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./lib/components/berkelybridge-textgenerator-configuration/berkelybridge-textgenerator-configuration.component */ "./src/lib/components/berkelybridge-textgenerator-configuration/berkelybridge-textgenerator-configuration.component.ts");
/* harmony import */ var _lib_components_text_generation_text_generation_configuration_component__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./lib/components/text-generation/text-generation-configuration.component */ "./src/lib/components/text-generation/text-generation-configuration.component.ts");
/*
 * Copyright 2015-2024. Ritense BV, the Netherlands.
 *
 * Licensed under EUPL, Version 1.2 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * https://joinup.ec.europa.eu/collection/eupl/eupl-text-eupl-12
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" basis,
 *
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
/*
 * Public API Surface of slack
 */






})();

var __webpack_exports__BerkelybridgeTextgeneratorConfigurationComponent = __webpack_exports__.BerkelybridgeTextgeneratorConfigurationComponent;
var __webpack_exports__BerkelybridgeTextgeneratorPluginModule = __webpack_exports__.BerkelybridgeTextgeneratorPluginModule;
var __webpack_exports__TextGenerationConfigurationComponent = __webpack_exports__.TextGenerationConfigurationComponent;
var __webpack_exports__berkelybridgeTextgeneratorPluginSpecification = __webpack_exports__.berkelybridgeTextgeneratorPluginSpecification;
export { __webpack_exports__BerkelybridgeTextgeneratorConfigurationComponent as BerkelybridgeTextgeneratorConfigurationComponent, __webpack_exports__BerkelybridgeTextgeneratorPluginModule as BerkelybridgeTextgeneratorPluginModule, __webpack_exports__TextGenerationConfigurationComponent as TextGenerationConfigurationComponent, __webpack_exports__berkelybridgeTextgeneratorPluginSpecification as berkelybridgeTextgeneratorPluginSpecification };

//# sourceMappingURL=data:application/json;charset=utf-8;base64,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LE1BQU07QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxJQUFJO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxJQUFJO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxJQUFJO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsSUFBSSxZQUFZO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxJQUFJLFlBQVk7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFD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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLDJCQUEyQjtBQUM3RCxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsMkJBQTJCO0FBQzdELFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEVBQThFO0FBQzlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtGQUFrRjtBQUNsRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNEO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNEO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixhQUFhO0FBQ2IsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFD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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQ7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4Qyw4QkFBOEI7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsU0FBUyxFQUFFLFdBQVc7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsa0JBQWtCO0FBQzNDO0FBQ0EseUJBQXlCLEtBQUs7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLDJEQUFhLCtGQUErRixJQUFJO0FBQzlIO0FBQ0E7QUFDQTtBQUNBLGNBQWMsMkRBQWEsa0lBQWtJLElBQUk7QUFDaks7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUIseURBQVU7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGlCQUFpQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHVEQUFZO0FBQ3hDO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsa0JBQWtCO0FBQ25FO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBLDJDQUEyQyxrQkFBa0I7QUFDN0QsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Qsd0NBQXdDLGtCQUFrQjtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxrQkFBa0I7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELGtCQUFrQjtBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtEQUErRDtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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Q0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFMmdDO0FBQzNnQzs7Ozs7OztTQzlsT0E7U0FDQTs7U0FFQTtTQUNBO1NBQ0E7U0FDQTtTQUNBO1NBQ0E7U0FDQTtTQUNBO1NBQ0E7U0FDQTtTQUNBO1NBQ0E7U0FDQTs7U0FFQTtTQUNBOztTQUVBO1NBQ0E7U0FDQTs7Ozs7VUN0QkE7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBLGlDQUFpQyxXQUFXO1VBQzVDO1VBQ0E7Ozs7O1VDUEE7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0Esc0RBQXNEO1VBQ3RELHNDQUFzQyxpRUFBaUU7VUFDdkc7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBOzs7OztVQ3pCQTtVQUNBO1VBQ0E7VUFDQTtVQUNBLHlDQUF5Qyx3Q0FBd0M7VUFDakY7VUFDQTtVQUNBOzs7OztVQ1BBOzs7OztVQ0FBO1VBQ0E7VUFDQTtVQUNBLHVEQUF1RCxpQkFBaUI7VUFDeEU7VUFDQSxnREFBZ0QsYUFBYTtVQUM3RDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ05BOzs7Ozs7Ozs7Ozs7Ozs7OztHQWlCRztBQUVIOztHQUVHO0FBRTBCO0FBQ21DO0FBQ087QUFDd0Q7QUFDdEMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AdmFsdGltby1wbHVnaW5zL2JlcmtleWx5YnJpZGdlLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvZXNtNS9pbnRlcm5hbC9Ob3RpZmljYXRpb25GYWN0b3JpZXMuanMiLCJ3ZWJwYWNrOi8vQHZhbHRpbW8tcGx1Z2lucy9iZXJrZXlseWJyaWRnZS8uLi8uLi8uLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2VzbTUvaW50ZXJuYWwvU3Vic2NyaWJlci5qcyIsIndlYnBhY2s6Ly9AdmFsdGltby1wbHVnaW5zL2JlcmtleWx5YnJpZGdlLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvZXNtNS9pbnRlcm5hbC9TdWJzY3JpcHRpb24uanMiLCJ3ZWJwYWNrOi8vQHZhbHRpbW8tcGx1Z2lucy9iZXJrZXlseWJyaWRnZS8uLi8uLi8uLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2VzbTUvaW50ZXJuYWwvY29uZmlnLmpzIiwid2VicGFjazovL0B2YWx0aW1vLXBsdWdpbnMvYmVya2V5bHlicmlkZ2UvLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9lc201L2ludGVybmFsL29wZXJhdG9ycy9PcGVyYXRvclN1YnNjcmliZXIuanMiLCJ3ZWJwYWNrOi8vQHZhbHRpbW8tcGx1Z2lucy9iZXJrZXlseWJyaWRnZS8uLi8uLi8uLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2VzbTUvaW50ZXJuYWwvb3BlcmF0b3JzL21hcC5qcyIsIndlYnBhY2s6Ly9AdmFsdGltby1wbHVnaW5zL2JlcmtleWx5YnJpZGdlLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvZXNtNS9pbnRlcm5hbC9zY2hlZHVsZXIvdGltZW91dFByb3ZpZGVyLmpzIiwid2VicGFjazovL0B2YWx0aW1vLXBsdWdpbnMvYmVya2V5bHlicmlkZ2UvLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9lc201L2ludGVybmFsL3V0aWwvVW5zdWJzY3JpcHRpb25FcnJvci5qcyIsIndlYnBhY2s6Ly9AdmFsdGltby1wbHVnaW5zL2JlcmtleWx5YnJpZGdlLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvZXNtNS9pbnRlcm5hbC91dGlsL2FyclJlbW92ZS5qcyIsIndlYnBhY2s6Ly9AdmFsdGltby1wbHVnaW5zL2JlcmtleWx5YnJpZGdlLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvZXNtNS9pbnRlcm5hbC91dGlsL2NyZWF0ZUVycm9yQ2xhc3MuanMiLCJ3ZWJwYWNrOi8vQHZhbHRpbW8tcGx1Z2lucy9iZXJrZXlseWJyaWRnZS8uLi8uLi8uLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2VzbTUvaW50ZXJuYWwvdXRpbC9lcnJvckNvbnRleHQuanMiLCJ3ZWJwYWNrOi8vQHZhbHRpbW8tcGx1Z2lucy9iZXJrZXlseWJyaWRnZS8uLi8uLi8uLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2VzbTUvaW50ZXJuYWwvdXRpbC9pc0Z1bmN0aW9uLmpzIiwid2VicGFjazovL0B2YWx0aW1vLXBsdWdpbnMvYmVya2V5bHlicmlkZ2UvLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3J4anMvZGlzdC9lc201L2ludGVybmFsL3V0aWwvbGlmdC5qcyIsIndlYnBhY2s6Ly9AdmFsdGltby1wbHVnaW5zL2JlcmtleWx5YnJpZGdlLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9yeGpzL2Rpc3QvZXNtNS9pbnRlcm5hbC91dGlsL25vb3AuanMiLCJ3ZWJwYWNrOi8vQHZhbHRpbW8tcGx1Z2lucy9iZXJrZXlseWJyaWRnZS8uLi8uLi8uLi9ub2RlX21vZHVsZXMvcnhqcy9kaXN0L2VzbTUvaW50ZXJuYWwvdXRpbC9yZXBvcnRVbmhhbmRsZWRFcnJvci5qcyIsIndlYnBhY2s6Ly9AdmFsdGltby1wbHVnaW5zL2JlcmtleWx5YnJpZGdlLy4vc3JjL2xpYi9hc3NldHMvYmVya2VseWJyaWRnZS10ZXh0Z2VuZXJhdGlvbi1wbHVnaW4tbG9nby50cyIsIndlYnBhY2s6Ly9AdmFsdGltby1wbHVnaW5zL2JlcmtleWx5YnJpZGdlLy4vc3JjL2xpYi9iZXJrZWx5YnJpZGdlLXRleHRnZW5lcmF0b3ItcGx1Z2luLW1vZHVsZS50cyIsIndlYnBhY2s6Ly9AdmFsdGltby1wbHVnaW5zL2JlcmtleWx5YnJpZGdlLy4vc3JjL2xpYi9iZXJrZWx5YnJpZGdlLXRleHRnZW5lcmF0b3ItcGx1Z2luLnNwZWNpZmljYXRpb24udHMiLCJ3ZWJwYWNrOi8vQHZhbHRpbW8tcGx1Z2lucy9iZXJrZXlseWJyaWRnZS8uL3NyYy9saWIvY29tcG9uZW50cy9iZXJrZWx5YnJpZGdlLXRleHRnZW5lcmF0b3ItY29uZmlndXJhdGlvbi9iZXJrZWx5YnJpZGdlLXRleHRnZW5lcmF0b3ItY29uZmlndXJhdGlvbi5jb21wb25lbnQudHMiLCJ3ZWJwYWNrOi8vQHZhbHRpbW8tcGx1Z2lucy9iZXJrZXlseWJyaWRnZS8uL3NyYy9saWIvY29tcG9uZW50cy90ZXh0LWdlbmVyYXRpb24vdGV4dC1nZW5lcmF0aW9uLWNvbmZpZ3VyYXRpb24uY29tcG9uZW50LnRzIiwid2VicGFjazovL0B2YWx0aW1vLXBsdWdpbnMvYmVya2V5bHlicmlkZ2UvLi9zcmMvbGliL21vZGVscy9jb25maWcudHMiLCJ3ZWJwYWNrOi8vQHZhbHRpbW8tcGx1Z2lucy9iZXJrZXlseWJyaWRnZS8uL3NyYy9saWIvbW9kZWxzL2luZGV4LnRzIiwid2VicGFjazovL0B2YWx0aW1vLXBsdWdpbnMvYmVya2V5bHlicmlkZ2UvZXh0ZXJuYWwgd2luZG93IFwiQGFuZ3VsYXIvY29tbW9uXCIiLCJ3ZWJwYWNrOi8vQHZhbHRpbW8tcGx1Z2lucy9iZXJrZXlseWJyaWRnZS9leHRlcm5hbCB3aW5kb3cgXCJAYW5ndWxhci9jb3JlXCIiLCJ3ZWJwYWNrOi8vQHZhbHRpbW8tcGx1Z2lucy9iZXJrZXlseWJyaWRnZS9leHRlcm5hbCB3aW5kb3cgXCJAdmFsdGltby9jb21wb25lbnRzXCIiLCJ3ZWJwYWNrOi8vQHZhbHRpbW8tcGx1Z2lucy9iZXJrZXlseWJyaWRnZS9leHRlcm5hbCB3aW5kb3cgXCJAdmFsdGltby9wbHVnaW5cIiIsIndlYnBhY2s6Ly9AdmFsdGltby1wbHVnaW5zL2JlcmtleWx5YnJpZGdlL2V4dGVybmFsIHdpbmRvdyBcInJ4anNcIiIsIndlYnBhY2s6Ly9AdmFsdGltby1wbHVnaW5zL2JlcmtleWx5YnJpZGdlL2V4dGVybmFsIHdpbmRvdyBcInRzbGliXCIiLCJ3ZWJwYWNrOi8vQHZhbHRpbW8tcGx1Z2lucy9iZXJrZXlseWJyaWRnZS8uLi8uLi8uLi9ub2RlX21vZHVsZXMvQGFuZ3VsYXIvZm9ybXMvZmVzbTIwMjIvZm9ybXMubWpzIiwid2VicGFjazovL0B2YWx0aW1vLXBsdWdpbnMvYmVya2V5bHlicmlkZ2Uvd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8vQHZhbHRpbW8tcGx1Z2lucy9iZXJrZXlseWJyaWRnZS93ZWJwYWNrL3J1bnRpbWUvY29tcGF0IGdldCBkZWZhdWx0IGV4cG9ydCIsIndlYnBhY2s6Ly9AdmFsdGltby1wbHVnaW5zL2JlcmtleWx5YnJpZGdlL3dlYnBhY2svcnVudGltZS9jcmVhdGUgZmFrZSBuYW1lc3BhY2Ugb2JqZWN0Iiwid2VicGFjazovL0B2YWx0aW1vLXBsdWdpbnMvYmVya2V5bHlicmlkZ2Uvd2VicGFjay9ydW50aW1lL2RlZmluZSBwcm9wZXJ0eSBnZXR0ZXJzIiwid2VicGFjazovL0B2YWx0aW1vLXBsdWdpbnMvYmVya2V5bHlicmlkZ2Uvd2VicGFjay9ydW50aW1lL2hhc093blByb3BlcnR5IHNob3J0aGFuZCIsIndlYnBhY2s6Ly9AdmFsdGltby1wbHVnaW5zL2JlcmtleWx5YnJpZGdlL3dlYnBhY2svcnVudGltZS9tYWtlIG5hbWVzcGFjZSBvYmplY3QiLCJ3ZWJwYWNrOi8vQHZhbHRpbW8tcGx1Z2lucy9iZXJrZXlseWJyaWRnZS8uL3NyYy9wdWJsaWNfYXBpLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCB2YXIgQ09NUExFVEVfTk9USUZJQ0FUSU9OID0gKGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNyZWF0ZU5vdGlmaWNhdGlvbignQycsIHVuZGVmaW5lZCwgdW5kZWZpbmVkKTsgfSkoKTtcbmV4cG9ydCBmdW5jdGlvbiBlcnJvck5vdGlmaWNhdGlvbihlcnJvcikge1xuICAgIHJldHVybiBjcmVhdGVOb3RpZmljYXRpb24oJ0UnLCB1bmRlZmluZWQsIGVycm9yKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBuZXh0Tm90aWZpY2F0aW9uKHZhbHVlKSB7XG4gICAgcmV0dXJuIGNyZWF0ZU5vdGlmaWNhdGlvbignTicsIHZhbHVlLCB1bmRlZmluZWQpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZU5vdGlmaWNhdGlvbihraW5kLCB2YWx1ZSwgZXJyb3IpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBraW5kOiBraW5kLFxuICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgIGVycm9yOiBlcnJvcixcbiAgICB9O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Tm90aWZpY2F0aW9uRmFjdG9yaWVzLmpzLm1hcCIsImltcG9ydCB7IF9fZXh0ZW5kcyB9IGZyb20gXCJ0c2xpYlwiO1xuaW1wb3J0IHsgaXNGdW5jdGlvbiB9IGZyb20gJy4vdXRpbC9pc0Z1bmN0aW9uJztcbmltcG9ydCB7IGlzU3Vic2NyaXB0aW9uLCBTdWJzY3JpcHRpb24gfSBmcm9tICcuL1N1YnNjcmlwdGlvbic7XG5pbXBvcnQgeyBjb25maWcgfSBmcm9tICcuL2NvbmZpZyc7XG5pbXBvcnQgeyByZXBvcnRVbmhhbmRsZWRFcnJvciB9IGZyb20gJy4vdXRpbC9yZXBvcnRVbmhhbmRsZWRFcnJvcic7XG5pbXBvcnQgeyBub29wIH0gZnJvbSAnLi91dGlsL25vb3AnO1xuaW1wb3J0IHsgbmV4dE5vdGlmaWNhdGlvbiwgZXJyb3JOb3RpZmljYXRpb24sIENPTVBMRVRFX05PVElGSUNBVElPTiB9IGZyb20gJy4vTm90aWZpY2F0aW9uRmFjdG9yaWVzJztcbmltcG9ydCB7IHRpbWVvdXRQcm92aWRlciB9IGZyb20gJy4vc2NoZWR1bGVyL3RpbWVvdXRQcm92aWRlcic7XG5pbXBvcnQgeyBjYXB0dXJlRXJyb3IgfSBmcm9tICcuL3V0aWwvZXJyb3JDb250ZXh0JztcbnZhciBTdWJzY3JpYmVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoU3Vic2NyaWJlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBTdWJzY3JpYmVyKGRlc3RpbmF0aW9uKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLmlzU3RvcHBlZCA9IGZhbHNlO1xuICAgICAgICBpZiAoZGVzdGluYXRpb24pIHtcbiAgICAgICAgICAgIF90aGlzLmRlc3RpbmF0aW9uID0gZGVzdGluYXRpb247XG4gICAgICAgICAgICBpZiAoaXNTdWJzY3JpcHRpb24oZGVzdGluYXRpb24pKSB7XG4gICAgICAgICAgICAgICAgZGVzdGluYXRpb24uYWRkKF90aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIF90aGlzLmRlc3RpbmF0aW9uID0gRU1QVFlfT0JTRVJWRVI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBTdWJzY3JpYmVyLmNyZWF0ZSA9IGZ1bmN0aW9uIChuZXh0LCBlcnJvciwgY29tcGxldGUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTYWZlU3Vic2NyaWJlcihuZXh0LCBlcnJvciwgY29tcGxldGUpO1xuICAgIH07XG4gICAgU3Vic2NyaWJlci5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBpZiAodGhpcy5pc1N0b3BwZWQpIHtcbiAgICAgICAgICAgIGhhbmRsZVN0b3BwZWROb3RpZmljYXRpb24obmV4dE5vdGlmaWNhdGlvbih2YWx1ZSksIHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fbmV4dCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFN1YnNjcmliZXIucHJvdG90eXBlLmVycm9yID0gZnVuY3Rpb24gKGVycikge1xuICAgICAgICBpZiAodGhpcy5pc1N0b3BwZWQpIHtcbiAgICAgICAgICAgIGhhbmRsZVN0b3BwZWROb3RpZmljYXRpb24oZXJyb3JOb3RpZmljYXRpb24oZXJyKSwgdGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmlzU3RvcHBlZCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLl9lcnJvcihlcnIpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBTdWJzY3JpYmVyLnByb3RvdHlwZS5jb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNTdG9wcGVkKSB7XG4gICAgICAgICAgICBoYW5kbGVTdG9wcGVkTm90aWZpY2F0aW9uKENPTVBMRVRFX05PVElGSUNBVElPTiwgdGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmlzU3RvcHBlZCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLl9jb21wbGV0ZSgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBTdWJzY3JpYmVyLnByb3RvdHlwZS51bnN1YnNjcmliZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmNsb3NlZCkge1xuICAgICAgICAgICAgdGhpcy5pc1N0b3BwZWQgPSB0cnVlO1xuICAgICAgICAgICAgX3N1cGVyLnByb3RvdHlwZS51bnN1YnNjcmliZS5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5kZXN0aW5hdGlvbiA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFN1YnNjcmliZXIucHJvdG90eXBlLl9uZXh0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuZGVzdGluYXRpb24ubmV4dCh2YWx1ZSk7XG4gICAgfTtcbiAgICBTdWJzY3JpYmVyLnByb3RvdHlwZS5fZXJyb3IgPSBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLmVycm9yKGVycik7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICB0aGlzLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFN1YnNjcmliZXIucHJvdG90eXBlLl9jb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMuZGVzdGluYXRpb24uY29tcGxldGUoKTtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIHRoaXMudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIFN1YnNjcmliZXI7XG59KFN1YnNjcmlwdGlvbikpO1xuZXhwb3J0IHsgU3Vic2NyaWJlciB9O1xudmFyIF9iaW5kID0gRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQ7XG5mdW5jdGlvbiBiaW5kKGZuLCB0aGlzQXJnKSB7XG4gICAgcmV0dXJuIF9iaW5kLmNhbGwoZm4sIHRoaXNBcmcpO1xufVxudmFyIENvbnN1bWVyT2JzZXJ2ZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIENvbnN1bWVyT2JzZXJ2ZXIocGFydGlhbE9ic2VydmVyKSB7XG4gICAgICAgIHRoaXMucGFydGlhbE9ic2VydmVyID0gcGFydGlhbE9ic2VydmVyO1xuICAgIH1cbiAgICBDb25zdW1lck9ic2VydmVyLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHZhciBwYXJ0aWFsT2JzZXJ2ZXIgPSB0aGlzLnBhcnRpYWxPYnNlcnZlcjtcbiAgICAgICAgaWYgKHBhcnRpYWxPYnNlcnZlci5uZXh0KSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHBhcnRpYWxPYnNlcnZlci5uZXh0KHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGhhbmRsZVVuaGFuZGxlZEVycm9yKGVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgQ29uc3VtZXJPYnNlcnZlci5wcm90b3R5cGUuZXJyb3IgPSBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIHZhciBwYXJ0aWFsT2JzZXJ2ZXIgPSB0aGlzLnBhcnRpYWxPYnNlcnZlcjtcbiAgICAgICAgaWYgKHBhcnRpYWxPYnNlcnZlci5lcnJvcikge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBwYXJ0aWFsT2JzZXJ2ZXIuZXJyb3IoZXJyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGhhbmRsZVVuaGFuZGxlZEVycm9yKGVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGhhbmRsZVVuaGFuZGxlZEVycm9yKGVycik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIENvbnN1bWVyT2JzZXJ2ZXIucHJvdG90eXBlLmNvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcGFydGlhbE9ic2VydmVyID0gdGhpcy5wYXJ0aWFsT2JzZXJ2ZXI7XG4gICAgICAgIGlmIChwYXJ0aWFsT2JzZXJ2ZXIuY29tcGxldGUpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcGFydGlhbE9ic2VydmVyLmNvbXBsZXRlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBoYW5kbGVVbmhhbmRsZWRFcnJvcihlcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBDb25zdW1lck9ic2VydmVyO1xufSgpKTtcbnZhciBTYWZlU3Vic2NyaWJlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFNhZmVTdWJzY3JpYmVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFNhZmVTdWJzY3JpYmVyKG9ic2VydmVyT3JOZXh0LCBlcnJvciwgY29tcGxldGUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgdmFyIHBhcnRpYWxPYnNlcnZlcjtcbiAgICAgICAgaWYgKGlzRnVuY3Rpb24ob2JzZXJ2ZXJPck5leHQpIHx8ICFvYnNlcnZlck9yTmV4dCkge1xuICAgICAgICAgICAgcGFydGlhbE9ic2VydmVyID0ge1xuICAgICAgICAgICAgICAgIG5leHQ6IChvYnNlcnZlck9yTmV4dCAhPT0gbnVsbCAmJiBvYnNlcnZlck9yTmV4dCAhPT0gdm9pZCAwID8gb2JzZXJ2ZXJPck5leHQgOiB1bmRlZmluZWQpLFxuICAgICAgICAgICAgICAgIGVycm9yOiBlcnJvciAhPT0gbnVsbCAmJiBlcnJvciAhPT0gdm9pZCAwID8gZXJyb3IgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgY29tcGxldGU6IGNvbXBsZXRlICE9PSBudWxsICYmIGNvbXBsZXRlICE9PSB2b2lkIDAgPyBjb21wbGV0ZSA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgY29udGV4dF8xO1xuICAgICAgICAgICAgaWYgKF90aGlzICYmIGNvbmZpZy51c2VEZXByZWNhdGVkTmV4dENvbnRleHQpIHtcbiAgICAgICAgICAgICAgICBjb250ZXh0XzEgPSBPYmplY3QuY3JlYXRlKG9ic2VydmVyT3JOZXh0KTtcbiAgICAgICAgICAgICAgICBjb250ZXh0XzEudW5zdWJzY3JpYmUgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy51bnN1YnNjcmliZSgpOyB9O1xuICAgICAgICAgICAgICAgIHBhcnRpYWxPYnNlcnZlciA9IHtcbiAgICAgICAgICAgICAgICAgICAgbmV4dDogb2JzZXJ2ZXJPck5leHQubmV4dCAmJiBiaW5kKG9ic2VydmVyT3JOZXh0Lm5leHQsIGNvbnRleHRfMSksXG4gICAgICAgICAgICAgICAgICAgIGVycm9yOiBvYnNlcnZlck9yTmV4dC5lcnJvciAmJiBiaW5kKG9ic2VydmVyT3JOZXh0LmVycm9yLCBjb250ZXh0XzEpLFxuICAgICAgICAgICAgICAgICAgICBjb21wbGV0ZTogb2JzZXJ2ZXJPck5leHQuY29tcGxldGUgJiYgYmluZChvYnNlcnZlck9yTmV4dC5jb21wbGV0ZSwgY29udGV4dF8xKSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcGFydGlhbE9ic2VydmVyID0gb2JzZXJ2ZXJPck5leHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgX3RoaXMuZGVzdGluYXRpb24gPSBuZXcgQ29uc3VtZXJPYnNlcnZlcihwYXJ0aWFsT2JzZXJ2ZXIpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBTYWZlU3Vic2NyaWJlcjtcbn0oU3Vic2NyaWJlcikpO1xuZXhwb3J0IHsgU2FmZVN1YnNjcmliZXIgfTtcbmZ1bmN0aW9uIGhhbmRsZVVuaGFuZGxlZEVycm9yKGVycm9yKSB7XG4gICAgaWYgKGNvbmZpZy51c2VEZXByZWNhdGVkU3luY2hyb25vdXNFcnJvckhhbmRsaW5nKSB7XG4gICAgICAgIGNhcHR1cmVFcnJvcihlcnJvcik7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXBvcnRVbmhhbmRsZWRFcnJvcihlcnJvcik7XG4gICAgfVxufVxuZnVuY3Rpb24gZGVmYXVsdEVycm9ySGFuZGxlcihlcnIpIHtcbiAgICB0aHJvdyBlcnI7XG59XG5mdW5jdGlvbiBoYW5kbGVTdG9wcGVkTm90aWZpY2F0aW9uKG5vdGlmaWNhdGlvbiwgc3Vic2NyaWJlcikge1xuICAgIHZhciBvblN0b3BwZWROb3RpZmljYXRpb24gPSBjb25maWcub25TdG9wcGVkTm90aWZpY2F0aW9uO1xuICAgIG9uU3RvcHBlZE5vdGlmaWNhdGlvbiAmJiB0aW1lb3V0UHJvdmlkZXIuc2V0VGltZW91dChmdW5jdGlvbiAoKSB7IHJldHVybiBvblN0b3BwZWROb3RpZmljYXRpb24obm90aWZpY2F0aW9uLCBzdWJzY3JpYmVyKTsgfSk7XG59XG5leHBvcnQgdmFyIEVNUFRZX09CU0VSVkVSID0ge1xuICAgIGNsb3NlZDogdHJ1ZSxcbiAgICBuZXh0OiBub29wLFxuICAgIGVycm9yOiBkZWZhdWx0RXJyb3JIYW5kbGVyLFxuICAgIGNvbXBsZXRlOiBub29wLFxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVN1YnNjcmliZXIuanMubWFwIiwiaW1wb3J0IHsgX19yZWFkLCBfX3NwcmVhZEFycmF5LCBfX3ZhbHVlcyB9IGZyb20gXCJ0c2xpYlwiO1xuaW1wb3J0IHsgaXNGdW5jdGlvbiB9IGZyb20gJy4vdXRpbC9pc0Z1bmN0aW9uJztcbmltcG9ydCB7IFVuc3Vic2NyaXB0aW9uRXJyb3IgfSBmcm9tICcuL3V0aWwvVW5zdWJzY3JpcHRpb25FcnJvcic7XG5pbXBvcnQgeyBhcnJSZW1vdmUgfSBmcm9tICcuL3V0aWwvYXJyUmVtb3ZlJztcbnZhciBTdWJzY3JpcHRpb24gPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFN1YnNjcmlwdGlvbihpbml0aWFsVGVhcmRvd24pIHtcbiAgICAgICAgdGhpcy5pbml0aWFsVGVhcmRvd24gPSBpbml0aWFsVGVhcmRvd247XG4gICAgICAgIHRoaXMuY2xvc2VkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX3BhcmVudGFnZSA9IG51bGw7XG4gICAgICAgIHRoaXMuX2ZpbmFsaXplcnMgPSBudWxsO1xuICAgIH1cbiAgICBTdWJzY3JpcHRpb24ucHJvdG90eXBlLnVuc3Vic2NyaWJlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZV8xLCBfYSwgZV8yLCBfYjtcbiAgICAgICAgdmFyIGVycm9ycztcbiAgICAgICAgaWYgKCF0aGlzLmNsb3NlZCkge1xuICAgICAgICAgICAgdGhpcy5jbG9zZWQgPSB0cnVlO1xuICAgICAgICAgICAgdmFyIF9wYXJlbnRhZ2UgPSB0aGlzLl9wYXJlbnRhZ2U7XG4gICAgICAgICAgICBpZiAoX3BhcmVudGFnZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3BhcmVudGFnZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoX3BhcmVudGFnZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIF9wYXJlbnRhZ2VfMSA9IF9fdmFsdWVzKF9wYXJlbnRhZ2UpLCBfcGFyZW50YWdlXzFfMSA9IF9wYXJlbnRhZ2VfMS5uZXh0KCk7ICFfcGFyZW50YWdlXzFfMS5kb25lOyBfcGFyZW50YWdlXzFfMSA9IF9wYXJlbnRhZ2VfMS5uZXh0KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcGFyZW50XzEgPSBfcGFyZW50YWdlXzFfMS52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnRfMS5yZW1vdmUodGhpcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGVfMV8xKSB7IGVfMSA9IHsgZXJyb3I6IGVfMV8xIH07IH1cbiAgICAgICAgICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfcGFyZW50YWdlXzFfMSAmJiAhX3BhcmVudGFnZV8xXzEuZG9uZSAmJiAoX2EgPSBfcGFyZW50YWdlXzEucmV0dXJuKSkgX2EuY2FsbChfcGFyZW50YWdlXzEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZmluYWxseSB7IGlmIChlXzEpIHRocm93IGVfMS5lcnJvcjsgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBfcGFyZW50YWdlLnJlbW92ZSh0aGlzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgaW5pdGlhbEZpbmFsaXplciA9IHRoaXMuaW5pdGlhbFRlYXJkb3duO1xuICAgICAgICAgICAgaWYgKGlzRnVuY3Rpb24oaW5pdGlhbEZpbmFsaXplcikpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBpbml0aWFsRmluYWxpemVyKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIGVycm9ycyA9IGUgaW5zdGFuY2VvZiBVbnN1YnNjcmlwdGlvbkVycm9yID8gZS5lcnJvcnMgOiBbZV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIF9maW5hbGl6ZXJzID0gdGhpcy5fZmluYWxpemVycztcbiAgICAgICAgICAgIGlmIChfZmluYWxpemVycykge1xuICAgICAgICAgICAgICAgIHRoaXMuX2ZpbmFsaXplcnMgPSBudWxsO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIF9maW5hbGl6ZXJzXzEgPSBfX3ZhbHVlcyhfZmluYWxpemVycyksIF9maW5hbGl6ZXJzXzFfMSA9IF9maW5hbGl6ZXJzXzEubmV4dCgpOyAhX2ZpbmFsaXplcnNfMV8xLmRvbmU7IF9maW5hbGl6ZXJzXzFfMSA9IF9maW5hbGl6ZXJzXzEubmV4dCgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZmluYWxpemVyID0gX2ZpbmFsaXplcnNfMV8xLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBleGVjRmluYWxpemVyKGZpbmFsaXplcik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JzID0gZXJyb3JzICE9PSBudWxsICYmIGVycm9ycyAhPT0gdm9pZCAwID8gZXJyb3JzIDogW107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVyciBpbnN0YW5jZW9mIFVuc3Vic2NyaXB0aW9uRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JzID0gX19zcHJlYWRBcnJheShfX3NwcmVhZEFycmF5KFtdLCBfX3JlYWQoZXJyb3JzKSksIF9fcmVhZChlcnIuZXJyb3JzKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcnMucHVzaChlcnIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZV8yXzEpIHsgZV8yID0geyBlcnJvcjogZV8yXzEgfTsgfVxuICAgICAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9maW5hbGl6ZXJzXzFfMSAmJiAhX2ZpbmFsaXplcnNfMV8xLmRvbmUgJiYgKF9iID0gX2ZpbmFsaXplcnNfMS5yZXR1cm4pKSBfYi5jYWxsKF9maW5hbGl6ZXJzXzEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGZpbmFsbHkgeyBpZiAoZV8yKSB0aHJvdyBlXzIuZXJyb3I7IH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZXJyb3JzKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFVuc3Vic2NyaXB0aW9uRXJyb3IoZXJyb3JzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgU3Vic2NyaXB0aW9uLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiAodGVhcmRvd24pIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBpZiAodGVhcmRvd24gJiYgdGVhcmRvd24gIT09IHRoaXMpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmNsb3NlZCkge1xuICAgICAgICAgICAgICAgIGV4ZWNGaW5hbGl6ZXIodGVhcmRvd24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKHRlYXJkb3duIGluc3RhbmNlb2YgU3Vic2NyaXB0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0ZWFyZG93bi5jbG9zZWQgfHwgdGVhcmRvd24uX2hhc1BhcmVudCh0aGlzKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRlYXJkb3duLl9hZGRQYXJlbnQodGhpcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICh0aGlzLl9maW5hbGl6ZXJzID0gKF9hID0gdGhpcy5fZmluYWxpemVycykgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogW10pLnB1c2godGVhcmRvd24pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBTdWJzY3JpcHRpb24ucHJvdG90eXBlLl9oYXNQYXJlbnQgPSBmdW5jdGlvbiAocGFyZW50KSB7XG4gICAgICAgIHZhciBfcGFyZW50YWdlID0gdGhpcy5fcGFyZW50YWdlO1xuICAgICAgICByZXR1cm4gX3BhcmVudGFnZSA9PT0gcGFyZW50IHx8IChBcnJheS5pc0FycmF5KF9wYXJlbnRhZ2UpICYmIF9wYXJlbnRhZ2UuaW5jbHVkZXMocGFyZW50KSk7XG4gICAgfTtcbiAgICBTdWJzY3JpcHRpb24ucHJvdG90eXBlLl9hZGRQYXJlbnQgPSBmdW5jdGlvbiAocGFyZW50KSB7XG4gICAgICAgIHZhciBfcGFyZW50YWdlID0gdGhpcy5fcGFyZW50YWdlO1xuICAgICAgICB0aGlzLl9wYXJlbnRhZ2UgPSBBcnJheS5pc0FycmF5KF9wYXJlbnRhZ2UpID8gKF9wYXJlbnRhZ2UucHVzaChwYXJlbnQpLCBfcGFyZW50YWdlKSA6IF9wYXJlbnRhZ2UgPyBbX3BhcmVudGFnZSwgcGFyZW50XSA6IHBhcmVudDtcbiAgICB9O1xuICAgIFN1YnNjcmlwdGlvbi5wcm90b3R5cGUuX3JlbW92ZVBhcmVudCA9IGZ1bmN0aW9uIChwYXJlbnQpIHtcbiAgICAgICAgdmFyIF9wYXJlbnRhZ2UgPSB0aGlzLl9wYXJlbnRhZ2U7XG4gICAgICAgIGlmIChfcGFyZW50YWdlID09PSBwYXJlbnQpIHtcbiAgICAgICAgICAgIHRoaXMuX3BhcmVudGFnZSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheShfcGFyZW50YWdlKSkge1xuICAgICAgICAgICAgYXJyUmVtb3ZlKF9wYXJlbnRhZ2UsIHBhcmVudCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFN1YnNjcmlwdGlvbi5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gKHRlYXJkb3duKSB7XG4gICAgICAgIHZhciBfZmluYWxpemVycyA9IHRoaXMuX2ZpbmFsaXplcnM7XG4gICAgICAgIF9maW5hbGl6ZXJzICYmIGFyclJlbW92ZShfZmluYWxpemVycywgdGVhcmRvd24pO1xuICAgICAgICBpZiAodGVhcmRvd24gaW5zdGFuY2VvZiBTdWJzY3JpcHRpb24pIHtcbiAgICAgICAgICAgIHRlYXJkb3duLl9yZW1vdmVQYXJlbnQodGhpcyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFN1YnNjcmlwdGlvbi5FTVBUWSA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBlbXB0eSA9IG5ldyBTdWJzY3JpcHRpb24oKTtcbiAgICAgICAgZW1wdHkuY2xvc2VkID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIGVtcHR5O1xuICAgIH0pKCk7XG4gICAgcmV0dXJuIFN1YnNjcmlwdGlvbjtcbn0oKSk7XG5leHBvcnQgeyBTdWJzY3JpcHRpb24gfTtcbmV4cG9ydCB2YXIgRU1QVFlfU1VCU0NSSVBUSU9OID0gU3Vic2NyaXB0aW9uLkVNUFRZO1xuZXhwb3J0IGZ1bmN0aW9uIGlzU3Vic2NyaXB0aW9uKHZhbHVlKSB7XG4gICAgcmV0dXJuICh2YWx1ZSBpbnN0YW5jZW9mIFN1YnNjcmlwdGlvbiB8fFxuICAgICAgICAodmFsdWUgJiYgJ2Nsb3NlZCcgaW4gdmFsdWUgJiYgaXNGdW5jdGlvbih2YWx1ZS5yZW1vdmUpICYmIGlzRnVuY3Rpb24odmFsdWUuYWRkKSAmJiBpc0Z1bmN0aW9uKHZhbHVlLnVuc3Vic2NyaWJlKSkpO1xufVxuZnVuY3Rpb24gZXhlY0ZpbmFsaXplcihmaW5hbGl6ZXIpIHtcbiAgICBpZiAoaXNGdW5jdGlvbihmaW5hbGl6ZXIpKSB7XG4gICAgICAgIGZpbmFsaXplcigpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgZmluYWxpemVyLnVuc3Vic2NyaWJlKCk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9U3Vic2NyaXB0aW9uLmpzLm1hcCIsImV4cG9ydCB2YXIgY29uZmlnID0ge1xuICAgIG9uVW5oYW5kbGVkRXJyb3I6IG51bGwsXG4gICAgb25TdG9wcGVkTm90aWZpY2F0aW9uOiBudWxsLFxuICAgIFByb21pc2U6IHVuZGVmaW5lZCxcbiAgICB1c2VEZXByZWNhdGVkU3luY2hyb25vdXNFcnJvckhhbmRsaW5nOiBmYWxzZSxcbiAgICB1c2VEZXByZWNhdGVkTmV4dENvbnRleHQ6IGZhbHNlLFxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbmZpZy5qcy5tYXAiLCJpbXBvcnQgeyBfX2V4dGVuZHMgfSBmcm9tIFwidHNsaWJcIjtcbmltcG9ydCB7IFN1YnNjcmliZXIgfSBmcm9tICcuLi9TdWJzY3JpYmVyJztcbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVPcGVyYXRvclN1YnNjcmliZXIoZGVzdGluYXRpb24sIG9uTmV4dCwgb25Db21wbGV0ZSwgb25FcnJvciwgb25GaW5hbGl6ZSkge1xuICAgIHJldHVybiBuZXcgT3BlcmF0b3JTdWJzY3JpYmVyKGRlc3RpbmF0aW9uLCBvbk5leHQsIG9uQ29tcGxldGUsIG9uRXJyb3IsIG9uRmluYWxpemUpO1xufVxudmFyIE9wZXJhdG9yU3Vic2NyaWJlciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE9wZXJhdG9yU3Vic2NyaWJlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBPcGVyYXRvclN1YnNjcmliZXIoZGVzdGluYXRpb24sIG9uTmV4dCwgb25Db21wbGV0ZSwgb25FcnJvciwgb25GaW5hbGl6ZSwgc2hvdWxkVW5zdWJzY3JpYmUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgZGVzdGluYXRpb24pIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLm9uRmluYWxpemUgPSBvbkZpbmFsaXplO1xuICAgICAgICBfdGhpcy5zaG91bGRVbnN1YnNjcmliZSA9IHNob3VsZFVuc3Vic2NyaWJlO1xuICAgICAgICBfdGhpcy5fbmV4dCA9IG9uTmV4dFxuICAgICAgICAgICAgPyBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBvbk5leHQodmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlc3RpbmF0aW9uLmVycm9yKGVycik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgOiBfc3VwZXIucHJvdG90eXBlLl9uZXh0O1xuICAgICAgICBfdGhpcy5fZXJyb3IgPSBvbkVycm9yXG4gICAgICAgICAgICA/IGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBvbkVycm9yKGVycik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVzdGluYXRpb24uZXJyb3IoZXJyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICA6IF9zdXBlci5wcm90b3R5cGUuX2Vycm9yO1xuICAgICAgICBfdGhpcy5fY29tcGxldGUgPSBvbkNvbXBsZXRlXG4gICAgICAgICAgICA/IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBvbkNvbXBsZXRlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVzdGluYXRpb24uZXJyb3IoZXJyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICA6IF9zdXBlci5wcm90b3R5cGUuX2NvbXBsZXRlO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIE9wZXJhdG9yU3Vic2NyaWJlci5wcm90b3R5cGUudW5zdWJzY3JpYmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgaWYgKCF0aGlzLnNob3VsZFVuc3Vic2NyaWJlIHx8IHRoaXMuc2hvdWxkVW5zdWJzY3JpYmUoKSkge1xuICAgICAgICAgICAgdmFyIGNsb3NlZF8xID0gdGhpcy5jbG9zZWQ7XG4gICAgICAgICAgICBfc3VwZXIucHJvdG90eXBlLnVuc3Vic2NyaWJlLmNhbGwodGhpcyk7XG4gICAgICAgICAgICAhY2xvc2VkXzEgJiYgKChfYSA9IHRoaXMub25GaW5hbGl6ZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwodGhpcykpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gT3BlcmF0b3JTdWJzY3JpYmVyO1xufShTdWJzY3JpYmVyKSk7XG5leHBvcnQgeyBPcGVyYXRvclN1YnNjcmliZXIgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPU9wZXJhdG9yU3Vic2NyaWJlci5qcy5tYXAiLCJpbXBvcnQgeyBvcGVyYXRlIH0gZnJvbSAnLi4vdXRpbC9saWZ0JztcbmltcG9ydCB7IGNyZWF0ZU9wZXJhdG9yU3Vic2NyaWJlciB9IGZyb20gJy4vT3BlcmF0b3JTdWJzY3JpYmVyJztcbmV4cG9ydCBmdW5jdGlvbiBtYXAocHJvamVjdCwgdGhpc0FyZykge1xuICAgIHJldHVybiBvcGVyYXRlKGZ1bmN0aW9uIChzb3VyY2UsIHN1YnNjcmliZXIpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gMDtcbiAgICAgICAgc291cmNlLnN1YnNjcmliZShjcmVhdGVPcGVyYXRvclN1YnNjcmliZXIoc3Vic2NyaWJlciwgZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICBzdWJzY3JpYmVyLm5leHQocHJvamVjdC5jYWxsKHRoaXNBcmcsIHZhbHVlLCBpbmRleCsrKSk7XG4gICAgICAgIH0pKTtcbiAgICB9KTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1hcC5qcy5tYXAiLCJpbXBvcnQgeyBfX3JlYWQsIF9fc3ByZWFkQXJyYXkgfSBmcm9tIFwidHNsaWJcIjtcbmV4cG9ydCB2YXIgdGltZW91dFByb3ZpZGVyID0ge1xuICAgIHNldFRpbWVvdXQ6IGZ1bmN0aW9uIChoYW5kbGVyLCB0aW1lb3V0KSB7XG4gICAgICAgIHZhciBhcmdzID0gW107XG4gICAgICAgIGZvciAodmFyIF9pID0gMjsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICBhcmdzW19pIC0gMl0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICB9XG4gICAgICAgIHZhciBkZWxlZ2F0ZSA9IHRpbWVvdXRQcm92aWRlci5kZWxlZ2F0ZTtcbiAgICAgICAgaWYgKGRlbGVnYXRlID09PSBudWxsIHx8IGRlbGVnYXRlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBkZWxlZ2F0ZS5zZXRUaW1lb3V0KSB7XG4gICAgICAgICAgICByZXR1cm4gZGVsZWdhdGUuc2V0VGltZW91dC5hcHBseShkZWxlZ2F0ZSwgX19zcHJlYWRBcnJheShbaGFuZGxlciwgdGltZW91dF0sIF9fcmVhZChhcmdzKSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0LmFwcGx5KHZvaWQgMCwgX19zcHJlYWRBcnJheShbaGFuZGxlciwgdGltZW91dF0sIF9fcmVhZChhcmdzKSkpO1xuICAgIH0sXG4gICAgY2xlYXJUaW1lb3V0OiBmdW5jdGlvbiAoaGFuZGxlKSB7XG4gICAgICAgIHZhciBkZWxlZ2F0ZSA9IHRpbWVvdXRQcm92aWRlci5kZWxlZ2F0ZTtcbiAgICAgICAgcmV0dXJuICgoZGVsZWdhdGUgPT09IG51bGwgfHwgZGVsZWdhdGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGRlbGVnYXRlLmNsZWFyVGltZW91dCkgfHwgY2xlYXJUaW1lb3V0KShoYW5kbGUpO1xuICAgIH0sXG4gICAgZGVsZWdhdGU6IHVuZGVmaW5lZCxcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD10aW1lb3V0UHJvdmlkZXIuanMubWFwIiwiaW1wb3J0IHsgY3JlYXRlRXJyb3JDbGFzcyB9IGZyb20gJy4vY3JlYXRlRXJyb3JDbGFzcyc7XG5leHBvcnQgdmFyIFVuc3Vic2NyaXB0aW9uRXJyb3IgPSBjcmVhdGVFcnJvckNsYXNzKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gVW5zdWJzY3JpcHRpb25FcnJvckltcGwoZXJyb3JzKSB7XG4gICAgICAgIF9zdXBlcih0aGlzKTtcbiAgICAgICAgdGhpcy5tZXNzYWdlID0gZXJyb3JzXG4gICAgICAgICAgICA/IGVycm9ycy5sZW5ndGggKyBcIiBlcnJvcnMgb2NjdXJyZWQgZHVyaW5nIHVuc3Vic2NyaXB0aW9uOlxcblwiICsgZXJyb3JzLm1hcChmdW5jdGlvbiAoZXJyLCBpKSB7IHJldHVybiBpICsgMSArIFwiKSBcIiArIGVyci50b1N0cmluZygpOyB9KS5qb2luKCdcXG4gICcpXG4gICAgICAgICAgICA6ICcnO1xuICAgICAgICB0aGlzLm5hbWUgPSAnVW5zdWJzY3JpcHRpb25FcnJvcic7XG4gICAgICAgIHRoaXMuZXJyb3JzID0gZXJyb3JzO1xuICAgIH07XG59KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVVuc3Vic2NyaXB0aW9uRXJyb3IuanMubWFwIiwiZXhwb3J0IGZ1bmN0aW9uIGFyclJlbW92ZShhcnIsIGl0ZW0pIHtcbiAgICBpZiAoYXJyKSB7XG4gICAgICAgIHZhciBpbmRleCA9IGFyci5pbmRleE9mKGl0ZW0pO1xuICAgICAgICAwIDw9IGluZGV4ICYmIGFyci5zcGxpY2UoaW5kZXgsIDEpO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFyclJlbW92ZS5qcy5tYXAiLCJleHBvcnQgZnVuY3Rpb24gY3JlYXRlRXJyb3JDbGFzcyhjcmVhdGVJbXBsKSB7XG4gICAgdmFyIF9zdXBlciA9IGZ1bmN0aW9uIChpbnN0YW5jZSkge1xuICAgICAgICBFcnJvci5jYWxsKGluc3RhbmNlKTtcbiAgICAgICAgaW5zdGFuY2Uuc3RhY2sgPSBuZXcgRXJyb3IoKS5zdGFjaztcbiAgICB9O1xuICAgIHZhciBjdG9yRnVuYyA9IGNyZWF0ZUltcGwoX3N1cGVyKTtcbiAgICBjdG9yRnVuYy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEVycm9yLnByb3RvdHlwZSk7XG4gICAgY3RvckZ1bmMucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gY3RvckZ1bmM7XG4gICAgcmV0dXJuIGN0b3JGdW5jO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y3JlYXRlRXJyb3JDbGFzcy5qcy5tYXAiLCJpbXBvcnQgeyBjb25maWcgfSBmcm9tICcuLi9jb25maWcnO1xudmFyIGNvbnRleHQgPSBudWxsO1xuZXhwb3J0IGZ1bmN0aW9uIGVycm9yQ29udGV4dChjYikge1xuICAgIGlmIChjb25maWcudXNlRGVwcmVjYXRlZFN5bmNocm9ub3VzRXJyb3JIYW5kbGluZykge1xuICAgICAgICB2YXIgaXNSb290ID0gIWNvbnRleHQ7XG4gICAgICAgIGlmIChpc1Jvb3QpIHtcbiAgICAgICAgICAgIGNvbnRleHQgPSB7IGVycm9yVGhyb3duOiBmYWxzZSwgZXJyb3I6IG51bGwgfTtcbiAgICAgICAgfVxuICAgICAgICBjYigpO1xuICAgICAgICBpZiAoaXNSb290KSB7XG4gICAgICAgICAgICB2YXIgX2EgPSBjb250ZXh0LCBlcnJvclRocm93biA9IF9hLmVycm9yVGhyb3duLCBlcnJvciA9IF9hLmVycm9yO1xuICAgICAgICAgICAgY29udGV4dCA9IG51bGw7XG4gICAgICAgICAgICBpZiAoZXJyb3JUaHJvd24pIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY2IoKTtcbiAgICB9XG59XG5leHBvcnQgZnVuY3Rpb24gY2FwdHVyZUVycm9yKGVycikge1xuICAgIGlmIChjb25maWcudXNlRGVwcmVjYXRlZFN5bmNocm9ub3VzRXJyb3JIYW5kbGluZyAmJiBjb250ZXh0KSB7XG4gICAgICAgIGNvbnRleHQuZXJyb3JUaHJvd24gPSB0cnVlO1xuICAgICAgICBjb250ZXh0LmVycm9yID0gZXJyO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWVycm9yQ29udGV4dC5qcy5tYXAiLCJleHBvcnQgZnVuY3Rpb24gaXNGdW5jdGlvbih2YWx1ZSkge1xuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbic7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pc0Z1bmN0aW9uLmpzLm1hcCIsImltcG9ydCB7IGlzRnVuY3Rpb24gfSBmcm9tICcuL2lzRnVuY3Rpb24nO1xuZXhwb3J0IGZ1bmN0aW9uIGhhc0xpZnQoc291cmNlKSB7XG4gICAgcmV0dXJuIGlzRnVuY3Rpb24oc291cmNlID09PSBudWxsIHx8IHNvdXJjZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogc291cmNlLmxpZnQpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIG9wZXJhdGUoaW5pdCkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoc291cmNlKSB7XG4gICAgICAgIGlmIChoYXNMaWZ0KHNvdXJjZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBzb3VyY2UubGlmdChmdW5jdGlvbiAobGlmdGVkU291cmNlKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGluaXQobGlmdGVkU291cmNlLCB0aGlzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVycm9yKGVycik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5hYmxlIHRvIGxpZnQgdW5rbm93biBPYnNlcnZhYmxlIHR5cGUnKTtcbiAgICB9O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bGlmdC5qcy5tYXAiLCJleHBvcnQgZnVuY3Rpb24gbm9vcCgpIHsgfVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bm9vcC5qcy5tYXAiLCJpbXBvcnQgeyBjb25maWcgfSBmcm9tICcuLi9jb25maWcnO1xuaW1wb3J0IHsgdGltZW91dFByb3ZpZGVyIH0gZnJvbSAnLi4vc2NoZWR1bGVyL3RpbWVvdXRQcm92aWRlcic7XG5leHBvcnQgZnVuY3Rpb24gcmVwb3J0VW5oYW5kbGVkRXJyb3IoZXJyKSB7XG4gICAgdGltZW91dFByb3ZpZGVyLnNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgb25VbmhhbmRsZWRFcnJvciA9IGNvbmZpZy5vblVuaGFuZGxlZEVycm9yO1xuICAgICAgICBpZiAob25VbmhhbmRsZWRFcnJvcikge1xuICAgICAgICAgICAgb25VbmhhbmRsZWRFcnJvcihlcnIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICB9XG4gICAgfSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZXBvcnRVbmhhbmRsZWRFcnJvci5qcy5tYXAiLCIvKlxuICogQ29weXJpZ2h0IDIwMTUtMjAyNC4gUml0ZW5zZSBCViwgdGhlIE5ldGhlcmxhbmRzLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIEVVUEwsIFZlcnNpb24gMS4yICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cHM6Ly9qb2ludXAuZWMuZXVyb3BhLmV1L2NvbGxlY3Rpb24vZXVwbC9ldXBsLXRleHQtZXVwbC0xMlxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBiYXNpcyxcbiAqXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyXG4gKiBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKi9cblxuY29uc3QgQkVSS0VMWUJSSURHRV9URVhUR0VORVJBVElPTl9QTFVHSU5fTE9HT19CQVNFNjQgPVxuICAgICdkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQXprQUFBTTVDQVlBQUFBa0V2OFpBQUFBSUdOSVVrMEFBSG9tQUFDQWhBQUErZ0FBQUlEb0FBQjFNQUFBNm1BQUFEcVlBQUFYY0p5NlVUd0FBQUFHWWt0SFJBRC9BUDhBLzZDOXA1TUFBQUFKY0VoWmN3QUFMaU1BQUM0akFYaWxQM1lBQUFBSGRFbE5SUWZvQXdnTkZTSmUybFhUQUFDQUFFbEVRVlI0MnV6OVozc2JTYmF2ZWQ4UmtRNEFuYnpLVjd0dGpwazU4LzAvd3p6ajlwenAzdDFWOG9hZWhFa1RiajB2RXFSVTFXV2tLa2wwNjljWG1oQkpxWklHUVA0elZxeGxSRVJRU2lsMWFZa0lXUVFCZ2tBYk0xMFd1cFRwczlDdjMvcC91dVh4cmZ6eng0YXpqNjF2UVFTZk9iOGZSVWdDVVlUOG8xZUp1UDc0MmNjRWtQWGJNMG5HZnlka0liNzFBUU00QTg0WUNnUFdHQ3pqVzh5Yno3TkFhUXlWTlJURy9PQy9iODM2eHZodlZOWlEydkZ6cS9YZk9YL2ZXMy8rNGMxU1dVUDkxdCtycmFGMjY3ZldNbldXcVROTW5hVkFLSXpCV1l2NTBmRW9wWlM2ZklxTFBnQ2xsTHBPenE0YmhSaUpLWTIzbU43Y1g5OVN5cVNjU2ZuTi9aOTl2eXVKell3MDNTU1VOWU1JUXhhOGpFRWxySVBLR0R3Z1p2bEJFRGtMR2xGay9USEdJUE9EejRPWTN3U1lER1FadzByKzBkZVkxd0VvcllQWDJlMkhuOE02S0kyZmU4YndKcUE0QTJPMk1kZ2Y1UVlERkc4Rm9iZFp4cjluMTMvdjdQT0tkU0Q2NXorenZvM0I1L3h6cktGODYzTkxBK1g1KzlhQlp4MTZ5cTZsN0pZVTNRcVhFczQ1bkxVNGF5bUtzL3NPNSt6NSs1MnpGTTdocktOd2pxSll2M1dPd2xuS29zQlppMTBISncxUFNpbjE0V2pJVVVxcEQwUkV4aHZqaWtnZk0zMU1kRDdReDBnZkluMk1EREV4eElpUEdaOFNQaVo4U2d4eHZEL0UrSVAzZTFmaEo1RXd6ZmlxZVJOWWVCTTJrb3poNCsxZzhsTi9UZ0tadHo2Zk1aQ01Iek5rMXFzelpseWR5UWcvWHU4WElKOTl2Vys5NzRmZkMzNXdER2ZPRm16R3NET2UxSnYxKzk5MjluSExEeFo0ZnZSdm1IWFlHVC9YdlhYZnJ1Kzd0KzViOC9hZnpmbDlad3dXT2Y4MzNQcS9leDZTTEpUZGltcTFvR3dYVkRsVEZZN0tPYXJDVWI5MXYzTGpyUzdPUGxaUU9VZFRPcHFpb0NrTEptVkpVem9teGxJYmc4dFpWNGlVVXVvRDA1Q2psRklmMEZrQThGaGE0MWdhWVdGaGFTMEw2MWlhZ3RabVdwZHBKZE54ZGt1MFpGb3luY2wwTnRPYVJHY3p2Umo2d1RENEFVODREeERDajBMR1d5VmpJdWZ2UGYrc0gzNk1INzRQT0lzVEl1ZDMzL292L1BUWCtxdmZqMS80cEY4N3B6ZS8rREh6ay8rVytZbS9QMzVNZnZnKzdJOCtYLzdwM3hqRDEvaGZLaVZUUzBWdGIxRTdtQmFXaVJ0djA4SzlkZDh5Y2VzL1c4dk1qbTgzakdQRE9qYXNaZE00Tm5FWUxFNE1JRml0SEZkS3FROUtRNDVTU3EySkNEbG44cnAwN0t6VUxPV3p0MmNsWlc5S3ptS0tZMWtaRUt1R1VFK0l6WXhWeXJRcDA2YkVLbWJhSkt4aVB0OUgweVdoenpBa3c1QXRmWVkrV1hySjlDSU1DTDNOREFoRFd1K3JTVUxJYVR6V2ovTWQrTW03SCs4YmZtRi9HZjZwQ08rWC96dUZnZElXNTN0NmFtTnBqS0hCVUl1bHlZWWFROFA2Zm9MR1FST0Z4Z2xUbDVqNnpNUlpaaTR5YzVhcHRVeE5wdXBiS3Q5VGhtRmQrdVorVU9wMmZuOWQ2bmIyNThJVkZJVWJWNkNjdzFyN0NYNW9TaWwxTldqSVVVb3B4b0NUVWlKbElVcW05WkV1QkZvZkdFS2tEMkVzTnp1Ly8rYlBRNHowS1ROTU51Z25Hd3l6UE82Wnlaa2haNGIwWnBOL3lHY2I4dGY3WW9UMW5wazNINHZuSDVQemo3MjlCMFo5ZW5tOVp3a3JwQXhSTWtPRzFocUttTS8zK3BUbiszdk0rUjZnY3IzZjUwM1RBNmlOSGQvbVJMMmEwL1FyNnI2bEtZdjFyYVF1QytyQzBaVGwrZnVhc21CU2pXK25sZENJVUZsTEtVSlZWUmY5YlZKS3FVdERRNDVTU3ExbEVZSmt2QmlXR0U3Rk1oZkhFbGhpV0dCWmltVWhscVU0RmhKWlNtS1ZJOHNrckZwTE93VGF4Zng4MC8zYisyRE85cjRJckx1U21mWDl0OS8zVnNleXR6NzI0KzVsNnRNNjI0T1VFaGdqREcvdEJ6cmJJMlRYcFczais4eDVrNFUzelJiZU5GMDR1MStJTUVuQ05KZE1aTWFHT0Rha09IODdXNy9kWEw5dmMzMS9VeHpiWWhFeFNNci8xSnhCS2FWdU9nMDVTcWxyS2VkOFhuNzJkbGxaZnJ0eldVcm45MFBPRExhZ0x5cjZxdUUwSnVZaE00K3dqSVpsdEN4andWSU1TeHhMVTdKMG1hVmtWbVJXZGwyZUZqSmQzLzhncUtqcjRmem5LWkQ0TUtuVEFvMnpUTnlFcHJSc0ZKYVpzMnc0eTh3NFpzYXlnV1VqV3piaWVIOVRZRE1MV3lteDVST1RvV1VhUFZNeXpocWNIVXZYeGs1dlkxYzM5MWJwMjNsbnVIV0ptelk4VUVwZFJ4cHlsRkxYVW95UmtCSWhDNTMzZEQ3UURYNHNMUXVCM29mejByTjI4SFE1MDFZVFZzMk1kckpCbTRRK25lMmRHVnMyOTJrc1ArdlAzemZlOTFubzg1dDJ6bGxYWGRRN0VpQUs5RW5Ja2treS9wNnRrcVcyZVQyeng5QllPNzUxaHNhYWRUQXlUSXd3V1ozU3RBc20vV3JzNEZhVjFFWEJwQzZaVk5XNnZPM04vVWxWVVorVnYxWGwrY3FUVWtwZEp4cHlsRkxYam9nUWMyWklRaTl3bXN6NWJSa01DMjlZQnN2Y0crYUQ0WFN3ekNNc2hzeThIVmdXYitiS0pERS9tUGZ5YTI4em9pczQ2cDBKNDF5amJJUWdoajZQTGF4ZFNPUGJkVXRyeDF2MzEvdCtuQmxmeENmZTAzaG9nbU9qdEd3bXcwWmwyUkxMdGhpMk1Xd1p3N1kxYkRuRFZvSk5aekFDMVhwcFNvT09VdXE2MFpDamxMb1N6bWJRbkhVL0c4dlFFam1QVjhEZmZuOU1tVFlMclMxb3l3bEgwWENTSE1kU01UY0ZwN1prN2pLblJlSllFc2NrVHQyNlBLMVBMT0p3MFYrdXVrSE9aaFh4czFPSGZsbGpDeXBiVWs4MjJTb2RXNFZqcTdUY0toMDdoZU9XZGV6Z3VJWGpWbmJzSk10MmhHMGpiSk1vWXFCSWtZSzhuakZrc2Rhc1M5N0drcmEzQjVacUdGSktYUVVhY3BSU2w5NjRkeWFUY3FZYi9BL0t6OXBoR1A4OGVIb2Y2THluVDVtdW50SlB0K2htMjZ4aVpwWEdXNWVFTm8ydG5OdjErODVhUEhjcEU3S3V3YWlySmNuWWpZOE15N2d1ZWN1V1Zjd2NoOFNlRy9mNXpBckwxQnBtaFdWV3VQUGJwSnN6NlZzbW9hY3BITk82R2t2YjFtK25UVDBPTlMwY1pWRlFGSHJxb0pTNi9QU1pTaWwxNmVVc2hKVHhJc3lUY0JJeUowUGlwRThjZDRtVFBuTGFSMDZId0dudldhWk1YeFVNWGNmUXVoKzJiaFlobnJWcVhyZHY5dm5OKzZNT1pWUlhUQkpCTWlRRFVSSjlOaXhpcGpSankrcHkzZEw2N1ZiV3RiUFUxbEpaeTFabzJZbzlXeW13WFdWdVJjZE9UdXlRMlRIQ2pzdHNtVXdXc01haUdVY3BkUlhvVTVWUzZrTEpPbFM4L2ZidCt6bG5ocGpvUmVoTndTRUZld2IyWGNGZVViRmZOZXhKWk45RURtemt3Q1ZPUWhybjBuUkNhRmZ2ZlV4YWpLT3VFb0h6ZldFQjZOS3ZCL1czOS9mY0toMjNxeW0zRzhmZHF1QitYZktnTExoWEZOeXpqbUFLVWpiRUZFSHkyREo3WGJMMmR2bmFqKzhycGRSRjBwQ2psTG93UGdSOGlQZ1lHUHk2NDVuM0RPSHN6NTQrUkxxeVpsVk5hQ2ViekZQbUpHUVdNWE1hTXFjeGNSb1M4NWlaaDBTN0hyd1pSY2k2L1YrcG55VHJKaGxnNk5MWUtqMkpNQ1JoRllVakgzblJPN1lMeDNaaDJTS3owYzNaOEMyekhLakxrcWFxcUt2eGJWT1YxR1ZKL2RiOXdqbU1HZmYyS0tYVXA2WWhSeWwxSVVUR0VySlZTaXg5WWpGRVRudlBhVGN3N3dkTys0RjU3NW43d0xJSUxLckVxb0V1ODZhbDg3cXQ4OWpTT1RPczN4L1dRemkxOGt5cG4vYjI4Tmt1Q3ptTUswRExtRGtLZWQybTJsQmJTMk1OazV5WURTdG1ROHNzOUd3MU5kdnIyMWFUMlc2RXJRYTJ4TEpsTEZ1dXdEcXc2NVZaWGRsUlNuMXFHbktVVWhmR0F5dGpPYkVsQjlhdzV4eTdSY2wrVWJOZkJ2WlM1RUFDOHdUemxUQmZyTWI5QndJWWMzNlNkdDZUU2dkd0t2Vk9makRZTkFsOVNoZ1lTOUdJR016NlBoZ1p5OXVtdG1CbU5wblZXOXlyU3U1WEJmZktrbnRGd1gxWGNzK1ZlRnVBTGFpTVhiZW5IZ2VlS3FYVXA2WWhSeW4xd2VXY0NURVNZand2U2V1SFlTeERNNWJlT2ZxcVlwNkUweUNjUk1OSkdEdEJIZnZFYWNpY0JEak9obE1wYUNXemtyRWpXajc3aitneWpWSWZ5TGpLSXJ6OXNQcmhSRnNySU1ZUWpXUEFrTFBGUjhQU0NNZVMyWStSblNEczlJbWRMckpUQlRhSk5IMUhFejJOWk9xcXBDN0hFcmV6KzFWWjRwelYxdFJLcVE5T1E0NVM2b09MU2VoQ1pqVkVWdDV6MnZXY2REMm4zY0FKY0dvZEowWEZJaHVXQ1piSnNvcGoyVXdYTTEzT3RER1BmMTd2c1FsWmRJVkdxUXN5RGkwRnlHUXhDREJrNFhUZG9ucHFMUk0zdHFlZUZwWkpZZG1ReUdhL0dqdTNTV1o3MHJBOXFkbVpUc1lTdDRsaDJ6a3c0Tlp6ZUpSUzZrUFJrS09VK3VBU2hpNDc1aFFja2RpbFloZGhGOHZyRU5rTm1WZkpzNHBDbjZITFFzaHZPa1NOd3hHRkpPTytnWXlzUzlPVVVoZEJnQ2hDU3VETnVCL3VOQ1NjTVZnRGp2RnRjZDZ1R3FZRzdsamhqcTI1V3hnZVVQUEFWRHlnNUQ0bEJzY0VnOE5nUkxTc1RTbjFRV25JVVVxOWx4Z2pNU1hpdWh3dGhIVlpXallFVStGTncwb0tUbUxpTkVlT1UyTGZDL3ZCc1orRi9RajdJYkUvUkxvNHJ0TDRMRy9LMEg2Qlh1ZFY2bUtkbGJTOTZWejR3MHNQaG5IL2ptRnNYTEFxSFl2S2NZcmpOQmVjQk1lUk1leExaaTlGWGdlWUpVOFRCeHBKVk01UUZpVlZXYTRIajc0WlFLb3JQVXFwOTZFaFJ5bjF6bklXaHBScGZhRHRCeGI5d0tMcm1YYzlpMmlaUzhQQ2JyQ2dZaW1CSlo2RkJKWXhzWWo1elMzazg0Q1RkSVZHcVd2anJHdWJNZVBxN0RKbHhFTy83dHgyT0VTZWw0NU5aOWt1SFp1Rll5djA0MEJTOFd3Nnk5YWtZV3Zhc0ZIWGJEUU5HNDFoWmgzR2lPN2RVVXE5TXcwNVNxbDNKZ1lHWTFoZ09SWExYckxzUmNkZWNCeDRZVDhFOXZPQzAyUnBKZEZMcENjUjFudHFna0JZejdBSldjdlFsTHFPTW1OSHRzQVliUHFVT1RXR2cvTlNOa05sREkyMTFOYXdZeEozeWR4empqdVY0MEhwdUI4ZGQwdEx6QWFYRFJQQWlPQTA0Q2lsM3BHR0hLWFVPVm5QdEVqcmNyU1VNekZub3JYRW9tUW9DNDR5SENYRHNUZnNwb0xYSXV4YXk1Nko3RWxrei9mTVkySklZeGxhMEM1b1N0MDR3cHM5ZHY0blB1NEFad3pPd0hicHVGZVZISlFGOTF6QmlTazR6U1VuMFhFeUdPWmtGamxTSms4bGtaSk00UnhsVVZJVUR2ZlcwRkZkNVZGS25kR1FvNVFDeHJiUEtXVmlUblErc09oNkZtM0hJa2Jtcm1BK21USnZwcHoyZ2RPVjUzUTVjQm9TODVBNERZblRtSm5IeEhJZGNLTElXM1g3U2luMWhnZ2tCREIwS1hNU0VrbUVkbjMvZFIvWktpemJSY0dXSzlndUhKdCt5V2JxMlNTd05hblpuazdabWs2WVZpVlY0YWlyQ3VmY1JYOXBTcWxMUWtPT1Vnb1lRMDdNR1o5aEhvWDlJT3g1WVhkSTdPYk03aXF6NXp6TFByTG9BOHN1TUNSaHlPUE5pekRrY1o5TmZLc1VUU21sZnV5c2dZR0kwQU5aRW0wYVoyWFY2eksyMmhrbTFqR3hsb214M0dQZ25vbmNjWm1ISnZOWmtmbXNGbkpNeklEQ0pRMDVTcWx6R25LVXVtSE9TdEp5enVkdmM4NE1NZEZub1RNRmU5bnhnb3FYRnA3aWVEWUVubmNETC9zVmJjeTBLYk5LR2ZNTy9jNjBlRVFwOVUvV1R3d0NlQkY4RWtqLy9DbkZlZzlQWWVDenB1U3pwdUd6c21CZWxBeTJRcVRBaDhTMkQ2UVltSVNBdGZiOGRsYkdacTAycUZicXB0R1FvOVFOa25PbTk0SGVlM3J2V2ZVRHk2NWoyZlVzc21IaGF1YlZqQ094SElYRW9ZOGMrc0NoVHh6NnhDcW1jYVZHOTlrb3BUNkJqQkFGUkF5TG1DbUdTRndQQ1Q3eWtlZXRaeWNOYkEwcnR0UEFsalBNbW9hTnlZVFpwR2JXTkV6cm1tbFRudzhjMVgwN1N0ME1HbktVdWtGU2hpNEtjeStjK3NSKzY5bGZlZmFXUFVmSmNHZ1NCMDZZWStuUzJZck5XRWJTcGt5WGhDUWFjcFJTSDk5Wk8ycldwYS96TUhacVhNVEVnVGM4N3l4VFo5bE1nYTNRc3hNSGJqbTR1Mkc0bnh6M2NOd3hrVHV1cEZyL1k4NmlJVWVwRzBKRGpsSTNTTWJRU2NtcGdUMHJQQ3Nzajh1U0o5V0UxMFBnMVJCNTFYZTBTY2FOd1NLSUdRT054aHFsMUtkMjFxVk5SQWhSV01TOHJuUVRER05KMjdTd2JCVU5PK1dVKzFYQlYxWEZ0MVZOWDFRa1YxTFprbTBNRnJENlJLYlVqYUVoUjZscjRteXZqWWpRZTAvWEQ3VERRQmN5cStSb21iQ2c1amdHanBQbk9QZnNENG5kSWJJL1JJNThaaEhIdHM4cHZ4VnNaRHlsMEd1ZlNxbUxZbjdpUGNMNEhCVXlkQW1zQVdzRTB5ZThlRTVDNWtVZmViU0szS3NkbTZGbmxnWTJUR1phbFV5Ym1sa3pvYTVLckRFNDUzVHZqbExYaUlZY3BhNkpzWW5BV0U2MkRJbkR6bk80Nmpqb0l2dkJjWkF5UnhKWTVNQmNQQXZ4ckdKbXNiNmRsYWZGcktzMlNxbXJJNHJRNTR6RTlmMTFHK3BYZldDemNHd1VqcTNDY2pmMTNNNmV1eTV6YjFKek54bnUyWUp0YXltdE9XOVNvSlM2SGpUa0tIVk5pSnp0bDRFVmxqMEtucHVHWjNnZWg4aXpmc1hyWVVtYkU2c1U2U1NUMW44bml5SExtN2JQR25LVVVsZEZFdGJEaHhPcmFEZzJDZGRIbklIS0dpcGpxSjNsODhMd1JWM3cxY1R4bGFueHBxS2lvRjd2MXltMDU3MVMxNHFHSEtXdW1MT1d6eWxuQnU4WnZLY2ZQRzBTVnNheXREVjdNZk95aTd6Mm1WY2VYZ2JoVlFnY3hNU1FNbjBleTlMZTBCZDNwZFRWbFFIT0JveXVteFVBRkFhY01SUXhZeWpJenVDRHBSMWdiaU9IZWVDZXpXeUdqbzBjMlNnY1RWMHhhV29tZFVQaEhFWGhLQW85WFZMcXF0RkhyVkpYaUlpUVVpS2t6SkFTeDIzUDhhcmplTlZ5RURQNzJYSG9HbzZTNFNna1RrTGlKR1pPMS9lN2xJbFp5Tm9kVFNsMUE1eDFaeFBHN213QWZSS09mZUpWNy9oSDZia2xnUjNmY2lzUDNMSndiMnVEdTVzejdtNFlwb1ZqVWhVNmEwZXBLMGhEamxKWGlJZ1FjOFpub1JYRFFiYTh5STZYcWVUNUVIanFNODk5eXp4Qmw4ZVd6NzBJSVkrM0tGcU9wcFM2T1RJZ0FsbUVoV1Q2SkJ6Wk9KYXhXVU5wREp0R3VHdUVlNjdnUWVuNE5wVjhtd3FjV0hKTU9HdG85TUtRVWxlT2hoeWxMcUd6a3JTY015Rkd2QStFR09oRFpKVmhaVXZtcnVTRkYxNUd5MHVwZUo3aGVRZzg3d09yT0FhYW1HVXM0L2dKMmkxTktYVlRDQkJFQ0NLY1BTbWVQUWRPckdWZUY1d1dCYWV1WU1nVlEzVDBmZWFXWDNHYnlLMlRVeVoxUlZXVmxFVkJXWlk0YXltS1FsZDRsTHFrTk9Rb2RRbkZHQmxDWUlpSmVkZHpzbW81V3E0NEdRTEhwdUNrbUhCU05oeUh4TEZmMzBMaXlDZjZsSW5ySzVkNjdWRXBwWDVaRkdFVk00WklYTzlYUFBhUloyM0JyWDdPN2RoeFd5SzNKalczTm1iYzJwaXlOWjB3cld0bTFsSnJ5RkhxVXRLUW85UWxGRk9pajRsbEV2YVM0WG1BNXdPOGJHRXZKdzdvT1RDUklZM3RVb2Y4OWxzWmgrZWhaV2xLS2ZWenpwNGZZeDVEanMvanNOR2prSGhtRFJObnVaVUNkNEhieHZDNU5YeFJ3WmNCN21mRGJXT29nUHFpdnhDbDFFL1NrS1BVQlRvYjNwbHpKcVZFU29rWUkvTis0Q1FLSjY3aVJTNTRiQ1k4S2l6UGlzQnVIM2pkUnc1OWoyaVlVVXFwM3lVRGZSYjY4NDZUNmZ4anR5dkg3YXJpVmxsd1ZCUXNiWTJYaWw0S0Jod0pTMGlaSWtXY0NBN09oNHBxR1p0U0YwdERqbElYUkVRSUlSQlNZZ2lSaytXS2sxWEw2V3JGWVJDT2JNVkJOZVVnVy9hSHlONFFPUndpSnlFeFpEa1BPRW9wcFQ0T240Vmx6RURFZEc5SzJaNkd5TzJRdUR0TjNMSENkdGV4blNMYnpqQXRTMlpOdzNRNndSamQvYWpVUmRHUW85UUZFUkY4akhReHNZeVpGMFBpeFNyd2ZCN1lpN0Fyd3I2RDAyeHBVMllWTTIzSzUyVnB1b0tqbEZJZjE1QUVrY3lRaERabWpuM2lSUnZZN0FMYmJlRDJ0T1N1TTN5ZVBGOVkrTHgyM0U0Wll3eVRTYU1oUjZrTHBDRkhxVS9zckVRdHhzaXczbmR6WWtwZXVpbC9MeTEvcTJ0ZTVzRHJQdkJ5TWRDbG40OHkrdktwbEZJZlR4UWhKbWdUbklRMzc2OFhocTNTc1YxYTdsVWxmOTZvYVRkcU1DWFp0MVJtWUR2Rzh5R2laMkZIUTQ5U240NkdIS1Urc3JQOU5qRmxldTladEMzTHJtZmVEeHdsT0RJVkIrV1VsMTBZYjMzZ3lFZFdLWk4wcVVZcHBTNmRMRENrek5LQUkvS3NOWVFzbkE2ZSs4T2NCM25nd2N2WGJFNGFObWNUTmlaak43YTZMR2pxK2p6OEtLVStIbjJVS2ZXUnBaVHdNZUZ6NW1pSTdMYUIzWG5IYnR1em13eXZpZXpaeEduSXpHUG1OQ1RhbE9sU0p1a0FPcVdVdW5TU0NFTUdpWm1VeHc1dEp5SHhzalhjQ1FQMzBzQWRJZzgzRWc4aVBCVEhuU1JzVlNXRmN4cHlsUG9FOUZHbTFFZVdSZkFwMDJFNE1RVXZUTTEzVG5oc0M1NE5rV2Q5NHVXd0pJa2hpNUNBakpDMXNZQlNTbDFLbWJFcGdjOUNTK2JFRzZ3Sk9BTzNuT05PT1dPbnNQekIxZnpKVGtpMmdaeHhJVEtMa2VhaXZ3Q2xiZ0FOT1VwOUlHZGxhVm1FVmRmUmRqMnJybWNSRTNOeG5KWVQ5ckxsUlJ0NDNtVmVlZGlMY0J5RlZSVE9SbmRxc0ZGS3FjdnY3WWJUaWZHcWxBRUtZeUU3ZkxhNGFFaDlvaldCL2R4ekwzWTgySWRiazVyWnBHRTJtVEJ0bXZYcWpxN3dLUFVoNmFOSnFROWdiQ1NRQ0NrUnNyQzNHdGlkTDltYkw5a1BtVU5LRG9ySWtUaE9RdUlrSkU1RFloSEdzalR0bEthVVVsZWZNSzd3ckdJbTVuRkZmaFV6ZTMza1RocTRHMWJjSjNLdktYaTR2Y25EYmJpSFpWSllwbFFhY3BUNmdQVFJwTlFIa3ZJNE1ic1R3NzRVUE1vVjMrV0dGeUh5TWdpdlk4YzhHWHdXZ2dnaHk5aTVSMFFEamxKS1hSTStDMUVTclRFc1ltWjNpSlFHdG94d3g1YmNjeVZmNUlJL1MwM0tCWlVZSkNaS2w1aGM5TUVyZFkxb3lGSHFOeEFSVWtvTTN1TkRvUGVCVXg5WmlPTzBhSGpVQ1krQzQ1RlV2QkxMWGd6c0RwRTI2cXFOVWtwZFo1bXgreG9pZUdTc1p3TlcxdEpWSlN2ajZDaklzU0FPMEpyQUxkOXl4MmJ1VEU1b3FwcW1IbS9PV2F3ZGIwcXA5Nk1oUjZuM2xITkdCUG9ZT1c1N2psY3RoNnVPUFovWnpRVjdMckx2STd0OVlHOEluTWJFSW1aQzFoVWJwWlM2cWFLTUEwVU40NFd1S0hEc0UwOEx1T3VYM0JQUHZRTHViVzV3YjN1RCsxdUdTVmxRT2tkWkdwMnhvOVI3MHBDajFIc1FFYktNZGRhOXdHRTJ2SWlHNThIeXBNODhIZ0pQNDRKVnpMUXhzMHlKSVkrbGFScHlsRkxxNWtvaWRHbTg0TlhHekltUFBHOHRVd3NQVGVhQk16d3NEWDlzTERGYUpobE16Z0E0WjNIT1hmU1hvTlNWb2lGSHFWOXgxalV0cGNRUUkwT0czbG9PSXp5SmhxZTU0cW5Bb3pUdy9lQjVzdXBKSWlRUjRvOVNqVjZIVTBxcG0wbGczSThwUXBmaE5JN3ZMNDFoM2hTY0ZEWEhyaVNhQ25LQjg4SWRQN0JCWXJNc2FNcnl2QU9iTmloUTZ0ZnBvMFNwWDlHSHlHcm9XWFVEUjkzQVFSUU9iTUZlZHV6M2dkMHVzVGNFOXZySVBLU3hrWUNzYTdLVlVrcXBYNUFSMnBRNTlva2tBR04zdHRkZDRGNGV1Q3VldXc1dVQycDJObWJzektiTXpGaStwbnQxbFBwNUduS1UraFU5Y0pMaE1BalArOFNqTHZJa2VuYWo0ZGduVG4xbUVSTnR6S3hTSnExRGptWWNwWlJTdnlZTHRER1QxdTJtbDJIYzAvbVAwdkhBSkw1MG1hOHF3eGMyODBXZEtiTXdBYXlNSmRTNlYwZXBuNlloUjZrMUVUbC9tMFhJeHBDTTRkUTU5bHpGYXl2OFE0Uy8rcDYvTG5wMnUwQ1h4aXR3WHBkdGxGSksvUVlDOUVubzA5aUc3Y0JBWVNMT3dPZVRrdU5aemRKV0RMYkNVRExKaGlabVNzbVUxbEE0aDFtdjdHamdVZW9ORFRsS01lNjdDU0hnWTZRUGtaT1lPTEdPazhtRXZUNnl1eHpZUCsxNXNScDQwUVpPZmFMUGdzOWpJRkpLS2FVK0JKR3hoQTBNeTVqWkd5SUc2SExpSkVSZTlZRUhoZUcyQkc0NXVGV1hUTXFTU1Ywem1UUWFkSlJhMDVDakZPUHF6UkFpcXhDWXg4eXoxdk1rd2JObFlyK0xISzBHOWhjRHAwTmtFVE9uSWRHblRKUnhKb0pTU2luMW9XVEcxNlZWek96MWdWVk1ISG5IYmg5NXZCcjM2SHhUWkw2c0xGOW53M1pJM0FhYXB0YVFvOVNhaGh5bEdGZHlocGhZSmppaTVFbE0vTWU4NS8rZEx6a2NJaWMrY2VRamZ0MEdXdmZjS0tXVStoak9YbU1BbGpHemlobGpvTEl3YzVacFlibGRPSTYyYXZxeXBqUTFFbnNhSDlqUnlnS2x6bW5JVVRmTzJkNmJmaGhZZFQycnJ1ZWs3VGp3aVgxVHN1c21QRjROUEY1NUR2ckFJb3hOQlVMT1AraVlwdGZLbEZKS2ZRb2lFRFAwQ0VMR2l1RkZuM0EyMEdmaHdURG5JWkdYK3dkc3o2WnN6YVpzenFiVVpZVnpGbXV0cnZDb0cwZERqcnBSUk9TOHNVQWJFN3Zkd081OHhldEZ4NHVRZVNrbEwwM2lhSWdjK3NTeGovUkpHSExXbFJ1bGxGSVhSb0FvQWdtUXhJdk8wOGJNWG05NUVIcnVpK2VCeTN5NW5maFNESjhYRmR2V1VvcWxLa3NOT2VyRzBaQ2picHdzUWdaYUxMdFM4TDFVUEJMaGtRODg2aE12L0FxZmhaQ0Z1QjdxS2VqY0c2V1VVaGNueXpoTU5CckJKK2hTWnErUFZGYTQ1d3dQeW9iNzFqQ25RYVJpQTB1VHdTQVVPZXRNSFhYamFNaFIxMTZNY2J5bHhNb0hGakd6TkFVdlErWnhGM25zNFZtMHZFaVczUkE1OUZIMzNDaWxsTHAwenZiclpDQm1BUVNUQkdNY1NRcDZIRVZ3MkQ2VEZwNEhxNTV0SXR2T3NGRlhOSFZOWFZWVVZYblJYNHBTSDUyR0hIWHQrUkJZOVFOZHpMeGFkYndhRWkrejQxVVVYdmVSM1Q2eTMwZU9RNkpOT3NoVEthWFUxU0ZBbjRWNVNFUVJET1o4bGVlQmlUdzBnYzlLeTcxcHcrMFozTUpxeUZFM2dvWWNkZTM1RUZtR3hFazJQQXVHdjdhSnY3WUR1eUZ6NGpPbkliS000OHlicys1cFNpbWwxRlV4cEV6TXdpcGx1akMybmY2dUdIaFFHUDdVR09aVFN4OExjaXhvc21Qbm9nOVlxVTlBUTQ2Nk5zNjZwcVdVOEQ3Z2cyZndnZjFWeDBHRWcyTEMzNFBsSDRQaEg2dkV3UkJwWTJhVk11R3REVGU2TlZNcHBkVFZZVWpyZmdRK0NZTkpuSVJNYVEzTHVrQmNUVW9sSVJZTXZTVWFReUpURTJnS29TN0c3bXRuTjZXdUN3MDU2dHJJT1pORjZFUGdjTEhrY0xIa1lMNWsxMmRlU2NGdW1YbnRNNis2d0xFZkE0N1BZNmMxcFpSUzZqb1lHK1VJTWNNcVpuYjdRQkpoN3VHZ2hOZDE1dG1pNEY3WjhhQ0IreHNWdFhOVVJVRlZhUmMyZFgxb3lGSFh3bGxiNkppRkxzTitoTWVEOEtTRDU0UHdQRVplNUJXTERHMU1MT080ZXBORXRHdWFVa3FwYXlPdjk1VUt3akltc2dpbkliSFhKMTZYa1h2bHdJTzY0TTh6SVJoSDNRaWJrZ0FvQ29kejdxSy9CS1UrQ0EwNTZzbzZuM21UTXpFbHVwQVlNQndsZUNFbDM1c3AvK2tzendnODk1N25uUjluRENpbGxGTFhtTUJZd3BhRVBpVWdVZG5JY1JYWUszdDJVMEVzSjdoVU1FMldQbmkyWFFESlZHV0pjMlBZMFZVZGRaVnB5RkZYVm95UmZ2RDBJWERTRGV3UGtRT3h2SmFDNTIzZzZjcnpvdlVjRG9sVnpGcVdwcFJTNnNiS0l2UkpjQ1lEa1VmTGdTVENzVS9jankwUFRPUkJVN0F6bWJBOW03RTViV2pxNnFJUFc2bmZURU9PdXJKQ2pDeUhnWGxJdk9vVDN5MDkzdy9DczJRNDdCTkhQbkkwUkxva3RDbVBaV2w2VVVvcHBkUU5sSUUralJmOGhpeEU4WnlFeEpPVjV5dmorYW9VdmszQzU5U2tRcWdiUTNQUkI2M1U3NkFoUjExWklVWldJWEdjSFMrTTQ2OHg4Mzh1V3I1YkR2Uko2RkptZUh2RGpRWWNwWlJTTjFRV0dOWUJoNWc1OXBGbnJjRUNmOTZzbVJjVGdxdkpaa1l0RTI1TGNkNjFWTXZXMUZXa0lVZGRDV2RQdEl1MlpiRnFXWFlkZTh1ZVYwRjRaV3FlcDRKSHk0SERJVEZrSVlpUUwvcWdsVkpLcVV0TVJNakdNQStKbDEzQUFKMjNMQWJEWVM5OFZtZTJpOEJPYmRtY1ZGaGpjTTVwcTJsMUpXaklVWmZlV1lNQmdiRTByUXU4UHUxNHZocDQ2dUdaWlBaeXdaR1BIUHRJbnpKSjBEMDRTaW1sMU04UWdXekFpTEFJbVZjRTJwZzU2WVdqWHRqdElsODI4UFVrOFEwbFZWVlFXb014UmtPT3VoSTA1S2dyUVJqcmllZW00S1dwK2M0a3ZzUHhuZmM4NmlMSHdaTkV4cmJRYi8wZHBaUlNTdjB6WVF3NkFQT1lXS1hNM2hEWUx3TDczdlBTbHh5bWtsVFViSXJsbGhqSWdyUDY2cXF1QmcwNTZ0SVJFVkpLcEpRSktUSWZBdk1NYzF2eGFCVjR0SW84N29RWEEreEZ3Mm5NdEhFc1RudjdxVmNyaUpWU1NxbGZKd0lSSVFKTE1zNUVNbU9ncVVxRGNaWkZpTnpLbnR1bDVkYWtwaW9MeXFLZ3FpcmRzNk11SlEwNTZ0SVJFVUtNOUNHeURKSG55NTVuUSthNWVGNTJnVmV0NTNYck9Sb2lweUhocytpcWpWSktLZlVCaEN5MGI0MWR5QUlMbjNsUkdiNnlnYThheDFjNXMxazZOcHVhc2l3MTVLaExTVU9PdW5SeXp2aVk2TEp3bWkxUFBmeS95OGovdSt6SGZUZEQ1TWduK3BRSjZ5WURTaW1sbFByOW9nakxtT2lTb1V2Q2lVKzhhRDIzU3N0L21SVUVaNm15SS9sRVlRTWJPZXNlSFhVcGFjaFJsMEpLQ2U4OVBnUlcvY0R4RURrV3l5NFZmKzh5MzdXUlI0dWVaVXdzWTJZWkUwbXpqVkpLS2ZWQlpSbjN3RVlSb21TR2JGaEd3eUk0bXNKUjFnYlR3VWxvV2EwRVB3ek1KZzFOWGRQVU5VV2hwNWJxY3REZlJIVXBETVBBeVhMRlNkdHowQTI4NkJNdnMrT1ZxWG5SZWw1MGdkT1FHSExHNTZ6bGFVb3BwZFJISmtBUzhGbm95THhldDVrKzlZblA0NG92VEdSL3NlTCsxZ2IzdGplNTd4eFRhekhHYUFtYnVuQWFjdFNsTVBqQWNkdnpxbzg4OVlidk91RWZuZWRwREt4aVpoSEdGWndvUWhJaGE4cFJTaW1sUHFyeHRYWjh6YzE1RERtbklmRzA5WHhsTS91VjRjZ1l2ZzBHU1pZdE1Vd0FSRFRrcUF1bklVZGRtQkFDTVVaQ2lPeWZudkp5MGZFa2wzd3ZOZitJOEo5OXo3UFZNSVlhK0VHdzBhZE9wWlJTNnVNVE9SdmpJSnpteEdsSUNEQk1TNGF5b2pNVmlRbEZMcGdGSVJPb1JXZ0tTMWtVdXFxakxveUdIUFhKNVR5MmV6NXRPdzduQ3c3blMxN01Wenoxd2xNYVhwak02eTZ5Q09rODRHaHZBYVdVVXVyeTZHTG1ZSWpqYTdReERGbVloOFRuUmVhQkZSNDBKYmVtRFlXekZNN2huTHZvUTFZM2pJWWM5VW1KeURobEdlRTBaSjUxa2NmTHdOTVdubnA0bGlQN0FzdVlXTVY4SG5BMDR5aWxsRktYUjVzeU1rUldNZE1sNFRRa2R2dkExNVhoWHljVzZ5eE55dFFpV0dNMDVLaFBUa09PK21UR0laK1prRE1SdzZFNG5wb0pmM1dHUjRYbmhRODg3enduY2Jqb1ExVktLYVhVenpCQW40UStKU0N4Q0luRFB2Qnk2VGpacUNuY2xPMWNzSjFobGhQV2dITk9TOWZVSjZVaFIzMVVZN0JKcEp3Sk1YR3c2amp3a1VOeFBGcDV2bHQ0SHE4OHUxM2kxQ2VkZWFPVVVrcGRNVkdFUG1XTWdkMCs4SS9GZ0FBSEs4TURBZzhieC8zWmhMb3NxTXVTcG1rdStwRFZEYUFoUjMxMEtXZDhTclFwODdJTGZMY2ErRzZBbDEza1ZSZDQzVWRPZkthTEdhOXQwNVJTU3FrckphNWJUQ2NCUzBUb09RMlJWNlhoVDFWbVNDWFdGV3lteEJaUTE3V3U2S2lQVGtPTytxaEVoSmd5UTRZV3g2dnMrRnNQLzcrampzTWhjZVFqSno0eFpIbXo5MGFmOTVSU1Nxa3JJd3FrZGZsYWx6S25JZkppWmJsZFdmcWRDZVcwWXN1VUVBS1ZqV3hkOUFHckcwRkRqdnJnVWtwNDcvRXhzdW85KzkzQVFUYnNVL0dmODRGSHE4RCtFSm1IY2JOaUZEa1BONXB2bEZKS3Fhc3JpZUFUWk1tNEFDLzZ4R1FSaUJrZXBwYUhMak5mTGRtWVRwaE5Kc3lhUnBzU3FJOUNRNDc2NEdLTXJQcUJoUThjZHA1SHk1NUhnL0FzKzdFOHJRc2MrMFNmQkovSERtcEtLYVdVdXZwRUlDRkloalptWG5hZUtNSmg3L2xLQnI0dU04dVF1Q2VHQjBWSlZRc2FjZFRIb0NGSGZYQXhKVlkrY0J5RWwxTHlOeC80ajhYQTMxWTliY3EwY2R4L2s0Ui9HdktwbEZKS3FhdExnQ1RqaWs3S1F1d0NoMFBra2JNY05aYUZyZWh6aFhjTlZWRnh4OXFMUG1SMVRXbklVUjlFQ0lHK0grajl3Tkd5NVZYbmVabExua25KOTczd3JNL3N0cEVvUXNoQzFHQ2psRkpLWFV0bkwvRUo2S0xRRzJFVmhabHp1T0NRNElqZWtDT1lKTndObm1uT1RKMmpLc2RUVTIxTW9INHZEVG5xZytqNm5vUFRPVWR0ejh2VndOTSs4U1FWdkpDYTExM2dhQmpiUTUrdDNpaWxsRkxxK3BQMS8yV0VlVXk4N2dJK1pZYlMwaGxZeE1TWEpCNGE0Zk9tb25DT3MzeWpRVWY5SGhweTFBZlI5UU1IcTU3blErYjc0UGhIbi9sSEYzZ1JFbjNLdENrVDh0aGdRRWZoS0tXVVVqZUhNSmFtTDBKaVNKbkR3YklFVG4zaWVEbXdiQng1V3JCVndTYUNFWEFhY05UdnBDRkgvV2JlZTN3SWVPOTVkWHpLczBYSDk5THdTR29lSlhqaUIzYTdBWGl6ZEsyVVVrcXBtMGVBUGdsOWdyR1FUWWdoMHJjZTJhd3BhWmhWQ1lObllqTFR3dEZVRmNZWVhkRlJ2NG1HSFBXYjVKdzVhVHNPNWdzT1R4YzhtYmM4Nm9YSEJsN21rdjArMEVjdFRGTktLYVhVUHh0UzV0UW5CQ2dzR0FOOUZ2WXJ5MmVGOE5tMDVyNjFPR094MW1pYmFmWGVOT1NvOXlicnVUYW5XWGptTTQvYnpKUEI4SGlBeHpGeW1ETmRHbSs2Z3FPVVVrcXBIK3V6SUNFeEpDSGx6SkNFRXg4NWJCei9QaTJwaXBMdEpGUTJVNkFoUjcwL0RUbnFuWWtJTVkwTkJEeXdoK1dwcmZsUEp6eTFOVTlsNEhudldhUncvbmQwZ1ZrcHBaUlNQeGF6RUxPd0lqTmtTeHVGb3lHeW5OWTBSY1ZPY3R5SndvVEV4STBoUjB2WDFQdlFrS04rbFlpUWM4Ykh4RUhiY1JBaUI4YnlqOFhBOS9PZXgwdlBYcGVZaHpFQUthV1VVa3E5cTVpRlBtVk1nTDArOEkvRkFCam1nK2VoaVR4b0hKOXRaVXJuS0F0SFVSUWFkdFN2MHBDamZsWE9tU1JDbnpQN1ErUWZxNEYvK015TFZlRFowdk5pR1ZpRWNjaW5ic05SU2ltbDFQdUlJblJKaUpJUkNSaGdGUklIWGNGZmFpRkt6ZVkwTTFsZlNEMWIxVkhxbDJqSVViOUtnSXpCNDloTEJmOVlEZndmeHgxN2ZXQzNEK3oza1pEZStndjZ2S09VVWtxcGQ1U0U5VjVlYUdObUdUS3Z1c0RUMXBIdWJyQkJ5WmVtd09SRWtmVnFxbm8zR25MVVB6a3JUMHNwMDNyUFlUdHduR0EzT2Y0MjczbTA4dXgxa1ZPZjZTUDgwL09OVnF3cHBaUlM2amNReHIwNlE4b3NndUg1eWpNckxGa01ENlRuUVFrUE42Yk1tb3FxS0tpcUNtdnRSUisydW9RMDVLaC9rbk1lR3d6a3pNa1FlYkljZU53bG5nVExzOVhBczlYQVhoL29rdERIVE5aUW81UlNTcWtQSUFzRUVTU0JJZkc4OVVRUkRvZkluNHJJbnlZV1Z4UkVFVGJxakhOT1E0NzZTUnB5MUQ4UldWOUZ5WENLNVVrMC9OK0x3RjhYbnFNaGN1d2pSejZSMTYya05lTW9wWlJTNmtNUTFwM1hFS0lZWWhzNEhDTGZMd1pXMnhXbXF0aWh4Q1doQ0lsSmxTakw4cUlQVzExQ0duSVVzRjY5aVpHVU0vTzI1M0FJSEdYTGt3SCtzWW84N1NLN1hXQVpFNnVZaVc4dDMrZ1dIS1dVVWtwOWFDa0xQWm1ZRFgzTXZCd0tOcnRNdlFpY0dzOW5MalA0Z1ozcGxLb2NTOWVLUWs5dDFVaC9FeFFBTVVaNkh4aFNacmZ0K1g0eDhNakRVei9Xdzc1c0EvT1FHRkltYUgyYVVrb3BwVDR5QWJJSWtiR003V0FJRkF0REd6TUhOakN2eHM1c0ljTldVN0ZsaklZY2RVNS9FeFFBTVNYNmxGZ2xlQjB0ZisrRS8rdDA0RW1mbVlmRXFZK3MxdnR2c2hhb0thV1VVdW9UeURJR0hXUGdvQi9QUlY2MW5wUEdrcllxNmxSUStBeDRtckprTXJub0kxYVhoWWFjRzJ6c29KYklPWE95Nmpqb0F3ZFM4SDB2UE9xRlIxM2taUmZ4S1ROazBSVWNwWlJTU24xU1oyY2VJdENsc2V2YXFjbVVwbVREV3liZWtuTms2Q01tSjR5QnNpZ295MUpYZFc0NC9lbmZZTjRIaGhqb1ErTEZvdVhSMHZNb09wNzBtU2NyejZsUCtIVjVXaFlOT0VvcHBaUzZPQ0tRaldBRWxpSHpvdlVJTUhlUlJSSHhNZUt6c04zVWJNMG1iRzVzWFBRaHF3dWtJZWVHRWhGOGpMUWhzVXp3d3NQZjJzei9zL1M4R2pJblBuTHFFOE02NE9naWpsSktLYVV1a3F6L1Q0QkZTRHh2aFJPZk9DNkZNSFhZeXVDR1JKS2VxbkJzYXNhNTBUVGszREE1NTdGRmRJd3MrcDRqbnprMkZjOVN5ZmZCODdkbDRHaEloQ3o0bkVrYWJwUlNTaWwxU1p5ZGxyUko2RkxpMENUYXBxQ3VTeHBwS0tJaHg0SEt3TVowZ25QdS9LWnVGZzA1TjBqT2VTeFJDNEdWOXp3OVdmRzBUenlUbXU4WFl3ZTFWUnpMMCtKNkJvNVNTaW1sMUdVbHd0Z1p0ZytVYzBQZkNTc3o0SWVCbElYTnBtWnoyckMxdWFsRFEyOFlEVGszU002WklRU1dJWElTaEdkRDV2OWJCUDVuRnpnWUVnZERwRnVIbkl5ZzIzQ1VVa29wZFZtZG5hYjBLYlBmQi9xVU9YSGdheG4zN2xTUkIzRnNScUQ3YzI0ZURUazNoSWlRVXFJTGtYbklIRkx5VENyK09nVCs5NlBWK2Z3Ym4zKzRncU9EUHBWU1NpbDFtUTBKaGhRNTZDTUhoY1c0Q1lXZFVKa0doaVdUWXVCZWpCaGp6bS9xK3RPUWM4MmxsQmk4eDRmSWFkZnpiTDdpaFlmblV2R2Y4NTY5UHA2WHArV0xQbGlsbEZKS3FkOGhaamoyaVNkTFQ4NlpMclVNYlV0TWlaMXB3K1owN0xxbTdhV3ZQLzBKWDNNeFJyckJzL0NSM1M3d2FCWDQyeXJ4anhEWTZ3UDdmV1RJbVpUSElaOWFvYWFVVWtxcHF5cUtjRHhFa2doekgraHR3aWZJUmM5blB2SXdaWnE2MXBCekEraFArSnFMS2RHR3lEekJ2cW40UG52K256YndINmNkSVF2RFdZbWFwaHVsbEZKS1hYRWhDMGMrY3VJVEx3MkV6UkpwR3F5cGthR25LUWJ1aHNoa2N0RkhxajQyRFRuWFVJd1I3d00rQmc0V0sxNHVlMTRreDlQa2VOd21Eb1pNRzRRazQwMERqbEpLS2FXdWl5eGpkVW9DVGlLODlCblRKbkwyNEhzc3d2MnVZOXJVVENjVHFxcTY2RU5XSDRHR25HdkkrOEM4N1ZqNndQUGx3RDhXQTMvdjRXbDB2TzRDeHo2T2UzQzBUYlJTU2ltbHJpdUJaVWk4YWdOOUVyS0pTTWhnVzdxVXVUZWI4TUE2RFRuWGxJYWNhOGpId05JSERpTzh6Q1YvSHdMLzEzemdhZC9UeFV5ZmhKakhlS01oUnltbGxGTFhrUURMbU9sVDRIQ0lwTVpBMFdCeVJlb1N6dlJzendZMjBmYlMxNUdHbkdzaXhraU1rWlF6QjRzVno1Y0RMM1BCUDNwNDZ1SDFrRG5vMC9rUzdobHRvcWlVVWtxcDZ5cG1JU0wwQ1E3S2ttbHlGTkdSWTZDSUxiVWJXMHJYWlVYVDFKUmxlZEdIckQ0UURUblhoQStCVlQvUWhzanpSYy9mRndOLzk0NW5IbDYyZ1dYTTQvNGIwRDA0U2ltbGxMcHhWakd6MXdlU0NORUViQmt4cGlWa3VEMXJ1Q09iYkd2SXVUWTA1RndUZ3c4cy9OaEY3VVYwL0wySC8zc3g4SHJJTEdObUZUSlozcFNuNlFxT1Vrb3BwVzZTTG1iMkpURDNpYUhNV0FxS1dFQ2Z5ZEl6cVNxMnR5NzZLTldIb2lIbkNzczVrM01teG5IUTUxNFgyS1BtU1hROGpZNG43Y0NoSDN2RnI3ZmdhTGhSU2ltbDFJM2sxMk16Rm1RTWprbFRVVXFOOFJsQ3o2U3diRXdtbEdWQlVSUTZTK2VLMDUvZUZaVnpaaGc4UXd5MFB2SjgzdkxkTXZBb1J4NjNrZGR0b0V0dlN0U1VVa29wcGRSb1NNTGhFQ2tXaGxRa3NodXdaTENHcmFabWV6WmxaM3Y3b2c5VC9RNGFjcTRvRVdHSWdhV1B6SVB3M01OL3Rwbi9XTFhzKzhUSmtQQkpaK0FvcFpSU1N2MVlueklIZmFDTG1WVUJOSmFpc3JnMjhqQm1uTFZzYjIxaGpOYkFYRlVhY3E0WVdhZVdFQUtySVhBU012dFM4anhYZkI4Qy8vTzBZeFVUU1RodkV3MWFwcWFVVWtvcGRTWUluUHJNcWMrc0trZGROOVJtUWlrRnBtK1pGajMzdktjb0Nvd3hXR3N2K3BEVmU5S1FjNFhrbkFraDRHTmswUTA4TzFueXRNODh6UlYvbi9mc2Q1R1FoU1NRZFFsSEthV1VVdXBYeFN3Y0Q0bW55NEVjQTVFT1lxQXNEdGljMU15YW10bDBpblB1b2c5VnZRY05PVmRJenBraFJOb1FPZktKcDEzaWZ5NDhmKzBEQjMxa3Z3OE1aL3R3UkFkOUtxV1VVa3I5bXBDRm8yRzhVTHp5QmlxaGNNSms1Ym1YRWlKQ1U5Y2FjcTRZRFRsWFNNNlpJU1ZXR1U1TXhiTmM4VDliei85eHRDSmt3ZWVNejlwb1FDbWxsRkxxWFlVc0hQdklzWS9zZCtCMkprenNsQTA3QmQ5Uk84L3RuQy82TU5WNzBwQnp5WjIxaUU0NWM3SnFlVG52ZU9uaGFYUThXbm9PaDhTUUVsR0VtRUVqamxKS0thWFV1M3Q3VUhvUXcwbklQR3NEeHZiMDBwR0dIbWNOdDJaVG1xcWlyaXR0TDMwRjZFL29ra3NwNGVNWVpJNkh4Sk9WNTIrcnhIZUQ0V1hyT1JnQ1BvOXpjTElHSEtXVVVrcXAzeXdMblBqSXM1VmhHVEt4REZoeDFQVkFFdGllSkp5ekduS3VBUDBKWFhJcFo0YVlhRE1jeVRqazh6K1dBMytkZTFZeHN3cUpzTzZpcGhGSEthV1VVdXEzU3lLYytFUWJNeSt0aDgyU1psS3pLVFZGRUp6MWJFeWFpejVNOVE0MDVGeENJa0xPbVp3enA2dU92WGJnSUZrZTljTGpMdkdxenh6NmNZTmMwR0dmU2ltbGxGSWZoRER1MFlraWtPQWdsRHdiaEtaTmhONFRheWpzT0ppakxBcUtvdENHQkplVWhweExLS1ZFaUltWU00ZTk1OUc4NDdzT0hnL0MwK1hBeVJBSlNkWmQxRFRpS0tXVVVrcDlLSEwrZnpBUGlXY3JUOGhDVjBSa1ltaktFdXM2WmxYSnhxVFJrSE5KYWNpNWhISVdRczc0RElmUjhxaUgvL09rNTBtWE9Ca2lKejdoYy83QlJqbWxsRkpLS2ZWaG5KMWVuZnJFa0RLSGZXU1lXcHF5NXBZNHBsR0FRRjBXMUhWOTBZZXJmb0tHbkV2a2JGVm1OUXljRElGNWRqd2I0T2tBVDlyRTgzYkFKeGtiRGJ6VnlkQmM5SUVycFpSU1NsMURROHo0QkV1Zm1icWFPOUZ4YTdBNEUzbm9Fb1V4VkdXSnRSYm5ITWJvV2RsbG9TSG5rampmaHlQQ1lkdnpkREh3MUJ1K1cwV2VMejF6bi9CSmlGbkl1bnlqbEZKS0tmVkppRUEyd2lva1hxdzhoVEcwVmFhcndWbERYVmZVaGFNdVM4cXl2T2pEVldzYWNpNkpuRE1wQ3drNENzS2pOdklmODhpekx2SzZEY3hEWExlS0h0dEZLNldVVWtxcGowdmV1ck9NWThoWitzU2lNYmlkaXUwQXQrSjRrZG9hb3lIbkV0R1Fjd21JQ0Q1RytpUU1XUGFpNWNrQWY1MFA3UFdSUlVpc1lqNXZGYTJVVWtvcHBUNGRBZHFZOFNsd01rUjhMcmsxYzl6TEpiZUNzQk1pemhpYU9tT00wYksxUzBCRHpnVVRFVUpNN0M4NzlyckFmbkw4N2JUaitjcHo0aU9yT0RZWjBIeWpsRkpLS1hWeEJFZ0NaR0VWRXk5YnovOTMwdUs5NStzaThVMnNhYW9LWncyRmM5cDE3WUpweUxsQXNtNEJIYkp3TUNTK1czaSs2ekpQbGdNdjJzREprR2pUdUlLVGRScU9Va29wcGRTRk9kdWJJd0tya0huVmVtSVdGcjBqekJ6VHV1SkJ5cFFaREVaRHpnWFRrSE9CWkwyL3htUFlUNDd2ZXZnL0Rsc09oc2hCSHpnSjZRY2xhcnJ3cVpSU1NpbDFjVVRlbEs2OVdnV08rc1JCWHpDdE5ubElTWWNsNTRUTGlWSUtMVnU3UUJweUxvajNucE5WeDJtRXZXVDVmajd3WXVVNTZDUHprQmlTNkF3Y3BaUlNTcWxMU0lBb2dzbGoxN1ZYcmVjL1R6dEthM2hnSWc4bUpRK05wU29MM2FOelFUVGtYSkFRSWdmekJTOTY0WW5VUEZyMHZGeDVEdnBBbnpORDBoSTFwWlJTU3FuTFNBUmlCcEhNeXNEck5sQlp3eENGdjB3TXpscHVaY0hsakRWYXVuWVJOT1JjRUI4OGgvTUZUMWFaL3pRYlBGa092R285KzMwa0krZkxvVW9wcFpSUzZuSTVXOGxKQWpra1hyZWVMbVVPK29pOU4rUDJwdU1iTExXQUx1SmNEQTA1bjFBSWdiYnI2SWFCM2VOVG5wNnVlTklabnBtQy9TNndESkdZODBVZnBsSktLYVdVZWdjQ1pLQ0xHV01pa29XWFhlTHhLckxWRE55enduWnB1RFd0cVhTR3ppZWxJZWNUNnZ1QncvbUNnMlhIODBYUGswNTQwc096N005bjRTaWxsRkpLcWFzakMvaWNJVURPOEdvMXNGRllEUEIxWmZscVVqQXBLeXJOT0orVWhweFBhQWllbzFYUDh6N3hLRmM4bHN6VEVIamVEVVFSTk9Nb3BaUlNTbDB0QXZnc3hKd1pVdWJWYXNBaWRERXhUR2ZVcHVGaHRoZDltRGVPaHB5UExLVkVqSkdVTWtmTGx0ZXJuaWZlOFRnVnZNb0ZSeW14aXVIODg3VnNVeW1sbEZMcWFoR0J4TGhIWis0VGhRMkVMTlEwM0dyZ1hndldCR3FiYVVwSFVlZ3ArTWVtMytHUExJVEFxaDlvZmVEMWF1QlpsL2l1VFR4Sm1ZTXUwTVowMFllb2xGSktLYVUra0Q1bDVqNlJCVFpkeisycVpMTTBoQ0Z5dTB6YzIyelkwSkR6MGVsMytDUHpJYkljQXFjeHM1c0xucWVDUjUzblNkL1RwVXl2TldwS0thV1VVdGVHejhMY0o5cVltYmlPcmRZeUtUTXlCS1JPYkZhR2pkbjBvZy96MnRPUTh4R0l5UGx0TlF3Y2RnTzd1ZUJGS25tWlNsNTV6MzRYdFUyMFVoOVJZUTJsTlRoaktBdzRZM0RXYUVtb3V0VFNXVXRhRVdJV1FoYWlDRmxmTEpTNk1rSVN3dm9NNzZEM2JKYUdxa2c0TjFBUG1WdU5ZM00yeFRtSHRSWnJkYi9PeDZBaDV5T0lNUkpUSW1aaGY5WHo2TFRqKzJENXZwT3hqM3BNaUw1Z0tmWFJPR1BZcVJ3N2RjRjJWYkJSV0thbFpWbzRuS1ljZFVrSll4dmFMbWJhbURrWklzYytjakpFK3FRdkdrcGRSZjE2ZG80eFlGMmdhWVR0UlVkZEw1aFdKZE9tcG1tYWl6N01hMGxEemtlUWNtYUltU0VMQjhId3BCUCtZOUh6dk04Y0RZRXVabDNCVWVvaktpeHNWd1ZmekNxK25OWGNyb3Z4MWhTVU9wVk5YVklDSEEveFBOdzhYM25NRWxZaDB5ZmR2Nm5VVmRUSHpFRy8zb05kdzFiaHVCc3RHMzNnVnM0NGF6WGtmQ1FhY2o0d0VjSEhSQmNUS3h6N1ZEeE5QWDliZE94Mi9yejhRQ24xOFRnTW02WGo0YVRpajVzTm4wMUxQcCtXZkRhcktEVGtxRXRzdC9Qc3RvSGRidXk2dVFpUjNmYWlqMG9wOVZ2MVNlaFQ0bmhJV0ZOeWh3bjN6WVN0WkRGRG9Da0x0dGJsUFVaZm56NG9EVGtmeU5rZW5KUXpoNnVPVjYzblZTejR4K25BYmpzbStKUWg2VDRjcFQ0SmE4WjlPWldGT2dmcWxHbkVVaHF0ZlZhWFY1TThkWTVVbHZNOVpVcXA2NkdQbWIzTzgvZFRTeHdNYlpXd0NOT21vWENXc2lpMHRmUUhwTi9KRDBnRVFoYU9RdUx4S3ZEWHBlZnB5clBialNWcUlRdUM2SDRjcFQ0eXc3Z3ZwelNHeWxtcTdLa0ZKdFpRbFJweTFPVlZrNmdrVXR1Q1loMXlOT2NvZFQxMFNkanRBbEZnMVJ2TWhtVnJJdHlMaVRxUDNYWTE1SHc0K3AzOFFFU0VqSkF3bkZEd2VCRCs3Nk1WQjMzazJDZTZsSW1hYnBUNlpLd0JadzJWTmRTU21SaGhXcGRVVlhYUmg2YlV6NXE0QlRXWnlweXQ1RnowRVNtbFBwUXVKblpiNFdpSW5EWUZXODBHbjV1S2xWaEltY0xxV0pFUFNVUE9CeEJqNUdUVmNob1N4eFE4V25wZWRaSERJVEVQaVNGbGNrWmIxeXIxT3huZXZkelQ4UFpqVGdEQkdLTTF6K3B5KzRsZjhCLytMaXVscmk0emJsdEl3akptOXZyRWR3dFA3Vm9lMnNURFNVbFRWUlNGR3o5Ylg2OStGdzA1SDREM25zUFRPYys3eEhQVDhQMXB6NnVWNTlSSDJwanhLYVA5MUpUNjdjNmU1czFiS1VjZlVVb3BwYTRTRVVnSUlvWStabmE3UUhQYUUxT2lid3lWdGR6TEdaTU5WaS9LL1c0YWNqNkFFQ0tIcHdzZXpUMS9zMXM4V3c1anlCa1NQby94Umh1cUtmWDdHTE1PT3diZDE2YVVVdXJLRVZnUGdoZjZKT3gybnBBenAwT2t1alBsN3BZallpa0VqRjdLKzkwMDVQeEdLU1dHWVdEd2diM2pFMTZjcm5pMnlqeGg0S0NQeklkeEJVZm50eW4xL3M0YUJ6Z0x4WHB2UXVVc2hUVU1NZE9uOFpaRXIzS3BhMHgrZEx1Q3JBSEwrRml1bmFWeGx0cVpINVRmaFN3TUtUT2tUTWlRUk1qYWlWUmRZd0xFQkYwUWpuSWlpK0ZsbjNuZVpSNnNQTnNtc1ZFWU5pZU5OaUw0SGZRNzl4dDU3emxackRodU8xN05PMTRNOEdLQVZ5bXdDR09qQVYyOVVlcTNzUVpxWjhhVG9zS3dVVGhtcFdWV09rNkd5RUVmQ0wzODdFVUU4Nk8zU3FsUHp4b29qRm0zY2pmY2JrcnVOT05nWHJ0ZW1UVUdGajV4TkVRTys4Z3Faa0lhNThscHN4NTFuUWtRa2dBWk8wUjJXOCtqZVUvakxKL1I4WG5qYUFxbkllZDMwTy9jYnhSaTVLVHRlTjBGbnFhQzU5UzhpSUZYYnczODFLZG5wWDRidTI3OVBDc3RtNlhsVmwxeXV5NjQxUlM4WEhsOEV1WSs0ZC9oU29JR0hhVXV4dG1LYkdVTjA5SnhiMUx3MWF6bTY4MGFaOGJIdVFFTytzQ3o1VUNTc3dzWG1TUzZsS091dHl6Z2N5YUtJV1ZodC9VMHpwQ3pNTENnM2l5NXY3WEJaSExSUjNwMWFjaDVEeUpDenBtY004dXU1NkFkZUQ3QWsxanhLaWVPY21MaGgvUFAxNU1ycGQ2ZFlWM2FZZ3pUd25DcmR0eHRDdTQwQmR0VndXYmwyQ29kSzU5b25NWDhRczJ5UWRhUHYzVlh0WXYrNHBUNkRjd1BibGZualA5c2xhWjJscTNLc2wwVjdKU09ieHZEMTQzd2JTUHJrRE91NUd5S1lBTGs1Q2lNNGRSSGprVUlXZHZwcXVzdEMyUVo1eWNlRDVIU0drSVdLbW01SlFXZkwxY1U2OVdjb2lpd1Z1ZTh2UThOT2U4aHBZUVBnU0VtanZyQXF5N3kvU3J6WFJnN1pLeWlQaUVyOVZzNVk2aldKV3EzNm9LdnR5cSszYXo1ZkZhTkd6Vmw3RGpnZEhhSVVwZVdQWi92WTlpcUhGOXUxSHk5VWZQRnBPQys4VHdvTXcrTHRBNDQ0NkRUcGt5VWpUQXJLblltbGllTEhwOEdsaUZkOUplajFDY2hqRE4wVGdaREV1R1dGZTcyaVh1blN5S3cyZFJzenFiVWRYM1JoM3FsYU1oNUR6RW0raERwa25DU0RLK2k1VkViK0s2TkxFSmlwVS9JU3YxbXprS3pMbEc3M1RpKzJhejVyN2RuL0hHcjRYaUluQTZSMHlIaHpOaGE4NWRkOGQzYVNsMVJGa05oeG9zVjI1WGo2NDJLLzNwN3lyOXNWV3hsejdZVGRwcnFCek9yTnN1ZWpUcHlPeGRzRG9hUU13ZDlnTzZpdnhxbFBvMHMwS1ZNR2lLcm1OaVpPTzdta3BmQllsdVBpTkJVbFlhYzk2UWg1ejM0R0ZuNXlHazI3RW5KYXlsNTdnZGVyQVpTUm1maEtQVWJ2Q2x0TVd4VzR5ck81OU9TYjJZbGY5bXErTmVkQ1U4WFBVYUVsVTlqbVF0YURxclVaWEwyZUt5c1lWbzROa3JMdmFiZ3EybkJ2MnhXL1BmYk0yb3paVkk0SnMwUFQ5UTIycGFOenJPVHdMYVoxNjFuNHR4RmYwbEtmVkpERW9hVVdBVFlyeWZzMmlrdmFDaDlvRFNlN1dsZ3RtN0dvZk56M28yR25IY2dJb2dJaThIell0N3liSUR2dXNUcjFyTU1pWlRIbnVmYUNFYXA5MU5hYzM2N055bjRhcVBpNjQyR2IyYU9QOVJ3MjJRS3liam9zY0ZmOU9FcXBYNkNNMk81YVdFTnQ2cUN6MllWWDB3cnZwNVkvbGpEWFJ1cGpWQlpnN1AvZkhKbXJhVndsdG9ZS2lzVXhxQTdEOVJOdGd5SlY2Mm5zSVpVUnR6TXNqVVptRXdHQ210eHp1SDBRc0N2MHBEeks4NENUaFpoR1lVWGZlVC9td2NlclJJdlY0RTJaUEk2NEdqR1VlcjlGTVl3Y1paSllibmZsUHh4dStHLzNKcnk3YlRndGhOMjZvTFNHR3owbUJoQXlvcytaS1hVanpnelhxZzQyMC8zN1diRHYrOU0rSFpxZVZCazdqVWxrOEtOKytsKzRzVE1Ha3ZoSExXQjJscEsreTRscVVwZFg4dVFlTFh5OURGanBvYk5zdUpoZ3AyUXFKMVFHNk1oNXgxb3lIa0hZeGR6dzhvVXZJNld2ODA5anhaKzNJY1RrODdEVWVvM2N0YlFGSmJOeW5GL1d2SEhyWWIvZm1mR0h6Y2FDaU9VMWlJaXVCUXh3WVBScHl5bExwdXpaZ08xczl4dUNyN2RyUGx2ZDJiOFphdGlZb1ZwNldoK1lTK0JNWWJDV1NwanFGMGFWM0kwNDZnYmJCVXlRL0xzZHdGbkpqemNhWmpiaGw0c05ndWxsZzY5RXoxaitCWHo1WXFGanl6RThualI4Mm9WT0I0U2JjajRLS1FFUm4vWGxIcG5aK1ZwaFRVOG1KUjhQcXY0ZkZyeXg1bmpTNWZaSkZHc3kxK3N0YVQwOHcwOWZ1NnhaK1RON1VNNGF4MmZjbWJ3Z1c0WTZBZFBDR0hkL25POHFadmhiTk84TlFaWE9KcXFZbExYTkhXRnN4YTdMaWY1WUQ3ZzcvS0hPcUN6RWpWcjRGNVRjbTlTOFdCYThvZkc4blVSdVcwOGpTbW9yTVg5U3R2YmZoZzRYUFVjSmNPek5uUFVSNGFVTDluWHJOU25JMGJJWWpBSXk1QjUxWHIrODdnamVjK0RVbml3MFhDdnFpNzZNQzg5RFRtL1l0RzJ2RnIydkphU3g0dkk2elp3TWlSV0lST3pqQVBMbEZMdnJMU0dTV0daT012RGFjbGZ0aHIrWmFmaHk4Wnd2ekpzRlpaaVhhNXlXVFpYNXB3Sk1lRnpaakZFVGxyUDhhcWxIUUlwWjFJZVMxclZ6V0FBZDdhUHBDalltY0VPam0zcnFKeFFPdmt3SWVjU053azhLMUVycmVGdVUvQ25yWWEvN0V6NHFoSStyK0ZXWldrS1MrbCtmYlpIUHd3Y3pCYzg4NVluM25IUUIzb2R5YUJ1TUJIV1d5RU1pNUI0dWZSVTF1QzlJMHdkMDZyaXJqWWgrRlVhY243RmN0WHk2bVRGZDNuQ295N3pxZzJjK3JIRm4rN0RVZXI5RlhiY2g3TlpPUjVPS3Y2ODNmQS83bTN5c0hIVUZpWmxRZUhjcFhyaVRqa1RjbWJJc01SeGtBdGU1WnFUWkVraXhDeEVEVGszaGx1M1NTNlNZV1lMZkM2eDJUSEJRaGJzaDFpQ3VPUy9UdU5jSzB2dERIY25KWC9hYnZqZjdzNzR2REZzV05oc1NwcTYva0dyNkovVERRTUg4eVZQZThlVFZJOGhKMm5JVVRlWEFFbkdlOHVRZU5rT0REblQrNUxHVHZrc1cwVEdZYnJxNTJuSStSRVJJWVJBaUpFUUkzdkxqaGZMZ2NmUjhzckR5WkRvbytnK0hLWGVrZUdzODlJWWNPNDNCUThuRlE5bkpYK2VXYjZvNEhZQm0zV0JNMXlxZ0hOV2dqWnZPL1piejJHMDdBZGhydzNzZFlsVG44a0NVWVNrVHdvM2hyUGdqT0NNWWVvU0p5bHdIT0NnVDl5eGdYdVRrcW9jVnpBdXkrL3k3emVXcUZsaktNeTQ5K1p1VTNLbktmbnoxUEpGa2JoWFpuYnFtdG9hcXJMOHhSV2NydXRvdTU1VjEvTms3NGducHkxUFFzVXJNWno0eEpEMDhhUVVRRWpDd285bDI3VXh2TzRUTDFhQlcvT2VxYzFNUzhkMDBsejBZVjVLR25KK1JFVG9CODl5R0ZqNXhKNFhYbnA0M0hrT0E4eEQwaXUyU3IwSFk2QnlaeVZxaGk5bjQrck5uN1luZkZFS24wMHMwOEpjdWhJMU9kOXJBOGQ5NE5GcHl6OWFZZGZEY1I4NVdROXR5d0laZEUvT0RXTFdlMUVzVUR2TDY3YmdhVjF3dDNMOFpTSVk0UFpXcGp6N1hIdjFHeUlieG9zVVo0TStIMHdyL3JUVjhJZk5ocStxekZjVHkzWmhhSnlsV085TCtpWExWY3Z1eVNtN2k0NUhwejJQdTh5emtIaVZ4cVkrZzY3a0tBV01GOUg2Sk9BVHh6YXkyd2FlTGdhbVZyaFhSTzVOYXcwNVAwTkR6by9rbk9sRFlENUVUckpqbDRhWEtmTjBOVEFQbWJndVRWRkt2UnZMZUZJMExTeGJsZU9MalpwLzNabnl2OTdiWU1kbFpvVmxWcFVVNnowTWx5WGtBR1FSTW5DU0RJKzd6UDkrMFBPNlQ2ekNlRHU3Mml6SVphOHVVaCtRWWYxN0ttLzJtRTBMeSsycWdMc1RibTBZL29qQmluQmRtcndhODZaRWJWcFlQcHRXL0dWbnd2KzR1OEVkbDlncEROdVRtcm9xM3luWUxicU9WL09XeDRQbCsxVHpPRm1lRHBsRDcvVjFWcW0zeEN5SVpIeUNBc051SDlodVBZMUpTREV3TVpuNzNMcm93N3lVTk9Tc25WMjFEVEZ5Mmczc3RvRlhOTHlNbHYxa09RbVpUamRDS3ZWT3prclVySUdtTU55dUhmY21KZmViZ204bmxxOG1ocytuQmJQU2pWZUhMMUdKMnBtVXhuMDRDY015R3c0Q1BHOERyOXZBa0RKRDBuMDRhaHlFV1FWTDVReXJtUGsyTk15ekhhKzh5bm9BNXBXZFp5SHJGYXN4M096VUJUdDF3ZTNhOGMzRThuVnQrR3JpMktwS0dtZHA2dXBudzQySU1Bd0RnL2NNM3ZQeTZKUm5TOCtqUE9GWnF0ak53a24wclBSMVZxa2ZFTWJWSEFUYWxEa2NJaTlhVHlHRzB2VnNPdmlzNjNGT2g0VCttSWFjdGJQMnNGMUk3SGVCUjR1Qi94d1NUNWNEeDBQVXprbEt2WWZ4aXU5WXVySlZXYjdacVBuRFpzTTNteFZmVmNLOTBsQmJ6bXY4TDZPWUVqNGxCaXh0SEM5eTlERXpwSEZGVjlkdUZKeHRFQlpDaG43OWU5TEd6Q29rc0Jtc29TeUs5dzd4bCtGUmNUYi94aG5EUnVuNGZGYng5VWJOTjVzMTM1YUp6eXBod3dtMU5SUy9zdjhvNTh6cFlzbkI2WnlEVmM5M3h5M2Z0WmxIMmJFWExhYytFWFFmamxLL0tDVGgxRWRlclF3NXdMVEozSjRramxjZFRlbG9xcEpKMDF5Nmk0WVhSVU1PNHhXbXNYdVNNQWdjSk1Qak52TWZweXRPaHNSeEg5RHlZS1hlbmJQalhvVlphYm5kbEh5MVVmUHZ0eWY4bDl0VHRrMWlxM0kweFhqRjZWMjZMLzJVai8wVUhsT2lENGtXWVJVeWJSVDZsUEhyZHRGYVRhT0FzZkVFUWs3UW0weVh4b0N6REFsbkU2Nnc1SnpmNitxcStkSDlpenBkT1Z1UnJaMWxzM1I4TWF2NTk5c3ovdXV0Q2JkTjRFN3QyS2pIVWxQM0s2dXhPV2RPbGl0ZXpEdWVEdkFvRkh6bkk0Lzd5RHhCbjhiWFlLWFV6d3RaT0JuR1V1azJHSGFLZ29lNTVDVEJKaEZyREhYMWZzODMxNW1HSENDbFJPOERYWWJqQ1B1cDRLV0hSeWM5SVdkOEVuTE9sK0xLbWxLWDFiaFBZU3h0YWF4aHU3TGNhU3ErbUJaOE15MzQ0MGJKWDNZbUZBWUtZeWpMOTNqNldaLzdqQU0rQmNQNjlyTXJyT1ozdGVBOXUvRGhZNkxIMENkaFNJSlBtZmpXRlE5OVRsQXd6clJJQ0NIQmtESjlTdlFwMCtSRWJYNzdvTmczQWVlWGZ0Yy92TFBIY20wTm0rVVljQjVNQzc2YU9QNDRLL2pYN1liRzFreWNaZEw4L0labkVTSEdTSXlSdHV2Wm42OTQza2ErWTRObjRuaVZCdmI2Z1U0ZlUwcTlrNFRRaGt3ZllVaU8zWTJHWFNsNUhRd3hCQ3d3bTJqSU9hTWhCL0ErY0RoZmNoQXlMMkxCaStYQTBSRFB5MUswN2w2cFgrZU1vWFNHMnBweDlXYXo1cHZOaG05bUJkODJobHN1VTZ6YjdscDdkVTVsdEN4TnZTOWhERDVYOFl6ZHJpOUNPR3ZZcmh4ZnpDcSszS2o1Y3VMNDB3VHV1MFJqTXBXMXVGOXBMaEJDNFBoMHpzbHl4Y0d5NVI4bks3NXY0VEVEQjBOazRaTU8xRmJxTnhER2hnVEhRK1R4WXFCeWxqK1VFWk1yZGphbXY2dEs0anJSa0FNTWZ1Qm92dUJ4bTNrc0RTK1dudU0rNHZNNEF5T0pudVlvOVdzS0N4Tm5tWmFXdTVPU2I3Y2EvdXZ0S1gvY0tMbnRNbmVha25KZHQvKzdXK3ErenhUNDMvamdsYmYyM1lqMlQxUHZRamh2TzM0ZWRLNlljYWFWb2JLRzdhcmc2ODJHZjc4MTRVOGJKZmRjNHY2a1pGbzZuTFcvZXJVNGhNREpjc1h6MDVablhlSzczdko5bjNrVWh2TjliaHB5bEhvLzZ4bWhZOGpwSTAvblBUNWw3S1pqcXk3NUtrTXRndVZ5ZFN1OUNEYys1SWdJZ3cvc3p4YzhtV2YrYm9SWEs4L0pFSFVZbVZMdnlBQ2xNVXdMdzFicHVOOFVmTE5SOFcrM0p2ekw5b1RTQ0pXekZNWFZlY3FSOVpucSsyN0hPM3RKTVViVzVVWTMrMFhtS2p1THR1TjV1SG1ubUh0MnpwN1hJZm1zYytkVjRjeTRuMjVTV0c3WGpxODNLdjc5MW9SLzI1a3dzY0swZEw5WW9qWitEK1I4NXR6aHF1TjVuL25lYlBEWUZEeE5QYytXdmU1cFUrcDNPR3Q0Y2pKRVFzNGM5WkZiMVNaZlVqQmdhTEpRMkhWNTl3ME9PbGZuak9NRGl6SFNEd05EaU93dFZ1ejFpZGRENW5VYUEwNnZiU3lWK2xXbEhhLzZsdFp3dnluNGNsYngrYXptbTZuajZ5cXpiZUo1aWRwMWY2STFqRU5QSzJ2UGg1L09Tc3UwY0xqci9hVmZTd0swSWRQR1JCdkh2WmsrQ2NONmhmODZjZXNaT000WWJqY0Y5NmNWRDZjVjMwd00zMWFaT3liU1dLRnk1bGRMMVBxKzUzU3hZTkYyN0o0dStmdHh5L2U5NWJGeDdIZUJWVWhYY29WTHFjdEcxcXM1ZmN3SWNOZ0hYcTA4aitjOTl3dGhvN0JzVHh1cXFycm9RNzB3Tnpia2hCQlk5WjZsanh6NnNkbkFib2k4NmdOZFREL1lDS21VK21tRk5VeUw4YXJ2dzJuRkg3ZkhLNzVmVGl6M0tzTk82Y1lXdE84d0FmMUR1b2lPVk1aQVpTMGJwUnRMOXBxQ3U1T1N1MDFKY1lYMklLazNEdnJBWVI4NDdDS0xNSFpOaTBHdTNVZ0IrMWFKMnAybTVJL2JFLzZ5MC9CMWJmaThFdTQwYmd6cjcxQ2kxZzhEQjZkTFhpMWFuaTBEMzdlWlI3M3dOQTBzUTJJVjlMVlZxUThsamwxUGlES3U1cnhlQlo3TWU2S0wzSzh0MDdMUWtITVR4WlJwUStRMHdaR2JjT0FpcitPUzE2dEJxKytWZWtkbjA5NDNTc2VEYWNXZnR5ZjhML2MyK0dKV1VsdG9Da2RabGhkNmpKOHFYcHl0NUd5VWp1M2E4Zm1zNXV2Tm1xODJhMnIzNlFLZStqQkU0UGx5NE5seUFIb2dFWE9talJkOVpCK2VNMUJaUTExWTdqUUZmOWlxK1I5M04vaDY2dGl3d3F3cW1EVDFPNjNHamlWcVBVOTd3M2ZNZUp3TEhnMER6N3YrdlBXNnZyNHE5ZnNKWTB2cHlCaDBqdnJJeTVWbldqckU5bFJUeTkyTkNUT21GMzJvRitiR2haeXpXdUhsNE5sYjlqd2I0RkVQdTMxaWxZVDBWaDJDWG50VjZvY000K3JOV2ZlbEI1T1N6eVlWbjgxSy9qUXIrTHpNN0RoaFdsaUtUekRwM2NqUHYvL3M5a0dzR3gzODByOXBNVlJtN0M0M0t4eGI0cm1UTXcrQmlkRjJubGVOR09oenh6d0hqcHhoNVN5RnNWZ3hQOXZPK2FPc0lIN28zK1gxUDJyWDdkNnRnVHYxZXRWeFV2TG5tZVBMSW5IWFJyYUtndHE1OXhwbTZzcUt5Y1lHT3dVOERBNWNTVk5YM08zQ2gvN09xRTlDenQ5a0VZYVVHYkl3UktGTGVheDhpZGV2aFBNcWFrUG1vSXRVZHFCMEE1czQ3bmNEVGRPZno3TDZsQlVWbDhHTkNqa2k0N3liTExDS3d1NlErY2RwNFBzdTg3cjF1b3l1MUs4d1pndzVrOEl5Y1pZdnBpVi8zcG53bCsyR3p5dDRPTEZzRkliU1dleDEyNGZ6S3gzZHpIcGZRK1VzamJOc3lNQ09KTzZYRTZiMXpYcGh1UTVFNE1RRTlzVXp0VFdORy9lZVhZZXJYMmREUHM4dVdOeHJTdjY0M2ZDbjdRbGZWY0tYaldXN01EU0ZvM2lIRXJYeCt6VStPTXFxWW10emt3ZFZwb3B3ZXpLMmsxL3FQdGVyU1FUV0hRTmpGazU4WkQ1RVRuMGF5ems3ZzAvaDJwVndYa1dybU5qclBENW5xanB6dHlrNDhablpFR2pLVEEwYWNxNHpXUytWWjJCbENsNUh4OStYSGQ4dkJ1WkRvbzNwb2c5UnFVdk5NSmExVEF2SFp1WDRiRmJ6TDlzTi8rdjlUZTZVTUMwTXM2cWlXSjhVWFl1UTh4N3RxdDE2WDhPa3NHeEs1RlpSOFhCN3hzYjA1cFlMWEZVNUMvc25wMnliek5RWmFtY3A3ZlhwbGVmTUdOb3FaN2szTGZuejlvVC83ZjRtRDBwaHU0RHRTVU5UbGRoMTIvZDNJUUpWV2JJenRSUlZaaWVOYytaaUZtMFZmWVdkdFVVZlVtYTM5ZXkyZ2IwdVVNd05ReEtPQmwybHV3emFrQWs1Y0Rva3Bsc1ZYMGpOd2xSMFNUQW1VYm9iZGNvUDNMQ1EwdytlTmlSYUxLK0h6SjRYOW9mSVVUOTJVd3ZhTWxxcGYzSjIxZGZaY1FMNnZhYmczclRpL3FUa0QxUEhGNDNoUVczWnJBdEtaeW5XUThodW9yTko4YzVBeWZqOW10UTFrOG5rb2c5TnZhZWNNN1d6Nis2QTQrYjg2OElDVTJmWnJCeGJWY0hEVW5oWVpENnI0VTVUMFRoTFhaVy9xZHpVR1VQakRCYVlXTGlZTmlEcWc1S3gyWVpQVUVkaEdpS3pvU2ZRc1NSd2FNZFcrV205MnFOblVoY2pyQzhtREFqSEVmWUNQT3NTaFlFN0JSVFdVdGMzcXduQmpRbzVxNjVqdngzWXp5VlBGNEg5MWpQM2FRdzRXWWVTS2ZWVHJCazMxRGZPc2xGYXZ0eW8rY05XdzUrMkd6NnZNZzlxUytQRzBwZHJWNkttMURYa2pHR2pjanljVlh3MnEvaWlqdHl4a1Ewak5NNVMvb2JhL2ZGeEx6Z0xsUVVyWTlCWFY5L1pyS2dheUNVME5Xd2xvVDN0T1NHd1h6YVliQm1TSUpMSGpsL3FreE1neXppamJSVVNyMWFldng5M3hLRWdURXRtdGJCOTBRZjVpZDJva0xOc08zWlBWanhPRlU5YlliZjFMSHlpVC9tODY0dFM2b2VzR1V0MXBxWGpWdTM0Y3JQbTMyOVArZTkzWjJ5YXhGYmxtSlRGalY3QlVlb3FzY2F3VlRrK200MXQzNzh3SFhkcngwWmRuSmVvL1piYWZXUEdkdkdtR1BmdVhhVWhxT3JYNVN3MGhlWDJ0TVp2VFRtWkw5aGY5YnlzRENrNzhBbWYwUFo1RjBqVy83Y01pZDNXQXhERGxJbWQ4RERkcUZOKzRBYUVuSnp6K1czZWRyeWV0endKa1JmZWN0UUgycEFJbW02VStnSER1SUpqaldIaUREdVY0KzZrNU9HazRKdXA0NXRwd1IrMkdrb0xoVEdVNWJWL0tsSHEyakJBNHl4YlZjSDlTY2t0NGpyZ1ZCVEY3M3NzR3pOMlZmelluUlhWeFdpb3orL2ZlZkdLbmRPT3JlaG9rMk9JZ2pXNnQvbWlDZERuekdFZjhWa29xTGszZFh6bEN4WkRwalNaMG4zODdxZVh3YlUvTXdraE1JVElFQk1IUStMMWtIbmFCVjU1dzhtZ0FVZXBuekoyQ1J0WGNHN1ZqcTgzR3I3ZHF2bG1WdkwxQk82VXN0NnJZTEE2NkZLcEsybThtR0hXdTJiMGNhemVqN09XdWlpWTRLZ1p4d2FjbFMycWl4V3owS2NNSG80SHozN2Y4M0pWc0ZrNnRweG51eTdZM0xqK0RYR3VkY2dSRVh5TXRENndTbkFzSmJ1cDROa3FjQkNFTG1ZTk9VcjloTUpDVTFpbWhlTk9VL0x0WnMxL3ZUUGxYN1lidG0xaXB5Nm9uSDJ2emt1L2wzbnJyVzVsVnAvU2ozLzNmdW56cnNydnBURUdZOFpHR1VaMEw1MTZmNFZ6bElWamdxVVdjNjI2RDE1MUtRdDlUSVNjT2VrSERycVdWeXZMaHJXa01sQktwU0hucWhNUmhwaFloTVNKbEJ5YW1uM3h2TzRIVG9ZNHRuL242cndvS2ZXeG5YVUhxNjFoczdEczFJN1BKZ1hmYkpiOHkzYkR2OTJaVVJnb3JmbmRaUzIvNmZoK05KVHpsNGFCZnBUdmpYekNBYVRxVW5qNzUvNXJ2d05uRjdEUFB2YzNrN2ZldnZVNy95R2RqVlNJV1VpTVhabk9obVZyNEZIdnd0cXhTVVdObzBwbVhObEhud012Z3l3dzVQSEo0OVFGRG9lT1Y1MWhaZ3hsR2Rnb1pqZmlzWDZ0UTA0VzRjUUhucmVlNTMzZzZXTGdxSTlqaTBOOUVDcjFBNlVkTzZSVjFuQjNVdkRsUnMxWEd6WGZ6QnhmMWJCdHgxYVV6bHlUK1RkSzNWQ0NzQWlKMXl0UDdTeW1DTXdLdzkwaFlLM0QyckZlLzdjOHp0OE0zUlp0UEhDRkdHTXduSzN1bWZPYnV2cDh5aHdQa2VlTEFSdWhtbVIySmdFZkFtN2RaT1M2RGdtOTFpRW5BU2ZXOFN3SWZ6M3VlYjRZT0I0aVFmdTRLL1ZQbkJtSFdFNEx4LzFKeForMkcvN3QxcFN2cDQ0N0plelV4VmlPWU16RlB5SCsyb0JPK2RGTnFRL2htdncrWllHRlQ3eHVQVEVMMHczRDNabWx6MUNuUk1sdkswV1Y5VHlWSkVMSzQzMTFOZGgxNmFMRllKRnhSVVpEenJYZ3MzRGNqOVZMTVJwdUZRVmZaSXZQUWttbWdJdC9UZjlJcm5YSXlkWnkwa3g0YmdOL1BUN2hxQXNjcjFkeWxGSS9WTmh4RnM1bTViZy9MZm5EVnNOL3V6dmoyNjJhMGtEbDdJV1VxQ21sUHF3c3dzSW5VaGJtUStSdXM4VlhwcUduWUNwZ3Mvem1HVGNDSkF4cC9WWmREWTR4NElBQkVmM0pYU00rWlk3NndNSW51bGp3NWM2VWhhc0pHRXdXN0RXdUw3eDJaeXc1WjdvUTZBUk9YY0YrR3poY2VVNzZ3TXBIUWtyckpmVHIrME5WNnAzSVdLTG03TGhoOVA2MDRQTnB6ZWNiTmQ5T0xWK1V3cVpKVk5hTUU5OHYxWldlWDF1bStWaVA4WGRaUXZxcCsrcnFlNWZsd1ErMWZQZ1RtM0krNE8rVE1PN0ZHVkpHZ0wwdThQMXBUMU5ZSGhhSk83WGgzc2FFamFiQnZXZURrVDRMSno2eTZDT0xJZExIVEJjelE4b2Y3UGpWaDdkUk9tYWxZNk1zbUpyRVJnSGIwNGFxcXQ3aGIvL1U3NnU2TEFSSUF1VHhjWGpjUjE2dVBOK2ZkT3lZeUU1ZGNHZDc2MXF1M0YyN2tCTmpaTm4xSENmaHdGYnNuM1ljTDNwTyswZ1hFME1Tc2o0QWxjS3dYcjBwTEpQQzh0bTA0azg3RS82eU0rSExCaDdVNDhEQXdwcXh6ZXlsZUFKOC81TytUM2ZVV2lPblB0elBmYnltTHV2YkJ6NUtnU1RDa0NCSlpuYzFVRnJvWStLYkNmeHBjeHdLV3BXSkVxR0FkNXFwWVl4aEFBNWo0bVU3c0g4NmNOeEhqdnJBNlJBLzhGZWhQcVM3azRyNzA0cjcwNUo3Tm5DdkdsOGIzaTNrcU10TWhQUHozajVsVHZySWk2Vm5xMmo1M0F5NGpacGJteHZYY203T3RRczVLU1ZXYmNkUm4zaE41UENvNWZpazQyUUloRHgyazlIVEQ2VkdwUjMzNFd5V2pnZVRpajl2VC9nZjl6WjQwRmdhQjdPcXBQaU5HNUNWdXJrdTk2dk0yVXBPUlBBWmRsdlBrREw3cldlMVUxTlhKZmV5WlRPRE1ZS3o3LzcxRE1ad2tPRnBGM2w4M1BKeTZYbXhITmhiVDE5WGw5UFhtdzNmYmpkODR4dThHeWdtaGp1ejVxSVBTMzBBWnlzNVdjYlYyK01oOG5McEtSRmd5U1pUY3M0YWNpNjdjUzVPNHFUenZGb0duc1RFN3FKbk9VUml6bVFaVDlUMGRFM2RWRWJBV1VOaHh0dTlwdVRCK3VyZG56WWNYOVRDM1FxMjZvTFNtVXNaY041bFpzbVBaK2w4eUsvZ2NuMDMxS2RpK1BVWlRSOWpUczdIbmdzbHNyNjY2eU5Eem14MmpsdXJ3TVo4b1BlQld3WGNudFpzVHByekxreS85SnhRcE1TTXpOYWtZUHYyakJOcnFXTEc5Z0dmeG5LWkllbndoc3RtcTA0c2ZLS05tVjRTSVVLVzMxWmlxRC9aeXl2bGNUL2VYaHV3T2JGWkJCNDBubVhiTVczR29QTmJPeXRlUnRjbTVKeTFyUFFaanIzd2ZCWDVya3Zzcmp3TG55NzVkVFdsUGcxam9MS0d1ckJNbmVXTGpaby9iamY4Y1h2QzUxWG1zNGxsNHFCMGw2bEVUU24xTVNVUmZNcUlDQWRkNE5GcFR4YmhlR0w1ZGpMdXhhdktrc0pteXFMNHhTdStFeEh1T1RDYk5jMjB4dFVGR0xBeGNUcEVqb2VJVDFGZms1VzZBRmxnRlJLSFhTQkd3OTBwSEVYRGZBaUlNVFJsUWZNSmgzeC9iTmNtNUlpc2h4OWhPWkdDRndOOGQ5cXg4SkZsU0RvWFJ5bkFHa1BsTE5QQ3NsMFdmTEZSODYrM3B2ejNleHZzdU14V2FkaW9xL01Wbk92eVJLZVUrbmx4M2U0NVpNTitON2FWUGhrQ0p4c2w1dmFFN1EzRDdRd2d1RjhwYTVrVWpvZW01cFkxYk1tNEJwVjlSRlllWnd4RHlzdzkrcHFzMUFWSUlxeEN4cWZBWW9EUG01b1RVN1BJbGlKbXJFbFVaYjVrallaK3Uyc1JjbUtNZEQ3U1plSElDNGZSc3UrRi9UWXd4TXlRQlJFOVdWTTNrMkdjZ2VDTW9YYVdXM1hCbmFiay9xVGs2Nm5qcTZubHE0MlNhV0VvbmIyVUpXby82eUpPbEg2aHNWYklRaDh6eXlGeG1Ed3Y4R3c4ZWNhMDFzMjdWMDBXNGRuK01YdXJ4TncwdEVFSWFUMWo3VjBiN0gwb0g3bVhoV0JJTXM2V1cvbE16cEUyaktWS081T2FuUzVSbHdPYkpyTlZGMnl2ci9UKzFJV1F3amtLNTVnQk5pV1dKUXhiRlRsc1l1WWR3VUliTXo1bVlwYjEzTG9yOG54em5mMmUzeTlCKzY1Y0VWbGd5Qmx2d0ZzNHlZNzk1SGpWWjFJSVNHMlpWT1cxR1JkeExiNkt3WHVPRmkxSEFaNTd3MjdyT1YyM3JneDVIRXFtMUUzbHJLR3k0d3JPZHVYNGFxUG1tNjJHYnpacnZxcUZleVhVVmlpc3hWNlZjSE1KWlJHNmtEa3lZZHpVUFFTT2oxdWU3aDlUNmJmMXloRmdOMXIybUhCUWVVNHpMRU82OXE4blNjYTVHZ0RIZmVUSmZNQVp3N0liK0tJU3Z0eHNxS3VTd2xxYy9lWFpXVlhPM0VHSTA1S3FyaWltSmFhd1NNek1oOGpjai90QW9uYVhWdXFUT3F0K09oMGlMNWNERzZWanNEMTJWckF6blZEWDlVVWY0Z2R4UFVMTzREbGFMSGsrR0o2RWd0M1dNL2VKUG1ZeTZOUmxkYU5aeGtHZXM5Snl1eW41ZXJQaHY5eWU4VyszSjJ6YnlFN3RhSW8zbXcydnpDck9KU01DWFV6cmNvREVjVEE4ajQ0bVJaeGUycnh5UktCekJYMWg2TDNIWXhpeUVLLzU2OG5aM3RZa2lhTmVzQWJha0RocUM0YnRpcVlXN2lVaFM2YitsZWVLeWxydVZnWFR5ckJqSGM1WkpBbHA2ZG0xbml5ZU5pUzB1ZlRWOWk1Tk9kVGxjZllNZGpZVStPWFNZekJnRm15a2tpL3ViQU96aXo3TUQrSktoeHdSUVVUb3ZPZHcwZktpTXp5TEZmdXRaK0VqNGEwcmJ2ckFVemVKWVd3eVlJQ0pNK3hVbHAyNjVMTnB5ZGV6Z2o5dWxmekw3UW1sRVVwcktjdXI4VlJnZUw4dVZ4KzZxOW92LzVzR245NWNCWWNLVEhYRm4yVVZHZkEvWEdxNGlOZVRUL1hmRkhsVHVvWmtjZzRzZkdicFMyWlZ5ZTFnZUJBeVUwbWswdUYrb2VOYTRSeGJ6ckVGM0JKaHFCM0RyQ0p1empCaThVbFlEQWtrazBSSFBGeGxHblN1SGhIREttVDJ1a0FRWVNZdG43bVN0aC9ZRE9HZHVpbGVkbGYyNVRmblRJeUptQlB6SVhMb004L2J6RE12SFBWanFacFNOMVZoRGVXNlJPMTI3ZmhxcytITHpZcXZwd1hmVEEyM2kweHBCR2NNMWw3ZEp6Q2wxTWN6NWp2QnhNemNSMTRzQnlhbEk2VE13eUx4Y0ZKZ2phRXVDNHAxNjltZjQwVFlpWWt2cmNWdWIxTlFnNVJrTVp3TW5sWEl0Q0hocjNrNW9GS1hpVTlqNVFIQVlXRTVDTEE3YjNGRnliU3VtRTRheXJLODZNUDh6YTUweUFrcE1hVE1VaXlIdWVCVjMvTjhOYkFLaVU1RGpyckJuQjJuVlU4THg3MXB4UisyYS83dDlveHZOMHB1dWN5ZFNVbHBMZGFhYTlORlJTbjFZV1VSWWdhUnpLbUI1MHRQekhBNkJQNHlzMWd6NFZZU3JCMWZiMy9wcXE4RmJoVVdPeW5aTGtxY2NlTy9MNEhTZ2V2R09Ub2FjcFQ2TklTeDhrQVFoaVFjVFFzT3FUZ0locVliU0RsVEZrNUR6a1ZJT1RPa1JKOE5TMXR6WkJwZStvR1h5NTRzWTVzOHBXNnEwc0RFV1RaTHk3MUp5VGViRGYvbHpwUS83MHdvakZEOXlsWFhtKzVONTZnM3BYOW43MWZxNTV5WDZ4anpwbVQwQ3U5enkyTElBZ0VoNUVUT250TWg4YnIxMkFjYjNOcDBmQzJXSWdtR1RGbkl6NGNjYTltZU5teFB4ejhMNFBNRW53ZGc3TFoyT2lRTVdVdldsUHBFZkpiMWhZWE04V3pDVWJIQmdac3dqVUpoQXBzeFhmUWgvaTVYTnVTczJvNzlaY2RoZGp4WlJnNzZRQmV6MXZTcUc2dTA1cnhNN2Y2azVQT05pczluTmQ5TUhWL1Z3cFpKT01ZU3RhdDYwdlVwT1dzcG5hTVJTMlV0cFRYWWRlalI1eGoxWTJjQngxbERiUTJUd2xMYnNaM3lkU0NzVzZTbmpQWHdhdVg1eitNV2crRitrYmhmT3g1c1RabldOYzc5ZWkzL3BndDhYbWZTMWdhbHJiQzBJRXZxWXFDUG1UN3FxbzVTbjFJWEUzdnJZY0JTWit6VXNUMU5iRi8wZ2YwT1Z6Ymt0SDNQL256SmsrQjQxaGtPdXpIa25LM2c2RUtPdW1tSzlZblZwTEE4bUZYOGFYdkN2OXlhOHNYRWNMOHliRlh1dkVSTlE4NnZjODVTQ1NSeDFNNk9MWFBOR0hUT3pyMzBhVWJCbTlVK2E4WjI3VTFobVJTT3lob0tkN1UzN3A0UkdZZUdTc3lJQ0srV0hnTXNRK1lQRTBpYk5iTkpUVkVrU29UeVZ5Nm1iTmVHenpjS3BrMUJWVlNJR0VKT0dEdXU2R1NKK0h5MXJ5SXJkWlcwSWJQZmVwd0JNN1ZzT3NzWGVXenlCVmV6a3VIS2hweFYyN0YzdXVESlVQSXNGQngwZ1M0bTlNS1B1cW5LZGNqWnJBb2VUQ3YrdURQaGY3bS93ZWVUZ3RwQlU3Z3IwMFh0TWlpY294QkRnNlZ5NDByT2Vma1JvaGRTMUxtenNrWnJ4b3NObGJYcmxSeEQ0YTdIUllXeHZFd3dXZkJwL09WZmhjVHJWV0M0M1RDYk5Ed1V5MHpBNUV6eEt3K1FyV25GdEJhK3dGSVhCU0ZsMnVTSkVzamlXY1VFNGFLL2FxVnVqalltOXR0eHdhQ1FtZ2NiQlIwRkltOUt0cSthSzNYR2sxSWFiem16R0NLSGZlSlZDM3RCV0E2Sm1FU1hjTlNOWVJoUHFKdzFGTVp3YjFMeWNGYnhjRnJ4NXczSEY1VndxeENtcGFWMDQrQythMEhlZXZ0emozYzVleTZRSC8ybGQyZk5XUHBIRnJiRWM5OEcvamdyMkhDVzlyeWNKcDhmZ2x6UkZ3SDEvc3o2WjI0TU9QTm1CWFc3Y256bUV0dmlxY2lVNjRHWnZ5bmsvTk1VK2N2eDJpYU1BMFA3bURGQVNNTHJ0dURSM0RNdE8rWjF6NjBTN3N3YU5pZk56N2FodGRaU3JaK1N0c3ZBZ3pxeW1sbEVhbUxLblBUaDBuek5ONExJbTk4ekVkNjVFZlRaNTcvOWQvWG5kaVdsWk9oSWlBakh2dVRZWi9hN3lPM1ZRR09GU1ZsUVZWZXJDY0dWQ2preFJvWVE4U2t6ejViajVOanJNd2Zlcy9TWmtQU0JwVzRPWThiVm02YXdOSVhsaTQyeFJPMVBPeE8rcUlTSEU4Zk1qZnQwN0kzZWgvUGJuaGVzdFJRQ3htUzJYZUxMQmxZN0RiZThjTmhGanZ2QUtveWJwTWYrTkRmMSszdnpHQVE3anMramRwYmJUY0d0cHVSdVkvbTZTZHgybWRweWZuSGh0ejcyRElDOENWV1hTY3JDRURNNUMzdXRwM0dXa0lTamllSGIyVGcvcDY0cUNoRUsrTVZHSjFPWHVkZGtNZ1ZpRyticktlenEwekcvTzV5OEZYYlVsUlJGSUVPT21hVlBIUGVCL2RhelhZd1hUTzIwMXBEek1jV1VHVkttUzRhRnFUbWlZVzlZY3RBblloYWkxcXFwRzhRQWxSdmJSRzlVanM5bk5YKzVOZUYvdmIvSjdRSm1oV0ZhbFpURitEQy91U0hudHptNyt1ekVjcnNwK1dxandqYU83Y0h3WXRGVFdDajdzVVEySTRoK2YyOE1JekplT0FBMlNzZm5HL1hZNkdOYThJVWR1RE10YWNvQzU5enZDemlYV014Q0ZzRm53MTdyQ1VrNDdBT0x6UkxucHR6T2xsdDVITmh0amZuRmtETXBMZmRtSlpPNlJGems1V0pnVWx5UGhnMUtYUlZwL1ppTzJiQUtrUk1mMmU4RDJ5NWh5OHlrTUd3eXUrakRmQzlYS3VSMGcrZTQ4NXhJeVg0d25HYkxNaG42bU04dklGejJGd2FsZm8rejdrM09qRmVRNzlRRjk2WWw5NmNWMzB3ZFh6YUd6eWFPamFxZ3NJYmlkNXhrWFdhZmFyTDJXZnZmV1ZOemJ4YXhRNmJNbnNvTjFHYkZxUWxrRVFRaDYyaXVHMlBzc2pmK2Iyb0tQbmVaejByRHc4WnhwNnpZYkdxS292aE5qNzIzZjY4dit4VDV2QzVSYW9NZ0V1bGlwcktHbldsaWV4a3d3SllUdHB1U0xXUE9MeHo4K1B0U09FZFRPckkxek1xOGJ2UnhPYi9tNit6SHYzdnY4M2N1KysrcWVqZXlIc0hTUmVGMGlMeGVlU1lDVlMzc05OVkZIOTU3dTFJaFo5bTI3SjUydk13TnI1WURKMzBrcEt6bG4rckdzQVlxYTZnTHkxYmwrSEt6NWc4N0RYL1ltdkJGbGJsZld5b0RidDNwU1gwWWRWbXkyVlFZRXlnemJBVGhYb2F1SEs5OGlZaFdhZHdnNXpOd0VPcFN1RFdEN1ViWXFRMGJkY1drdm5vbkE3OUhGbGtQRllTalB2RGt0QWRnM280WFhyN2FtbEJYSllXMUZEOHhveXRMSnEyck1VS1djV1ZVSDFCS1hSaWZNMGQ5NVBtaXh5WExGbzdQcm1DbnRTc1Rja1NFWmR1eGU3cmsrNVI0MFdaT2ZTUmtQYmxRTjRjelk4Q1pGWTZkdXVTcnJacC91ejNqdjkyZHNXa1NXNVZsVWhibkt6aFg1WW5vc3F2cmloMXJtTmFSblVuTnc4MHAzZ2RpaXVkUCtxSm5aVGZHMmVQS3JGY242cXFpcmlxcWNpd1ByYXJ5UmozMmtnaVNJZWJFWVFmUU0vZUprMWxCdk5Vd213aDNNNGhrRFA5Y3VwWnpKcVpFU0lZZ1FoVFJUcWxLWGFBaFpvNkhnQ0JZS2ZsaVZ0RlRrRVhPQng1ZkJaYys1T1E4OXVTUE1UTHZldmFXSFUrRFlYZUErVENHSEUwNTZqbzdhMDFyaktGeFl3ZW4yODNZU2UycmFjRTNzNEkvYmpjVUJncGpybitiNkI5M25mcTF6L2tBaXFLZ0tBb21rNHYrNHRXTmRZbGY1ODcycFFFc2ZTSm1XQXhqTTZETnV1SldEenRkWUNLSlNXSFlTRzlXdW93eHJMcWVlUjg0U1phVFB0T0dwSy90VjVuKzNLNjhtTWF1eFNFS2piVWNSOGNpV2JxUWNRaWxFNG9yc0cvdVVwOE5pUWdoQkh4TTlDRnlFdUF3R1BiYXdIR0FkdDNaUmFucnpObHh3R0RsTExlYWdxKzNhcjdlYlBoNm8rVHJpZUZPS1JSR3hrR1Y5bXBjWGZta2RMT2VVcDlNRWdncDB3RW5mZVRaWXFCMGxwVVAzREdCTzZYaHpxeGVkM3djLzg1Sk8vQzZEZXhGeC9NZVhxODhiZFJCb0VwZGxNdzRGd3N5eTVBNDZnTjdyZWZWc21CS1pMTXUyTnE0L0UwSUxuM0k4VEhTK2NReVprNnBPUmJQWGg4NERjS1FNa2xMUk5RMWQxNmlWanJ1TmlYZmJEWDgrNTBaZjk2cTJYR1pXMDFCK1RPektLNlY5MWlaTWZKVys5MjMvNzVTNnFQS0lvUU1TVEluUStEWlltd090TDhhK0txQkw2Y0YwVHJzK3FLTUFmYTZ6Tk5sNG1rWGVOWG5NZVFFRFRsS1haU1UzNVJocjlZaDUxWHJ1Yld3M0xFZUo3V0duTjhyNTh3UUVxdVlPYzJPVXpmaDJIZ08rNEUycHZOemxtdDhXcWR1c0xQZjY4b2FOZ3JIVGwzd1lGcnk5VWJGdis0MC9PdWRHY1Y2VnM3L243My82cTRqU3hKOHovOFdMbzZDSUNoQ1ptVlZkZmVzTlRNUDkvdC9nWG1kZXgrbXUyOVhkVlpsUmdUSklDR09jckhsUExnZkVKUUFTU2lDOXN2bENaSkJnSDZVdTV1YmJUTnI3L1ZIK1ZxZms2dDA4Zm5jRGtGQzNGZmZXc2Vxbk1kNUcyUldXUkdTNDdRTHZOaGEyc01Kc1Npd3FjUXFoY3BEZzVUbk1mT2ZMdkp2SzhmTHBtZnJFdTA0YkZSOGUrUjFleGhpeWtTZzhZbVRQdkJ5NjlnekdheGpab1lBNkw3ZldMM1hWMFl4UnBhYkxjK2J3TXM4ZEZSYnV5alpHL0hnV2Ewb3h1MW9VdkRMdk9LbmVjMWZab1pmYTlnM0NUdDJVYnZ2QnhraHhQY3A1NkZibWdxSmpZcTgyRG9VdzBXVFVzTkFWZFJRMXZaaTZ6anRQSzFQdUNTbDZFTGNGeUhsWVVEdnRxZklrWElTZURRcGlURmh6UDJ1SUxuWFFVNElnZFZteS9PVjQyODU4WExyV0x1QXJFY1VENTNWaXRwcUpsYnpaRkx5MS8wSi80OUhVMzZkR3A2VW1mM1NZTWR5RDYzMVhlK3VFRUs4SitYZDBGQklSRjV1SFZzZmVkbTRZVDNPV0U3YWhzVGFEYlgvZlJ5R2U4dk5UQ0h1aDVBenl6NWlONDRjSTRmRzhHdFNKREw2bnJlVXZ0ZEJUb3lSczgyV1AwNDcvaDA5QmptUkpBYy84Y0JacFpoWXpieXdQSjBXL1BQK2hQLzNremwvbVJkVUdpcXJIMzRYTlNIRU55M0QwQ1dOakl1dzlaRS9tK0dDS1BQbWJ1VXdaMG9OczNIdTU3V1NFTit0a0RJckYvQXAwWG5EcjRzNVcxV1FVUGUrcjgrOXUwcmFkVlFMTWJKcU9zNTg0clZML0JrY3l6N1FoWVJNeGhFUFVhRVZaaXhSZXpvcCtYRmU4R3hXOHRlcDVlY3FzYThqdFNteCt2MDVFMElJY1o5bGVEUGc4NzBibGVxdEwwS0kreU5kS0R0dHRPTE1KVjUxbmovV0hYT2RtVmpOYkZMZnk2cVNleGZreEJqcHZhZnpnWlZQTEZQQlNmSzhhanh0U0hReFNvZ2pIaHpGRU9UVVZsTmJ6WS96a3Y5eU1PRmZEeWY4Vk1HeldyTlhhZ3FqeHRhcmNqVWdoQkRpZWx4c2J2R2xaNWR2cVVHR3VMcWNoeVlFZlI1S1M1ZDk0RlhqK1gzVDgwaDVqdXFDdWl3a3lMbUtsQko5aUd4RFpxMUtWbmJLV1k3ODJiVGtQTlRwU3JXYWVHaVVnc0pvSnRhd0tBMC96RXIreStHRS8rUFpnc2VsWW1KZ1dwWVUxa3FBSTRRUVFvaGJrUmxLMXBUS3RENno3Qk4vdHBIZjE0Nm9Pc29VT0poUEtZcmlybmYxUGZjdXlQRStzRzQ2amwzbWhkT2NlTVVtS2x4SWIvMDl1Y3dURDhIdWZXeVZZbW8waDVYbGFGTHdxQzZZbFlaQ0R6V3ZmWWpFMEl3VnNOK1hFQlByM3RPRVJKc2pMaVppek1Nc25JODhIWEpIVVR3SUY5N2Y2dnY3Nkl0YnBNWTVaT3JpUExLcnZ1Zkc3N3U0aVljblo0aGtOaTd5cXZIOHZlalF0bWZQdnBtcmM5L2N2eUFuZU00Mlc1NDNtWCtFa3VQV3kxQXc4U0FwaGd5T1ZzTmFuSGxwT0pvVS9MeW8ySzhzQ3NXcUQzaWZVZEdqWTRDY3Z2cmYvZGJFbERudUU4dW8ySVJoZnNiUXNlbCtIbFNGRU9LYjg3bUJqZmd1SldEakk2OGFoMUV3bVdTZXpvWUdJL2R4YnM2OUMzS2M4NXl0dC95eFNmdzlUbm5kRG10eGhIaUl0RktZY2FEbnJCaUNuRjhXRll0eWFDeXdjcEV0ZWVqRm1oU0srMWZ6ZXROaVNwemtnbVdLckh5a0N4R1hrcHlMaFJCQ2lGdVVjMmJyaDB4T0h4TUh1dWFmY2tGQVM1RHpNVG5uODYxMW5tWG5lTG1KUEkrR3M4N1JoWWpjWGhBUFhlWk5GNU90ai9ReGM5cjVlM2ZRdVBYbkpTdU9lOFZwbnpucEFxcytEbDBXODhXNkNpRWVpdnlCci9KZUY5OFNlYTgrVkNrem5uOERMaVpPWnhQT2dtYmxNN1VMbEVaVFdITnZybHZ1UlpDVFVpS0VTRWlKSm1aV3lYRGlJNjk3eDZvZmF2Q0ZlSWpTT0JqQ3BTR2dLYlNpandremxyQ1plM0tndUVzNVp6WStzdldScll1c1hLRHhrU2puVVNHRUVPSld4WlR4S3BORFl1UEQyRzNOWVpObVhpZ1drK3JlTkNHNE4wR09qeEdYTWkyV3RhbzRqa09MT2hjVHZRUTU0Z0hLNC84bE1qa2xUanRQRnhLdkdvZFd3OEM4NzY4NDdYM0RRTUZFaUVPV3k4V0VrelU1NHJzZ0N5V0VFUGRIQmtMTzVKZ0lDWm9RV2ZhQjE2Mm5TaGxWS2lhRmxTRG5vamkyalc0aXJDbFlxNXF6MkhQYWRXOFBFQlBpZ1RsL2YrZWhZOG5HU1pPTjY3SnI3S0RPZnkzemhZUVFRb2l2a1RMbk54a2JuMWk2SWNpcHZhZWFhUGFuRlJQcXU5NU40SjRFT1YzZmM3cHVlZTBWZjJ4M2Q3U2pCRGhDaUs5eUh1aEljQ09FRUVKY3F5WkVqbHZQUDFZZHhuUk1vK2JwM3V5dWQrdmNQUWx5SENmckxYLzBtdWVkNHJRUGRER1JzeVRwaFJCZmJ0ZWlXd0lkOFMxU3lNd25JY1Q5MVliRWNlc3BqYUpTRzQ2eXdYbDMxN3QxN3A0RU9UMm42eTIvZDVvL1hNRnA2K2xER2daTTNmWE9DU0crT1dvOGRxaXN4b3RFQ1hURXQrWDhuU29ERnNWOTlzNzdVOTZyMzVmV0Q1bWNrRElUdHZ5aURjNzV1OTZ0YzNjVzVPeGFScWVVNkdMbTFHZitiQUl2Kzh6S1JieTBUaEpDZktiZGhhSFdVQm5OckRBY1ZBVnpuU2p0L1ZnSUtZUVFRandFTVdYNmtGaXJ3TXBvbHNsdzJ2YnNyOWFVMWxLV0JkYmVYVDdsVG9PY21CSXhaZHBzV0NYRHk4N3hzb21zbmJTTkZrSjhub3VOQmd5S3ltam1wZUd3dHN4VXBpeXRaSExFdHlGL1lCUGlQcFAzNm5jcHBFd2JFaUZsVmhQTFNsV2NCY1dxN1ptV0NhM1Y5eHprWkVLR1RwY3NxWGpaTzE0MkRqKzJpaFZDaU0raEdOYmdXSzJvaldaZUdBNXF5MVJwS3FzbHlCRkNDQ0d1aVUrWmtDTWRzSmxXck8yTWxhNVpCbEFxVUJYMlR2dXMzVm1RMC9XT2pmTzBTWFBjUlpZKzA0UkVINGI1RnpJRFF6d1VwVmJVVmxNYmc1SEJOOWRxMXhvYXdHbzFMSDYwbXYxQzgwdVZPREtlbWM2VVJsRklrQ09FRUVKY200dGRrTHNFeXdBdjJzUlVkVkJtSmxhejRPNjZyZDFaa05QMlBhZWJqcE5vK2JQeHJGeWtqNWs0cnRXUkdFZDg2M2FYMHhOck9Kb1VITlNXV3FLYzY2VkFNMlJ2S2p1VXB5MUt3MEdoK0d1ZGVGb3BhcU1vak1ZYUkwR09FRUo4Z0hUeEUxL0x4Y3haSC9oajAxUDVTRkVuRHV1N1hRdDdkNW1jcnVkazAvQkhLSGpWREJOVCt6Q3MwWkg0Ump3a0U2dDVOTEg4dktpWkZSTGtYQ2VsRkJvd1dqRXBOSThuSlk4bWxrZWw1cEVKUEo2VXpPcHkrSHRhbm5zaGhCRGlKdlF4Y2RvRi9sajNsSjFqejBWKzNwdmU2VDdkV1pDejlaNlR0dWVQTHZHeVNheGRKSXpyY09SdWd2alc3UmJCQTB5eTUxSE8vR3BndjVBT1g5ZEpLWVZXQ3EwVms4SndWR2NlVFRVSFZjSFVGc3lyOGs0WFBRcnhOUlF5SzBmY2p1dDhyOGw3OWZ2a1kyYmRSNnp5VEl6alI1MW9uY2Q3ajlZYXJXKy9aUHpPenY1TmhtT2YrSDNiODJlVFdmWFNObG84UEFxb1FzT2pxUG5WYWg1UDVJTDdPaW1WeDJHZmlyTFF6TXZNM0dabWhhSTBHaXZsZ1VJSUljU044eW5UK0FqQXZNcXNzbVVkb2VrOWhkRVUxbERjOG8zZVc3L2l5dU5pbThZWVhxUDViZHZ6WjVOWXV5QWQxY1NEc2xzVVg4ZWVJMlg0NTRNSlB6NTVkTmU3OWFEczdnb3BwVEJhVXhTV3doWllZekJHU3haSENDR0V1QVVoWlRZKzBzZkVUR3RXdXFiUkpXMU01SnpSV25IYnRTeTNlZ1VRWXlUbVRBVFdhTTZ5NWxVWE9HM0QySFFnSVIwSHhFTlRac2ZDMWp3OTNPT1hIMys0NjkwUlFueUw1TndvYmxRZTMyTmY4ajdMRExmMThvV2ZJNzQzSVdaQ1pHZ25YZFZzS0ZsVHN2YVpwQUpHUTExVnQ3cFB0eGJrNUp6cG5HTWJJaTJhWlJ0cCtrUVhFaTVtUXBLMjBVSUlJWVFRUW56TFFrcHNYT1JWNDNoZUtvNU14SkpZekc2M25mUXRCem1lZGU5WlpzdXFqV3k3Uk9jVExxYXhkZlN0UG5ZaGhCQkNDSkhIREV5R041a1pJYjZNVDVsMUgzaTE5ZXliakRhT3hSMVVqOS9hUDVsU291dDZWbzNuSkdkV1l5YW5Ed2tuYTNHRUVFSUlJWVQ0NW9XWVdmdklxOFl6eHpNdC9aMDBYcnJWSUdmYmRSeHZlbjVQaWVQRzAvaUl4RGRDQ0NHRUVFSThEQ0ZsTmk3eXVuVk1zdUpJZ2N2NnZQblliYldTdnRWeXRXM1RjYnh1K0QwcGpsdlAxZzJOQ0lRUVFnZ2h4TGRGSWZPY3hQdENIb0ljb3p4bE52dzZMZWxWUWM1dlpnamVobHZONUd6YWx1TjF3eC9KRGtHT2o5SnNRQWdoaEJCQ2lBZGlsOG54TWFFcDJhZ0taK3Z6SlYrM0ZlamNlSkNUVWhyVzQzaFBFMkhwNFZYdldIZkRlaHdTS0lsenhBUHoxcDB0ZVg4TEliN1UySlZYamlQaXZubjNPbFhsTjV2NHZ1V1VpV1I4aHRZbjFqNno3Q09ubmFjZ1VSbE5WUlkzWHJaMm8wRk96cGtZSXlFbCtnaU5LbG5tbnRlTnB3bVpQcVF4a3lNSlRpR0VFRUlJSWI1MU9UTjBUVTZaUGliV0xuRGFlVjV0SFhNVm1KZUdzckFQSU1oSkdSOHpQWnJHVGxncHgrdG1UY2dRVTViR0EwSUlJWVFRUWp3UW1lRWFQd0pkdUJEa05JNm9IQVVGT1U5dmZEOXVOTWlKTWRMMFBSdWZPUEdLVlZSc282SVBtUVNrREZteU9FSUlJWVFRUWp3WXV4eEdITmZuSExlZUY1c2VwVHNtS25HMG56REczT2crM0dpUUUwSmd2VzA1N2lNdnZPVzA5WFFoa2RrRk9FSUlJWVQ0R09sWUpXN0QxN3pQNVAwcFBpWG1UT01qeDQzbjk2S2owQTBISnBOU3V2Ri8rNFl6T1lsMTAvS3FpVHdQSmFkdG9QV1JuTE5rY0lRUVFnZ2hoSGpBVW1ZSWNscFBxV0d1dC94UWN6NHo1eWJkYkNZbkpUYWQ1OVhHODl6RGFSZG9mQ1psZGF0OXNvVzRiZS9PRExpdHQzdk8rZnpBY2ZIWFFvanJkWEhCck5iNldoZlFmbWptaUp3eXhVMzYybk9Wek1vUkg1VXpiVWljZFI2ZEUwOEx6OVlGblBlVVpZbFM2c1lhRU54b2tPT1RaaDBMWG5lQjUyM1BhUnZvUXJ6SmYxS0k3OWF1WGZ2UTBHTklCU2NKZElTNEVic1RzMVpndGNFWWZlUDE1VUlJOGExSlFCOFNheGZKS2JNMGhpWWJXaDhwbk1jYWpiVTMwMm50Wm9NY0xLczA0Wlh6UE45c1dIYUJOdHg4RFo0UTM2T2NNeUVsUW9LVU15RU4zUTJUdERBVTRsb3BCVm9OWDQyQ25PUHdhd2x5aEJEaUxTbG51bkZrVE84Vm0zbkpWdGQwU1ZISElmRmhUUDUyZ3B6aERyS2l6d1ViTmVVNHRMeHFQSzJQOUdQakFSa1dKYjRiNHpDL203REwzcVNVNkgyZ0N3bW5EREVyUWhvREhjbmtDSEd0dEZKb05hd3N0U1FxSXBWUjFJWEhXb3N4NW5vQ25uemhxM3lNeFUzSzcvejZjOTV2K1FPYkVLT1V3YVdFajlBcTJLZzVqYTVwc3FFS0NUS1V4YzNrWEs3OXA0WVE2SHlrVDVwbG45bTZuczU3T2gveGNiaXpMSVQ0ZWlrbE50c3RtNlpqMi9lY05wNFRCMHNxWEZiRW5FbEl1Wm9RMTAwcE5hdzlVSW9pZVNhaFpab2Q4MEp4OU9pQW8vMDludXp2ZmQyZFNmbllDaUVla0p3aEs0YjFPWDNneGRhUitzaGhaYWlMYTdveDlJNGJDSElpYmUvWUJNV3lnNjNyYVgxUEY5NnNGWkJGYVVKOHZaUVNtNmJqZU4xdzNFZCtXM1g4WXhQNW8yL29zeG9ESEVoeXRTVEV0WHF6U0Z0UkV0bkxQZnM2OEtqVy9OTmtqdDdMSEFIWGNzcVdPK1BpTm54dEZrYXlPT0lUenQ4V09kT0Z5Rm5yZWJucE1kWlRSTVArdEthcXJ2L2Z2ZllnSjZaSTF6dldQck4ybVRhMGRNSEpXaHdocmxsS2lXM2ZEM09vMG9SLzd4UC9ZN25sL3o3ZTBJWkVBc2haempsQzNLREtLSjVNUzQ0bUUzNm9hbFMxeDBFMWxjK2RFRUs4SXdPdFR5ejd3TXVObzdRZGN5d3gza3hUc21zUGNwenpyTnVXNHg2T1c4WGFCVnhLS0Rua2krL0liYlRTakRHeTJqUzhYSGI4UjRLWFc4ZmFSVUpPeEp5RzFQQmRQeEZDUEhBeFFSTWkxaWxzNHpuZGV0WmRZRjFaSmpsaEZkaXZLTU5RNVBOTmlQdnE0dnRVM3F2aW96SzRrRmoxZ1ZlTlkyNWFucGlDRU1PTi9IUFhIdVQ0RUlZU21oWmVPOHU2RDdnb1dSd2hybHVNa2ZXMjRjVlp3OStTNGJqeHJGMGdwQ3dCamhDM0pPWk02eE01QnpLSzVicGp2YW5ZVGd0VVRsUmFZYTU1am80UVFueXJ1amhrY3NxdFkxKzNiSXY0N1dSeXZBK3NtNWJqQmw2N2luVWZKY2dSNGdZTW1ad3RMODQyL0VjcWFWeGs2eU14U1ltYUVMY2xabWhEcEk4Smx6TExaY3QyWHRITUs2eEphS3VwaXB1WkFTR0VFTithUGlSV1hTQm5PTklkelNRVGJtaUc1dldYcStYRUptV091OGh4cjltNGdJOXl5U1hFVGRwbGJ1U1RKc1R0MnpYNFNER1RRMGFsakVhbXZ3c2h4RVVaOENuUmhFZ0cxZ1ZzRTdRKzBQZjllZnY5NjdvcGRLMUJUczRacnpVck5NZmVjOXc2Tms0eU9VTGNCS1VVeGhncWE1bG9UVXdaRnhPZFVzTlZseERpeGcydHBJZlpPVVlyQ3Ewb3RhWXltdElvdEZhU3hSRkNpRkdJbVk1RVN0QVVCYTJxMkVab25hZTBtV3E4dHJrTzE1L0pzUVdib3VRNDlyd2VCNEI2bVkwanhMVlRTbUdOb1NvTTAyUndNV09DWEV3SmNkdUc0YUJndGNLT2dVNWxGTllNZ1k4UVFvaEJ5SmtVRXk0bW1rVkZXODdvVkVFYkVvcElZYTl2WnM2MUJEa3BKVUpLK0p4cE1qUlpzdzZ3NlNNK0R2TnhwSTVHaU91bHRXWXhuZkI0QVQrbml0cm9ZUzVIenJnNERBRWRQblp5a1NYRVRWQ0EwWXJLYUNxcm1aZUdSNU9DV1drd1dwRnlwdmVCcnUvSTQ4MituRDg5b0hlNTdWajNnVzAyZENFUmRqY0o1UndxdmhYeVhoV2ZrQzdNNytzeGJDbFlCczIraStRWUthMmhLSXByK2JldUpjaHgzdFA0UUp0aDFVYWFQdUY4SGdLY1BBd0FGVUpjTDJzdGovYjMrS3V1S05PVUY1dWV2ZEl5S3d4ZGpNUTBkSDZTWWxFaHJwY2VieHhvQmFYUjdGV1d2Y3B5VUZ2K2FiL21ZREkwR3VoOVpOdDJ0RzJEOTU0MERzVCtWSkR6dXZXY2VNVloxcXk2UUJ1R1ppSkNDUEhRdUpoWTk0SFhyV09LZ2hKbXBXVXlxYS9sNTE5ZmtOTjVWbEd4N2lKZGwvRSs0ODhQNkhmNkhBcnhJRmxyT1RyWXc5U0J3MXl3WDFtbWhhRTBpbVlzRXgwK2czZTlwMEk4TEx0MU9FWXBwb1hoYUZyd2RGYnllRnJ5YkY1eVVCZG9OYlJLUFhPWmt5YlIrYUdxSWFaUEJ6bG5Yckh5c0lxQnM5N1QrdUZtb1JBMzdUYm11d2x4a1l1WmRSOTV0ZlZNWTZTcTRYQmFYZHZQdjU0Z3h3VzJiYzh5YUZaTnBPMFRQdVMzN2o3SmgwWjhUeFEzZjhJd3hyQ1lUYW5xeEtPc01EbWlvME41eGNhQlQ1aytSSktrY29TNFZrb05aV3BhS1dhbDV0bE04OE5ld1pONVNXVU5Wc0c2RHh4M2daZGQ0cVV6dEY0UjgzQmUvRlRRc25XUmpZdHNuR2ZaQlpxeExieWNROFZOZXZkY2RkWDMyOFh2a3lCSmZDNGZNMnNYT1c0ODgrRFl6K0M5djdhZmZ5MUJUdThkcTZibGxUT2N0b210TkJzUTRsWVlyYkJaUVVyc200Z3ZBcVp5ZE1vVFU4SWJLWFVSNHJycE1jRFJTbEVWaVlQU2NHZ0w1c3F5YW5wZUJWZ2x6WEhqZWQwNFhyZWVQZ3pCVGM1OHNvUzdDNGt1SlBxUVdMc3h5SkZNamhEaUFUb3ZWMnNjTTlmeFJJRVA0ZHArL2pWbGNoeXJiY3RyVjNEU0RuZWlndHcrRnVMRzdmckptNlE0bUpSVWFzWkJwUWtoa25JaXhvU3NBaFhpdWcxdG9YY2REdXVxcEs0cnROYThQRG5sNzB2SGYvcVM0eTV5MWdaTyt5SElBUzQwQlBtd2tESmhMR3R6TWRIdm12Y0lJY1FENDhaTXpxdkdNOWN0YTNNZk16bk9zMm82WG5XUjQwNno5ZkZOUnhnaHhJM1JXcU8xeGdKVldkNzE3Z2p4WFd2YmxuYTk0cmNYSy80dnQ4L1NaNVo5WU4wSHFXNFFRb2gzK0pqWXVnQTVzNjg2TmlWNGY4OHlPVDVyTmtGeDNBWk9lelZtY3VTQUxvUVE0bUhMT1JOQ0lLYkV0dXRwc21HVDdWQnFGb1p5RERrYkNpSEUrK0k0OGtJUmFRcERnMkVUTXB0dGd6V0dvckJmTlRQbnE0S2NYWWVZcUFyYVhIRFNPVTY3SUVHT0VFS0k3MExPR1I4aUxrU2FrR2wweFZZNTFpN1J4S0hrVE1Zb2lJZE1HZzJJTHhWVHBnK0ptQlZ0VWRBV0ZRMld4Z1ZLbTRZbUwzY1Y1QURrREZGWGRLcm14SFdjZEFGM2NZQ1pFRUlJOFVEbG5QRXgwcWRNaTZVcjVqUTJzT3hYdU4wQTBMdmVTU0dFdUlkaWhoUVRMa0l6cmVpS0JaMmRzbzJRaVJURzhEVU5wYjg0eUhIZTQyTWlKTVhHWjdZeDA0YUU5NG1RRWpsbGxCelp4WGZxclJiUzhrRVE0c0ZLS2VGRG9IR0pkZEEwTWVQVFdPa3dabkRrVHJlNDkzSWVvL0hQT0YvbE41dGllTCtyY1JQaWM0VUVUY2ljdWNScDY4azJVV3JGak1rWC84eXZDSElDalF0MFNiUHlnYTJQdUpqeEtaSGVITnVGRUVLSUJ5dWxSTmQ3dGk2eERvYldKM3pNa3IwUjM1WmRVSDRlN0h6V045LzEzb3NISUtSTTR5T25qZWZZSnJTTnpBcjlWVC96cXpJNTI4Nnp5WmFsQzJ6aTBOYy9wUHhsbnhFaGhCRGlHNU5Td25uUHBvdXNRa0VyM1VXRkVPS3poWlRaK3NocDUzbHRBblVaT0pwK1hkZllMd3B5Y3M0NDU5bDBQY2N4c1hLQk5rUkN6c2l4WFFnaHhQY2lwVVR2UGRzK3NnNXFLTnVPNmJ3eHo0Y1lsU21OcGpDYXdpaU1VaGc5ZkwwcE1XZkNXRzNoMDdEZ2R6ZVRSd2doN2xwSW1kWW56cnJBQ1ltREdIQmZPVFBuaXpNNW5YT3MyNDZUbUZuMWdjNS8rcUF1aEJCQ1BEUXBaWndMYkR2UEtta2FIeStkaVdPMVpsRlpEdXFDUldXcHJLWXltc3ArWFduR3AvaVkyTGpJdWgvS3l4dVhhSHdrcEhqWFQ2RVFRaERIY3JWbDV6bE5rVTMyZHhQazVKenBlOGVxNlRrT2luVWZhVU1rU3BBamhCRGlPN0xMNUd4Nnh5cGFXaC94TVgzeWU2eFI3TmVXSCtZVlQyWWw4OUl3S3cyejhscEcxMzFRNnlQSGplTlY0emx0UGFmS0UvSlFIaUtFZXVlckVMY3Q1RXpySThzdU1BdU9yWEozR09SNHo2YnRPZkdhWlJmb1F5Wm5KUjNWaE9DZDdtcDN2VE5DaUJ1VDhyQW1aOXQ3VmpIUXVySHhRT2FqNThOU0tmWXF5N041eWE5N05ZdENNUzgwaS9MTDUwRmNwdkdLcVlwWU1ocEZpSm5HSlRsbkMrRHRjOVdYbkxOVUhuL0dKOTczUW54S2lwbmVKMVpkWUdvODJ5TGlRaUtsaEZJSzlRWGx2RjhjNUhTOVk5VjBISHZEcWs5MElaS2t0bGNJSWNSMzVMeTdXdWRZcFlvbVJIeThyRnhOc1NndFQyWWxQeTFLWmlveU01bVp2Ym1zeWpZSGdnMkVDaElsclkrY2RWOTNsMVFJSWE1THpNTmdVSzBpbTFMUjZoS25MVDVFdEZJWW85SDY4MHA2dnp5VDR4enJ0dWZFbGF4Y3BndEptZzRJSVlUNHJyeHBQREJrY2pvZjhlbVNjclZ4VGM3VFdjVXZlelUxZ2FtQlNYRnptWnh0MnhORElDcUl0dUMwODFUbTV0WUFDU0hFNTBncDA4ZEV6Sm1wVm5SMmdqTVZQaVdzVnFqRTdRUTVLU1U2RjFoM2pwUGVzUTZLUGlTU3JNa1JRZ2h4elhMT3BKVE90NHROYnBSU2FEM2M0ZHVWTkh4SldjT1hTaW5UKzBEVEI5WXgwUHBFakorZW8yQVZ6SXppVVczNFlWRlJxWkpKWVpqVTlZM3Q1M2JiRUZJbW1rRHdCUzgyN2tZYkhRZ2h4T2VJR1ZKSU9BWGJvcVF6TmM3V3VBUTVKeFNmSDdSODF0K1BNUkppcEhXZVhoZTB1bUxyRTIxUU12eE1DQ0hFdFlveEVtTWlwTWhxczJXMTJYSzIyb3lCemhEOGxHWEJZalpoTnBrd25kU1UxbENWSlVWUjNPaSs3UUt0cURTaHFPaDBaTnZHODNseDcxS0EwUXFsd0NhSDZkYVV2cVJTYzBxak1aOTVoL0p6YWEyb0NzdTgxaXkwWVZwb2loditONFVRNG5QbERDbG51bkY5emtucm1hckl2TFJVNWVmTnpibHlrSk56SnNTSUN4R1hvRGMxbmVuWUJrOFh3S2NzbVJ3aGhCRFhJdWRNakFrWEl5NG1YamVlNTJjZHowOGFmSWlrbklrcE1aOVVQSEdLcDhseWlHWldXclRTdHhMazVBeEpHMEl4b1ZXQmpSdjI5VVBsYWxxQlVRcXJGVFoyV0JjcHdweEpZWWNaT2VibVN0VmdLUE9veXBJWmlUMmxtRmlETmRJV1JRaHhmK3lpaUpnelhjaXMrOGhKNDRnNlVKREpPWDlXcHY3ek1qa3A0Vk9teCtES0dWM2gyUGd6K2lEQmpSQkNpT3NWY3lJa2NGbHpsZ3IraURYLzVpTjlpTVE4bkpNT2l4SVhhMHdxc0ZHaFhLQXFicTRWODBVWlNLWWcxak42MDdOeG0vTzdrS0NIM0JjQUFJQUFTVVJCVk85U1NtSDAwSFNneUo3Q1JTb2lrN3E2bFgwZGdoekxYR2M2TmF6L3NWcUNIQ0hFL1pOU3B2UERYSy9UeG1PTVkyNXZzTHRhakpHdWQ2eGQ0aXhxTmo3aDRuQ1FseEJIQ0NIRTE5cXR2WWt4MFRuSDYzWERjUmM1RG9iZlZoMi9MWHVlYnowdURvMXVZczVzbzhjbHhkb25udHZNb2VvNXFoU0hzNHI1ZE1wOE5tVStuYnkxWnVkcnhmT3Foc3pXSjdxUUNRblNXRUwzb2ZPaUFTcWptUmFhaFNxb1M0Mjl4WVgvV211c3RWUUdKZ2FLUllXZEZoUkdrZEt3ejlJOFNBaHhIOFNzNkVKbTJRMlpuTXIySEpUNjVqSTVLU1hhM3JIcUlxZlJEbW41a0NUQ0VVSUljUzB1bGtWdlhPQ1BWY2QvckJ4L2IrRDExZzNETExlT0VOUDVSZm5LQnRaOTRPV21aODhrbmxqUDR6THpkRmJ5d3lONHBpMTFYV05JbURIUStWb3hSbnJuYVdObTJ3YzZuOFlnSjQrUDQvM3ZzVnBSbWFHY2JtRjJRYzd0Wkp4Z3lDU1ZoVVZsbUZnb1ppVjJXbEpxalNlOUZhQUpJY1JkeW1NNzZYVWZPR2tVODZMSFRjMWJUV2V1NHJPQ25HRTJqdWM0Vm16NmdJc0pPU1FLSVlTNERrT1FrL0FKbXFSNTNzUC9mZWI0LzcxdTJicklwbzlzZWo5Y2tJL25IcU1VV2l1TVVpeEt6WTh6eXcremdvMnR3QmRNb3VGeFZwQXlpc3gxckxXUGNXd2I3VE5ibCtoOHhzZFBqMUhRR21xcm1aZUdSVkV5clNMbWxqTTVoVkpZb005UXprcUtTWW5WaXBTVm5NdUZFUGRHeXBrdVJGWjk0S1RKUENwN3V2N3oxMWwrZmlhbmNaeEVOUVE1WXlaSFNjTUJJZDZpZUdlQ3RIeEVoUGlnaSsyaHQxM1B5YmJsekdWZTl2Q1B0ZWY1SnZCNjA5T0hkTDVkL0RqNUM3OExVV08xQnFOSUpzTTZFRXhQbnpWelBGT1RtVmNGVldrcHJLVW9pcytldXdBUVU2VHJQV3VYV2ZmREhjZVk4aWZQaFZZcGFxdFpsSlo1bWFncmpiVTMyMnpnWFVxcG9RMXJESlJkUSswN1pvWEdLT2hESkpHbFpPMTc5VVd2KzFDWXFYSkdaVFdjNTNLV2EwTHgxWVpNVG1UZGUwNU1ZbDFBci9YTlpYS0dOVGs5eTlaeEVnenJmbWlWS1RkL2hCQkNmS21VRWlGR2ZFd3MyNTdmemhyK3NRbjgxc0EvbGkydnRqMnRUNFNVQ0plVVU0V2MyYmlJMmpyNmtPaGk1cXoxUEYvMVBEYWVwN1hpMmFKaXJ5NloxU1VML2ZrVHRJSHpOVVByTHJQcUZZMlArUGpwazZIUmltcVh5YWtLNnRMY2FybmFSVHBHeXZXS2FiTmhVUm1VR2hiNk9pVmRVcjlyc3NoYTNCTkRkN1doWEszVXNINVUwMDhtNU04c04vNk1URTZtN1hwV1RjOUp0QmZLMVlRUVFvZ3ZrMUxDeDBRZkUrdWcrTDFKL0kvamp2KzlkSnkxbnJNdTBQcWhaZlJsNTV1WU1oc1g2RUxpclBPY2RaNC9Wb1pGV2ZEWGhhRTVxTkFsWkFKS3dhVDZzbms2SVFTYWZoZmtHRm9mUHpnYjV5S2poaUJuVmhybXRhSXUwNjFuY25aVVNoVGJMWk91WmErYWtESzRrRkQrVG5aSENDSGVrak4wSWFJNlVFYXhta3pwWnZPYkMzSml6clJSc2VvVEo4NnpjVU1tNTNOVFIwSUlJYjV2dzR5WllkdDJQYXZPc1E2S2Yyd0R2MjBUZjE5N2ZsOTJkRDdSaFdGMHdWV2tEQzVtWEl3b0QzMUlyRHJOc1hFb0p1aWl3SlNKdHV2WmJCT3U3MWxNSjFSVitkWUEwVjBYdGhBQ0lRUmlUUGpnOFg3NC9ldXpGWCtjTlR4M2xwZStZTlVIK3BnK3VXOW1YSk16S3czelNqT3A4bzNQeHZrWWxUTlZTa3pKTEVxTGk1bkd4VGYxdFVJSWNZZFN6bU4yUEtLZHBsV1czaFQwS0hSS2FMaFNGdjdxbVJ4bDZkV1VkWXFjZHA2dGsweU9FRUtJejdjclVRc3hjYkpwK1czWjhFZWIrWDJiK1B1eTViVHhkSDRZcXZrMTVWTXhaVHlKak9MMTFxTlZTK01pUjlweHBCMVBhczNSWXNMUndSNUgrd3YyNXdxdE5Gb3J0RkswdldQYjlUUmR6M3Jic3RvMnJMWU5yemNkTHp0NGxXdU9VOG5ycmFQMThaUDdZdlN3Sm1kZVdSYTFvaTR6OXE2Q25MSFQycXd1MkErV05pUktveVhHRVVMY0N6a1B4MjhZYmxiMVcwZTNkYXhuSlRrblNnVlZVVnphTGZQcW1SeFYwSm81Nit3NWJjL29mQnFDSElseWhCQkNmSVloTXhMeENVNWQ0cmRONEw4ZmQveStDUnczanRQVzA0Wkkrc2hnemF2SURCVUlPUTFyZFk0YlIrTWpMemM5ajJ6aWNabDVOdEg4bUFPdWpKVFR6RFNCMVJueWNPTHNFNng5NXJSTnZOcEcvbHdGWGk0OXI1dkVpVmVjQk1jcUJscWY2TUtuZzV3M2pRY004OG9NUVk2OW16VTVRNUJUTUt0SzlveGw1U0tGR1FJN1daVHhmWHEzV2M3bmZKOFExKzNpOGR1NVNOZzZ1blZQczFkalZFUVpUV0hNcGRud1M0K3dPUS9kVmp5V1RzL1kwckRwQXpGbHdyalFVdDdrUXJ6dFMwOFlRanhrdXhLMXpqa2FGMm16NXJWVC9OWmsvdjIwNS9tNnAvT0pOcnk5a1AvZHo1RUNsSHJ6NXg4YlpKbkhnYUVBNnhoWnV5RVFXVmFXemJ5aXNTWE8xMWhYTU9taDdDTFdhS3pPR0tVNDdqUEh2ZUtWTTd4d0JjLzloRCtDNWpnNnpwem5yQTIwM24xMFB5L2FOUjZZbFpaNWJablkrNURKS2RrUEJhZHRvTlFhbmUvM01ldmQxMzFvSlM2dXc5ZTg3dXJDVnpudmlldXlPMzZIbVBDTm85LzBiTGNPYXlORmFjamw1ZXNwUHhua3BEVGNiWE5KMGZpTWl6MGhla0xNeEN4ZFdJUVFRbHhOakpFUUl6RWxYcTIydkZqM3ZQS0svMWc2Zmx0MkxMc3dycjlKbDdZeHRrWlJhRTFoRkdSd2NhZ3NpRmM4SmJtWTJmUUJQWHc3SVdkV0x2Q1BaWWZWQ3FzMVJpdk9Xcyt5OVp5MlF4T0Uwelp3Mm5yV2ZzamV4Q3V1RlZKY0xGY3p6S3VDMnVhN2F6eWdGRlZSTUswUys3WmdXcnFoWE8yZVhwM3VkcXN3aXNKb0NxMklPZU5DdnRMN1JRanhiZk14MGJqSXN2TllHeWl4ekNmcDB1KzdOTWh4SWRLRlRPc3pJZlRFNkFocENIRGt3Q0tFRU9JcTNwU29aVjYzZ2I4dE8vNTlHWGkrOGJ6YU9sYTlQNTgzYzlrTnRFSXJwb1ZtVWhoaXppZzNCQ3J4aWxHT1QwTnJVaDhUalI4R3pyMVk5OHdyaTlVS296VmF3YmFQYkYxZzJ3Y2FIMmxEb3ZNUmw0YmhuL0VLTi9wMjJRZXJGVld4NjY1V1VHdnVySVcwVW9xaUtKaFZtZjFrbVJhRzB1cEw2OXZ2WkY5NWs3MHB6UENhVDZ6R3hZUWlFYjNjY0JYaUljdUFUL244V0YwRngwd1A4OVV1ODhramJJd1I1ejFkeVBRKzRtT1BqLzdTZVFCQ2lBdnUzM1dERUxjcTUweEljZWg4aHVZNEdQNWpDLy9YeXkzSGphZjFjWnlGOCtGenk4V1AwQzVnMksxdkNUbVIwakNRODdJNU9qcytabnlNYkZ4RXQ1NC9ONDVDSyt6WWNFQ1BWOVl1REJtaWR3ZVFmcFp4bWN2NW5Kd3hrMU1vN2l5VG83V21LZ3VtOVJqa2xJYkNLTzdEa3B5TC83eGlxSjlURFB0V21pRzRuVmVXenNlaDYydTQrMzMrcnVXUGJFSmNsNXp4WWN6a3RKNnBkWFQyV29LY1JPOGNhNWRaOVVNVUZhN3dRNFVRUW9nWTQzQWU4WjQvbHh0ZU40SGphUGkzNHkwdjFoMGJGNGJnSk9aUGppTlFDdWFsWlY0YTVwVmxYL1VjcUpiREloR3pZbWtzeTJuSk9sazJMckxwQTFzZnlXUGpnc3VxRGxMT3hIRzJ0Vlo1dktqT2hIUzFiTTNIVEFyTnREQk1TOE96TXJPWE91cm9zV29JZXU0cWM2S1VvaW9MRmtNaEhYdHp3OTdNc0Y5YnlNTmRVeC92cGd4TWo4OU5vUldsMGV6VmxrVmwyYThzMDRsbVdodG10V0haZWw2dEhhOVhnVTA3bERyMk1jbE5XQ0VlSUIrSEdHVFpCUmJXNFVxdU5NTG0wMEZPaXJTOVo5MGxWcDJpOCttODJZQVFRZ2p4TVRsblFvejRNSlI4dlZ6My9PK3pqdi9ZWmw1c2hpWURtejdpUWhwTG9ELytzN1JTekN2REQvT0tIeFlWUnpuejJNRFRpU2FpT1BXYVV5WWN4NEtYNitGbis1U0phUWhlUGxYT2xQTXc3RHFvWVg2TUd0TVppbUhSYTBwWHl3NTlTRzBOaDlPU3g5T0NaM1ZnWDBjcWxTajAwS2I2TG9PY3VpckoxbEtnT0poWjlxYVcvWWtsSldoOEpGMmhiUEFtR0RVRU54T3JtWmVHbi9kcWZ0eXIrSEd2SG9LY2lXRldHVjVzT3Y1UmRaU3E1MWhybG0wZzlWSnBJc1NETTY2N2JGeGsyUWNPZzZPcjFmVmtjanJuaGlCbm5PcDgxYUZzUWdnaHZsOTUxeFVuUVpjMHIzck52NThGL3M4L3QyeGRZRDJ1ZHduamVlcFRaeFlGTENyTGozczEvM28wNVFldCtYbXErZlhKQVNFay90eTB2SEthRjczQmFrVWJFcXMrNExsOHpzN1FxblFJYU5RSDl1UnJ6bmgxb1hrMEtmaDVyK1paMlhOUURCZnYxcG83WGYraWxLSXVTNHFjV1FBSGs0TDlxV0cvTHZCaGVDNjZrTGlMVk01UWxqYXN2VG1vQzM3ZXIvbHZqMmY4dHljenB2V1F5ZHVyTFA5N3RhWFNCcnlDcUlncDA0WUlYcXBOaEhoSU1weXZuMXgybnJWeE9LOUpWemcrWGJvbXAzZWVUUmRaOThWWXJpWkJqaEQzUWM0WjV4ek9lNXdQTkczTHRtblpOZzBoUk5JNFNQRXFLVjN4L1RKYVk0ekJHTTJrcmxuTVo4eW1VK3FxeEJxRHRmWktrNlZoSERtUUVpa2xtcTduZU4xeTJpZGU5NHIvWFBhODJIcE8ycUhCZ0F0RE43U1B2VHV0VWt6RzVnTHpVdk56bGZqWjl2eHNEVThubHNlTEtmdUxCVEVtSWdyVGVuVDJoR25DSk11aW5yUHVBdXMrc09vREx1UkwxOWRjK1pPU2g3S3FYZGUwd21oS295bnRrSVhZL2Y1WkZmbXA5dnhZd0krMTR0RzhvcTdLZTdIQVgydU5HbzhOand6OE1qVTB6eW9PRnBhenJXWFpSTnArWEVjVkV6Nm04eksyWGJia2E0OHN1MmVodEpwNjNCYVY1V0JTY2pndGVES3gvRG8zL0ZSbkhwY3dLZFNRNGJHV0k2djVxZGI0UnlYYWdpa0FsZEhxVGJlOVMrYXpDaUcrQVRrUEhURWJIMWwxa2ExeDlNNWNUK09CdG5lc3U4aks3Y3JWNUM2SkVQZEJ6cG0yNjlsMC9WQU9kTExreGNtU0Z5ZG5kTDBuaElpUDhjcHRic1gzUndGVllTbXNwU3dzVHcvMytPbXg1OGNqeFg3SzFJVmxxdFJuQlRsRGlWcGkzWG4rV0xiOGZlMzViWnY1YmRueDU5YlIrdUU5R1hMKzVEQnBxeFVIZGNHVGVjblRxZVdYd3ZIckZINmVHUTVtTll0WlBRWmdpZm1rUWlrd0tsT3Frc05aeFMvUjhPZkc4V0xkOFhMdFdIVkRaNTZROGxmZnJOTnFLS3ZTV2xHWm9abkFvckp2dG5FZHlTUFY4dGhHbms0dGg3T0tSM3R6cXJLODY1Zjl6ZXMvQmx1SGhlV2ZGeldUdXVTNGpaeHVQY3ROWU4wT1hlaFdYV0RqQWxzWDJicEl5dkY4aHQ2WFBwTVh1NlpOck9ab09nWTJzNHBuaTRwbmk1b25FODJCaVJ6Vmhua3hCSTZWMFVObXp4cCttbFVVaGFXZVdLd2R5Z3cxNmp5dzlYSzlJc1EzYjhqazVLRmN6WGkyMXRNNWV4MXJjaEpkNzloMGlaVWJ5dFVra3lQRS9aQlNvbk9lZFJjNEM0cS9kNFovM3hqKzk2cGcwMEh2RFgwWTVwSUk4U0VLeGFTMFExdmUwdkxYd2hMbmx0b3JyRXNvQWxWUlVGdytjdzNZelZZYjd2aHZndUo1ay9tZkp4My9kdHF6N0FLcnp0UDZkS1VMWktzVkI1T0NYL1pxL21tLzRrZXIrWFZSOHRkblIwT1d5VnFzSFU1MGUzUE50SzdZbndjZXUwQVRZWk0wZnp0dG1CVUdqY2JxWWZ6QnhvVnJlTjVBajkzWUtxdlpyd3VPcGdXUFp5VlA1aVdQcHlWUDVoWDcxQndVbWNOWnpiU3VLY3VDOGg0Rk9UdEhzeW16cXVJbk1pZDk0UFhXY2JyeG5HeUdYNy9hT282M0RxMzgyTkVzb2xCa1BoMm9mdkk1Vk1OYUs2VmdXaGlPWmlXLzdOWDhjakRoTHdjVGZ0bXZlVG90c0VRcW82aUtJYU80Mi9icW10SmFIdWZNWXRJUGd3TjlKb2NoY090RFlvc2MrNFI0Q0Z4TXRENmhWV0JySGM1YlVyNkdURTduUGVzMnNBNldOZ3hCenQwbjJvVzQzeFEzUC8wNXBjU21hZmx6N1hpWmF2NW9OWC80aXVkeHhpWUhIQW1uRXZGcU4rSEY5eWpESkd2cWJLaWpwZ3dWODE0emJ6TXFPMUtBdXJEVWRmWHhIekdXUkE3dng0NVYyN1B5OE1jMjh0czI4c2NtOEh6ZEQ5MnZ3dHNETk4vOWJCUktVZHJoYnYxK3FYaFdKbjZxSXI5T00wK3JpaWY3TS9iM0Zoanpwdld5R2pOTlJWRlE1OHdrQkJZeHNSY1N2dStJVFNTVlBiWDNsSk5FcVF1YU1MU2M3a01pSkQ0YWRPa0xGK0s3NGFPbDBkUmFVeGVHMmxwbVZuRllKaDVWa1VlVjQwbHRlRHlGSnpQTnZKZ09hMGhtVTZ5OW01azRWMUdYSlhVSit6bFRxNTQ2SmVZcE1vK1phUWhNWE0raWRPeVRPYk9HbzBsNVh2clg3MHJad2xER0ZzY01YWDduQmM2QVVXTndxQlQxT085bVdoZ2UxNHBmNnNRdmRlRG5PdkxUUlBGc2FuZzhMOGVBOHYyRFdHR0hET1E4RHlWMHE2bWwzeS9JZ0RLWnhORFFJc1RoNjdDZVdLNWVic3B0blBQRWR5cERUSmt1UkNEVGF1aVRHbWFWeFRpVTNuNmtCUGp5SUtkM3c1cWNHRDQ1eDBBSWNidGlqSnl0Ti94KzNQSWZNZko4M1hQU0RPVkFQbDU5Wm9qNHZvVThYUENubkRsdFBTL1hQYlhWaERLUXA3QlhGK3d0NWgvOS9wVFNlUmUxczZianQ5T0czN2VSMzdlSmY1eTFIRGR1UEhla1Mwc25TNnM1bWhZY1RrcWUxdkNYT3ZKTEhmbDVxdGliMU13bTlhWHJXYlFhTWl5MWhzTUNRZzNWZkZoMzhtUlNjSndxanZ2TWNlTTRiaHhiOStaaStOM0dYRU1yNHlHNFdWU1cvZHB5VUJmc1ZRVjdaY2xlVlRBM21Ta3RVKzJaMjh4aUFvc0s5Z3FZbE9ZOEEvR3RxTFJpYmhTNlVKUTFUQ01ja05rV2lrMnl0THFpTVZOV25XZlorU0ZEMXdkVzdiRCtxUXVSTkY2VXZEM3pobkhkMHJEMjVzbXM0c21zNU1tczVKSDFZMW1mNHFpR3d5SlQ2MTFKMitXWHpGT3RlVkpaMG1GTlZSZllBcFFHc3FKeHd6eWswQWM1SGdyeGpZcmp6UXdBcDJ1OG5lQ1N3dm1BTlJwcjdRZVBGVmNzVjRzc1k2RHpVZGJrQ0hGUHhCZzVXMjM0L1hqRC80cDZ1T0JvdzNrWHhLdk1CeEVpcGd4NXlHZ3NXOCtMWXJnZ2owWEgxTU9QQjdOUGZ2K2JFalU0NnpQL1dBZit4M0hMUDlaRGs0SFR4dE9HTnpOclBxVTBtc05KeVY4T2FuNlpLWDR1L1BEcnh3ZFVSVUZWbFo4TUdKUlNHR09Ha2lhbGVMeVlNU3NNUCt4TmVMMXBPZTR5cDduaTkyM2dQMDgxUG1aQzlFQWlKZlhlVEJ5ckZLVlJReXZvU2NGUGV6VS9MaXFlekNvZVQyc2VUMHYyQ29YTlBRVUJxek5sVVF4YldXRDB4MCsrOTVGU2l0SVk5dXFLaVRIczFRVnVYdVBEQWg4aVhWSTRWZERyaWxjYng0dE54NStibnBjYmgxVTlQbzBCWTBwa0JmR3RudzJGMGN4S3c3eTAvTFJYOGMrSFUvNzUwWlJITnJBd2lmM0tNcHRVMUZWRlZWNHRPRlJLTVNrc1A4eW5MS2FKZlJmUkNtS0U1T0M0OFlTVTJUcSt1TFJPQ0hGM011Tk5rd3crUlp5cDhlVU1yeXcrWlpUSzZKVGV5dkR2ZkRESTJaVWZoSmpvWTZZSmljWVB3N2FHRTZJY0tZUzQzRGcrL0lZK0x6RkdtcTdqZE4zeUlrekdxZkZ4N0ZvbG4xRnhOZWxDOExIMWdXV3JNUXFtdG1WakZNRi9lQTNMN2p6UjlvNU41OWxHelo5ZDVvODI4N2VsNDdkbFJ4Y2lYUmlDb0kreDQ5b1dxeFVIcGVKcERiL01GSC9kSzNoV0YvejRhTUdUbzBkWGZqeEtxYmRLMkhaWnFNWFprb050eDVtSHl2UWs3M0crR0ZwTyswampJbTY4aWFlVUdoYkVsNHBwT2JSOS9tbXUrR1dtK0hWaCtHRlI4SFJSOG1SUnMxZGJ0SnA5VTltYVQ5bXRkWnJVNy84MzV6MHhaVnlDZzFJeE01RkpkcFFKYk5KQXdiVFE5R1BwbWg5cjVoVUtwV0cvTXV4UExJdks4TXZDOE5kOXkzOTlWSEZZVFlmU3RicWt1T29Dc0F0MmdlVkJ6c3ljbyswY3JndG9ueWtNcEp4b1hNREgzZUJYeVhLL0o4TjVuV0hlL2NGbi9vQjhZUlBpR3FVTXU3NllYcGQ0VzlObFF4OFNLbWVNVmxjTGNuYnRQMk5LT0RUZVR1aG9hYzliZnNxYlY0ajdRaW1GMGdxajFiaDI0TnU0WXl6dUo2WFVlZWV3WGZld0Q0a3hFdUtRMlgrOTJ2SjgyZkd5Vi94ajVmbkhXY3RaNStsQ3hNZDg2U3lEWVI2SzVXQlM4TFRLL0tXTy9GeDRudFVGajZZVms2cmlPcFNGWlZaYUlPRHJqTm8zN0ZWVFR0M1FqV3ZkQjlxUVVPdytUekF0TTlNeU02c1VSMWJ4dUlUSGRlU2dpTXhOb2h4YkZuOHZuenV0RkZsQm9SSnprM2hjUkhRVm1LWE1VV1g1OVhEQ0ppaTJMckxwdzNpWGRkZHFHL1lxeFdLaTJLOE5QOWFHSHlhd01KbktLS3pSMXhJb2xzRGpRcFAzU2c1S3k2TFdsR1lZK0xydWgxa2Iwa1JKaUc5WFNFTVRnbFh2bWVwSUxvWTIvaCs2UC9KZWtMUEw0SVNVQ0xyRWwxT2NqblEranRPZjcvcmhDU0YyRk9QRnFIb3p0ME9JTDZVWjNsTmF2ZGsrZFAwZVk4S0hvU3p5cEUzODU5THh2MDRkZjJ5SGJseG5yYWNMaVpUeXBUZkdKb1hteWJ6aXA3MmFuNnRoRGM1ZkRtcCtlclNncmlvbTlmVUVPVlZab2xDVWhSODZvazByZm82YVZZQ3pObkRhZWpaOUhPcTd0Y0pxbUZXd3FCVjd0V0d1WUtvVlUyT29xNUs2TENpdFBzOGNmUStNTVNpVjBFcXhOeWtvMUlUOVV2UE1SN3FzYVZYQkppcVdyUi9lQXo2aHRjSW9zQWIyYXNWK3JUbWNGQ3kwWXErMExPcVMwbHJNTlFRNXUzSzdKOU9hYVdGNUVqT0ZIZ0tjMW9IVkhoZzZyMzM5bEorSFJZM0RjTlY1S3VmN2VFK0xiMDlJbWRaSFZsMWdCdGlrbUpVZnpnQi9NSk1UWXNKbDhMYkNGek9jN3VuRDl2enZ5RnRmaUUrN2pVNHpTaW1NMVJSV1UyV04xd21yaGdzS2tJb0JjWFc3YS9SaHNPV3dEcVcwQm12ZXY0RFBPZU5qcFBPSkxpdGVlODNmdDVuL2Z0enk1N2FuOCttOXdkRnYvWVI4b1gwd01MT2FKeFBEWC9mTFlRN09WUEhMNDRQUEtsRzdpcUlvS0lxQ0dYQ1lNM0ZzaExCeGtaT3Q0L1cySDRPYzNYQlB4V0l5ckJGNlBLMnhIeWlGK043czFqd1pBMFV4WjI4K2xBS204Ym1NT2JNZW44L2p4dEc2aU5aRFNXSmhGQWNUdytHazVNbHNjbVBsZllXMUhNN25IT1E4cmhGS3RDNnhib2YzWTBpUnJZTVEzMVJuZlNjeDZxWFVPMTgvNS91a3U1cTRMU0ZsT2g5Wjk0RUZpYW5TeFBUaHliL3ZCVGtoUmxybmFLSmkwd2RjakplV0d3Z2hicCsxbHNPOUJYOXhCaGZtdkI1bldSeHZOWDE2Y3hkZFByN2lZeFREQmFnWnQ2ZnppcC8zYW43YXIvbWxMSGs4ZzdvZUZtZWtOTXkzOFNIeTZtek55NDNqbGRQODdhVGorYnBuM1lkaExVYTZmSGJLdkh3ek1QUG5PdkZMNmZqSkdwN1ZOWHVUaXVvTDFtVjh5V1BYQ2dxVm1lcklnUWxVeG1PTXhtcU5OWnFaTHFtMVFzbGwyeWNOWlk3RE9wZFNKV1k2RXJWbllzSjVLYTNWaHJuV1ZQcjJNbDhhbUd2RlR6T0QvbkhDM2xReEtZZFcxaWZOc0Y2czg1RWdkNFNFK0dhRU9MU1RYdmVCVFE0c3RDWitwQ25hKzBGT2lIVE9zL0d3NlllN2RWSzdLc1Q5WTR6aGNHL0JyMVRZV1BONzJWRVpUY3JRakcya2h3dE8rZnlLanl1TnByTEQ5bXhSOGN0QnpWOFBwL3hRSlk0cXFNYzFNWGxjc08xaTRyangvTzJrNWQrV2tSY2J4OHZObXlBbnBNeGx5N3JubGVYWnZPS252WW9maTU2L1RCVy9MRXFlN3MrWTFoVlZkYk1ETTNlTkNVaUp5bXB5WmJHVStITG95allNbkZTVWhhVzI1cU5yazhRYlNpa01VQmxEcml3RkpTR2FNV3MzUEo5VldWTFoyOG1JN1pwSExLcUNuL2FtN00raExnMEtoUXVnR0ZwZ2g1UUlRWTZSUW53clFrbzBQckhxQXdmWjAxdE5TbGNOY3VJUTVLeDcyTGh3UGo5QkNIRy9XR3Q1dEwrSHJnTDd5VklZVGM3UXVFaGhGSDFJYnpvaUN2RUJ1Mm56MDlJd0tRelA1aVcvSGt6NGwwZFRua3cwRThQNW1waWhKWGttWk1XSjEvekhPdkovUGwreUhCZHpiL3B3NVR2aTg5THd3NkxpWDQ5bS9GUVUvRHczL05QVFIrenZMVDQ1Mk8xNkgvdXU5TXBRRmdXTDJmU0RmK2Q3V1cvek5TNCtUOFlZcXJJZzM0UG4weGpEL216R1lqcUUzZFpvK3BCWmR3a2ZoeGxSR3hjQldXd3N4TGZpdkZ5dEM2eVRveXMwTVY2MVhDMEV1dDZ4N1JXTlM3aVFpYkpHVDRoN1I2bmhUdk04SlhTSS9HQjdvdDFpN0lwdDhuZ2lEaWszRlo5V1cwdHRMSlV4L0dnenowekJucW1aV0VOcGhqdnd1OEhRclUrc1BTeTd5TEtQckZ5azhlbk56YkNQdk5XTVVzektJWmlhRnBwZko0bWZiY2VQMXZCMFlqbVkxdFJWK2NFV29MZEJncG5yZForZVQ2MDFtaUVUT2RYd3cwVGpIMWRNUzhXc0JLTVN4OXZocGxBZmg5Ylg0Z3ZrZHpZaGJraU1tZDRuR2hkcGM4QlZtbmpWVEU1TWlkNEZHcWRvWEpaTWpoRDNsRktLcWhnK3dsWUg0cXlnVGhWSFprTHZMU0ZHWWt4U3JpWSt5VnBEWVMyRk1ld3ZTaDdOQy9ZcVRXVU54WmpwQ0NIUWREMnJQbkxxTldlZFo5MTdHaGZwd3pqODhSTnZNNjFocjdZOG5WYzhtNWY4WEhUOFphNzVaVzQ1bkU5WVRDZFlhNisrMDBKOEpxVVVzOEx5YkZZeHFRcW1kVUZoRkRHQndySHNBcmtQK0kvY0VSYWZJS2NZY1l0aXpMaVEyUGFSSm5sY01GY3ZWMHN4MG5uUHR0YzBIbHlVY2hjaDdpT2xGR1U1RE05TEtUR3JTMzU0dEk4UC9ueFE0MjRUNGtOMmQ5eDNteldXb3JBVVJUR3VTeGxLeDNhWm5HWGpPZllGWjJPNzVXSHRWK1lUU1J4Z3lPVHMxWmFmOW1yKzVXakNqMXJ6ODZMZ241NGRNWjNVV0d2dkxJc2p2aC96dXFZcVN4N256S1JxaDJHMkx0TUhSYzVEYStrdEV1UUljWi9Gbk9uQ1VDYmRaSS96NlRQSzFXS2tkME9RMHpxRGk4TnNuUHVSZUJiaTIvQnVLODJiK3Z6czJyQWFZNzVvVXJnUVYvRmVHMm5HQ2RUeFRTZTFUNzNIRlZBWnpidzBQSm9VN0p2STNyUmlQcHRTbGpmYlpFQ0lIV3N0bHFGMGJXWTZwaW96TlRBdERhWFZHQzE5OUs2RFBJZmlKc1UwWkhJYUYyaGpvUGNmSHpyOWZybGFURGdmYU55UXlmRlNyaWFFRU44MXBSVFdHdW9DcG1wWXEyUDBPQ2owQ3FlSFhidm1ZVjZLeGhxRE1iZlRZRUNJZHltbHlENlFuVVBuUktFVlZnSWNJYjRKdXlCbjZ5S045amlYUG1OT1RnajAzdFAwaHRhcm9WeE5ZaHdoaFBodWFhMHByS1V1RlZNMXRKc3VQck90c2xIRFFNamhldzFHUzNtYXVEczVCckozbUp3cGpCbGFoMHZRTGNTOUY5TXdKd2NGamZiMFBwTS9wL0ZBNXdKYmw5bDZUU2RyY29RUTRydW0xSkNCcVcxbW1qSlRGWmpveEt3dzlHbVlqUk5USnVVUFh5Um13S2RNNnhPckxqQ3hnYzRQQTl5c3plZi9oaEEzS2FWMHZuVzlvK2tjYlE5ZEFKOFNVYXBXaExqM1lzNWpGOFJJWDBCQUUvTHcrWDYzcytPSE16bk8wN2hFNHcwdXlBZGZDQ0crWjFwcnlzS1NnUmdkZS9RY1djOVBleVVybDlpNFlVN094KzZIcFp4WmRwN2ZseTJLVEpnbEpvWGlxZmNZTXd6YmxNWUQ0cWJ0cm05Nkh6aHRITWRkNG85TjVFV2JPR3VIdVlCQ2lQc3RKUWpqeU9sUWw4UnlRc0RnZk1DTTU1TGRldVVQTng3d25rMmZhV0xFeFlRa2NvUVE0dnMxekdRcWhoS3puRGtvNFhFRlA4NHJiQmRKMmRINlNQakl5U0ttekxJTFFNZldSMHBLSHU4cFhJSXFKUXpxMW9hQWl1K1hENEhXZWJZdXNneUcxOTd3Zk90NXZ2VjA0N3duSWNUOWxuS0dOSHdOdGlKVmM0SXBDU21UeWVjQkRueW9oZlRZUnJGeGNleGFFSWYrMDVMTkVlTExaSm1PSnI1dFNpbUtvcUFvd0JqTndiVGs2ZHl6TFd2eTJ0R0Z5TElGbC9NSDMra3BROU1IZkVnc3U4Q3plY2xwMEd3Q0ZENVNhREJhU3paSDNLamVCemE5WitrMXg3SGdKQmE4N2xxT04vMmxiZEFmdkhjSGVYN09rNUVaem5NWE55RnVTR1lvV1NORDBoTmlNU1dZRXBjeVpZYWswL201NUR6SXlUa1B0YXFtSkJWVFBFUHFkbGRyTFlRUVFtaXQyWnZQK0NFWlZDeEpSdFA0eU9uV0VkS1F0WW5wL1dBbjVveEtpUnpnclBVOFgvZjg3NU9HSjJYaVVXVXcrM01tazhsZFB6enhBTzFtaGEzYm5oZG5EYjgxbWY5Y2VvNjNuaTVFdVNZWDRoc1ZNMk03NmNTMjl5UURSbk0rVXNQQ2hRQW5ReTVxVWpuRHNhSDNRNUR6ZmQvZUVFSUlzYU8xWm44eGg2SmluZ3hkeXB3Mmp1ZExReGN5bmtUT3ZMV1dNelBVVWZ1Y1NUbXhiRDB2VnoyellrdGZPUExjc2pldEpNZ1IxKzdOVUdUWStzenpqZVBmVGh5L3J3T3Z0ejE5U0hLSkE2ZzhidkJGMTN3M1BSTk9pQTlKT2VOaUhnYUR1b0EybWRxK3FRaDRrOGtCTWdyS0dibnE4SFQwb1NPVDVTNkhFRUlJWUNoZDI1L1BtRTR6VDRGbEgvaGoyVEV0REJzVFNWbDk4T2JZcnJ4Z3R6N24rYW9mL3J4b21LYVNuNDhPN3ZxaGlRY3NBMDNTdk9yZzMwNWFYcXc5alkreURrZUliMWhNR1JjVHJZODBmYUFzTWpHK21abGpZVmlNNTBMQ1owWHJJMzJNNDJ5Y055Y3FpYzZGdURyMXppYkVRNksxeHVRSUdlWUVuaGFKZnptc3FLM2xlT3M0YnR4SGg3UEJzTzV6MlhxMFVrekt3RkdwZUwzYVlJdUNxaWdveXdKcjdXZnMwY09SVWlMR1NNcVpHSWNoZHpHbWNhSjNQaSs5QW1CczFLRFZtOFlOdzlvbWpWYjZmT0RxeFlXNDM1T2NNK3R0dzlZRjJxaDR2dW80Ymp5YlB0S0ZoSS9EcEhRNVJyK2RpZm1jODVaNjU5ZHl6aE8zS1NYb1E2WnhrYVpYVEhJaXhQTDh2MXVBRUNLOUh3NEM3WGhuSStZa0MvR0VFRUs4WjNjeHJYSm1ZZUdIaWFFL25HQk5KT2ZNcGc4MC91TkJUdWNUU3hWd01UT2JaWjQ2eFVrYm1Xdzc1blZFYS9WZEJ6aytSa0xNK0JCeEllSkRKS1poN1VnYXk2L2VtZ1ZoTk5ib1lXaXJNUlRXVUpqaC9HMjBlbTkyeFBjaTU4eG0yL0I2MjNNU0xNOVhQYThiejdvUDU5MEFwVkpGaUc5WHloa2YwMWl1bHBtcEQyUnlRb3pEQU5DbzJQcEFQdzRBbGMrK0VFS0lkeWsxekNJd3dQNms1SWU5R2xOcHNKNjFDN3hZOTUvOC9qNGtYQndHZ3k2S2lwTmNzOHdsQzUvUk9sQlg4V283OGdERmxBZ3gweWR3U2RPbFRCOHpQZzVkNnVLRmJvMktzZk1kQ3BzMWhkR1VTcEdUQnEzWXpYL1FPbiszUWM2MmJmbnpyT0YzWC9GODR6aHVBcXMrMHZvb04zS0YrTWJGbk04N1FtLzd4SjVLSHk1WDY1eG5Heldkai9pWXlGS21Lb1FRNGhKVlViQlhGNkFTeTNYUG9lNDVMREp0WmZCeHVNc1dQckkrQnpJYm4zbmRKdjYrOHVRWWlETk5YVmltazhtRHlVRGtuQWtoNEx3Zk51ZngvczN2dmZlRUdBaytFSFNCTXhXeG1PS1RwbzhKSHhJaEpSSmpKbWY4dVVPUUEwWXByRkZZclNuTkdPd1lnNDA5Tm5hWTJHTTFGTlpTV0l1MWhxb3NLY3VTcWl5eHhtQ3RPZTlJOUsyTE1aNFAvanpkZEx4YzkveWp5N3hjTzlaOUlLUXM4LytFZUFCU1lseVRrMmhjeHBsRWpHOENHQXNRUTZSem5pWVlPaDhKTVNIOVJvUVFRbHltS2dzV2t3cXJQWStLeUdQcmVWS0RVeVdiUHJEdUlYeGljWGZySTY4Mmp0STB4RjVUNUpMRCtiQW1SZVg4VFE4SnZkalpxL09SVGVQWXRCMmJwbVhkZG15YVlXdjZucVp6TkYxUEttZUVZa2FxRjBUMCtSaUg4N2tRUUI3YUJKMmZwWTFTYUswd0d1eHVYWTdTMk5oUitBMUZhS2wwWmxLVlRPdUtXVjJ4bUUzWW4wM1ltMDJabElaSlZiNDFLZnhibFZJYWc4ZkF0dmVjOW9tWFRlRHZ5OEJKRjgrREhDSEV0Kys4WE0wRkdwdm9iWHByUGVoNXVWcnZBMXVYYWYyNEdFK09BVUlJSVM1UmxzUEY4YlFPTEZjcmppckZrNm1oczhQaXp6NGsydkR4NzI5YzVOV21wdytSR0NzT1p5Vy9KRTFNR2ExQTVXKzcxR3EzanNZbDJBUTRjWXJUWG5QY0tJNDNpcE9OWnRVYVZxMW0yUnFpamdUZEVuUWtaM1hlNFhRM2IvSE5xdTRMdFZacXlPZ29wZENBUW9HQ1NpVXFBcldDV2FIWm4yajJ2R1kvYWg1cmhiTUtWVUhLQWEwMWRmWHRuL2h6SHRZeWRTSFJSTVV5bDd6cVcvNSsxckQxUTVta3pQNFQ0bUdJWXd2cDFpZWFQdEFYSDhqa2hCanBuYWYxbkE4QUpXZVVIQWVFK0NMdmRabVJ6NUo0b0l3eEdHTW95NUtEeFl5bit5MGJsY2w5QVFrNmw5ajI2YTJMOVl0OHpHejZpSStaV1drNTdqS25mV0xaT2tvTmRXR29xK3F1SCthVjVKeHh6bzBsYUlFK1JGelc5Tm13ZG9tVHhuUGFCazZiek1sV2M5b1ZuTHJNS21qVzBiSktGU0ZrUWtxRTJILzFZYU95aXRwcTZxSmlwZ3hyVjdDbkM1YkswQnBGUTJLYlBiUFlzckNSdmNwU1YwTUpXMVdWRkxiQVdvTzE5cHZKOE1RWTJiWWRaMTNreEJ0ZWQzRFN3N0lMdUpESHhnM1NBZXc2S2Q2ZXN5UFhqdUsyNURSVUN2USswcG1BOHg5WWt4UGowTDJsOVhvTWNwSjBIQkZDQ1BGWjZycm02ZUVlcVFhN0hRS1laZWM1YlJVeEQvWFQ4WjJUUzg3Z3h6dHY2ejV3M0hpZUx6dHFuZG0zaVVleitwc0ljbEpLeEpSWXR6M0x6WmJsZXN1eWl5eTlZcFVLTmtHeDdqd2JGOWoyZ1kyTHcySlpOM1Q2Nm56Q3gzRW85eldkZjRjWkVwbk0wUFV1cEV6ckk4dk9zT3c4TDhxZVJXV1loQzJ6MURMVGdZUDVoRWQ3Y3g3dEw5aWZUWmhVSmJOSlRmVU52QVlBM250T1YydCtXemxlaElybjY0NVZINFptU3RmNDNBb2g3dDZ1WEswTGlkWkZ2SS9FOU82YW5KUndJZEI1UlIrRzFwVnlIQkJDQ1BFNXBwT2FKNGVLZXBZcHFqZ08vZXl3dWtkbDhCOUk1ZXhLaDJJZUx2aVB0NDdmbHoxRkRzUXFNVEVBKzNmOTBENXB0KzRtSk5qNHhPc3U4WEtUZUxuMnZHd2lMNXVHVGNqamlJWmhUSU9QWThZbTVUZnJic1lMOFl2TkJiN0c3Z0lnSmpYV3JVZXNNV2l0S05hSzBpZ0tvNW5pbU9DWjZjUVBmZUJYRXFITUpCMUlLVk1XOWhzS2NnSW55elgvZU4zeEgySEdpMVhQcWh1Q25DVGQxSVI0VUhJR240WU9hNzBhWm42K2w4bEpNZUZEcFBkbStBdnBuWUZqUWdnaHhDV3FzbVJmRzJZeGsrajRiV0xZcnpUenl0TDdCRG0rdCtnN3cvbWZOUzV4MWdaZWJSeDFobm9TZURTOW4vTnlVa3JrUE14azZFUEVwMHliRkg5MmllZWQ0by9lOHJ5Ti9MYnkvTDVzYWR6UXVkVEgvRjQyNjhiMk1hdHhmVzJHdUh1MjMyOENNUzBOMDZKaVZobzZYNU5kaGVvMGtVRFhkY1FZaUNHZWQyQ3oxdDdiem5jaFJkWk54OHRsd3orYzRhejFOQzVLZ0NQRUE1UnlKc1JNRnlJZFExVmF1bkNPZWF2eFFPYzFMbWE4bEtzSklZVDRURW9OYll4empsUXFzS2Nkenlhd09aaHcybmhPR2tmN2lVNXJNV2U2a0ZqM2daWEpiSlhEZTMvWEQrdjkvWXdSNXp3dUJKck9jYnp0T080VEowSHhldU9HYmUwNGFRS25qYVB6UXhsNHpKbjdXQ2NSeHp1aEFNZU5RNnRoTVBpZk5ySkh5Nk15ODJoV2NyUy96Nk9EUFI3dEw5QktZWXpHR0hQWHUvODJwWW0yb0ZPYVplZlp1b2dMTWhORGlJY29aUWdwNFVLaXkwT1FrL083NVdyam1wd3VKTW5rQ0NHRStDSnF2UEJWQ21xck9DamhoNW1sMThPZC85WkhhRDhldE9TVTZVTmswd2VXeENISUNlRXo5dUIyeEJqcHZhZjFrZE11OFBlem52OWM5dnpXUkZadFlOVUdscTJuOVluT0Q0dGlRNzYvYTBKQ3pPU2N4dmt4ZWVoNHQrMVptTVNCOFJ3V21TZXp5RDlSUStXWnp4TldxMkZHenowS2NuTE9aR05JWllWVExXZXRIMlkxaldXQTR1UGVhcFFqeERkaUtNa2R5OVhTRU11OFB5Y243Y3JWSWo1Q2pKQ0hKcFJDaUMrZytFQ0hOU0VldUYwSms5YWF1akRzMTVZbmMvQmxTZXNqSjF2M3ljOUR5dUIzMDZ2eHROYmhmYnp5djMvVGRqZi9mQWkwTHJEeGNPb052emVLLzNYaStiZlhXeG9YYWZ6UVZPQ2p6OU5WbnN2aFh4eWYxM2YyNDYyZjhPYnEvV0xYc0h6bGYybTRVRWd4NCtNd3orZVVJUkNkRklaSDA0SkgwNUpWV1ZHRW1rV3dQSTFRcGdnNTM3dlpPc29ZcUd1Y0tkajJUcnFwWGRGMW5xL2t1UmEzSlkwTlZmcVE2SFVreEVoNlA1T1RjRDdRZVVzZjFKQlNsN3NlUWdnaHZsQktpYlozYk5yQXl1dnpOU21mWWhSVTFqQ3ZESXNLcG5XbUtPNUhwcUR2ZTdyZTBmV08wMDNEbit1ZVk2ZDUyV24rY2Ryd2V1Tm8zTkJVNEV2bXNPd3VESzBaU3Y2c1ZsZ05SaXVzSG9aOUtrQVBBM0hHZHR4dmhvM0dQR1JoWXJxNERYKytXM1QvdWVKNU56YVBWbERiWVg3UnV2TWNtTUNqaWVGb01hRXVTOHJDVWhURm5RYzhPUVJvVzhyZ1dOUVdGNGF1ZFgyUWl4b2hIcHFoNFV0R3hZVFhobGlVWkZ1UnhnNXJZNUFUY09mbGFtcnNyaVlIQkNHRUVGOG14a1R2SEp2T3MzS0d6c2RMSjgxcnJhaXNabFphRmhQRHRJTEMzby9HQTg1N1Z0dVdkZWQ1c2VyNSsxbkgzOWVKbDIzbXJQR2NOa1A1MnE1VDJ1ZllCVGhhRGQzT0txdXA3ZkIxdDFtdE1WcGhGQ2lsaCt3THdOaEJMYVJoUGEwUENSZUhzajhYeGhiU09aRys0TTVsR3RkSTVSd0k0eEROZFI5NHVlcjRkYWI0ZGIvRTJJSkZHZ0l1ZThldmxWSUtVa1M1ampKRjlxcVNyUnJhWi9kM3VtZENpSnVReHpVNW9BaWxKWmMxMlZibmlacDNNamtCRjgwNERQU3VkMTBJSWNTM0txVkU3enlienJGeUpZMkxoRXN6T1dPUVV4bjJhc1cwVmhSRmNkY1BCWURlZWJhOTU4d3JYcmlDdjIxNi91ZnJqdWZMSHAvZUJCcndaYWZQTVVGRG9SVVRhNWlXUTBaclVneS9yc2RBcHpCRFNXRGFaVzlTcG85RGNOUEhSRGVXeWhtdFVFUXlpUzlkZHg5U0pycElweUxySGxaZDRPVzZaMW9hdW1kemluckNZVFJvbjdBbU1xblMzYS9SaVFubFBCV1JSVzFKWkh6VWpPM2xoQkFQU01xWm5NWlcwc3FTeXhrVTlYa1B5YmZYNUxnNGxLdWxOTFJnazVvMUliNmFWeVZMci9qdHoxUGlOOUxrWjdldVFtdUZOWWFxcXM0bm9lL1dYZHpIOXJIaWJ1V2NoNkdZTWRMNVljM0tXWmM1NlhvMkx1QmkrdUI1WmZkT0tveGlyN0k4blZYOHNHYzVyTU9kRGdMdHVvNjI2K242bmhjbks1NnZIUytkNVk4bTgyTGpXTGJESU04MGxvcDk2cFNwMVZCNlpyU2kwSnE2MEZUV0RKa2FveWpOa0wwcFkwZEZUMFdndG9hNnNFeUtnc0pvN0xnTlFjNFE0S1NjOFNyaVZjS3BpTXVCTGdlNkZPZ3FoWnRXOUxyQ1ljZk16dGlKYUp6WDA0ZjB5ZGs4bWZFbFU3dWhyVU1MN0pjYngvUzBSV25Oa3lMd2JHcUlNVEtmMWxoajdxeDB6UnJEWWxMemVBRXJYNk1WT0o5UUlBMlZQaVZuNEF0dWNPKytiN2ZkMSs0YTR1SEtrRlVtbzRoSzR4SzRNTnpVT00va2hCanBRc1FGVFloSnl0V0UrRXA1K09UUjZZclRaUG5Ic21NVHp1NTZ0NjdFYUlVZDI4Tk9xb0tEZWVJQWpUWjJ2RkRURXVTSTkrU2M4V0VvYldxam9xRmdGUnduWXltWCswQ1VyeGd5R0ZvcEtxM1pxd3FlelN0K1BLZzRMQktUK3U2Q25HM1RjcmJaY3RZNC9uSFM4UGVWNTdkVzhhcUYwOWF4ZGVGS0FRNE1qNjgwbXRKcTVxVmxmMUp3T0MzWXF5eDdsV1ZSRFkwYXROdGlRa3VSSElWUkZOWlNGSFlZNHFrVVNpdTAwcVNjeHV2SllWWlBUSW1ZRWlGRW5QZUVFT21TeHBrS1Y4eG9LVm4zZ1UwWFdIZVIwOVp4MW5waTlFU1ZVVmtOblZVLyt0cStHZHlhY3VUMTFnR3c3aU8vVGpOdXY2QXNDa0JSVjhWNGsrUU9naHhyMlZ2TWVCb3QzazhJS2JIdXd0QzhRUzVyUHU0OE9ObHRuL085ZDczejRudDJQZ29zUTBnS2w0WXlXOWdOQTgwSk4zWlg2Nk1tU0x0RklhNUZKdVBNaEtXdStNUFhyTnY3c1lqNk1uYWNoRjRZd3p4cnFEVmxnam9ES2FOSWQ3N0FXTncvS1NWQ0hOYUJPRlhTcUpwbDdEaHAydlBGOEIraTFkQ091TFNhdmRyeWRGSHgwOEdVaWNsTXlydGI1OUYwUFNkYng1OGQvTlpiL3JaeC9QdEp4MmtYaDliRWNhaDZ1TXJwMG1oRmFUWFR3ckEvc2Z5d1YvSGpYczJ6UmNYamFjbmpXY25qZVltT2UrZ2NzVHFQejh1UVZiMllQVldvdDI1RURzMEg4bmttYmZmcnprY2FuM0dxWUIwMXJ6YzlyN2ZESEo5aU5RUTEyejVDdnJ4WlFvYXhnVUVtSk1YcmJjKzZEenhmZFhTUGFzcXk1RkhRVkNHamRLQWFHeEhjTm1zTmUvTXBQNmdDN1V2V3ZlZlB0YXpJRWVJaDIyV2NZd1lmT1ovN1pYUE9aR1dKeWc2RFFHTWU1K1RjOVM0TDhlM0s1LzhIZmRhY0JjUHpWbk4yLzBaK2ZKRFJVSmhNWVJJemwraDFvTXVPMWllbU9yS29DZzcyRm5lOW0rS2U4VDdRZEQyYkFLZDlZaE0wYllEZXA3RVQyUHZmWTQyaXRtWUljQXJZTTRHRlNTd3FRNkdoc0xkM1l5RG5UQWlCRUFJK1JJNVhXMTRzTzM3ckMzN2ZadjVzTXlmdE1NZm5VM2JacWRKb3FyR1J3R0ppT1poYTlpZUd3OHB3Vkd1ZVRCTlBKcGxITThYUnd2Sm9VYUdwaGt6cU5TemlkODdSOW80dUpCWjlwRXFLT2lVbUlWQ0dSSTFsWGhvYUgybkh0VHo5MkkzTXgvemVLcGJ6MHJXYzZYM0NoMHlqNFdWZGNMaU9MTTQ4M25tT2FvWEsrVHliWTR5NXRjeXZNWWJaZE1LQkxVbTVZSzhQVERlT3V0amlRaUtOSGVlRUVBL0xydE9haXhjeU9URWxzcDFBTWNObmo3L0hVNW1GK0pic1BrR2RUNXcybnBReWhmMDJzaCthTitzSHBvWGh0UFc4MnZROHJqWFBDczh2aDFNSmNzUjdldWRZYmhxTys4eWZtOFN5Yy9UaFRXZXZENTFWS3F0WlZKYTlpZVh4SkROWGpscDVpckdWOG0xbURGTktkSDFQMHptYTN2TmkzZlAzWmMvZnRwNVhUZVNzOFdNbm40L1RZK2tkd0Y1bE9aeVdQSnFXUE5telBGMVlqdVlGZTRWaVNtSnFGSXRLTWE4VUU2c3dTZzNmZjAyUDJSanpKa2hNaVZ3cnlxU1lvemtvUzM3YTA2eHl4VW5qT040NlhtOGRxeTZ3Nmp6clBoRGp4NjhEemwvVEJPdk84L3V5SlpGWlR4Vi8yYmVVaGFFc1N3cHJLT0hXT3E4Wlk1alVGYWtDbEdHdkM4elhQZk1YQlEwQkh4TTVmbGxMYmZGeE1oZE8zTFdoZERjUDNhTEgrV28yWjFEbGpGeTIrTHdhMXVQSXVqRWhyazNySXpGbk5uMUFmeU5uQUtYZTNJMnVyZUhWMW5Hd0tuaFNRVC9wbU9zSXY5ejFYb3I3eG5uUGNyUGx6d2IrYkJUTE5nd0wyei94UFlYUkxHckxrM25Ga3pxd1YyUW1ObE5hYzE2bWRWdHl6dlRPcys0OEs1OTUxV3QrMjJiKy9YWER5ZzJkeTBMODlNbFJvYzdYR0MzcWdoLzJhbjQ5blBEelFjRlBCeFhQOWlybTFtQlN4Q3F3MmxBVWxzTGE4NllDMS9XWXRkWlVaWWsxa2RKYUpxWGhjRmJqUTZCeEVaYzFIU1YvTEZ0K1ArdVluclc4V0hla1BNekg2VDhaNUF6UGwxS3dhZ01wZFp5MW5tYS9vTEF6anZaaFB3d1pQS00xdDlWZFdtdk50Q29wQUtzMCsvczE4NzJLZVczSlk0QWF4ckk3SWNURGtSa3pPU0c5Q1hKQ2dteEtzcW1JV2IxMTUrWWJ1UjRUNGw2TE1kUEdTUHVOdGpBdFRhVHBJK3Myc0MwVGU0dWVYdzhtcEhUMWRUa3hSa0lJNDlkSWlFTkowRzdoTkVqbm84OXg4U0xZR0gxZUZsVFlncUt3bEdNWHZLLzE3bHFQdDdkTVRQR3RQM3Z4K3BUbnAxdWV0NGFYdldYVmVWeElxRSs4dEtYV1EwZTFlY1dUMnJBL2dib3NiblhteXU3eDljNnhhanBlYnozSHZ1QmxyM25Wd1o4YlIrZkhHNEM4ZjI3Y0RlbFVockVqbXFhMmhoOW1ocDluaWwvbmlsLzNob0RuNldMS3JMcWUxK2N5U2ltTU1lZHRuU2ZVNS8vTk9VL01tWkNnVkFtVEhQaU04Z2s4eEdBd1dnK3RzV1ArNkl5am5LSHp3NkRYZGFld1JuRzBnS2N0ekJyUG9oaWJTbFRscmJ5V1NvM05HZ0NkRW5zNmMxQW9EdXNDUWlLblFPL2pKOStUNHZNb1FPVzNOeUZ1WFlaMEh1U001V3Fkai9RcDRiTVVxQWtoM3BmeVVPUGF1RUFCOUtvaW1vbzQzaFc5N001empKR21iZG0ySFUzdldXOWIxcHN0cTIxRGlIRm9YNXVrbytOVnFRdVgyRnByNnJJNGIrOTl1RGZuWUcvQjRkNVFwdlExRjlLN3JsMWg3TDdwZktCM2p0NzU4ZGQrK1AzNDU4NTVYbThkTDV2RXExQnpIQ3huamFjUG53N3VoM0sxZ3FmemlxZlRncjJKb2lwdjU0SVl4bVlKNHhxY1RkdnpZdG55bjJjOXY3V0czODlhemhyL3lYV3FpbUZkMGE2eHdKTkZ4Wk41TlFSdGhlZlpCSDZvRTRkRlpxckIzSk83aDhab1NFTkw3MFdSZVZvbDFDUlMrY2hNd2FLdU9YR2EwOFp6MmppMmZUeGZWL1h1VTVGeVpqZVlZdHNIWHE0Ny92MjFJZmlTSCtjR294V0wyWFI0dm00eE02ZHpadG8ySFBxT0h4Y2xLZy9CMnFZUGVEbmVDUEdnNUp3SktlSGloVXhPRnhJdVpjSnVlcklRUWx5UThuQm5KT1dNem9yZXpJaDJRc29NaTR2NTlJVkxTb20yNjFsdWU1WXU4MnJsZVhubWVMWHNjV0hJQkF5dGErV2k0eXAyUVk1aVdEYzFuMFFXazh5OGh0NEVkSjFZcER6VUl2UGxGNVU1WjBJY0ZxRzdrTm02U05NbnRtMWsyM3VhM3JQdGhtR2Z3NjhkWjEza3hDbE9nMk1WL1BsQzlrOHA5TkJSYlFnTUZQc1ZZeXZpMnpHMHZSNzJjK3N6cjd2TWZ5NGQvL1BFczJvRHk4NS9zcld5VW1DMXBqU0thV241WVZIekw0OW4vTXZSbEFQdE9DamhZRm95bjlUVWRVVnhpNHZ3UDJXWGhkVXFzeit0S05TYy9YcFlHN1czOFJ6NmdoZWQ1cmZURmhjU2pZdVFGYWozQTc0aHhzbmtDSnMrOG5Mc1p1WjlRT3NwaDR0ZENYeSsxY2V1Y21ibVBVY2t0dk1LRnpLYkxweXZtUkxYNUoxUk9VTGNoUXhEZDgrUTNqUWU2RUtrajJsWVRDa3I4WVFRNzBpWllZQmdCSzBzVHRla1lrSkNEYVVKbDV6VllveHNPOGRwRjNrZFNwNjdpdDlkNGcrbmNlT3hKMldrUnY2S1ZCNnpaNERXc0crS2NiUFlVREpQaHNjSmJNcG9sYkh2VEtEL1VLdmhEMjArUkh6SytLenBrMmJ0Rk90ZXMzS0dqU3VIM3p2TjJsdldMckQyRlN2dldYVkRZTkQ1ZEQ1RDVvT1BneUZBcUF6TVM4WFIxUEI0VVRJdDFLMEdPVEZHWElpMFByR09odGZlOFB1NERtY28wMHA4TEU1VERKbVp5aWdtcFdGL1V2RGpvdVJmRG12K1h6OHNtSnZFdERUTXA1UHprckg3WWxmS0JyQzNtTE8zbUFPd3YzZkc0bVRGUVp1cE53bm5QTXRHcys3TjhGekU5eityNTEzWEdOYnlIRytIaGhNeHc4SGVqSitUd2FVME5EVEo4ZGFlQzYwVUV3V0hwY0V0U3RZdThucGp2cG0xa1VLSXEwc1pRb0krNWplWm5ENGtRaHphS2dvaHhHVXlRd3ZXb1d3bEQxZXFIN0M3aU81OTRIalQ4ZmZqanIrMy9Ya25wNVBHalRPNTh2blBFNWRUNTE4VldtVkNIQzRzVjUyaEtBeDFZYWl0NXJCVVRBek1KeFZGVVp5dm13a3gwYlRkc0hVZHpubDY3L0UrNFB5YlgvdXNTY1dFVU16d3BxTHprZFpGR2gvcGZLSWRmOStOQWNMdTk2MlA1d3U3UDliRXhtcUZIYnYzMWJsbjRyZE04NVNKcmFpc0dVcXBib2x6bnBQbGlsZHQ0a1duK1hQVnMrN0NPQVBudy91LzY2QTJkQi9VUEYzVS9MQ29lTFpYOHV0Yzg2Ukt6SFNrc2w5Zk5uamJTbXRaVEVwU2R2amUwVTRDSEJiTTY1TFRkaWhkTzIzOFI3OC9wV0ZHaFZLUlplZDV2ZWw0c2FyWUt6VlRGWmxYbHIzNTdGWWVpMUtLdWlyWm4wR3FDbDQxbmtscHNIcTRTU0NISENFZWtEeGNtNFNZM3N6SmNXSHNoeTl0bzRVUVZ6RGNuUjh6QXVyREY0SG5DOVV6OUNGejJtWCtzWFQ4OTVPV3hnMmRuYll1anNGTmxpcUh6NUV2QkRwcUNIQ1duYVl3aXJJd1RNWXRWb21EU2xOWmc3VjJDSEJTcGcrSlZSYzQzVHBPMXgzYnJtZmJ1Zk8yeWR0dW1LM1NaMDIwSGNFNnZDNEphVGhYaEhFSVprZ1h2bzVEUUgxTVEvWW5wamRCemdjZWd0R0t3bXBxcTVuUVUrZVdtVW5NcW9MQzJsdk5ldlRPY2J4Yzg5c3E4cnNyK1hNekJEa2hYZ2prMzZIVkVLUlpvNWxYbGgvM0t2NzE4WXgvZmpUaFVabDRQQ3VZVlpheXNOaDdVcDUyVlZWVnNwZW1GTWFnU2VRVXFXdkZvalA4NDdRbHhNVFpHT1I4NkxXTjQzc3M1Y3l5MFJ4dmV2NDRhNWxvT0xJZU5hOVl6S2EzMW5oaE9xa0p5bUNqNFdEdG1CVERHaUUxUmpseTNCbDhPKzlRSVQ1c043RFl4L3dteURuUDVNaHRWQ0hFRmJ4VmV2MmhWbE1YL2w3S0dZOWhHU3kvYnhMLy9jVjZYQnc0M3VsSExqSStXMzc3TnhlZi9yb3dUQXZOckRDb09tQ21odjFweFlTYWxNY1RRTlpza3VVa2xMejBrWlhUTEoxbDJSZXMrekMwVCs0Q2pZLzBJZE9GelZ2bFdoOHFWZnJncm4yQzBZcks2Q0VnVTU2Wk1zenJnc1V0M2VHL3lIbkg2V3JEYjhlZS8zUlRYcTA3MXIzL2FEZXhpNCtoTklwNVpmbGhyK2EvUHAzei8veGhRYTBUazlJd24wNXYvYkZjaDdJc0tjdVMvYjNNZkRhaEtsY2M5Sm45VmhGVDVyUnhuL3orbURNeFpQb0FSbmxlclhzV2xhVWlrY3FlcWI2OXNwRWhrMU9oYmNFMEtRNG1IZE55REhKUWNtTlhpQWNrNXp3R09SY3lPVDRPaTM1VHltL2RJUlRpTnUzcTg3VlNsSGE0Y0ZoVWxrbHh2K3JZSDVJTU5DNnc2U09OQzRRMFhBUi9hcEgxN2pMMlRhQXpCaXI1N1FYRlF5Wm4rRmxwTEVjTEdXSk81NW1mM2I4aHg1elBwRDc2RzJKNmsybnhJUkdUSXVkTTIzYThYbTQ0N1JLbndmQnEwM084NlhtOWNXejd3SGFjZGo5TXZjODBJZE5IOEFsaXZ2cUUrS3UrbGhPck9ad1dQSnFWUExHZXhieW11TVdXMFRGR3ZQZjRFRmx1Tzg3YXlFa2JPVzRkNno3aVF2N2tZNm10NFdoVzhuaFc4dVBDOE9Na2MyQWpVd3VsTVJUbTloN0xUZG0xWXA3VkpURTcrcjduaWUzNFlaSm9IazFwZkR6UHluNHNIdlFwcys0Q2Y2NTdDaExsTEhBMHEvQStZTWN5dnB2TzZCaXRzSGxJMjlTcFpaWTdEaXRGU2dWOUdFb3ZnOXprZld1WTUxVmZrWGYvdmd3RUZYY3BqeTJrZCtkQUFCdGkvbVI3VENGdWcxTER5Y2dveGF3MC9MQlg4K05lemVQNTdiV1MvZDZrREgrdU8xNnVldjdjUU9lSDFvdjVNeTVxUCtWOGdYdUd5Tmg5YVZ5aklYZFFiOGJ1dFFzcGoyc3RoeUNuNnp0ZXZEN2hQNWFCRjZFZTExVTR6cHBoam8wYlp3djRPTHdIZHJOUllyNlpvWWwxWVRpY2x2eTRWL09rU0N5bUpjVXROaHNJSWREMW50WUhsbjFtR1MwbnZlZTRjYlF1NHVLSHN3MjdpN2RKb1htNnFQanJveW0vN2hsK21zSmhyYW1zeGhwOXEydUticEsxbHRta1FpdEZpb0hUR2paelE3SWxyemVPMTF2T0cweDhTRXlaZFI4dzY1NGNBL3ZHc28xcXVBQlJZTFMrOGRKRXJmVXdNMGRsYWdJTDdUbWFHQ0tLVlRjTUR3eEJqa2RDZk90MjFTTmhMRm1EaTVrY2lYTEVIVklNQVk0MWlsbHArV0ZSOGQrZXp2bjFjSExYdS9aZ3hRei8rN1VGRkZzWHlUa00zVWxVdkpZYXN0MEJKekp1WXlwWjNKeE1Ick01aVpoMm1SeG91eUhJK1YrdlBIL3pNOVpkWU5WNTFsMDhQL2FuTWZpOEdJam1HMXF6TUNrTWg1TmlDSEpLeGQ2OHdOcmJ5OXJHbE9oOG9QR1piUzVaNVpvejV6amVkT2RyaVQ1R3FXSC9uOHhML3ZYSmpMOGVGQnlXbVVlem1tbGQzVXAyNHJZWVk1aE5wMHpxbXNJYU5rMkx5eG85bTZDVkdqcXBxWStYcjhYZFRKcVE2TDNoeDcyYWhwS0l3bVRRdDNBNE1NYWd0Y1lDRTVOWjJNelIxT0tWSnFaaFRac1E0bUhZbFdXSFhTYkhweUZWZTM1UWwyQkgzSUhkTllGR1lZbE02VGt3RmM4bUV1VGNsQkFUSjlveHdWSG9vZU9WVWJzcjNJOGNCL0pRcEhheFBPRmpoZzVVWUZLa3pwNTltM2t5TDRmTVFVeTRrQzRwalJPWDJjM0syWFVxVzFTV2c3cmdjRkt3VjFzbUV3dEs0VUppNHpNbmJlQjExOVAwY1N3M3V2NEx2TjE3WXRkOVRPdGROelZOWVRTbFZmeDhXUEhMbzRwZkgxVWNGWWE5aWFXd3Q1Zko2ZnFlczAzRGNROHZ0NG5sV0tMblBqRzR0RFNhY215VzhLaUNSOVp6VkFRZVQycG1wV0ZTbCtlelp4NktYWnRwWXd6VFNjMmp2UmxlRjFTcHhLZkF1cmU4Mm1oVUhySTU3MzZlODVnbHlTbGhGV3hjNXF4THZONDZaaVl6TFF6VFNYWGoyWnhkMERtZjFqemRuOUZYQldVRHBkVkRoNzkyNlBRWXh1WWN1K3FXNys3NDlOV0xKTWNmSU5lUjRpNk1EWStHK1c1akptZFhybmJaM1NzaGJwcFdhdGlpcDNDUmFhNDRxQjdXUmNOOUVtSm1ranVxMkdHVnhpaDFQbWp5WXhTZ3grMlRmMDhwekhqQlYrdk12ZzQ4bmNBL1BacHkxbnFXcldlWi9JMW5EQjQ2cFlZTHRjcHE2c0x3YUZMeWRGN3kwMTdOMGRRd3F6VEtXRncyT0YzUkVkaDBFUmNqSVY3L00zNXhiWjNWNm56ZkttT1lWNVpwWlZoVWhuOTVQT1d2UnpXL0hOWXNUR1plbUZ2TjVIUmRQM1JVMjhJZmplYTBjWmNPTFMydDRuQnEyWjhVL0RESkhCV1JmUnVaVjRhNnRPL05JM3BvakRIc3pXZW9zbUtlTlZ2dk9OMTIvSEZtWUp5bDlXNnA2MUFqRDVCeE1iSHUvZGh0cmVPd0NEeWFXT3FxdUxWdWVvdlpsQitPd0RyRHRFblVwYVcyaHVPdG9iblFBdDJOYTlyU2hRUFRnejgrWFF4d0h2eURGUS9UZUhNaXB6ZHJjcVJjVGR3WDV4ZEl5VlBFeE53a2p2Ym1kNzFiRDViem5wbU9GS25IcXNsdzEvMEtaVGFheXhlWDd1NEFhejFjZk8rVm1tZlRnbFpYbExZampXVXNNV1hJMHVYb1MybWxLSTFtVmxybWxlVm9XdkIwWHZIamZzM2VwQmptZ1doRk1BVyttTkZteDZidlBqbWs4enIyU1Ntd1JsRlp3N3d5ekVyTDBhemtjRnB5TkN2NDYrT2FYdzhuL0xRL29kWWFxOVd0Tmg1b3U0N1haMnQrV3lsKzZ3dE90NTR1ZkRxclZWdk4vcVRnMmFMbXg5cnplS0o1TkN2Wm4wM09zeDBQbWJXV3hYekdKQ1lPY3VhMDZmaGpYakN2TEM3c3BvMi9YZXE2SzFuTmFRaUNObjNnZU92NFk5a1NpNTRpbFJ6dXpXOXRQZFo4TnVOSFc3SWZGSHROb0M0MHBWYlVoV2JaRFRkZmRBZmFEV1dlSWVYenRZUkNpUHR0ZDVNbHBuemVIZFA2Q3gyUU1sbTZZb2c3Y2JFcmkwNEprd09sVVV5blVxNTJVNnd6RkJvTTZUeHcyZm5ZY2VCenV1ZnMxaWFVaFdWdlV2QnNIb2c2VWlRb3NxVXFwdlJ4Nk1LV0VuS2o1WXFVZXZNOEdRVlRIWm5id014NG5wVVZSMVZtdnpaTVN6TmVaRUpTbG1SS0F2YjhEaGRjRXFqeUptQVpzcXlndFRvdlF6elB2R3FHTEtCU1dLVW96QkMwV0pXWjZNakVlS1kyOExoU0hFME1SN09DWnhQTllXMVlsQVhGTGMyUjJUWEN5RG5UdXNDeWRmeTV6cngyUTRZaHhQVEI1K084MllBMUhOWWxQKy9YL0ZBWFBGNG81dE1KZFYzZnhzdCs1NVJTMUdWSnpwa3FKZlpMemFOSzgzUldRbEtjdGVCOUluN2doc1d1NjFIcklxZU41OFdxeDVZdEM1dUk4ZmJXeEZSbGdUYUdhY3JESU4xZWticEVGUUtMNUppSG5yM29hWXpDMVpZMmwwUHpqWlNKaWZPNVhydmoxWnR0ZUh6blE1SXo1eTN5djBkeUhTbnVRdVpOZDdVM2EzTGkwSVZBMWdNTElXNkN0WmFEK1l3UUUxYjNISlNXSC9ZcU5xckNKMFdNYVF4MDVDQjBGVU04a0lmZ0kwZkswRkxGampKN2ZsN0E0eHBxTXdSQVErbVErcUtMTGFPSFJpQ0YwUlI2V0k5UzJpRnpWTm54OXhmV3FSUldEN052cktFeUJwc0RKalRZMUZJUVdjd3lpMmxtTVlXREFpYjZzdUxJNjVWU0lvUklTSWt1S3BwY3NIS09WVHUwUWY1UStkN0ZRRzlTR2g3TlNuNCttQXpkMUNhS3F2dyt1ejhxb01xSlI2WG1udzZuR04yVGdHMGY2RDhTcytROGRHSmJ0cDVYbTU1WjBmQzBIbXJvYjIyLzFkRGdCcDJabU15ak1zTTBNOCtaeG1hMlphYno0SFJKS0thRWN2Wm1EYUVmQmd6NkdJZXZJZFBIaUF2RFRJN2QxMTExVEVoY09tdEpDSEY5TG5ZWGZidGNMY3N3VUNIRXpUREdzTDgzcHl3TERoYzlmUUtId1p1S2tJY2dKMFlwbWIwcUJXaTlXeCtWMEtIREpvZk5rZmwweW13MnBTNExVSW9VeDJsR243RVcrR0xqZ0dJYzJGa1hRMG5jdERUbjI2eTB6Q3JEdExUbnY1NFZoa2xobVJhR1FpVUlIVG82RkpHeUtNNjNxaTZweWhLajlhMTFJb3U3MXRncDA2dVNWbFdzdkdmWitmTS9mOWZGVE5hMEhHYmovTFEvNGNlNVlWNStuMEdPR2pONEUyczRtcFQ0UjBNNzVrMGZlR1VVK0E5LzN4RGtSRmFkeDJqRlFkblN6RFV4M2w2UXMyc01vYk5pVnBjWU5XTlJXL3AraWc4Qkh3SXhKb0t5SkZ1UnlnbGJOODZRY3BHbUh3TGlyUXMwZlJ6L1cyRHJJdHZ4dnpWakMvS01ORllSNGpidDF2ZUdsUEhwZkU1T2VqTUlWRDZOUW9ocnByVm1OcHN4bTcyWlpwOVNJak5NVU4rVmcwaVFjelhEMnJYZHhmZXdSc29hL1Y1bkwrLzlNTk45bU5ZS1hENmZhRmVHcGhSVU9qUFRpWVhOeksxbVhpb1d0V1pSdzd6V0xHckxvaTZHYlRKOG5WY0ZzOG95TFMybE5TakZ2V21uSEZQRWgwaVhGQjBsSFJXYnNHSGJodzgydnRnRmsxWnJyRkZNcldLL1ZEeVpGVHplcTRiR0NzVzNQL1R6UzJpdG1WVVZSL09NcVExckgzbStNc01hc1BIdnZQdDhaakpkU0t5N29WWDkwK2hvKzVJUUl5bWxXMnU5dmZ1Y1RJeGhVdGV3Ly83ZmlUR09NNkpnMHdjMm5SKzJQckJ1UGV0T3Mra2M2eTZ4NldDbEUrc2NXU2RQR1QzYkJGdkFmMkVXVlFqeCtkUllKaHBUT3MvTVd4L3plY3RFSVlTNERVb3B5RU5kL0s2dGo1YTdMRmVrVUNvUEY0WHNncExydVRpMFkxbGFaVFY3MnZIRWRqeXQ0ZEhVTXFrU2t5b3hyVEoxQlpOS0RWdXBtRnJEeEdacWt5bFVScXMzYmVIdmk5Nk5GNnBCcytvOHJZK1hEc0t1ckdZNlpyRDJiYVRPSFVYMkZMcSsxU3pVZlZTV0JmTnBoZ1N6RmRSVnBpeUdibjh4ZmFDZGRHWW9GUnliRkxSVlFVZEI0d0xUM21HTnBpaUtlL0djS3FYR0dUNlpVZzJsYmRoRWtTSlZETXh5b0NYUUtrK3JIYTN4Tk5iUmxvNm04L3kyOXZ3UkRiMmFBRnE2UndweFM5SjQ3UEVYNStRTWpRZmtReWlFdUIyN0M1bGR3d050SU9lN3Y3ajVGdXl1QVMvZStiNjJJTWNvSm9WaFZoa2VHODlmSjRaL1BhcjU2V2lmd2xxc3RSU0ZlZlByM1ZhOCtiMjFCcVB2MzBCTTd6MmJwdVBVRzFaZGVCUGtmT0o3eXJIMTlhTnB5WDdobUNwUFpmSjU1dXkrUGNiYlZGY2xhRTJWTTR1SnBpNmhMQlNGR1lMdjk5cEpNN1N0Snc5M1dUdEtuSm5RSjBVZklqbm5lOU9sVG8wTk5UU0txakJvTXFXR1VHZ1dsY0g3a2hCS2ZJaERtWnNQaExIY3Jlc2QvOSsvdmFUemp0ZWhKaXNsSGRxRXVBV1pjVTFPSEZyV0ExZ2Zoc0U1S1NXeVJEcmlybVN1WVJDWitDTDVBNy9Qbi9pNzEvUTZQYVRKOE4rRUs4ekFNRXBSVzgyaXNqd3BMSDg5S3ZnLy91dXYvSmQvK2V0ZDcvMVg2NTFuMC9hY09jTzY4N1F1RHV0d1B2SjhLSlVwaldKUkdSN05DdlpMejlSQ1ZaaGJhM2w4bjFWbGViNG1hWDl5eHFTRXlpb0tyY2twRVhqL3VSMjZIZzEvMk9zRnJwalJVK0pDUmpOY2g5eVhJR2QzYkxyNE9LL0NPY2UyL2Yvd2ZQVW54bVhDUXorM3ZUdGY1eUUvVm5HdjVUVE01UXB4R0VJTTd3d0RGVUpjWFl5UjNudDY1d2sra0hmckhuSWVUb3hWT2JRc2ZXQlQwSVg0RnZrUWFEckhxcmRzKzRDTGx6ZmNxYXhtcnk1NFBDczVxRExUeWUwTnJ2eVdsQ2t5ejRsSGxjRlBMZXZPdnpXcjRrTml5blIrbUowek5SR1ZOSFg1ZmE1eEVrSmNqNVRmTFZlTGtSaUhZVjBTZlF0eGRSRm9ZMkxyQWwzVEQzTVI4ckRBZHBFVWFJTzE5bno5eEgybFByQUo4ZEFFSDJqN25sV2IyUFNSM3NkTFJ5ZFVWak92TFVmemlvTlNNYTBMakpZZzUxMWxTdXpwektQSzBrZE5USW5PUndnZi81NlFNcDJQYlByQVRFT0JKc2JxcmgvS2QrMXJqdjNxR242R0VGOGpNelF4R2xwSTd4b1BCTW5rQ1BFbGdsSzAyckxKa1NiR04wTjFNK2pTVUNiRjlLNTNVZ2dCZ1BOK3lPUzBtVTBQZlVpWE50eXB4dEs5bzFuSllXV1lUUXpHU0diMlhaV0N1VkVjMW9ZMkcxb1hXZW5BY0N2b3cwSjhrOG1aNjh4RWEySzZ2Y0dnUW9pSFpSakNPelE0TVdObmVydWJEN0M3QXkxUnVMZ0wzMG9Xb1hlT2JRaTAybkNhTmE4M2pwT1RsdWEwUFo5MkRYQzBEVHllQng2M2dhbE5UQXZOZkZyZjIxcitxMlp6N3Z2ckl6N3Rzcy9ZdC9JNS9CSWhSam9YYUp5bUQ0b3dWaTk4OUwyZUZWWnJKc1hRS250V0dhclNTUG5wQjFoam1KWWxlMVBOS2lucVFxTXZHZllhVThhSFNOTkhXaDF4VnQvcVlORGI4QzFseUw5bVg2VWFRTndIUThPVE1adXp5K1NFOGU2elpIS0V1RnpiOWJ6ZXRyekc4R2MwdkR4dGVmVnF3L0trWlRlT1JDbDRNaXQ1dXFoNFBLczRLaDFQWnBiUzZuc2I1QWp4ME1XWWNINEljanF2OFRGZFdxNW16WERCdnFnc2t6SlRGbHFDbkE4b0NrdGRGU3lTWWVZVHBkV1lTMHAwVThyMElkSDRTS3M5cmpURHpENGhoUGdDT2I5Wmt3TzdZYUFwbjdlUUZrSjhXdE8ySEo4cytiM1QvTjRiZmo5cCtQMzFodU96SGhpV3RTa0Z6eFlWcnpZMVR4ZU9YOG9XZFZqdytHRE83T3YrZVNIRUY0b3g0a0tnZFliT1owSk01ODFDUHNacVRWME1iYVNuRlZTRmxzWURIMUJZeTZRcVdXVE4zRVVxYTdpc3FpK21vYzFyNnlLdEN2akFnOHZrQ0NGdVR5YVRzeHFxMDhZL3Mya1g0R1FnSzZUN2dCQWY1M3JIYXJuaGVLMTQzVmxlbjdVY0wzdU9HM2YrZDRhSjlFTy9kaGNUUmJYaHFLd0lJWHo1UHl5RStDb3hSYndQdUdCdzBSSlM0bE5UY3BSUzZOcGlKd1gxcEtBdXdON0QrVC8zZ2RHR3NyQk1rcWEyVUJxRnZxUm9LZVpoY1hBZklzNUVRbFNYQnAxQ0NQRXh1MHlPdW5DdnhLYU1UT01WNG9wOENHemFudE10blBVVmpZdUVEOXg5ZEdGWVVLdFFIUHFXZGpHVXl3Z2g3c2JRZFNmaDR6Z2Jianozdld0M2swSnJCZE1TdmFnb0trTmhGSmJyRzd6NmtHaXRLSXlodElwaUxGWFRsenhOZVN3cmNTSGpyUVE1UW9pdmwvT1FyOWt0d2JGRE42Z3NRWTRRVitCOW9HazdUalp3NnRVUTVNVDNQejB1Sk5aZHdJWE1ZOS9SdEZveU9VTGNvWlFTSVVUODJGVXRwUTlQTFZRSzlEanhYazBMMUt5a0tneVZBbzBFT1IraXRNWWFRMlVWcFk1WW95OTlubEtHRU1lZ015VFNPSlJjQ0NHKzFIazJKdy9ISDV2SElHYzNLRWZKblJSeEIxUUdsWGZ2di92N0hvd3gwRHBQMDhFMkZQUStFbU42NzNNVFFpS25UQWlKYlhJNFg5elRFL2o0ZkkvcDNOMXI4Tkhqd1AxOWFjVEhYSGpOZHAremozbnorais4RGtrcFpWSkt4RFJjVU9lVUlBMlA5Znp4QXhxRklxT1ZSaEV4UkVvMXJNOFJINmExcHJDYUlpa0tvN0VhOUNYWEUzbHNlQlJUSW95dnkwUEw1Rnc4bnFwNy90RE9YNnZ4eStkOC9oWEFXNC8xbmo5WThZQmxjbnF6OUVhbkpGa2NJVDVMenVlbExwODZLV2QyYzNQeWd6dDVpMjlNdnJCOXh6S00zVVEvWEtvR3dKakpNV1QwMlJucTlCUWtDL3RKUStackNIU3NVV2gxdGJWTHU3a1dPY2t4VWdqeDlYYlhaWGs4eHR1VU1qbU5CM3c1eGdqeFNic1B6MlZsbnJzdUg0bDhhVEIwUCtRTFgrLzd2b292OHAyL3RNTm5NbC82MmQydHlWRTVvYzVPVWFjYUZYKzQ2OTIvMTVSU1dHT3dhV2pPWURTb3k5NXN1OWNoNWZHMXVldEg4WjNMK2MzMitkOHNOMUxFdlpESC85c2Q0Y2ZHQTlKNVFJaXJHQUtjUk03cWt6Y0c4b1ZqZmhvdnFPNS9vQ01lTExuNEFNYlBieG9tS0Z5MkZsVURhcjFCclV1SThhNTMvVjVUYXNqZUdBUEdqRm1jSzlZNzdlYUxnUndqaFJCZjcrSlJSSjlmZ04zMVhna2hoQkEzUktGUVdtSDBwOHVwZHVmQ2xETzVyc2hWVFpabUE1ODBaTWdTTVE0TkhUN254dWt1Y3lhRUVOZE53NXRXYTBJSUljUkRwQlFZclRGYVlmWFE0dmhqRjlmRHpUOUZxbXJ5WkFMU2RPQ1RkdTJnWS82QzRlTGpheUNCamhEaXV0azAxbEpLbWxnSUljUkR0U3Vwc2xxangrWUNINVF2bEpuV0UzSXRtWnpMN05ZNzdRS2R6eGxMb2NiL0NTSEVkYk1wdjFreklIVnI0czdrRDJ6ZmdxdnM3MzErTE8vMkc3anM4ZHpueHlJdWQ1WDM2cmYwK2ZzTVdtdU0xbGl0c2RxZ1ZVWmxQWTVQdVBqd2gybHlDU0FiVWpMME1lRkN3Q2lGTWVhdUg4cTlFMlBDaDRqejRId2lqR1ZybjNvZmFUVzBtNjZzcGl3TTFoajBROHFZZmF2bnRPdDY3RUxjQXpxbi9OYkNQeUh1bkx3WGhSRFhUR3VGTlhxYzQ2SXdDdlFIRWdnNXYrbU9TTExrcVBFaDQwTWt4Q2hWRHgrUVU4S0hRTzhUTGc1QlRyNWtMTmp3ZWloS3F5bXNvYkJHQnEwS0lhNlZUVmRmSHlpRUVFSjhrN1FhTXptN0lFZC92UEZBemhESnFHUWdXbndBYnhMS2FuTE9jakgramwwbXAvY0pGNGJobnBldDlUVktVZWd4azJNTjVxRmxjb1FRZDg0eTFLdU5rN0FmM3BScjhXMVFIOWp1czh2MjkrS2ZmUXVQNVVPUDZiTEhMYjR0MzhyNzhhWVlveWtMeTZRdzFFblRPSTFSSDE4Tm9ySWl4b3dMbWFhUGxFUkl3d1c1WEl5L0xhWkk3d0xiWHRHNmlBOURrUE9wOTVwV1VCaEZaVFhWbU1sNVNNL3J0M3hPdTQ3SEs4UjlZSzh5dVYwSUlZVDRsaGxqcUFyTHJMSnNrcUl3QVgzSjFWaEltY1lGMWwyZ3lBbWROZE82dk91SGN1LzRFT2g2eDZiVGJQdEVIeExwa25JMU13WTVkV0dveTR3MUZuM1pDeUtFRUovQnBqeTBlNVFRUndnaHhFTmxyYUVxQzZiQlVnY29qTDYwN016SFRQZi9aKzgvdCtSSXNqUkxkQXRWWXNRWlNFUkdaVlgxOVBTOC85dmNkYWVuNzNSbVZrU0FPVE9pVE5qOUlXWU9Cd0ljenVDUXZaYUdJZHpkekpTckhEbm5mTjhVV0EyT0tnV3MwTVRQamQ1L1Fyd1A5T1BFZXBCc1J4aGQrR3k1bXBSWmVLQTJrc3JvMHBOVEtCUnVIUDIyeVhLbktsTW9GQXFGd2lQRGFFMVRHZWJCMExxSVVmS2pmVG1RbjRlVGoyeGQ0TEozVk1IUnFFZ0k0YjQzNWNIaFFtQTdlVmE5WkQwS0JwOElueGxPYUNtb3RXSmVhV1pWd2hxSmtrVzVybEFvM0J3NmZvVXpjYUZRS0JRS1B5SkdhOXJLc2t5R0MrZXBqZnhzdWRvVUlwdkJjNzZkcVAzSTBrUkNLSm1jOTVtRVlCc1RaNzNqc2hmMGs4ZC94aEhVU0VsakZjdmFNRzhFZFZYa3VRdUZ3czJpcjB6UDdudE5Db1hDdlZHS1JBcnd1SnVIdGRZMHRXVWhOTE1CckpZZk53VGRNZm5BZHZTY2JTZGFOM0JzSXlHV1RNNzdqRUt5VG9LTE1YRFpSWG9YOEo4SkJyV1N0RmF6YkN6TFZsTHJMQTVSS0JRS040Vk9LUUlKa1NLQ3JMSldLTnc1ZTkzVzlOQmQwOUxWdW9yM2x1dThxNjcyd0xPbGUyWEZkNVlQcjdDNHl2dys1QTBxZkpoOHpNU25laVZpZHF1UE1lSkNaSFN3N1FkV3F4VkNpS3RGU3ZuSi8zK0l2UlhXR05xNllxa1VzeTVTNlp6SitkVCtjRDZ5R1J6blc4a2lUUFNqd0RsZlpLVEpZa1VoUmhJd0lOZ2d1WndDbThFenVFZ004Y1AzUlFFQ2dSYUpSc0c4a3JTVndTb2VaQ1lucGJmWHhQN2YxNWYzZno2T0U4UGs4THRIMmR0bnhIMXZ5YWU1cnJBcnZ1SXhuUDkrdDQzWC9sMG9QQVQwZmE5QW9WRDQwY2dUSTRYSGg0K1JmZ29JUUx0QUZVYUMveS8rZUgyR05TWXYxbUNOM3YyL3hscExaUXpHYUt6UmFLMHhXcU8rb0xIL0xySEdNR3NpVVV1V2RhQTJDaTNmU2toLzZJd2VmV0E5T0tTQUpaSE9DNmFRY000alpTNnZla2piZUpjTTQwanZQR05NckRyUE1LUzNQamtoL3NWZ1hBQmFDYlNVYUNXbzBvQnlHMHc2d0Nqem9NNlg2MEhMNUR6T2VTYnZtQ2JINUh4KzlRN25QT08wKzduM1ROTkVQMDc4M3kvV25JNlNrTVRidWJ0Q29YRG42SEx4RlFvRllKZWg0alB4eS80UFNxRHpHUEVoTWJpQWo0bW9Jc0hCWmhyNVkrV1oxWmFtc3JTTnBhMHNiUjFvSzhPc2hyYUdXUzJvazZRbW9sUkM3aDR1RDJYZ2FxMWhua0Fhd2FMeE5FYWhwRUFLa1VWM1BwQndIVjFrTFR3dUpKNVVtajRacGlqeE1hSjRtOEg2R1JrbngzYVlXQWZZOUpGaGhIRktPelBROUJkMU5TRkFTMGxsSkxWUlZHbkV4b0ZLSnF6Tzh0RVBaVi9tREUwaTdzUW51c25UajU1dWNIVGpkUFhhRHhPYllhUWJKcnJSMFEwVDIySGlWU2U0OEphUWZxQjJnUFRlNnpkOXdFT3Z4Q2o4YkpSTVRxRlErRXBLZ1BQRElYSUI1ZWVHa0Q0bS9CU0F3S2dsblcwNVJ6RkRzOEN3UUxPUWhxVXdMS1JtcVF5ak56aXZJU2hFa3Fna3NVbWdJSmQxUHBDQmEyVXRRaXBzaEdVOVVSdVpNemtDU0FKRWVtZkdQWkV6T1c0blByQTZxT2xGZ3hNR0gvSzJLUmtmbFlIbGw1SlNZcHdtTnQzSXltdTZYakNNZ25IS0hqa2ZRaURRTzErY1dhVnB4QmFMbzdZYWE4MTliOUpmdGkrU2lFbmdrbUNJaWsySXJJTmg3UVVyTDFsUGl2V2t1UndOcTlHeDdoMnJ3Yk1kUEVPSWpDa1FVaXgzeWtMaEh0RlNpQzk0OUJVS2hjS25HYWVKcmg4WXhwRnhuSERlNDMwb2tydTNqQlFTUk02WXRFMU5VOWMwZFlXVWFpZmorMjEzK0poUzlvbHhFZkRFUkpaVW5nS3IzdEZZUldNVXJkVzcxN3cwUnRFWWpTRWdmSWNJSTRwQVhWbXFxcUt1TEUxZDB6WVZUVjNmV1IrR0VLQ2tRS2VJRGdOdDdEbXdpVTFycnNxc3BnODB5Ky9GZVhvWE9OOU8vSEhlay96RXdzTGhva1hybjIrdU1LVkVOenJlYkFiKzJBaGVYQTZzZTBmNGxLS2FnTVlvRGx2RHlhemlxSExNMnZwT0RVQ3Y5OUFNNDhTMjYrbjZubjRZbVp4am5DYWNqd1JsaWFvaW1wWitDdlF1MGsrZTNnWDZLUXNyZEZPZ253TGQ1T2ttejdENzJlaXpBdC9uZklJS2hjTHRvNFVneTJnK2tObTJ3cy9KWTFaMWV0U0l0MGRzY0o3TGZ1UmkzYkhwUm9iUk1leHEyQXUzaDlxVlRDa3BPRm9HRGhkd0loVkdDNFNVSkhiTjNsOTVZY1dZRys5VFN2aVFaK2kzU21LVXhDaUIxUkl0SlZaTGpCUVlMYW0wd2lxQlZRcExRSWNPblVacUdWbk9HcGJ6aHVXczRmZ2dnVkpVVlM1cnU0dHNqNVFTdmRzWEZZNVdUQnhhd2JhMXJBZEhUSW5wdlhnOFhZbHNDTHJKYzdvZCtmMjhJMDN3YkNab3JHYld0bmR6b0I4SUtlVlN0RDVFVG52SFAwNGRMeTRuTGdmM1NkbG9LYUMyaW9QRzh2eWc1c1FHWmsxenA1bXd2VmhDaklsdWNweHVCazR2dHB5dnQyeUhrVTAzc0IwOFRsbWNhdkJxaXdzcDkySDVMTWJoUXRvdE9TajJJUWZJK1hmNTl6SG02NmVFT1lYQy9hSmxsam9wQTh0Q29mQnQ3RzRlUTR4YytzaWJTYklhTmVzaHNSMWdtSDYrY3A2N1FwQ3pFMG9KbEJCTVZpTnFSUnNrS0lGTXZOTmMveldFbElnaDRlTXVGN1FUSk1nVFkva1Q5MHBaK2VjQ0xRVktaSG5nU2drYURUT3JXRlNHRXl4UHBPR0oxdWlnbUpFTEgrOEtLU1ZTU2xSSzFBcGFGVG1vSlZzTU1TYUc2YThaeDczb0l5VDZLWEMybWZndjI4UG9NVjV5c21qdWNBc2VEb2tzRzMzdUV2ODQ2em5kT05hRHgzL0NBVlFnYUl6aWFHYjQ1YURteE1COGRuZVpQSGpiYXhNUzlFRnk0U1F2UjgzTDNuSytUVnhzNGFLZjZIMmk4eDNkMU9XZW1wU0k3eGludnhVRFRVU3VpMDd1NDd3UzRCUUs5NCtXQWlTQy9lc1AwaUpYZUdTSWE2OFBQZUFXSDFrKzlEYy9FbCtTVFh2L2QxT0l1Q25nWXVURnV1Ty9MZ2Rlbms5Y2JuTjVSemNGSmwvTUUyOFRKVVJXK2hJdzR1akR3TVlsam1hV2c5WncwQmlrQXEwanRZRldLMEpNZWZtQyszM2FEZTdlL2RNUHYwL3V5dWFVRUJnbEdZeGlUREFraVpPSkFjOG1URVF0RVZxaWxLS1JBcXNrdGJWM011QVZRbEJadytHODRWa0VieFUrUk5hRCsrUTFPN3JJUmU4d3F3SGxQRE9wZUxMcFdXeTNHSjFWNVI2aUJQSk5FV09rSDBlbUVCa1RuSGFPczYzbnNuTnNSOC9vQW5Fbkkvek8vaVlIdzBibWdQZTR0Znl5ckRrMmtsbHpOOGQ4ejdicldmY2oyeUI0dmZIOGZqSHkrK1hFNjNWZ05TVFdvMkE5S1VhWFM5Snk0UHMyc1BrYWZzVDcvL2U4dDFSakZCNGlXb29jNEpTVHNsQW9mQzJEQzZ6SGlkVXc4ZnRGeHo5UGUvN3JkT0J5RzNZOURxazR4Tjh5dWE4eUQ5NVhnK2Q4Ty9GcVBmRDgwUEx2VDFwbTFSeXRFOW9rNmdybXRXWjArOTZCbTUzVTJtYzlBaUJDWkNEM3MwdytYc2t4djFsUGhPUkpKQ1NDQXcxekkxR0x1M084cjZ1S3c4V01YeVI0QTV2Qjgzb3pmdkk5azgrOVNERWxkSVRqUm5MUmV3NjJBNDAxTkhWNjFFR085NTcxdHVOeWNLeWo1TVhGeU5rdWc5TlBXYUFoZmNBWFJ3cUJsSGxHZFZZcGpsckQ4MlhGMGhobXRiN1RjclhOdHVQRitZYlhvK1RWTnZMSFJjK0x5NEd6N2NUb0k0TUxEQzZYblBrUVA2cTZWeWdVZmd5MEtHRjNvVkQ0UmtZWFdIV2UxeHZIbjJlTy8zb3o4djk3M1hHK2RibThJNlhpRVhHYnBHdFpVQUZuVzgycmFtQldhUzRuaTYwQ2Z6dXEwUXFzVGRSV01xdHlvN3lQQ1c1WUUySmZ4aU5Td3BId01RYzRRc0NxejJWMVdnb1NFWkFvSkdNVmlZMWkzdFIzdHR1cXluSzRuSkVzVENyd1pqMWkxYWNIMjRPUGhON1JUUjRqTE04UERPdGcyRTRKY0JqemVBTWNnQkFDcS9XV2wrdUpVMi81ODN6aXpjcXhHYlA1NTc2azYzMmt6SUdPVnBMV2FvNW1sdWNIRFkwR3ErOHVzSVZka0hONnlUKzJpaGNkdkx3Y2VMVWVyNExYRVBNMjdPOWRNWlhoVWFId0k2TWxBcEYya1U2Uk9DL2NGNGs3bDlsUEtSRkNWditLMTV6ZUVhQ1ZSbXYxYWJPLzcxem5sQkxlZTBLSWVPK3Z2a2NJZ1ZLNWxPZmV6QWJUSjM1KzdYY3U1RjZGZFJkWWJRT1hXOC9seG5IWnVidGY1d0tUand5VFpETjQybGxrTTFhRUdHbU01cWlwK050aFM1ZzBxOTdsR2ZsK0lzWmQvODF1Z0JkMkhpZlhnOVN2UGIydlRwUDA0Wks0MDdWalprY2FyYUdlc0VIejlHaHhaL3ZKV3NPOHFVZ2laNWVXT2pEVGlkYmtVajYvSytlN1Rrd3d4WWp6c0I3aGJCUzgyRWFzR1RtcEVsSmttZXA5Nzg5RGtjNytIbUtNaEJCd3pySGVkTHk1M1BMSCtjU2ZZK0RseGNqbDFqTk84YU9xYWtKQ3BTV05VUnpVbXFWTnpFMWlYbVhCaWx4cWVidVpuT3ZHbnQyWXhRYit1SlM4M0FyT3R4T1hXMGMzZlRqYS8vR1A0QzN6L3JPdldPVVVIaGg2WHk5Ykx1YkN6MFlJZ1dHY0dIYXlvVEZHZkFpa0JHMVQwZFlWYlowZndMY3hZQWt4MG50UDE0K013NGhBWEJuaVZVYlQxRmxxOXlFUGxrTE15a0xkbUNWVVhZakU4b0M3TjBMTXlrOFFjQzRSb3lCRnFKVG1sL21jK0V4elVEbk9OeVBuM2NUNWRtTDBnZEhsY3JMSjcwdkxZcGJTalFrZjQ0MW40d1lYdU93Y2YxNE02THBucVF6dURsWDR0RkkwTzIrV2hmSXM1TWloaVJ6UDdKVTBjQjgvUFBCTkthLy9xOVdBVllKaDBQeDlLVkZLTUdzYmxKUVlyVERtWVhtL2ZBc2hoQ3l6UEl5Y3JUcGVya1ordjVqNFo1Zmx0TGVqLytSNFZrdkJvalljenkzUFpvYVRLdEZLanhhZ2hMd1QrZWo5ZlQzRVJCOEVXNjg0MjNvdXVrUTNoVS9MWGhjS2hSOGFMVVIyZkg3QTQ2aEM0VllJSVRCTWptNE1qSUdkUk9odUZsc2xsSUU2Z2VSMkpHNkRFUFJKc0Ftd0hSSlNwSjBVc0tTTkRpbkYxY3p3UXlYRXhPRHlvSENZQXM0blVoazAzQnZaMnlZU29zRDdCRUVTbzhCS3hiTkZ3OHhhbmk4Q3I5Y0RyOWNEWit1UnplalpqbjczR3VoR2p4eXprcG9Ma1pBRU54M2w5RlBndkp1SUtWR1BXMzZwSzd5L3V5REhHSU1RQXFNMWg4MkdBeE01cWdVYkxMTExVc2k5KzdEYUd1UWc1L1ZxWkhTQlRXOVF0QnpNRTA5OXhLcUVsSUlmUDhUSmZUajlNSEhaTzg0R2VOMExmbDlIL25HK1pkejFyNlJQbkJ0YVNaYU40Zm15NXQ4T0xFOW1nYm5OcFd0SzNjMTlMWVRjZStaaVloU1diVFNjOVFNWFhaNlU4VGZjbC9aVGNnK1ZHSVhDbDZEVmJ1d205djhwSjJqaEViTXZ2d2doc05uMm5HOEgxaE4wUWVGRFlneFpYM0NTQ2E4aVNYa3NDYU55ZGdVaEVWTHpOZUszUWlxRTBnZ3BjK2xIVERnaDJBakJhUlJjVG9MTk5xR2tRSXFFRkpHWm5IRFRSSXFSdHFuUk8vV21oNWpWRWU5bzQwSGFOY0tYVzhuZEl4QlhqZDRLZ1l3UkVmUDVlMUFibHBYaFpCYVpHNWpweUZ3RlZsMWtiV0F0SXhzUldDZEhFeDBkQ2FlelFscEE3S1IwZ2F1K2hYeUU5OUs2K2ZlQ3RQdmRwNDcvNUNPYm5lVHcwbytzbDRKeGNuanZyOHE5YmhNcEpkWmFyTFVzWncxSE04dXpRVENaR2hLTVUyQzkrOXNQYmNmb0k2R2I2Q2FQQzVHamVjT1RBWTYzbmxaRlpwVkg3MHBOZjdUU3RldGx2SnV1NTN6VDhhYUx2T3dscjBmTjZ6N3hhalhzL3ZiRCsyZXZzbGRwd1VHcitmV3c0dThuRFUrdFoxN2JPNzJYK1JBWVhHQ0trajRhdW1qWWpPUXNWQkVWS0JRZU5idE16bjJ2UnFGd053ekR3TGJyMmZRanA2c3RyMVlUcjN2WUJJMlB1Ums3QVVlTG1vT1o1WGh1T2RTQmswYno5R0FHdWtMV002UVo0UXZiVG1UVm9wb1pTV3EydzhpYlllSVV5V2xTbks4R0xrKzNkRysyc0ZjNkZJSkROZktrVGp4ZFZCek9HNWJ6bHNQbGdycSt1K2JzTDZFMmltVmplTGFzNmFiQTVlQ28xeU85L0xMQmJ1Rm1xVXdXRm1pdDRzZ21XaVpNOHNoZHl5VUNURXpNZE9MSVJuUVRXUkFZVkdDclBMMTFESldqSHllbXBQREs0czBNcnlyOHJvUnQycitHYTY5aC8vOXZqUk45ekJNQkgwcnNoWmdZZDBhalE2VVlNR3hHejJiYlk2M0dHb1BXK203MldXVTVPVnd5U284ZThuZDJrK2VzbTk1cFFML08vbWN1UkxhVDUrVnFvSDZwR0NmUGt6cnlmRzRCZ2RVS2F6VFcyaDhtMEptbWlXM1gwNDhUYnk0My9IN1c4Y2NtOGJLWC9ISFJzeG44SnhON2FpY0picFRnYUdaNGRtRDQyM0hGdjUwMExGUmsxbFIzdGkwcEpmb2hDd3RzZ3VLeW4raDNVdGRGRUtWUWVQeG9KZk9nNmtlNUFSY0szOE13VGx4c09pNDZ4eCtYam4rZUR2enIwbk0rY3FXcUl3UWN6bnFXczRyRG1lSHZDMFU2ems3dDZCcFp6UkFLNE12S2ExVFZJSnNGUWx2NlhTMy9QL3JBSDBQaS9LTG40cXhqZmQ2LzB4djN0SUcvTFNTZEZ3d3VFbE9pcmVzSEYrUlVXbkhRR2xLQzllQjVzeDZwakVJclFZaUpGRys4MHFud0NXcWpPR2h5RDhSeDdXaEZ3TWlFM21WR1VrcElyVmcwQmlNYmxyWEd1UnJuUE01N3ZQYzQ1L0VoNENJNXVGRTFUbGIwWTVZSzNpL2RtSDJRdXNuVDdVb1d1eW5RaldFWEJPUkE5MFB1YXlFbThKRVFZY1F3eXBvdUtMYWpJNUZRVXQ1WmtHTk5EbkprRmJBOWJNZkFtODJJVVhMbkovUTJhN1VucFoyamZVcjBZK0RsWlk4UGtjdnR5SDhlR2tpQ3hUd0xtZ2doTU9aMlNsNXZnOGs1MXQzQVplOTR1UTc4NjhMenY4OG4vdHpFSEN3TTdwTVRGMG9JckpZMFZuSFlHSjR1TGI4YzFmenRxTVVDbGJtN0xFNUtpV0VjdWRnTW5EdkR4VTVrWUQrWlZTZ1VIamRYbVp4aTRsUzRUKzdLU0d5Y0p0YTk0M1NVdkpvcy85eU8vTTgzSXk5WGJ6MHlsQkFzRzgyaXlVYUs2VzhMRm0zRHJ4NjhzbUJuQ0QwaDhGOWtCaXBzQTFXTGx3cnZFcWRyeis5L3J2bmZyenZPTmhPbm01R0w5OVRJL3UyNHdhc1pOQld5OTlSbTRNbmh6U3VXZldpL2Y4NE05RHFWbGl4cmc1R1NpKzNFUVpPekNMV1crSkR3TXZ0TkZHNlA2K1BGMWtpT0dzWHp1ZVZKazFoVUNydFQ2cnVPdFlibFl2N0p6dzBoTUU2T01TU0drTmowbm5VL3NSbjgxV0IzMVR2V2c4eXZLbUZFUXFSSUNKSVlFbkZuTXZMK0dSQlRJb1lzWVQySmxsSE42S25vUEVnWnFPemRuVE5WWlRsYUxtamFTTjE1VGxjRGY5U2FTa2tjQ1ZJa3BMOXFDY2RkcmRNd1JkNnNKOWE5NS9WcVFvb2xzNW5pbVpQRWxNMGs5MElFRDNWQ2NhOCtGbU9rNzBkVzNjVDVLSGc5R2Y3c0ZmL3ZoZWYzcys0cU8vdXBMZEFDR2kxWlZsa3UrbVJ1ZURhdmVEYWYzZm0yeHhqcGhwSExUYy9yS1hEUlRmU1RKOFJVeGpydmNWUFAzektPTER3azlGc2p1ZnRlbFVMaDloa254M3JiYzlaTHpyZUpidkpYWlRWN0VybmtwdC9KaXI2NEhKaFZHd1J3MFUyOFhnMzBVL2ppVXF4dURMeThIUGxmTDllRUJQOTRzNzB5b051T251a0RqYS83bm9XenpVVHJSNDZOdnRQRzdDOUZTVUdsQUJsNFVnWCsyNEZFTWVOaWFKbDhZSXFwTlBiZU12c1NSd0VjYU05eEZUbHVCcDdOTmNmTGxzcmFiL3JjdlpTNVNZRVVFMUVGTUFIbEhkWTZabWxpa1NZNkpqb3gwY21KU3hrNGs0SUxhMWc1U3pkNk5vT245eDgzNUpsOHpBSENlc1RpaUkyZzFwSzJhZTVrLytYdEZOZ2thR1RneUFaK1cwaUdYNWVjYnlmT2RrdjhTRW95a2VXbXA1Q1FVK0RWYXFRMkczeU1IR3JIWVpVNG5sbVc4NGEyYVppMURmWUJLSy90ZzVvWUUrdnRsdldtWTczWjhtYlY4V3JyT1owTWIzckJ5OVZBZDlXLzh1RjlzRDhIbFJETWE4M3pnNXBmRDJ2Kzdjanl4Q3FxZThxYkpLQ1hpck1BTHk1SHpyWVQzWlF6YklWQzRYRnlQWnpSY0R2eXVJWENRMlNhSmxiZHdPbEdjdEZKdWpIOFpSQ2VVbFphNjhnMTl5OHZSNlRJWldQZDVIbTFHaGxjdUNwWCtWdzVWamRHWGwyTy9EOTJRMHp3WDJjOUx5OEh6cmZUVlgvRCs3Z1EyUXlPTXkyWStaNXRZeDVta0NOeU5zY0l6Yk5saFZHQ2swUFk3c3JzUnA4VjF3cTNneEE3Ui9tZDJFQ2JCdVk2c0xDU2cxbk53V0pHVlgxSGtDTWw2UHdkQ29PVk1OT1NxVlk0cDVtY1lYSVZ6anNtNTNtejZubTU5cngyRmFlajVzMW14SVg0MlNCbk5UaGVyd2RNVEdndk9HeS9iWjIvQlNrbFJtdUVDRFJXY2RJcS92MjRRdGVhZjUxMmhKUlk5UTRYUGp6RVQyblh5NWR5d1BCNm5iZjViRHZ4dEk0OG4wdTJZK0JaRXB4SVJWVlZHSDMvNVdzeFJrS014QWpyM3ZQaW91ZkYyWnFYcTRIWDI4anJjZUppaEZXZlM3d1NIL2RNRWlLYnZLcWRaUFF2QnpYLy9kbWN2eDlabnJTU1J0K1AzMWNVZ3M1WXpvWG01WHJEK1hhaUc4TkhBOVpDb2ZCajgzN1NSdTlGQjBSSk1CWitBcTR5T1J2RlJhOTNtWnozZ2h5NGFxWVdPNW13d1FYT3R5NTcyK3g2RXI2MGViVWJBNjh1SjFJU2hKQjR0UjU0c3hsWjlXL1ZmZDYvK2tZZjJZdzVxSmxQUFp0WmVKQkJqbFlTcVNWYVZiUjF6ZFBqM011eHo0VDFMaks2OFAxZlZQZ2cxd2VYU2dvcTRXbU1aRlpiakRIZnBWUW1oTWlxZnVSZ3ZxbXJkNHdWZ2IvOCs0K1hyL2wvL3p5bjNRaE1ML0V4QndpZkltZHlISzlXSThaNzVra3dIczN1ZGgvdTFRdUJwd2N0VWhzV3poQmo0cktmK1AwVEEvUkU3akVLSkVTQVY2dUIwMTFQejk5UGFvYlVRbVV3WHRNbStZV2RmTGZQdnE4b0pOaDZ4ZWxrK0ZkZjg4YzI4ZWZsd0l0VnoyWUlYeVFnSXNWT2NFQkw1clhtbDhPYS8vNTh3YjhmMWRRYVp2WDlaSzZTbEhUdGpITXo4bUo5eW1xYkZmR0tOMDZoOEhpNUhzOW9LVUNTbTBORlNxVkx1SEEvSk43cWtkNmlycWRXaXRwYVdpdHB2TVJJaVlJUG52ZjdWWmw4b0J1elYwZ2lEOG9tSDY4OEZtS01IM2wvM2c3bkE5dkJJVVVlREcxNnp6VEZLeitaRHcyZmpCQlVTakt6bXJZeVZMc0I2NjBlZ0t0OS80bjd3QWQrdnU4ejBMdlpXcDBTUmtZVUVTTVNreWozbE50Q0NOQVNwTXlaSENzTmxkVlUxYzM2SysxbjRUODNHeitmdFJ3ZlRIZ0R6aVF1ZTBlbEplSVRnK1RKNTRaMm95UlZqSnhZUlQ4RnBpbDdSU2wxZDFrQXBSUnRaZkVoSVlUbmlaMzRkWmJZbkZTc2g3Z1RXL0E3dzlXL2tzaStMREhtVE1sbDUzbHBKb1NVVENteDlaN0xjV0poSkNvRWpNamlIZFZPenJxeWJ3UFRtOWptbEJMZWUwS0lPTytacG9saG5CZ25seWNnb21LazRzL0xuai9PZTM2L25EamRldFpEWUpqaUovdnAzaHFKQytaV2N6aXpITGFXZnp2UVBLMFRDeDFvcmNRcWdYNnZKK3cyaVRFeStjQUlySVhrc25lc084ZW05d3lUeDdtdzB6MHY5NlYzdU1ueFg5bTNoWHZnN1QzcExWb1ZJOURDVDRRMWhsbGpPUXlLYllSVjU1Q2Z1UUQ4TGl2aHN5RUlJVVo4ekhYNE1hVVBsajZrcS8va3JNWm16Qm1qbUJMREZQN1NCL1ErV2dwYXExazJoa1ZWMFZRR2RVZHFVOS9Ldm9kRHhEeTdYeW1CUW1FZnJwZnBvMER0QnNSUzVzR2t1YWZTSUlES1dwYnpsbVJnbExrL3BUTHlLaU1LZjUyLzhENnk3VDBrcUJHc2w0WWhDQ2J2cy93bjNKblNtcFNTdXJJZ1FNbUpaek5CUHlwUWMxNnRKMTZ0Umx4NFcrTDZ3ZkkxRXFTc0xyZ2RQSy9Gd0RBRkx2dVJOeHZEbnhlR2hSWE1SV0p1SkFlTlpURUxMRnFRU2lGalFxdDBJOXNjUXNENXdPUTkvZWhZYlhwVzI3eGM5SUhWSkZrSHkzazNjYjZkdU9nbTFvUGZaVHMrY1k5Szc1WktMbXJOYjRjTnZ4MjMvRG9UL0xKUUxDdEpaU1JhcWpzMU5JNHgwbzBqbTVDNFFMTSs3K2t1QnJvaHF3T0dtQ2phYWgvaGM1TmNoY0lEUnlDdTdrMndVMWU3NzlyZ1F1R3UwRWJUMWhYTElGbjVTRzBVNmpOR1VUNUdna3VNUHJ4Tk11MmFjRCtWZE5yL2ZQSUJIM0taVzBvUVV2cHM0NnRSV1lMMW9ERWNOSkdtTnJrLzRnR3p2NWNJc1hOODErcWRjcWJDN2JHL2grOHpBUGQxVDdmR2NMaVlZZXZFSkJ6L2FqcXNWcmw4UUh5NHZIUHlrVlZ5REM3UTZvcE50SXhZY3BWalJJcTdPKytsbERSTlRWVlpabzJuNjN1U2tOUnpnekVEVTRpY2R4T2ZNZ09PdXh1RVNMQWVITDBMbkc0bVhxMGxpM1BOdkZZY05KcG5jOHZ6UmNXSUlCcUpyZ1JOQkNVU1V0N01OUk5qeFBuQTZCSmJKemdmSmFlZDRQVkc4dkxTOFhJOThISzlZdkM1ckhUd09Yc1RkcE00bjBMc0Fod2xCWXZHOE90aHcvLzF5NEpmWm9MRFJuSTRiNmgzL2tCM0dlU0VFQmo2Z2ZVUXVQU2E3WnN0M1ZuSGRuQTRIM2ZHdFhlMk9vVkM0UzdaQlRqN1o2QldJamNQS3dHU0lxdFl1QjgrSkdOOEc5U1ZaWGt3WjV4cnRtM2dQTUhCbUYzTFhVaTQzUVArT21sdkNQaUpkZjhVKzhEbS9jOTk5MzBKTFFWYVNiUVVITTRNVHhlV1h3NHJuamFhNVR3YkN0NG1YeUxqL1NYSHBVeWMvTHhvcmJCUkkyUmlwa2RtMGpGWGtYbXQ4YnMrTi9jWG9ZOUVDRERFd05iQlpoSmNESkh6N1VTckU3TTZZdTNkOVhRb3BWQXFTejRmTGxwY1RFZ1ZHZnZBME1Ld01EUmFNZnJjbS9jeFFRTFk5ZXJFM0pQbXZXU2NJdXRlc1IwU0xpaGNESXpKczNZRDUwUGtxSE1vUDZDaXc0aVlnd2lsa0ZKY0JRc2Y2cDlONUxMWnZDL2pUbFFnTUhrWW9tUVNGVjFVbkc4bXpyZUJzMjNrMVNid2VwMVY3YTRITnRlMzVmMXZlcXVpUmphZHJUU3pTdk52Uzgydk0zald3c25jTXFzMWxUVi9rUzYvQzBJSWJMWTlaNnVKVjZQaDRyeG42Q1o4aUZkWjkzSjMrakRmc2wvZXR4NG9FdEtGKzBKZXhUTzVzZ0ZBYTVWdldHVk1VdmdaYUpxR0k2V1JRalBPSXh1WjNjMUZ5TTNQbTUzaDRWMGpCVlJHMFZoRmF4VlBseFcvSHRYOHg5TVpUMnM0YXRRM1N3RVhDbmVGbEJLakZFSkVLangxR2xtWXdQSE1zdDJaaDdyd2J1dDlTaEJKU0VRV0lSZ2NyMVlETTUwNHFpSkt0Q3ptZHlkRWNKMm1yamp5QVMwbnBrRVFuVUxybGpkZDRzMW01SFE5c3Q2Wm4zNnVsVENrdEF2d0FxdmR6L3JKYzdZZGR3R0RZbDVwbE51aWZJK0pJMFpMck5ZWW83UEl4NjVmNS8wU1d4OENNZVlzek9ROGszT01rOGNseVNScm5KNHhzVHNHbzJjN2V0YURZelBrQ1o0WVA3LytBbllDRnhLakJFOFdGYzhQYXA0ZjFQelN3aThMeFdFdGFTdEZaZlNkbFJpK2ovZUI5V2JMeS9PUlA4WjZKOVVmU2dWV29mRElFYnpOTHF1cklFZEtsQlJGWGEzd1U5RFVGY29hNWxJUjYwam5BOE42SkcwZEFuRFgvSEh1RWtGV0psclVtb1BXOHZ5ZzRyZmpodjk4TXVPbzF0UkdVdDNoYkhhaDhDMElJVEJHbzJLazFvS1pDaHhZT0pwWmhNajliZHNQdkc4ZjZMaVFSUWhlcjBacUVVaHRZSGFQVFYyenRzVm96WHptRWFUYzA3ZVF6TllSSVFUZEdOaE9nVWh1T3ZyVVFEckdoRXNSSDNLZjN1QUNaOXZjbUcrVVFFdUpWb0pLT0dvUnFHU2tNVkNaU0dVRFZvTldvQ1IvRFhKaWxxSjNmcWYrT0VhNk1UQ0d3RWpDRVpoU051Z05NUXVtdUYxbUxZUjBWWHI3NldPYnY5Y29RVzBrVHhZVi8rM3BuUC8rZk1GeEZUbXNKU2ZMaHFhdTBGcmZTeFlId0h2UDVYckxxNHVlMzRmSTJXYWtuM3dwbXkwVWZnTGtWWC9xdFV4T1Z1YlpsWmlVRzBIaEVXTzB4Z0F6b0krUmxkV01UVXRxSW5GU1RDTk1KbHdKQzl5bTFLZ1E2V3JXd1NqQlFXTTRXVlE4VzliOGNtQjV2ckE4bVZjc0cvdE9qZW1OazNnN2hmdis2OGYrZHIrVXVaSENOZmFsaWxKS0txTnBiUTdjajdCTVBySWQvRWZQclpTeVA5UjJETGxVVFRyYTZCa1gxYjF0anpFR1l3d3pzdUNJVkpxNkQwZ3hNZzJTZnRBa0VxUExpb3VqajIvTFc5L2J6a1RPNWtET3ZJeC8yWGY1Y21wc0xnTnJyYUtPbWpwS3FxZ3dLZ2RCV29xL0JEa3VLRnhJdWZmUGFmb3BzSjE4N3JOeGtjbVBIMVdFKy9UeHpOa2JLZklrVEdNVnMwcXpxQlMvTGczL2RtRDRqK09LWlNWcHJXYlcxdmVXd2RrVFFxUWZQWmZya1RlOVpqVTRSaGZmSG9UQ3paTStzQlFLZDgxdUlrYUpQR2tFb0kyU3U1dllmYTlkb1hDM3RDSHlKRUt3TFdwV0lWMkZpQXB0RXR2UnN4MEQyL0gyWEMya0VOUzdFclZacGZqMXFPYnZKdzMvZGp6aitVeHhXRW1zZklCeFJPTGR2dXZ5UUN0OEFDa2xsYlhNYWxnSXcycHdWMnBwSHlQR0xQQ3hIVDFyblJoMHdEMFFmNmphV3VhTkF5YmNCUEZRMFpnWnozckIyV2JrZER0eXZuVlgwdktUajEvOUhZbWNsUm5jWHI0KzBVKzdYajBscm1yTjMzOWVYNStVY2Y1dHdPVkN4TWY0elkzMldncHFxMmlNWWw0YlR1WVZUK1lWSjNQTHIzTjQyZ3JtQm1xak1PWnVWZFEraWxBa0xGUE1BYzZYcUZrV0NvVWZuNXh0em1JRDF6STVFdldCR3Q5QzRiSFRLc216MWpCN0lwZ2pzb3FURE1ocDRtd3pFbE0yanJ1dDVLWVUwRmpGc2pFY3pReS9IVGY4dDZkei9zL25TK1lHNXBYR2F2MndHdm4zQVU0SmJBcWZRVXBCWlEzekJoWkMweGlGVVo4K2oyUEtnL1J1OUd4a3BEUHV3WmpnVnBYbEFLZ3JRNlVsODlyeWJCUzg2ZUdmcHgxS0NFYVh5OUJTQ254dFljVCtiMzFJcEpRRHBWeDZrUnRweGM3dUlYdEJ2THNmOThiRUthVXJrWk93NjdQWlM5MS9DMHJtRE0xQmEzZ3lxL2p0dU9Ydkp6TitPNnFaYTg5Qm8xazBGbXZNbFUvV2ZaSlNRZ2dGMUV5aFl6Tk1WMEZuNGN2NTJxUDRRSjVPaFo4Y1FYN3VhQ2t4ZS9zQkl5VmFDQ1FDa2tDVTBVdmhIdmlRSXN0dDN6Z3JhNmlzNGVRUTVrMWs4aFpQU3hwR1VoQU1VMklsM1c0QWNYT3lvM3VGSXFzRnMwcHhQRE04WFZiODdiRG0zMDlhL3Z1ekJVYkoyeTFSZTQ4UEtlUjg3TzlFS1ZrcmZJYmMvNUNWd1l4T1dKMHpFVko4NW5SSjVPWjVIeG1jeC9uY1VQOFEySmV1elpreGIxc09ob2x1aWh4dlBTSkZ4c216SFNPYjBhR0V5SDFHdXl4SzJwbWhma21zRVdPV21IYzN2UDZmdTB6Mzl5WElKV3BDd014SURpckJrMGJ3ZktINDk2T0svK05weTM4K202TmxQcTRQVHhCRmdyREVxQmxkbi9kbktyZXB6L0U5eXFhQ29xNVd1SC9lbHFvSjdGV1FvOFNWbVZ5aDhMTmliZUI0R1JpZFJZcW55R0dMY0N1RWlIUlRZSERoeWtqdWU5QktaSWR6STFrMm1yOGQxL3g2MVBEYlljT3ZDODNTQ2lUbElWSDRNY2tTeG9FWWMwYmpvdmU4V28zOHZwazQzNHlmRmZWUU1wZHdMbXJOc3BITUduWHZQUjRmUWtxSlZwTGFKT1ltOG53bWlVOWFsbFhMNVRCeDBVOWNEdU03YW1aN2VmcjlvUHNoWVpUQUtJbTUxbmN6cXpRTEV6blVqcVBhY2RKS250V09oZkVZbWE1NmRSNGNLU0JTajFXT2c4WXcrc2pvSXFPL2UwR1pRcUZ3dDN5d1hHMC93MVlvL0t4WUt6ZzV5bEt0aTBZaG93SVN5WTZjZDlrSmZIU0I3MzFNYXBrbFZ1ZTE0Y25DOG0vSExmL3hkTVovZXpKallRVEx4dXhtVVI5UWlWcWg4SVdrdEZmdmlvd2UxcFBnMWRieis3bGoxYnZQQmpuN1ByVjViVGljUVZzSHJIbDRxb0pLcVowUGpMeWF1VjYyOExkanplbDI1SFE3Y05iMXZGbVB2RmxuaVlGdTlEaXl3dHBERS9qUlN1YmVHNnM0bmxVOFdlVGx5QWFXZXVLb0Zoek5HNWFMR2N0NWhkRzdNdmVIMElOekRTRUVpSUFRSTdVSkxCdkRadlRFbEpoOHFiSXRGQjR6UXV6TDFjUzFjclVyNFlFeW9Dcjh2RmlyZWZwRTgrUWswZmVRYUlqU0U4Y3RRbVpYOXN2TzhiMlBTU1VGalZVY3RybEU3YmZqbHYveGZNbi9lTDVFaXIzODRjTWFPQlFLWDBwS09WTVJvbUJDczQ2RzExM2k5N09PNlF0Nkk2UVVWRHNwOVdVcm1UWHhRUVk1VWtxc3RWaWdiUm9PRnBFRU9KOTRjVDd5Y21WNHRkWTBOc3NvOTVQZm1WRkd2a0dQNE5iUlV0QVl4YUkyUEZsVS9QdEp5NzgvbWZHMEZTeHQ0bVRaY25SNEFQQURUTDVFbFBSVUpySnNMVEh4VFNJUWhVTGh4eU1yMXNvcmtadGR1ZHBlZTcvTWN4Uitib1FRYUIwNW5IdCs2UldzbmlKc0IvV2F1QkJzM2NUb0lvUDc4dEkxbzBRMjlWT1NvN25sbDhPYVg0OXFmajJvZUQ2VHpIVGFlVlg5Q0FPSVF1SGpkSDNQK2Jwbk5TYitYQWZlckNjMmcyZmFsV3A5NkpxUnU5azNLWEtQMnVIYzh1eWc0cGNqeTFFVmFacjdrNUQrVXFRVXBKUlFFaG9UT0RDZVlFZlN6R01SSExRek5sT2lHd0xERkJpbXlPUURrNDlNTVY3SlAwLytiZi9mVGNqWDU5S05QSkdwWlZacHMxcGlaSDdkTDQwWW1VbEhxMGVlTm9IbmxlVFlHSlpWeGJ5eVZOYitNUGNtb3cxSEJ3dCtjd2JHaGorMElNVEl1cDk0Z0VtMFFxRndRK3pOUVBYT2V3emU2OGtSTzBPelF1Rm5SaWs0UEpBa0xQT21SVWFEaUlLa1BlZURZTlU3Zkl4ZkVlUklacFZtWG1tZUhWVDgvYVRoUDUvTytkdUI1YkRPczZmN1RPcVBNcEFvRkQ3RU1JeThQcnZrNVRieHgxYndhald3R1QwK3BDc0JqL2M3enVTdXRNQW95YXhXSE0wc3p3OGJmanV1bVJ0b2Y0QWc1MjNEZnFLMWt0UXFyS3lZVzhuSnNtWWJGZHNwc2U0RDI4R3oyUzNyM3JHZFBOMFU2RWFQRkxuVXo4ZDBwWmoyUGFqZHZxMk1wRGFLZHRkdjAxck52TmJNYThPaTF0UnhTeU5HNWpxeG1OVXM1elhMdVdYV1ZsVFdZTXpENjR2NkdNWm9qZzRXVEtLaW1zd3V3SEU1a042WnpwWkFwMUI0Zk9SeXRiZjNQZGozNUJTZm5FTGhDcVVrUjRlV3hSeThsd2dFU1FiaXRrZVpITnhzQnMvSWw1VkFHSjJEbktPWjVmbEJ6ZDlQV3Y3SEx3dCtPMnd4RW95NmYrblZRdUVtNlBxZU4rY3IvbkVSK2FQWHZGNE5iSWJjZEE4Zm5rWGZ6N3hWUmpLdk5NZHp5eThITmI4ZHp6RXlaMEYvQklUSWFuS3p0cWFwTFNITThUR1hwd1VFbXpGd3NaMjQ3QndYVzVlOWRUWWo1OXVKeXo0cnNzWGtzdlMwajdnYjZKT1hjbWZpdWV0ek9tZ05oNjNoc0xXY3pDdU81L20xa1RQbUJwYXpldGRycEZBcSs5N0lCOWg3OHltTU1Sd3RGNWdxc0pnRTY5N3o4ckpIU1VHSUNaSEtWRzZoOEZoUk80UDF2NVNyQ1pFZDJNc1VSK0ZlMk91cnB2MFQ2SDdQUTYwVmUxR25rOFBJWmxENGRJRDBsbUMzdUVaZ1pKL0xUVDdRYTdCWEsxSktjand6UEQrcytPV3c1bStIRmMvbW1zTTZEenF5cnZ0OUR5RFNOVW5vOUhiNTRKK1crMFBoWFp4ek9PZVluT2ZzY3N1YjljREx5OFNyUHJEcUhPTVVTTy9NQjd4N0RsVmFjdFFZam1hV1h4YUc0eXF4TUZCYnRUTy92Ty9yNCt2WUJ3aG0xMHNVWSs3WHNYSkNwWURGWTJQRUJrL2xKMlp4WUJsSE5uRmtGVWRDYlhHaXdzdVdpTGp5djBtNy9YYjFlalZZZit1Zkk0VzQ1cTBqMFRoTW1xakVRR01HbG5YTnNxazRiT0N3emIyQlI2MmdNVFd6MmpDZnRTaWw3bnNYZmhkU1NxcktrSVFFRVRqUWppT2JlRHF2Mkk1WkpmTnJ5bzEvR3ZiUGdHOTk0NWM4UHdxRlcwU2tsRXQwaGNDK0xWZkw5YnFxekNRWENoOWtNVTg4UDFKWXZjQlFJNEpHeU1qWm1GajFqblh2OE9IdHRLc0FyTnFWaFZTS1h3NGIvdjZrNVQrZXREeGZHSTViVFdQa2crbkJLYjRHaGU5aG1oeWJybWZiVDV4MW52TUJUanZQK1RiUVRZRXBmRHJqMlJqSmswWEZ2NTIwL0xaVW5EU1NXaWNrajBObFVPeGNRYlVTdEVZaUtvbEppa1pvbHRyUU5aRitsaGhHNkFkSXVpWG9sbVFYK0pUN1NhN0sxOGdEeU92ZU96SGxmcHM4ZTVtTjhQU3UvRStGQWVrNlpPZ3hJdExVbHFhMnRMVmgxbXJhUmpHckpKVlJXR04rdUlEeVEwZ3BzNGt5Z2hRalM1TjQyZ3IrZnR4d3V2V2NiY1lyT2U5Q29mQ0kySGw5NWZ2Z3RTQkhTOGtQL2h3cEZHNk41Y0pnamVMSnNhSXlKbWM4N1lUdXN4UDc2UEpnN2pwV1MrYTE1bWh1K2ZXbzVqK2Z6dmdmdnl4NE1yTlVTdERZeHpHZ0tCUkc1OWdPRXhkRDRNSVp6cDNockhPY2JhZVBpZzFjcDdHS3A4dUsvM3d5NTdjRHlaTlcwVnFkNVprZndZTnBINmhaclZHTm9MRWEzOWI0Z3huZUIwSUkrSkJmWXdnRUZGRWFncXlZQWxtZ0lFVENWVjlUSktTOVhIZWVRTi8zTkZVNmU5M1VXbUcxUk9HUjBTR2lSNGlFVWhLdE5FcXBuSzFXR3EzZmxxWTlsdjF0VEM2NWswSncyR3FlempXVHRFZzU0bnp1MFpudWUwVUxoY0tOSWhCWDVXcHZlM0wwTHBPelYzZTY3N1VzL0pROFpMZGthelY3VSs5cENuUmpJSWlBRkFFWlFDWk5iZDZXZUlna09Ld2JqcHVHNDdybTEwYnp5N3ppK2FMaWNGWS9rQksxZC9sU3grcUhlSHdLOTBQYUNRbDAvY2paWnVSMUI2OTd1SndrRzVjWXBuZXptOWQ1bTNFUUxDczRzb2xuTThIVHVjMk44RCtRbXRlWHNpOWoreHc1Nk1tQnpPUUM0Mjd4TVpBU096UFJTSXdRZHFWQlJpdU1sbFJhNXlESGFxeFdWOC8yaDNhL3VXMzJmVVJDQ0phemhtY1RpTnJpZ21UVEI4NTB6dWFreEkwSVBEd0d2dmZlZnYzOWordktMZndvN0lVSDlGOGxwSXRQVHFId0pUUzE1K21oQnlLdEZoeFdtbWNMUzVmc1d4ZnpCSE14NThETU9LZ3FuaTA4eDVYRUZwbm93aU1oeGtpTWIwVTRYbDBPL084THorK1hudlB0OUZsZmt0cnN5emsxSjNYa3dEaVdKakN2TlUxbDBQckg3Z3Y1SHNSdUpwS1lNTm1UR0FXRThMYnRJVVpCSWhFamdFQXAwQkswQnEwRld1eHRJWDd1KzQwUWd2bXM1VW5TMk1uUWozQ3g5YnhaOS9pZGRMY0xNUWVMaFVMaGgyYmZsNml1UzBqdk5mU3o4TUI5cjJLaDhMQ1p6VFRQUmN0aUJzKzZtc3ZlczNLQ2tZcXdueEZNMERKamFSc09Xc05pNW1uYlJHWDBUemVqV25pYzVGS3AzQnV5OVpJM1hlSWZiM3BlcmgycjNuMDJ5S20wWk5rWVR1WVZUNXFSbzFwdzJCb081ZzFHYTdUK2NTU0xiNXI5UFVLSVhST3RsRVN0U0tTcjdCbHdKVWlRMzVPek5WTEl0Ly9lVzBQOHhBOTJLU1h6V1lNMkZjc2dXWFdCVjZ1SlJXVVpmQUFYQ1RGeUEwSjJoVUxodnRrSnIranI2bXBXNVpJQmVlV1RVeWdVUGtaVldhcktjblMwWkJ4SDFsMld5QjJqSk1iY0NKeGlZbVpxRm8zaGNLbFE2dWNkc0JVZUo1UHp1WVFxU2RhVDRMU0hQeThuVGpjams4OWVMeDlDaUR6VDF0Z3NxZjdMVWNQelduS3lOQnd1Wjh4bnMvdmV0QWZCUHRENTBaWE9IZ0p0VTFOWGtZVGcxZm5BU2FzNG5odW1HQkE0bkkrNFVNS2NRdUZIUjZTY3ZWWTdzMk1BYlhRV0hpamxhb1hDMTZHVXdtcEZheE1teEYyUWs0Z3gwZHFBTlJFaHlpQ2w4TGlJTWJMYWJMbllUS3k4NW8vem52UHRSRDhGSnY5eDFhcXIvaEFoT0dnTnZ4dzIvT2VUT2MvcW11T0Z4aHA3MzV0V2VLVHNGZTVhNDNrNlQvem4wd1pySlgrYzk0dytNUHBRK25JS2hSOGNJYmhTbVRSL3llUVVOOUJDNGF1UVVsSlpnOXlaekhGVlJwTFFXbUdOS0NXZ2hVZEhqSkgxZXNPZlp6MnZScHVEbk0xSTczTERmTncxYzE5bi8vRFpxOTRjTkpabnk0Yi9lRHJqcUlaRkpiSFczUGVtRlI0cCs1SzlXUzE1ZG1BUlJxTzBablNSOCszRXVuY2dpcjFMb2ZBanMrL0oyYXROd2xVbVI2QjJabUtpWE9TRmUwQ2s5NWI3WHFFdklKdk9WVlJWZGQrcmNpTzhmd3creURjYnhoVWVDekZHTHRkYi9ueXo1bDk5emN2VnhQbG1ZaGc5M3I4OU9hNWZ3NUtFQWlvbHNMdCtuT2NIRmY5KzBySnNORXFDK1luN2NBcTNqeENDZVpPemhiTTVSS0U0V3c5VVdpSjNaMnZrNTFWYTJ6OTNyMTYvOVROU0dVY1c3Z2V4NzhlUjRtMjVXbTJ5UUM1WWtnQUFnQUJKUkVGVXJuN0o1QlFLaFVMaFE2U1VjTTdodktmclJ5NTd6MW52ZVhrNWNMNzFkSlAvNU9CUVNzR3lNUnpOTFVmeml1Y3ptQ3VIRmhHNTY5TXBGRzRiclJTVlVjVGttWW1CUXpQeGZDWUpvYWFmQXQza0dWMzgvaThxRkFwM2ppRDM0MVJhVXB0ZGtGTVpoVkU1eUNtUG1VS2hVQ2k4VDR5UmNYS016ck1lc3FMZ3hTQjRkVG15R1FPREM1ODAvVlJTc0dnTXZ4NDIvTnRKeXkrenhMSVdXUFhXeCtWblZnRXIzQTNHYUJJSkpRWExTbkJVSlo0dU5FRmF6amNqSWFZUzVId3RKYnRmZUNCSWtUM1lqSlkwTmxjRzZOb290TW9sYTRWQ29WQW92RTlLQ2VjRC9SVG9nMkliYXk1Y3o0dkxEUzdrRVU3OFJDcEhpaHprL0hMVThILytzdVRRT0k1bWxzciszSExSaGJ2RkdJUFdtbFFuRGxkclR1YUdiZEFrclFneHNobjhmYTlpb1ZENFZzVGJVclZxbjhsUkFvVHZ3ZlZJSWtvS1VrckVFcGtYQ29WQ2daekpjVDdMUnZkZU1nYndnZXd4OG9VVDMrOG1hdEx1WjJWeXJYQzM3TDJEdERab1pSSEN2YzFHbEhGUG9mRERJbmNDTjFZcmFwT1ZiYk5menRUQnVFR1RVRklTVS9iNitGa2I4QXFGUXFId2xuMG1aNWc4d3lTWmZNRHZmS0crbEJBVFBpUkdGM0FpRUVLNE1yTXNGTzZTbEJJQ1RjSVFZbUR5dWR5eW5JK0Z3bytMUUZ4NTVGVDdJTWRvalhBOXVBNHRMVm9KZk5pcGpOejNHaGNLaFVMaDNra3A0YjFuZEk1KzBqcy9uSy9yWFlneDRVSms5QUVudzFlL3YxQzRVWVJHQ0V1SURoY2NQcFFLbGtMaFIwYnNlbktzbG04ek9VSUlKQkZOeENxQklaZXJoVWdSalMvY01RbFNKQ0J3VWJFWkhLZG41L2U5VW84Vzd6M2RGSmlTdUpyRlRKK3QyL2kydW80WTQ5WGluTWVIZ1BjK2YrYzFmNkhDL2JJdkh4TkNvSlJDYTRWV0d1YzlRaXFNaGlwSXJKSVltWmVVNG1kTG5HTks5SlBuWWp2eDhtSWdWUU1HVDF0YlptMkROWWFxcXBCUzN2Y3VLRHhpeG5HaUh4ek9KVTR2Ujg0Mm5vdk9zZTRuQnVmeE1mTHoxcXlsajd4K3pmdEwzVi9oL2hDQUVtQlZWbGdEMEFCU1NZelJWRVl4SUFreEZSUER3cDJURXNRRUFVMmZKT2Q5NUk4M0YvZTlXbzhXN3lNWEF3elJNSVZjU2hSdllTcHpud1Z3UHVCOG9CdEd1bjZrSDBaQ2lNUVVpVEdWM1BFRFFBcUpFUG5WV2sxVFZiUk5oVklLcFEzenhpQTBIRGFXZWFYemJKbklwV2d1eEkvT2k4V1lXUGVlRnhjOW93dDBqY003aHhDUzQrWEljdFp3dVBPZEtoUnVpODEyNFBTODUyTHIrZk44NUY5blcxNWM5cHh1SnJyUjQ3KzB3YXhRS0R3NEpHQmtub1M3eXVRQWFLV3hXbE5iUlo4a1BzU2RiMEVaZEJUdWhyUnpTWThwRWFSaGtCV1gzdkpxVXg0NnQwV01pWFd3OUNubWNvMFlpZW5tZS9IMi9SeWpDMHdoc1JrVGwzM2tjaHZ4SVJCaklzUllFc2NQQUNrVFVnaWtURFJXc2t5UnBCSk5KZERhWXF5ZzhuRFFHdWExb2JHS1JHTDBrUkFGNFNNSE1jVEVlbkJNUG5DK0dmR0hHcVUwVlJPSkRBaGcxallseUNuY0dpa2x1aUh5K25MaUgyYzlmMXdPL0hrNThNZGx6MFdYc3pnKy9NdzNvZS9Kd0pRc1R1SCtrUUtNRUR1Zm5HdEJqbElTWXhTVmtWZ3ZtWVJBcEZSY2F3dDNoa2hBekwxZ0xnaTJ3WEEyR3N5bXBCUnZpNURnYk5SMFhqRzVDZThUTWFSUE9sWi96VDFoWDRvMlRZNU5ON0FlUEYzUVhIYUJpMjNpc2hQNGtEUEhJWlpINDBOQUNyRUxjcUIxMEtYRWtEd0xMNWhWaGxtbGFDckJvckVjenl1ZUhkUmNkSTdONElqUklYYVRGZS9IT2luQk1BYUdNU0JFb3JVejJsYlJkSklVSFNJRm10b2lwVVRyTEN0OUY2VnIrM00waEhlRkVQWUtYRkpLcEpRb3BlNzcwUHdRcEpTdXlsSS90aitWVW5kV2xwaFNZbklPN3hQQko4NVhqcGNyeHovT2UvNVlEWnh1Umk0NlJ6ZUdxL2Y4ckUrY1Q5MzN2NGhyVlc1bDdGaTRLNFRJMSt5KzlVWkVqeUpnZGI2U2M1QWpKVVpuSitES0NYb2xTcmxhNFU2NXF1bVBNTHJBMldZRVlOVlA5NzFxajVhVTRIdzdjYkdkNkYwdUpic3BoYUY5aVZxSWtXMC84dWZabWo4dlJsNTNndTBZMkF5TzdlZ0pNZTBHeFVYTjhTRWd4TzVoc1pzTmE2eG1YbXNPV3N1dlJ3Mi9ITFljenkzelJ2UGJTVXVTOFBLaTU4K0xuaFNobjNMSlR6NnVILytlN2VCNXZScnk3SHJqbVlZODZCMUd4MkxXc0pqUGFKcm1WcmMxRDhZVHpudjZJWmRQVHM0aGhVU3BITnpVMWxCWEZYVXRTci9RSjlnSGl6SG1vS0lmUi9waHdudS9DNXJmN3MrbXJxanI2azdrdzJPTXJGWTlsK3VSZFovNDUrc3QvenJiOHZLeTN3VTMrejZjUXFId0l5SUFLWGVUYzlHUjNKcmtGbGN4eks0blIrMTBwVFZXSjdTVUNFcTVXdUh1U09UeXFTU2dkNEd6OVVnM0JsNnZ5c0RpdGtnSkJwZkx5QVlYU0x1QjZVMWM5U2tsZklqNEVPbGM0UFhhOGYrODNQSy8za3hNUGpLNXJMSVZFN2x4bmFKejhoRFl6NG9oQkVZS2pGWllMVG1lVjB3K1VobkZjbGVxOXR0SnkrSGNNcXMwTVNVMnZidFNUSXNwZnZLQWJrZFB1aHpZREk1aExrbkpZQ3RQRWowaEpxdzF0eHJrN0Fma01TVmNTSFJUWk5VSHVzR2pWUTV5bEpRc2trU3BpRTBwVnplVTJiOFBrck5odWR4MThwSHRFRmgxbm5IeUtDbVFVcUNWWXBrVVNpZXFheG1lMjF5bkdCT2J6dlBpck9lL0xpYit1T2o1L2FMbnhlWEFadkpNL21jdlVmc0laWmNVZmhDRUVDZ3AwRklpMDBTYXRvZ3c3dnh4M3Nua1pPRUJxeU9xWkhJS2QwemFENjVUSXNURTVDS1huYnZ2MVNxOHgxVnFlUDl2OGJZVTVUb3g1bjRiRjZBUGtyTkI4cThMei8vbnZ5NTM1V2w1S1R4Y3NnQ0JRQW80V1ZUTUtzM1RnNXEvSFVjYUs1blhOVklLWW95c3U1RTNxd0huSTBLRWF4bTZ2MzV1U29KK2l2VFRCQnVJc2FGcURMUFJJcmNKSlFibWJjVjhOa05LK2NIejYxdUpNVjROeUYwSStDam9wc1JxaExOQjBJMHFQekNWeEtoOGdpc1owVHFpWkVUSzNYNjV0bDQvWStEek5uTVRyM3J1UWt5RUpOaE9pY3NSTGdiSjRCUlNDSlFTV0NWM0VxOFJxd05TNWhsWXBXNzJHQU40bjN2OW5JdXN1OGlmSzgvL1BOM3lhajN5Wmozd1pqc3l1WEwvS1JSK2RQYlBLYTBFV2dRSUhwSzd5cnhmOWVUWW5icWEwYURsejNuakxoUUtYOGIrN3ZDeCswU01rV255ZEM3UDZ2YTdXZFA5NExmd1k1QlNJcElseGtjWDZFYlB1bmZVR2hvanNVcHhZQ08vSFNoaVhQQnlYdlA2c3VmMWFtRGQ1M0xGejVXdURjNXp1aDVSVWpCc0UyT1hpTUV6T2Mrc3FabTFEVzNiZnZlMmpPUElNRTZNazJQZGpWejJucTJUYkp6Z2NqdXk3aDM5NlBQQWU3Y2NHTTFCcFZsV0dtc0NsVTAwbGFLcExXMVQwelExMXVpZkp0aTU2cmVKa1czWHYxM0dRT2RnVEliT3dicjNyQWZINkJOSzVrbFRJeVhIbGVhd05oeTJocVpLekZ2RllsNVRXWVBSNmtaNnNjWnBZclhxV1c4ZG16N3h2MTl1K1AyczQ5WGx3RVh2Nk1kQXFWQXJGQjRIVWdpTWtsUmFVUm1OTVdrbm5KYlpaWExVVlUrTzFlVDA4dU8vWHhjS2hXOUE4RzZweVlmR2RpRkV4bW1pR3lQYklURk1BYmNMY29BUzZQd0FwRVNPWm5lbGg2UFBRYzZtbnhBMlVVdE5wUTFITTBPSUxmTVpMTThuakJJTUx1U3lSQStKU1B4RVNWQS9CVTdYSTRNTGRJMGdPSVhTRThndFIzT1BsUEpHZ3B6SlpRR01idlM4dXV6NTgzemcxU1p5TVVJM09MYWpZNXpDMnd5V0ZNeVZZbTRVQzZ1WnQ0bkRtZUpvYVRoYUpBSlpWdHRvRGZ3Y3BXd2haQk5YSHhLcjNuRzJHamk5N0RoYlQxd01rWXRSMGszUU84L2czcGFDeVYxSnlXR2xPYXcwQjdYaHlZSGkyVkVGVXUzS1ZkTjNDenprWHNERWFqUHg1Mm5QaTVYajkvT09QeTQ2WHE5SHVza3p1bEE4dVc0QmNXMHBGTzZLS3dOUUk2OFNOZGZ2STIvVjFiU2lOaXIzNUtqU0IxRW9GRDdOcHg1bU1VYkd5Ykh0QTV0QjBJK0J5WVZTb3ZhRHNTOGpmVGVUTTJHQ1oyRnJtcnJpcVJUTTI0WmZnMkRXZEV3dUJ5MmIzcE1TdTJQKzhlTys3d3M3MndpNnVjWFlPYzFncVFhSmxCT3pacnlSYlprbVR6OTZWcFBnZFNmNXgzbmdmNzFjODJZOXZRM0szRFdWTFFHMVZqUlcwMWFLWndjMXY1MjBURVlqSzAzbEZmTW9mcXBlc3JnekN2ZEowQVhGaFRPODZDMS9yZ012TGh4L1htelk5QjYzNjhlN2JqdWpwR0RaYUJhTllkRVkvbzg0aDdwaTZTWEdKNlFJVkRGK2Q2QVRBcXk2eU84WEUvL3piTXZyMWNDcnk0RlhsejNoblJMS01od3ZGSDUwcE1qOU9GWkxLcXV4SmlIbCs1a2NwYkxqdE5GVU8rRUJoVVNrOE0xZlhDZ1VIZ2RLNXBrU295VHpTbUxUaUk0RFVxU2RlZVJmQnd0U1Nxd3hOSldrOVZCYmpkVUt2ZnZiS3pXOXdvTm0zNE5scE5nTitCV3pTdE5VOHFwTVN5dEZaUkpDUnBZbThud0czZE9HMW1qT05pT25tNUZWTiswYS9mbHJvSnZFbGJ2R09FWE9ObzdLakhnMzBiZUI0SEp2WGwzdFM4U2FUMlpOOW4waTNnYzIyNDV0MTdIWmRweXVlaTZHeE1wWHZGcDdYbHdPWE83a2czMkl1M0xLZHo5ckVnbGNJQ1RRMnFIVWlJdXc3Z052TGlhT1pqMXpDNUlKSXdORzVmV3Nxb3FtcnRBNlAxdU5NVDlNcG1lYUhPTTBNVTJPWVJ3Wng0bGhISm1jWndnQ0x5eVRyRGhkajV4dEprNVhJNmZya2ZPdG94c0NrNHNmTGxOTWlXR0tTT0dKRVY1Y0RpZ2xtWHppc0FyTWRlUndacGczTlczYjBEUVZkZlZsS216ak9MSFpEblI5NEdMaitkZnJqajh2ZWw3dGpuRS9CbExNNTlxUGNSVHVIckc3Q0w5Vy92a3FnNVBlWFFxRnUwQWgwTHZuVS8wbG1SeWp3bFVOYmFGUUtHUTVZVVZiYVE1cXFLVkRwZW1xcE9kRGd4Q2xKSFZsQ1NMU3gwQmpzNEtqVWZKcU52aW5tZ0wvQWRtWGJRbVJqMmRsRlBQYWNOQld0Q1pjRGR6bFRyaEdpTUN5VWZ6dHNNSVl3OEVzOEkvWDI1MlFTTUNGbUVzV1AvR2RMa1F1dGprZzZucUpXK1RtZjIwMkxGdERTb202cmo4NjhOMDN3NGVZR0gzZ2ZEdnc4czJhbDZjWG5HNGM1NFBnMGcxYzlwRlZQN0VaL0s2TU1uNndoQ25FaEF2WnFQYXltL0E3VTlNM2x3TnpxNWxiVFdNU3RYSzBPakNySlFmemx1VThjTGlBMmlwaVRHaXRIM3lRczkvK3lRZTJnMlBkOWF3M1BaZWJqc3QxejZZZjZZSmtpSWFlaXUzbzJRNmVUUi9ZanA1dTlBd3VsN045U0tVeDdZNXZQNEVQQ1hrQjQ2NVU4YWlLbkRUd1pLRjVjdUE1Q1FJaE5aWDl2QXBiU29saDlKeGQ5THkrbkhoNTZmalgyWmJmejN2ZXJFYjZhYWNlZWQ4N3VGQW8zRGhDZ0ZHN1RNNHV5SkhpYlRYYVZVK09OWnJhWjdsUVhScHlDb1hDRGltaHNvcDVyVmsyT2NneElxQzErdWpnUXlsRlpRM0l5QmdrYmFXcGpFUXJnUStRUktMa2lSODJld1U5SlhNV3J6WTVpN05zRFpYUzJKMmo5TjdjVVd2RjRiekZhc09KZzhOTFI0aUp6VEJ4MFdXL3F4QlRkcUg5Q0pQUFFjNjZkMXhzTmRCZ0cwM1RDV0thcU8zSThXZUM0N2hUYUhRUkxpZkJpMDd5ajVYbTFTcndadU40c3g0WVhTU2tYYlpoWjBUN29ZK05LZUY4d29zY05LMTZoNUlDdXl1UE1FclNXTWxScXppYUc0N25pcWRTRXJSRVZZS1lBa3A2WW93L2hNOU9TaENTb1BlQzFTZzVIU1J2dG9vM2E4WFpXbkhaZTFhRDQzTGNFRUx1dVhFN3BjUjRUVEh4dzZwNk9jZ0pNVEdJUU84OHA2c1JveVZQNW9iZmppcEdMRWtyZEsyWUI3bjduTS8zT3ptWE9OOEUvbm5hODQvemdSY1hQUzlYQTYvWDQ1WEtYNWxUS1JRZUgzdGx0Y3JraWdLaitXdTVtdDZKRGpSQlVaa3NuZm53YjhlRndvK0IzVjJBVmt2VUR6S0JrTXVVOGl4K2JSV0hjOHZSdk9LNEZUeWZaY1BHVHcwOGhCQm9yVWhDMEJqUFlSWDU5VURUL2JKZ3ZOYi9rSDF5ZGdPakJ6N1QvVE93THpNUklxdHNhaVd4Um5MY2FwN05CRXNicVhXZU9kUDZiVW5BWGwyc3Jtd3VWZlFSN3dQUEY1TDFrU1dtT1JjNzQ5bkxOQkd2ZkdyZS9mNFEzL2J3SkFMbmZhUlpCNVNlR0x1SkZCekdLTnFtcHJLNUxDeWx4RFJOT084Wnhpd2cwRG5ZZU1udnB3Ty9YM2hlYkJMbkhWejBpZlhndjlnYjVicTBmVjdCWGJaRFJwVGJtYVk2aFVzd29SaFRZb3llclJ0WmpZbUZtbGhXaWRWcXphek5QVXh0MjZLMXZ1OUQvUTZiYmM5MmNQUmVjTmxudGJ2enpjajVkdUo4RXpqZndHVW5XUGV3NmdMcjBlMENoNjhyTzgxQjFFNThKQ2FjU0FnWFVFSmdqVWJxUUJBT2wwWkdKMW4zZ1VwNTJrclMxQVlsVmZZd1VpcVgwUTJPWVVxOFBodjQ4M3pnajR1UlAxY0RaOTNFWnN5S2pvVkM0ZkdTaFFmeUpGeHR3T2owb1hJMWhiV0dOaWxxN2JJWjZBOHlHQ3NVSGlyN01YdGpGWWV6aXFPNXhlb2ZZL3BBU29IYWxhUFZsZUo0WVRsWjFCeTFpcE1xY0xEOHROclYzcUFySlVGakJNOFdHdmU4WlRsdjZYYWxMZDJRaFFnU3FjeXlQaEFFdVFsSEFKV1dOSldpclJTTFN2RExRbkhVcWwxR0xwdGx2bytVK2VkR3dhd1MvTExVa0dZczJwYmZUenUwMkRLNDNBUGppYVQ0OFdNZlkyTFZPYVRvbVNiUE1BdkU0RkJhY3pnZk9aaTNLS1dJTWU0RzZTT1gyNUhYcTVHelBuSSt5dHczc2hwNXN4N3B4OEF3aFJzNTEySktFSE5HY25Ld0hRUXhaaFhCZGVkNHZScVpWWW9ETTNGVUo1N09EY2ZMbWllSEM2U1V6T2Z6K3o3VXdOc0podFc2NTgvem5wZmJ5SG5uT2QrTVhPeGt0YnNwWDZ2OUdPaGRZUFRoS3NENW5sMzVObmdVOUpQbmZKUExBYmRENEhMamVYTTVjVHpYbk13aVQ1YUdwNGN0bFRGWW0yV211MzdpelZuSCtjYno0bnprbjJjZGYxejB2Tm1NZENYQUtSUitDcFFVV0MycHJhS3RCSlhsbldmVHRVeU9wa0ZSVzRWV3NraElGd28zZ0NCblFvNFhsdCtPVzlycVljM2dmb3k5SWFKV2dyYlNuQ3dybml4cmptYUdSaVVhKytudHlKa2NqWlFSQWZ4eVBHYythL2pOUzlhOVo3V2RXSFVPSDNlbWdpbVJTa3Z3dlNQWloyVnljTDZvRGN0V002OGtjNXRZTkpiYUdxU1VIeXkva2xKaWpFYnJSRXFSWDA4UzgxbmtwTStab2RINW5SSGpibFkvZnJ4WEl1eUNuR0VLWEd4R3dyRkJhMHM5Z3hCSGxKVE1aMjMyYkJsR0xqdlA2MjNrWDJlT2Y1NzF2Rno1cTE2UmJ2VDR3SzVmNVB1am5Cemo1QUF0cGtpSWpuN3lYSFp1bHdITGlqOVA1NEpuQzBNZk5HTVlrRUt3bUxjOGpCRG5MWnN1OE9lYmdmLzdUY2ZyemNSbDU3anNKdnJKRTJLV1piNXU0aHR2WUdKaW55VVRwTnpMczhsQjFjWEdjZHBNdkdnNmptZVdmMzlTa2FSZ05zc2Q3VktCVFRDTWtkT1Y0NStuSGYrNkdQbnpvdVBGWmM3aStGRE1oZ3VGbndFcEJFYnZNam1WeEJwUTF6TGxHc0JvVFcwTlFjcWQrTURPeWZtKzE3NVErRUhacTFJSkliQWlzalNCNTdQRW92MHhyaXExRzZpWm5lREE4ZEp5c3F3NG5GVzdQbzNQWjZTRUVGZjlHZ2RBMndRT0k2eTdrWlZOckd6Q2hiQWJLQ1pLWi9EOUkwVDJTQk5DMEZqTlltWll0aFZ0cGJGYTdNeld6Q2MvWXgvOE5IV0ZFSksyaVRTVlo3WFJYRzR0bDMzRHBuZXNlc2U2ejRQUkQ1VTl4WmdZWTVhWDdpZkJ2RGEwbmFCYXd6VDBUT05BOEE0ZnNpTGI1U1I1MDB2K1dBWCt1SEQ4ZWRidHBJeXplTUIxeVdEeGwrM2VxMFM5KzV0OXR1TEtNK2lkWDNMbDd4Smp3bm5ndlU2emtDcFFGbUVWRXNlOG1oaW4zS056M3dhaTNudEN5UHQ5MDBkTzE0NS92ZWw0czUzWURvN044T2xzeUkydCthNU5LOFRJNENLREN3ek9zeGswM1RTaERCaHJNTlhFWEFmbWxXZGVlVjZkamZ4NVB2TFA4NEhmVndObjI0bkxuZG5uamEvalQ4Qk4rZHdVcjV6Q1hTS2x3Q3BKczh2a1dKT0ZjdlpjbGF0VmxTSHRGSFJNeWVRVUNqZUdpZ016SWlkVnpjbmMzdmZxZkJGU0NwUVNLQW1WaGJtRlN1L1UxT0NyQjJkYVNWSktDQkVKV3BBczZBZ2hpanlRTEFIT2cwRHNtN3dGVkFZYUsyZzBXSjB6ZTEvVFBKL2xwV1hPQ2hsNE1wT01KeFdWdGZ4NTN2UGlvc3NsWGp2L0pCL2lSL3M3VW9MTjZIbDUyZU5qNGt6MXZOU09QMStmRVpOZzVTU2JZRms1dytsNllOVk5WMDN1bjh2YzdGWGtsQlJJM2pXNHZjcGVmT01KT2s2QmkrMUVTZ21iQkNjTHcrQWpQb1Q4blVyZFM2Q1RVbUljSGNQa21iemt2SE5jOUk3MU1MRWRmQlptdUtkTVNFenNnaXNQQXY0ODYzRStjdEdOTExSbVlSUnpxemxkai94KzNsMzE0R3kvb3RlcVVDZzhEcVRNbVp6R0twcEtVZG1FZnI4blIydEZuVUFxUVcwbFJzc0hMM2RaS0R4MDl0ZVFTUU56TGZqbHNPTFhaMGYzdlZwZnZPNWkxNU9UZS9ac2JnemUvZnhyN2cvaTJtQXV4b2dVVUJtSmIrMHV3Q2tEazRmRy9wZ3BwWEw1MmU3Zlh4UGs3QlhYWkJTMHRlSHBRWU0xaGlmSGl0cnFxM0swbU5MT28wWjhWQUlycGNTbWQ0UVFXWFdPaFFuTVRXQlpaYkdDalJOc25LUHpNbWNDcG5BbC9meTVJR2NmNEdpVmc1eDlOZ3ZZWllEWWxWTitQWU1McE8xRVAzb2FVL09iMTB4SjRVTkNLeEEzWUg3NUxjUVlHYWFKZGVmb25PUzhkMXdNam9zK2wvWjlURkw3VHRZdHBhc0ExZStDMzR2dHlCOW5tcmxWTEl4bVhtbldnK2QwTytiTTA1VDd2RndvZlRpRndzK0VFcmtucDdGNkYrUjh3Q2NuUnowQ3BjRXFrQVFVQ2NISDVTQUxoY0tYb2FLajFUVlBqcGI4N2Rmbjk3MDY5OEwxSGc1cmY0eHNWdUg3MlFkS2U1K1l4VHd5QmNFNE9kYmR3UGttbnd0WEErdVlQaWpuSEJQMG82Y2ZQUURyV2pPdkRhdWc4U0d4R1J5YjNqRzRUd21Udi8zUTZ4NUFXZ21zVnRSV1VpbUZnQnpzQUdNSUREc2x3SkQycFhXN29DZWxqMHBQNzVsY3d2bklGamhlMW5UUk1DV05DMW5UV0pyN21Vek1tWnlKZFQreWNvYUwwYkdhQXQzZ0dTWi9MK3YwZHQzQTc3Sklrd3QwZzd2S0hzOHF6YXpPeXpBRnRrUHV1eW9pQXpkQWV1LzFhOS83emxJR2pZVzdRZTU4Y3JKUnRhR3l2RE1acDRHckdWdGlRdmdlNmJjb0hGWkxZdVRLM0t0UUtCUUtoVzlCSzdYTERpUU82OFRmanpSU0xIbDVPZkhxY3VEbFpVYzMrSGNhM0QrR0Q0bCt5Z0ZOU09tcnk2dk1yalM3M3ZrL0hjd3NSN09LWmExUkNYUVNxSlRZdU1EV0JUWStzSjF5bHFNZnM3bms1Q09URDE5VUlwV0FFQktqMnczTWg0bGFneFQyWHVTa1UwcE16dEVORTZzSitpbmdmSHl3YlhIN2xpZ1g0cFZDbmd0eGx3RjhxR3RkS0JSdUczbVZ5VkUwdXlCSHZ5ODhzSTk2cEVqSU9DSmNoeUZndGRuVlNZc1NtUmNLaFVMaG04amxieEpRU0JrNVdXUUJpNE9GWU5IMktDbm9KNGYzdVZRcHBrOWJ4Zm9Zd2JFcnEyTDNuaTkvUm1rbHI0eE5UeFkxZnp0dStQVzQ1Y204d2dpQkFSUncyVHN1QjgvbDVEbmZqbG1TZXAxVndMYWpKNFRBNS9JZSs5V0tJVEpOT1RPeDdTVllzWk9Vcis3OGVLU1VHS2NjNUt5SG5Fbkw1WDBQN3psL3RmOUlPYmhONGFxY2JTOWFVYmhueWlFbzNCTktzQk1lMExTN0lPY3Z3Z1A3K3V2OEE0K0tJMGFBMWJsWldFbFJaa3NLaFVLaDhNM3NTOWNBbnAxSURoYUJLVUpsRGYwVWVMWHE2UVlIaWM4R0RqNGtmQWpndm1JRnJqM0NzalM2NG1obStlV281cjg5WC9EZmYxbncyMG1Ma1ZrNlhVckJ4U3FiWXA1MkV5OHVlbXFqZHRJRUthdUJqZUtxclB1OXIvZ0xJVWFjaTNTRFo5TUxWT1RlSk9WampFelRSTmVQckFaQlAzcWNEdzg2WU5nSHN5N3dkY2U5VUNnOFdxUzRwcTVXR3lvTldyMlh5WG5uRFZKaGphYXRvQmE1dktBMDh4VUtoVUxocHBBaU4vb25JZ3NUK0hVQjR5OHRSNjNoeldya3pXcmdzbmZFbVB0ZnZuV1NUVW1CRkFJcFlXWTFzOW93cXpWTEd6aXNJa2ROejlOR2NHSnJHdVZSSWlGbHV2SUswaXBSNjhqQ2VGdzFRVE5nWngyTE9ISWhFeGVWWWVNMTIyRlh5dmFKbnFBUXI1ZXJRU1VnaFBBVlczT3pPQi9vQjhlbVZ3d3U0SHhST1N3VUNnK2Y2eFlkQkVPYWFtU29NRktqWk1ydE56ditFdVFvSmFtc29hbWdRZU5EUkU1RmFhMVFLQlFLTjRPVUVxMXlNSEhRS0g0N3FxbXQ1WERtcVBRR0Z5S2pqN2lRRy9mRE45VERaRCtubmFtdEZCek5LNTRkTmp3N3FEazBqcVYxSERhS28yWEw0YkppMFJpMEVpaVpaYStGRUZnam1UVWFKUzFXQk9ZbThtUXVPTDFVdkY0SHprYk4yV1I1c3hwSUtYMVJrTk9Obm0wZmFXWDJxcmtQVWtvNDUrakdpYzJnNmNlc1RsWW9RUEc1S1R4c0JGazZXZ3FCREFiaEtqUUdheFJhcGI4S0QxeEhLMDFsRFcwTlRWSU1rMFFWMDV4Q29WQW8zQkI3T1dvREhCM01xZXVLcHg2V1p3TStKaTQ2eDBYbmdFQ0l2Tyt4K2VYZkl3VkdDYXhSSEM4cS92Nms1VCtmTHppcEl3YzFuQnpNbU0vYXExSTZLZCsxVDZqckNtc05pM25MeWRHU0VBSXhSbDZmbnZQN3EwdGVyQk96WGhGallqdDQyRTRmWFpjUUU2T1BPWk5UQ1JhYVhISjNEMlRoQVU4L1RteDZ3K0Q4bGVSMm9WQW9QR1N5ekgrVy9pY1loSyt3MHREVTh1cjNlejZTeWRFNWt4TWtHNTJOUVV1WVV5aDhPZUxhYTdsMkNvVy9zbjhRV1pNZlEwWW5EaHZCczdsZ2MxSWpsZVJpTTNHK0dibmNUc1NVaUFuaUowclhwTXpOL0VaSktxdFlOaVl2cmVINVF2SzNCVHh0SW9ldFpqbXJXTXhuMUhYOXlYWDhrSS9OTUU0YzlJNVJCRVlwZUZPUEdDVStlYTJubUhBK1ozSTJmV0swNFAxOUJUbUNhYkwwZzJFek9QcHhyNjZXeXYzcUorYW1qbjA1aHdxM2lkcmQ1NjJXMUhiRTZBMVMxZ2pSL3VWdi81ckowUnByREcyVmFMekNhdmRPZlZ1aFVDZ1VDamRGTGwxVENBTHpXdkw4d0NLa1lqR1AvT3ZORmlGZ25BSStwaXNGc0k5bEhKUVV0SlZtMFJnT1dzdXp3NXBuQnpWUGx6VUw0em1vSmNkenc2eXgxTlczeXpkcnJhanJpbmtJekgyaXNRcXRQbTJVbXN2Vkl0M2syUTZCb1JhRWV5cFhpMUhoM0p4K0hGbjNHM29YU2lhblVDajhFT3lEbkd3QU9sS1pTNVNjQVY4UTVFajVOcE5UdS94QkpjZ3BGQXFGd20yZ2xFSUlnZGFLQTBBS3llRXk4YVNMQ0FIOTVEbGZqNHd1eTBSL0t2bWhaRGFNUEo1WFBEK3MrZnVUR2YvK2RNYS9QWmxoUmNCcVFXMDFSdXQzMU42K0ZxMDBkV1ZZSk0zV2h4emtmT1k1R1dOaTlObHdjeXM5UTNPZjVXcUswUzNwaHBITmNNN2swNE9Wa0M0VUNvWHI1Q0JIMFZTYXRocXhab09Vd3dmLzlnUGxhaXIzNUZUUVRsbC9XaUdLRG5xaDhJMzRKRm4zbmo5Zm5kNzNxbnd4V1YwcUwxcHBqRFZVMW1LdFFVcDV0UlFLTjhIK1hLb3JpeENDMmtlVW1qaGJLRllIaG1GcTJReWVUZWRZNzFUWElEK1d0QlFZTGRGSzBsYndaQ1o0TWd2OE1ndjhzb0RuUzgyelpZMVdPMVczR3pEZlZFcFJWNVpBWkRZSktxdFFXaUw0dUtWY2lJbkpSYmFqWnlzbit2SHV5OVZpaklRQWt4UDRxSmlDWkp4aTlzT0w2YTFqZmVIbjR5YU9mYnFoenlrVVBvSGFHWUMyVnRGVUFtc2pTbjM0cFB1QThJRGFxYXNsbWpGaHRVU1ZzVXloOFBXa1JCS0NQaHBlYlJMLzMzKys0Y1haNXI3WDZvdklKVVR5YWpCM3RKeHp1Snl6bkxkb25XWG1yYlgzdlpxRlIwWU9xbk4ycFRXQ3AzTkZlTm93Yitzc0xYMDU4R1kxNENOWFpXdU5WY3gzZlRjTG0xZ2F4MUVqT0o0TFRsckJ6QXEwekJtaW02cEtVRXBpalNHSlJEc0pLcVBmOXVUc3Z1TDlZQ2VreExUcnlka3lNWXlDRU84dXlNbmVPQUhuWVpnZ3FKR2tSM3hJTzZudU8xdVZRcUZRK0dhVUZGUmEwVnBOYlRYVzZJOU91bjVRZUdEdms5UFlpTkVTS1VxNVdxSHd0U1NBbEJpVDVXeFMvTC9uMEh4Q2Zla2hvYVRFYUlYUmtVVXJtVVFBRXpCVnBFcTdCdS83WHNuQ28wTktpZGI1L0pvMWlWK09aclJOeGROSjh2dnBsdHBrZWVmSlo2ZjdtT0NnTlR3OXFIbDYwSERVd0Z3N0Rock53YnlocVN2cXBrYXBtODA4NW9vSGtDb3hxeEtWVWVqcnltd3AvV1V5ZTkrVEE1NU5uQmhIUWJqRFRFNUtDUjg4bzBzTU1SSDFRTklUSWVZc1RvTFNrMVA0SnNSN1M2RndteWlaUlFlYVN0RlVCbVAwUjB1UFB5ZzhVRnRMR3hKTjc3RktJWVVvSjI2aDhEVmNHeXc0TEt0Z1lEU1k4R09rUmJXUXV4SWd3VUV5eUZxaUtsRGFNN01SUVVYYk5QZTltb1ZIeUw0VWNpL3BQSnNGVG54Q0prOTBJMjVnWjF5WmlDbHhNSU8vSFdwK1BhbXlxSUNWTE9jMTg5bnNWdGZSYUpBeVlUVVlHZEVpWVpRa3BKd1pFYVIzN2dNcGd2Y0pVcUFuTWdXRkM1RVF3anZsb2JkRmpCSG5IS09MakNFUnhFaVNFekZHVXNyZlc1N3pQeS9pdmRjdmZjL0hsa0xodGxCU1VCbEpXMm5hS2xJWjg5Rjc1NGQ3Y2lyREhHaDdxRXdSSGlnVXZnY1hJdjJVVlpTVStqR3VKWVZBN1l3Uit6SGdZKzRsdUZocm5yV2VlRExuNkhCNTM2dFplT1Jrbnh0SlNvR2xUVHh2SS9JZzRrTFlsYXNsWmszZ2VCWTVxQkl6SzZtdHZpcDV1MDJ5VndPSTZHSGFZaGhwYTgyMFV5cWIvTHRwa1pRU0lTVUlFSVFoNmdxSFpoZ25sSlJvclc2a1graGp4QmdabmFjYkE1cytHNWNXQTlCQ29mQ2pvWldnTW9wWnBXa2JxT3hYWlhJVXRiVWtBVzBWc1ZvVk05QkM0VHZ3SWRLUDRIejhZVW8vcndad1FyQTJrdTNvT2Q5TW5EYUNZVGt4MDNtQWVac3p6NFdmbTcxSGpSQUNLUVhIeTRaS3c5SGNrR0lpa2M5QmF5MU5YZEhVTlZWbGM1bWxNWGV5ZmxLQ1RCNFZlZ3lPV1dXUUF1SUk4RzRBa2NnbGE1RkVGSnBrWm5oUk1icUkwV21uTUhkNzZ4dENZSndtdHIxbk84Z3N5eDFLZlZxaFVQaXh5SmtjeGF6V3pHcEpWWDFOa0tNMGRSVVJDbHJyTUVxZ2hLRElaUlFLMzRZUE82bFlkOTlyOG0wb0tWajFqck9ONXRRRXpEanh0ME5iZ3B6Q3JiT1hlVFpBWFZXY0hCL2Q5eXE5UTU0TVNLZzBVY2xBVzlYRUZKbGNRUEJ1WDA1S1hFazBCMUVSZFl1WERZT0hHQU1rTU9iMm9od2ZBdU9ZZzV4MXJ4aGM5aDdhcmQxOTc4ckN2WlA0Tm5tMDYzOWY1TlVLdDQ5Umd0b281clZoVnFlc2JxbStVSGhBU29GUmlwUUNLZzVJdDBiRkVhTmxiazdjTlhzV0NvV2Znd1NFa0poY1lDQVJaRTFTTlQ0RU5OeDZMMEdoOEpDUk1pdXR0YlZoSGszTzNPcFBDd3I0a05nTW50UDF3SXR6alJXZXhrQzlYdC9hZW5iRHhKdkxudE50NG15UXJIdkg1TzdIcDZkUUtCUytGUzBGOVU1VmM5NUFYU21VL01KTWpsSUtZeEpDQ3F6d3lOQ2gwb2hSaGlCaU5tSXJFaXlGd2s5RFNna2ZJOG5ueHVxb0c2S3VpUkdDaUtqcnFsS0Z3aytHRUlLcXNzeWF3RHhxaHNtaiswOWZEeUZHdXNGeHRwNlkyWTVHSnhvRHJiazlZWkp1ZEp4dEkrZmJ3SG1YMlBTT3laZWVuTUtlTXE0ci9CZ29KWE1tcDlITUdwbURuQzh0VjVOU1lxM0ZwSVJWQ1IwSGRKb3d1Z0svTXhNckYwT2g4Tk9RVXA1NURqRXhLRW5VTFpnWkVZRzhWb0pUS1B5TVNMSFA1SGdXMGJEdUhmb3o1bkpobDhrNVd3OVlCWXRhTTZzMUx0MmVZRUxuNEhJS25IZWUwL1hJcG5lTUpaTlRLQlIrTUxUS21aeEZZNWczbXNxSUx5OVgyN00zWmF1c3BxME04NlRwOGFTWThQNitON0ZRS053NWlld1ltQVFKc2VzeEtJbmR3czlObmhqVU5KVmxIZzJOVVZnbEVZaVBYaHdoSkxhOTQ4M2xRQWlSeGlvYXE2bnQ3UVU1a3d0Y2RoTVhXOGRxTzdFZFBONUhpRVh5dDdDVGZuNi92ZVpyM3AvZVhRcUZtMFFLWUNlSUpMMUZoaHBEUmFVVlJxY3ZOd085amxLU3VyTE1tc1FjUTBvSlZ5UW5DNFdmbXNRK3N0ay95Y29RcWZEem9wU2t0cnZuWk5JMGxVWi9SaXJlaGNpbWQ2UUUyOEZoVlBhbE1yY29NZTlEWW5DQmZnejBrMmQwa2NtVjUzbmhBNVFncGZEQUVFS2daRmJhRk1HaWZFMGxEZGJJN3dseUZIVmxtVGN3UitOOHBCOUxlcnRRK0tsSlJUMm5VTmlUTXptR3R0NEZPVlo5dGx6Tmg4aTZkM1NqenpPVFFpQ2s0RFp0dEdLQ0dMTlJhZGg1RE1XaUlsUW9GSDRBcE14QmpsWVNGU3c2Vk5SRzA5Ulp5ditMelVEZithWFdWTll5YXdUelpPakg4TmtacWtMaFd4QmlsdzhRQXFzRVRhVm9LazJsYjkvVTcyY2xrUmltY0xXRS9TQW9wVStXb08zOVNkNldxeFhQbk1MUHkxdDFOWmduUlcwVVdrcEUrc1JVUU1vbGE2SDQxQlFLaGNJbkVTSXJxbFZHVVJsRmJSeEc5MmpWb05TblBkRStHZVJJbWN2VjVtME9jbGFkUThuYlUzOHAvTHdJUUVtSmxEQ3JOYytQV3A0Zk5UeFpWUGU5YW8rV0VCTnZWZ092TC9NeXVvanprU25FSWlaUUtId2hWNW1jSUpoU2ZoQWJKU2oyY29WQ29mRDlDTUJvU1ZOcDVyVm0xdlpVZG8yVUMrQTdncHg5dWRxc0VTemlQZzFmWm1zTE44L2VQVndyeWJ3eC9PMms1WC84N1lCL2Z6cTc3MVY3dFBpWStOOHYxaWdsR2FhQUVKNUVvZ2d1RlFwZmpoQ0N5aGphS1BHUU16bXFUQVlXQ29YQ2pTQnltVnF6ODhhWjFST1YzU0xsNTFYUVBodmtWTll3YnlSZGxGZHArREk3VmJocEJDQVJLQ0V3Q2c0cStHV3ArWStuN1gydjJxUEZoMGpYOVp4ZUNpb2pHWjFrRWhKQitQZzFYdHB4Q29WMzJLdXJoUVErUmlvWk1DSmdwRUN3THdHOTc3VXNGRDdEdDU2ajZTTkxvWEJEaUpUTDFScXJXVGFHV2VPcHFvaVVuei9SdmtoZGJlNEQyd0IxeWVRVWJoa2hCQVJIbkxiSTBGTHA0L3RlcFVlTEpDRjhUM0k5a3BpYm4rOTdwUXFGSDR3cnV3V1RjTTVqR2JBTXpHdkY0QlBPNXpMUUV1Z1VDb1hDdDJHMW90bDU0OHlhUUdVdFVuNSt4UExwSUVmdXl0VmlZTzVURG5KS1QwN2hsaEQ3UVhad3BDbWkwaUcxMWQvN3NZV1BJRVZDeGhIaEJ3Ulo0S0ZvQnhRS1g0ZVVFbU0wVWdwQzhGZ3gwVWpQdk5hSUtRRWVGNHFoVktGUUtId0xRbVFEMEtiU3pGdERXMGVzTlIrVmpiN09GMlZ5ZkFvc2ZManF5U25qb01KTkk2NHRCQS9CbzBTZ3Jvdnd3RzBocFVBbUQzRkNVTE9mRkxrNkRoL2dVNy83RUhzQmc3MENXeEUwS0R3VzltcUN1WjlRSXFXa3FTT3pXck5vRkVlTENqTUVsTXpudncveGkrS2NCQkQzZmxRaVN6MG5paDFWNFZaNTV4bDhBNTlWS053VVY4SURWckpzREcyVHFHNGl5TW5TbUpvV3lUd0lHaXN4T3B2eGtGSXV2U3hqbGtLaDhCNHBKVUlJaEJDSk1lSjh3SGxQQ09FdmYxY28vR2hJSWJQc3ZaUm9wZEJhWVkxQlNNWEprNmY4dDlSUVhjSmw1N2pZVGx4dUo1eVBiNlhYUC9IWkllVHlOaDhTazR1TWJpL3hYcTZWUXFId0V5TEE3REk1aTlZd3I4WE5CRGxLS2FyS0lIVmk4RkJiU2FWemMzaUVxMENuVUNnVXJwTlNJc1NJajNuQU5rNkJjZklNazN2dkQrOTdUUXVGcnljYjAwbVV5bTdiTlFLcEVscEpUbzRPa2FiaDhOQnp0cGs0WDQrY3JVY21Gd2d4dmMzTWZJVFJCY2FkZDlXbTk2eTZIQ0FWVDUxQ29mQXo4amFUbzFrMGxyWldONW5KTVJnTm80dlVWbDdwLzJjTEFGRlNPWVZDNFlQRW1QQWg0YU5rREpMT0szcS91MTljdlpUN1IrSEhRMG1CVWhLZEJGWklWSlNZQkVZSURoY05pMW5OYnlIeVpqM3krbkxneldXZnN6RXg3UUtkajMvMmRuQnNlODkyY0NpWkE1enQ0S0ZJdXhjS2haK1V2WVQwc2pYTXJNSmEvVVVHNUo4TWN0NStRSUlZRUg3QUNzZWkxVXc3NDhBeFJWSXFGWmlGd3MrT2M0NWhHQm1uaVUwM2NybWRXSS9RZWNYb0lvUHpqQzRDSUhnMzJDa1VmaVNFRkx0c2pzQm94YUkxekdyRHZEYk1hc1c4MHN4cVRXc2tCeFppNVJtRnU4cHdmaXJJcVpMSEFsWWJYRWhzZW9mNkFoV2hRcUZRZUR5a3E0U0trb0phQzlwS3NtZzByUUZyMWZkbmN1QmFjMlVLeURCaWhHZlJHRHJwU2NEa1F4bW5GQW8vT0RjeGhKb214N1liV1BjanA2dUJQMDg3WHE0Q0Z3TjRINWxDYnI2R3Q3MDRaZWhXK0NFUklIZFBZR3R5bmZpaXNSeTBodCtPR240OWFsazBodFlxbUJtc3JIRk83VXJWUGkzQTBheEhxaTVTZVVNL0pjNnRLa0ZPNFU3NTJyTk5YSHN0WjJyaEpoQmlKK29pY2hhbk1wSzJVc3hyUTJYQUtua3pRVTcrTW9FUUNaa2NWZ1lXYlV0TU1QbDQzL3VoVUNnOEVDYm4yQTRqcXo3eVppdjR4MW5nZjczWThPSjhJQ1VJTVEvd01pWElLZnk0WEE5UmpGWXNXOHV5TlJ6UEsrUVVPTEFhOVd5R3JnMlZWUnd1bTNlVUJqOUYvZW9VY3psaVI4V3FqOVJXNVlDcVVDZ1VmaUxrYmpKSlNYRVY1TXdhZzlVaSsvcDliN25hdTE4bXFZeG0zbGdPb3lYNHlEaDZCQUpSK25JSzM0bElJRkxhblV1cERIN3ZDRUhlOTF6Yi8yK1B3NGYrL3VQWCtqUk5yRFk5cDV2RTZUcHhzZldzdG83VmRnSzRVcFlxRkI0VFdrVlNUSGdmaUQ1d3NhalpEbzV4Q2hpVEJRcTBObC84ZVpVMUdPM1FRYUpWbnNrVXBQS2NMZHdxK1JuTXQ1VVFwOTA1Q3A5OGZoUUtYNG9VQWlzbDFpaG1sY1FLajBvT0pYSTg4aVZHb1BBMVFZNFUxSFhGWWhZNHhESk1ubFdueW1DMFVDZ0FNSXdUbCt1TzE1ZVJOMnZKdW5jNTIxdms1Z3VQbUpBU2t3c0lRQUtyd2JFWlBmM29pVkZnVFg0Z2YwbHBSYUh3SVBpYWUzWGEvU2Z0RFcvTGpiN3cvVWhCRG5CcXpiS1JHQndpVEFnU1VuNVpGZ2UrS3NqSnhxQ0xXYVFYbG5YdnNIb3NEdW1GUWdISW1aekw5WlpYNTVFM1c4MjZjNHd1ZkZJdXQxRDQwVWtwTWU1OGJXS01yRWJIZXZKMExzdWhDU0V4NW9zZnRZVkNvZkRUSTBRdVVadlZobVVqcWFSSDRhOTZkYjZVTDc3ektxVnlrTlBDSkRTbnF3Rmp5c3hVb1ZESXhCaXZqQXdubi9BeGxRQ244UGpaeldTSGxIQWhaM1lpRUZPV1NDOFp6RUtoVVBnNmxBQ3JKZk5hY1RnM3RCVzVmUGNyTStKZmxjbHBtcHBsa0FTbG1EY0dxMlhwSEM0VUNnQm9wYkJHMDFTUnhpdTJneXlxVUlXZmd1c3FRRm9yakZaVVJtRTBhQzIvYXVheFVDZ1VmbmFFZ01vbzVxM2xjRzZaenlSMVZYMzE1M3g5dVZxVUpDV1kxUnFqWllseENvVUNrTE85bFRXMGRhSnhFcU5sVVlVcVBIcUV5UFhqMlNCVVlKVEVLSWsxRXFQRlY5V1BGd3FGUWlIckFGUldNYTgxaC9PS2VhT3cxbnoxdmZTcmdwektHaUtTSkNLMUJpUFQxUTIrTkJZWENqODNXbXZhcHVMQUpZWW8yQTZPZGUwWUovKzJON1UwcFJZZUVZSWN4QmlkZy9xMlVzeXNwTlpnbFVDcm5NMHNRVTZoVUNoOE9WSUlLaTJaTnlZSE9iV21zdmIyZ2h3aEJGb3JxZ1RlQjNUY29rTlByUVZERXNTVUNMSFVIeGNLangyNVc5Nm5iUnBPRHBlb0tsRTNDYU1rbFZZc1cwTUlDUmNpb1RUcEZCNEJleWR1SVhMbVpsWnIybHF6YURSL085SXM2NFNTT2J2enBWS25oVUtoVU1qc016bUx4dVlneHdicTZwYURIR3NNVWtoU0RKZzBvZE9BMVpLUUJENUVZaXp6dElYQ1kwYTh0MXluYVdxZUhBdG1FOHphZ05XSzJpb1dyV0YwZ2NsSHhwM2lWS0h3STVPTjZQSnJiUldIYzh2aHJPSmdibmpTSm81bUJxTWtTcFYrbk1ManA1emhoWnNtOStSbzVvM2hhRjVUNjNpNzVXbzVrNlBSV3FPVXhNcUF3VkhyaGhnbFJBaWt6N281RndvZlltOUU5bDJHWkErWWo3bWRpeTkwN2IzOUZmekFNZmpJMzhuMDRVeE8wOVJVbFNVbVdNd2NSZ3VzRWJTMW90LzVodlNUdis4dExSUyttNzBMdDVTQ3BqSThPMng0Y2xCenNxeW9WY3pDUFBiTERVQS95cGRjazRYQ0RYQmxDdjIxNytQZFNhOHJnK2xDNFR0UVFsRHRzdVRMbWNXcVJHVy9Yb3IvbThYN0sydVp0elVIVTRYc0U0bUU4NUh3MkVhbmhjSjNNb3dqZlQ4eWpDUE9lVkxLVXN0U1NkcTZwbWxxNnFxNk1neDhFRUhQZHlBQUpST05EaHhXSHRGTWpNb3pLTWRrU3BCVCtQSEphbW9DcVFTMWpSeFVpb1hSMU1wUVc0WFc2cjVYc1ZBb0ZING9zb0JMN21Pc1ZFTEZMU3JNTVBJUXJjUTNxYlYrVTVBamhLQ3FMUE5aelpHdmlBU2NqL1NqaDFLTlVpZ0FiN00ybzR1c2U4ZHFQZENQRXlIa0lFY3B5ZUVTRG9WQ2FZMUtBazFXS2Z0UkVic3lIcU1sODlZZ3FXZ3RoQkJ3M2hOOHVVRVVIZ0c3REd3KzF6Vk5YZE0wbHFiV093bnBZdjVaS0JRS1g4TmV4TVZxU2FVQ09nMm9ORkpabFlPZmJ4Z2JmZk9kMkZyRHZLMDRDQldqZDNTRC8rRm5vQXVGbXlZbGNGSFFlY25scE5nT0dyOHp6RFJhSW10RjdRV3pDSkNRSXZFRHh6aFg5NERLR3F6UkhDeG1wSlErV3E1WEtQekk3TS8zZlFiMitsSW9GQXFGTDBjSWdWWlpjS0RXdVNYR3lraFRWOTk4VC8zbVRFNXRMZk8yNFNocHVqRnh1WlVVRVpsQ0liUHRldnJKTXdYSm05WEl5L09lMStjZDI5N2pZOFNIaEZhQzlSQzQ3QnlucTRHWmlTeGJ5OUhCREswVThodG5MaDRDKzRIZTE3b1RGd3FGUXFGUStQbFFVbERiTERhd3JLR3RFOGFvNzVvMCtyNXl0YlppRkliTExsSVpWWXovQ29VZG04MldzODNJZWxLOHVKaDRjYmJseFp1TzdlQklDVUpNS0NVNFhRMHNaNFpscTNtK1ZQeDIwdExVRmRZa2pGYVBva2VuVUNnVUNvVkM0VlBrSUNjcnNoNjBpbG1ic09iN0JGeStYWGlnc3N6YlFGQ2EwN1hiQlRuM3ZZc0toWWZCWnR2eCtuVExtMDd6eC9uSUgyODZmbit6WlR1NG5Tbm03b0t1RkcyVi9UWEczK2EwVGNQekFFTEc3TUZ4QXdKTmhVS2hVQ2dVQ2c4WnRmUEdXYmFXZzNsaTFvQzVqeUJIQ0lHMWxubWJRRXNXamFhMkVpbEJpbUlJV3ZoNnNnUmwxckRNcno5dXhKeFNZaGduMXR1T3M3WGhmTzI0M0E2c3VwRnVlS3N1SnFWZ2RKSmg5UFNqNW1CZWNUQ2ZtTFU5Q3h0Wk5BcklNeGxTeWxzdC9kcnYvK3ZMaC8rdVhOeUZ3bTN6VnBaM3I2ZWZ5clZYdUZYZTN2ZlRCMzNRUHYvKzk4L2JRdUhyMEZMUVdzV2kwUnd0Y2lhbnF1ejNmZWEzdkVrSVFXVU44eGEwbFN3YVEyTVZXa21rRUdSQmFVcXdVL2hwOGQ3VER4T2JIdnJSTTduNGw2YjdsQkloSkNhUkZjZGVYL1FZSlpsYzRObEM4TXRoaGRFR0d0QmFvYlV1UFM2RndrOUplWmdXYnB0SGFGQlgrS0hRU3RCVWlvT1o1WENlWTR4N3llUUFPK2RSaFkwd2J3eTFVV2ladlFNaVJVV3A4SFBqdkdjWUhadGUwSTlaWWozR2QvOG05K1pFb2hPRW1IaXpHbkFoY3JFWjZaL1ZhS1U0UG9wWW14QWlvbFM1cGdxRm40ZHl2UmNLaFo4SHVldkpXYmFXdzBYRnZNNUtyZC9ETndjNVJtdWtpSmdFbFU1VUtsSmJnZFVDSDhDRlVyWlcrQXJTZThzajRSMDM2QTlzVzB6NUZ6RW1ObHVIbXlLcnpVUnRGTXQ1NEhqbGlDSFNWb281aWJxcWJrK2k5a3VPd1NNNk5vWENneVpkZTMxazk4WENBK1I3enJQRW8zMkdGMjRmSWZJWXlTaEJZelNMeG5Bd3E1aFYzSi93d0pVOGJFcW9OR0hGeEx5U0RJMWhtQUp4ekFPM1F1Rm5wS2xyRGhZdFR6RUVITU1VVUdvQzkvSDNoSmh3UHBlMW5hNEcvdXVWZ2dSUEY0b25TODN6dUFBRVdzbFN1bFlvRkFxRlF1R0hSa3FCRWdJcG9WYUttVllzS3MyaXFhZ002TzgwVnY3T0lBZEVBaVU4Vm5xV2pXSUtDcGdZWGNDVmNMN3drOUxVRlllTEdWNXBCdDl6dVoxUW44aSs3R1dsVXdyNElEaGZqNUJnMDN0V3g1WVFXK2F6bHJhSmtFREtlSE5CVHBtRkt4UWVKdVZhTEJRS2p4Z3BjcUNqbGFCU2t0WW9GclZoTWJNb0JVWi9uMWZnZHdVNSs1SVpxd1NORlJ6TURHTVNURDZ5NmQwUHJJOVZ1R3ZFQjVZZkZTRUVUVjF4TUErZ0JldmVjVnBKS2lNWUprRk11V2Z0L1hMT0ZCTUJDQ1JXMjRseENseHNKbnljTTJzYm5nNkoyZWlwdEVCSVVPcjdUTEt1MXBlMysvdHorLzlIUHphRndvL0dZN2duRm40TXZ2YzhLK2RxNFd0UjVCakNha2xqSmEyUnpDckZyTFUzTXI3NXZqelFEbXNOaTNuRGNSQk1LZEtQSHIyUlFMam4zVmNvM0E5VlpWbTBEb1RqdUhhczVwSGhwR1pXV3phRFk5dDdSdmZ4NnlORzhDRXh1c0RsWnVTUE4xdTBrbHl1dGh6TkpFK1BXbzRPUUN1SlVncWx2bSsybzFBb0ZBcUZRdUV1MFZveXF6WHp4akJ2QkZwTklOejNmL0QrODIvaVF5cHJXY3dhanBLZ0Q1Nkw3WVJTSlpZdi9MdzBkUVVwVVZuSDBQZU00d1RTMGpTSjF4Yzl6c2RQQmpraEpmQ1JFQk1YbXdrbHR3d3VjTGsyL1AxSmpiR0dXUnV1VkF4TGtGTW9GQXFGUXVGSHdtaEpXeHNPRnhXTEZxd0pTQkZ2VEZ6cGhqSTVsc1c4eFV2bzNNanJDNDB1VGRHRm41aW1hYWpyR29BWUF6RUpiQXYySXN0SlgyNG4xcDlRSVlneEVVa1FJRzRpNHhRNFhZMnN0ZzNHR2s1T0JDNndrNVl1MTFxaFVDZ1VDb1VmQzZNa3MwWnp0S2c0bUFWcUN6YzVaM3RqbVp4WkUwZ0tWajAwVm1PVVFrSXhCUzE4R1I5cWVQL0s4eWIzdVNTOEQzUjlUOThQZFAxQWpCSHZQVDZFZS9GdnV0eU1YSGFCdGJPTVV5U0VMQjZnaE1qcnpLZXZrVnk2Rm1HQ2RlZDRkVDR3YTlaNEh6aW80V2hSOGVUb0lLdVVLSFV6Z2dSRlFycFFlRmlVYTY5d20zenYrVlhFYXdyZmdOR1N0dEljelN1T2xvbFpxekRmcWFoMm5SdjVKR00xODFtTnRuQ3hpYlNWd1NpWmpVRjNQaURsbkMvY0ppa2xZb3lFR0ptY1o3MGRPYjNZY0g2NVpYS2VhWEtNenIwVFROeFZ3RE1GeVJnMUxrbTZJY3RFQzVIZGZXTVVoRjF3OXFsdDh6NFJVMlRiTzE2ZTlhU1UySFlUZnp2S0d2S0x1VWNyU1VvSmErMjlIb3RDb1ZBby9FUzg3K2xVS0h3aFdrbG11M0sxbzZWazFncTBlV0JCVG1VdFVpcnFDQWRyVDF0cmpNNUJEcVNzSm5WZmU3RHcweEJqeWxtUEtPaWM0S0tYdkZ4TGhrblNqNUorVU8rY2gzY1ZlaWNrQ1VFaTBJMEJGeEpDaUYyWldTUitScDhqSmtneElpS3N5YXBzMjhGeHZwNkFBeFp6Z1E4QzBzM1ZzUllLaFVLaFVDamNKcmtuSjVlckhTNDA4MXBpSGxxUUk2VkVLNUF5WVdUQUNFZHJZTllZSmhlWWZDU0dlRzg3c2ZENG1hYUpiVC9TVDVITmtQanpiT0RQczRrWEY1NXhDb3d1TVV6dnZ1ZnVLdGZpYm9IUkJmclI0M2VtbjE4NkFaQjJmK2Q5b2g4RFBpWlNGTHk1bkRoYVRDem5QVFBqV1RRR2EvVHRDUkVrR0tmQXBuZWNyMGRFOGdnOElrWEtWRWFoOFAyY25xKzUySGcyazJZWVBjNEhVbmw4RmdxRlI0SVVnQkJJQVkwUkhEU1N3NW5pWUdhcGpFU3JCeGJrWkdOUUFSRWtFNVVZbVZXSjVjeXlIUnlwOTdnUzVCUnVrWEdhT0QyNzVId2JPTzhrTDg0N1hweDJ2RHJ2Y1NIaFE4U0hlQy9sYXRjSk1URk9nY0VGZkVqRWJKcnp4ZTlQS1YxZFM1M3duRjRPek9vTlFzQnhQZkxyY2NQQmNuWnJRVTVNaVc3MG5LOUcvanpkSXFJanhRbWl1NWY5V1NnOEtoSmNkbzcxQUJzWFdmZU9ZUXJFY20wVkhqQ2xmcUR3TlVncFVESlhzOHdxd2JLQmcxWXhieXhhQ2ZSM0dvQmU1OGJDSlNrbFFpU01URmpwV1RTU0E2Y2c1VUZkb1hDYkRNUEkyY1dLMzg4Y3I3YWFWK2M5cjg1N1hsOE14SjN4Wmt6M1h6Y1pVdzVzUWt4ZkpEcncxL2NESWU2Q0l6aGJqU2dwR0taQVArOXBsT2UzWDUvZVdsOU9TdENQbnJQMXdCK25XeFFSMG00cEZBcmZ6YWFIelpqb1JzZTZ5NmJBTVpZZ3AxQW9QQTZrRUdnbE1Ub0hPWXRhc0dnTXM3YmFsZkkvd0NBSGNrWW5OeEZwRG1Zd0pJM3pnWFUvbFVpLzhFbSsxeWs1ZU0rbUd6aTdISG16clRoYmpaeXZKMWJiNlJzLzhXNjMvV3RJYVpmUjhZRnQ3OUJTNEVPa0NSM2JRMDJNWHg5d2lBOHNIL3p1bU9nR3orbHF4T3J0bFh5MUxMMUFoY0tOMEkyNUpMVWZQZXZPTVV5UmtNcHNlZUYyRWUrOWZzdjd2dmM1WHZnWlNHZ2xxRXhXVld1TXdDb3dTbUNNdWZGdnU5RWdCOEFZemF5dE9WcEdKZ1RiM21GMDhmRW8zQzR4Slp6ekRKTm5tQlNUejBwcmo1bVVzdGpDNUNQREdCaW4yNWZKamlteEhSeW5sd01oSklUSWt4dWlQTllLaFJ0aDhvSFJ4VHlKTVhqNnlSTkR5ZVFVQ29YSGdkV1NSV000bUZmVUZnVHgxc1l0Tng3a1dHT1l6MXFPWW1CTWlmUDFnQ2xtaFlWYkpzYVlnNXpSTVV3YTUrT2pML0ZJWlArY3lRV2tnR2x5ZUgvN1FVNDNlRUpJckR0SFR1Q1VBS2RRdUNuMjVhd2g1bDVDOXhOTTJCUUtoWjhIYXhTenhuQzBxR2dydnhNaXVKM3Z1dkVnUis4eU9ZN0lHQU12YTRQUkNyR1R2aTBVUHNpK09XWGZOL05ONTByS3FmS1U4Z0tQMjRrMmJ5QlpEUHQ3dHZPYStNSFZNZmp3NTZVRXd4Z1l4dEpuVnlnVUNvK0c3emJ5dlBZQmovbTVXL2d1aE1oQnpydzFIQzlyNXEyanN2cldxa0Z1UHNoUm1xYXBTQXI2NkppMWxxcFNhQ2wzRGVDSlJ6N0JYcmdIckRFc0Z6T2VIaG5pcnVsK2RJRk5kODJuN0pHZGQwb0ltam83QlIvT0xTY0hndm1zdVQzNTZFS2hVQ2dVQ29Ydm9ES1NaV041Y2xCek5ETzBqVVhyR3c5SGdGdnF5V21iR20yaEQ1TDJ5cmNqUzB6SHlPTWJiUmJ1SFcwTUI0czV6NEtEU2pJNXoybzdaWFBNM2ZuMjJNNDZJYUN0TkVmTGlsK09XMDVtaXRtc1JjcFNIbG9vRkFxRmIrU3hQU3dMRHdZQlZFYXhhRTBPY3RyRXJOVTNLaHQ5blZzSWNneFNLbHBnOURCckRaVlZHQ1VSUkh5Q0pFcnBXdUZkdmxYWlpVL081TFFFNFVFblZ0dVIrbHloSktRb1NMdFN0b2R3MnQzVXVTL2xMc2haVlB4NjBuTGNhT2J0MTJkeUJGK3VybFlvRkFxRng4ZjMzdmZMODZQd3BWUmFzbWdOSjh1YVpTdVkxZXJIeWVSQW5tRk9LU0dUbzBvRFN4dDRjbEN6SFR6ZDhQOXY3eitiMjBxeWZmL3ptejYzaGFPUnFycjYzUDk5Lys5bllpSW1ZbUlpN3JtbnUwdU9CbTd2blpuellJT1VxdHFVVkRKMDZ4T0JvaEdrU3BJZ2dCOXk1Vm9qdTZNY29oVGZscldHS25pbVZKaW1Jejh2UWFlS2RSZEllUzZSVEY4NGVQTmJ5YWVXejduQVlaalk3a2UyKzdrVDNOMmZmZTZ5ckZGVXdWSUZTeHMxNTIxaUU0K3NZMkRaT09vNnlFNk9FRUlJSVI0RnBjQm9QUS82TkFxdkRyaXlJNXFSNkFMZW1ybnE1anY0VGlGSG9RRk5KdWlKUHNKbUVkSG15SlF5dStQMFBiK2Y0Z1d5MXRJMEVXM1UzRy9kd0xMTC9QWFVhUzNsd3BqeWcrd2dwbHhJYVY3RDlYYmc3KzkyL0owZFk4cVFDbk1GNStjdHpCcE5XODBIOXRhdDRiSkxYQzR0cnpjMWRSMW9heWxYRTBJSUljVGpvSlRDV1VWd2h1QTBRWThFUFZKSFF4VWN6dG52OXJ6bHU0VWNwUlJXUTJVTGk4cXdYemltMHlCQkliNDE1eHpHR0pxNkppMFNtL1hJTUdXbXJEa09pV0hLSE1mMElDRm5Tdm0rRmV3LzN1OHBGRzczSTdlN2NiN0NLZWg4RG1zMFhlMDVYMVc4V2pvdTJvbS9YUGI4MXkrdjBWcmZYNFFRUWdnaEhwcGlmdTRTdktHSmhtRDJSSnRvNjBqVDFQZVo0WHY0UGtWd0o4NWFtaXF3WGlpU3Rld1BFeCtzUnBXN0V4SkNmRHQzVCs2Tk1TaWw4VGt6cFVLd01Jd3d1RXo1VVpXU1NsSFFLS1c1M1k4Y2g4VHRidVI2TzdBL3BIbU9UeW1VL01lbGF0WW9vamQ0cDFuVWhrMlRPS3NHemx2RFpoSHAyeHAvNmlnbmhCQkNDUEZZS0JUUldmbzZzR29keXc3cUtuelhIWnc3M3pYa1dHdG8yNXAxdHVBMEgyNFBoUGZTM2xaOGYxb3JRQU1aaFVhcmdqWG11dzdLL0ZRcGlud3Eycnplem1WcS8vZk5scis5Mi9IdTVzRHVPREdsUXM3bEQ5Y1VuS1p2UE1zMnNLd0xyM3A0dFRMOGRGYlJ0eFZOVXozMHQxc0lJY1F6SVM5QmkyL0phRVVNaG1YcnVWeEYxcDJocWF2dnRudnpxZThjY2l4ZFU2TzBSL3ZDMzkvdENFNUNqdmorakRGb1hUQkZVNndodS96REFnN2NsYWdWY2xIM1ozSCs3OXN0ZjMrNzQyWTNzajlPcEpUdlo2RCtKOTRaK3NaenNhNjQ2T0JWRDcrODZ2bkw2MHVjc3pqbkh2YWJMWVFRUWdqeEx5Z0ZWYkFzV3MvRnVtWlZPK29xL3BEUyt1OGFjclRXaE9ESUtLWThFbTBpbUVSd2hwVG5BOWxaSm9NSytPMjA1Vzkway9pMHp2TkhEOGdjYnJmc0R5UEhTZlBoNXNqNzZ5UHZQaHk0dWhrNERCUFQrTEYwN2wrOWxtR014dG41c3F3MTZ6cHozbVF1RjQ3elpXQ3pXckJZOU45dXdRWFU3eTVDQ0NGZUJzVlgzdmZMNDRmNEYrYk9hbENkZG5MT1ZoVzlkOVQxTXdrNXpscEtnV0VZOEJ5SWVxU3JIY2V4Y0J3VDQ1aVFuQ09lbTV2YkhXK3VkbHp2RFg5N3UrUHQ5WUhiL2NoaG1PYnpPSDl3bzQ5aEhwYlYxNTVOazdqc0ZhOFdpc3RWWk5uWFZERSs5SmNvaEJCQ0NQRXZhUVVvaFRHYUtoaTYxbk8yakZRMlVVWC85TXZWbEZKNDd6QkdNMDN6VGs2MEUyM2xVU3FSUzJHYzhvUE1MaEdQekRmZXhYblFMNlVVYm02My9QcjJoci9mR1A3MmZ1RGQxWUhiM2NoaFNPUmN5SDkwRHNjYVZtM2dZbFZ6MW95OFhtbisrbXJCeGRtS0VBSXhob2YrTW9VUVFnZ2gvb2s2QlJ5dDV0azRWVFFzV3M5bVVlRjBvZkxtNmUva0tLVXd4bUNNb1lyVFBNQ3dNaXdhRDR4TUtiTi9EczlxaGZoRUtZWEQ4Y2lINnkxdlBqamVYNC9jN0liN1haeC94MmlGTVFxakZWMmxXTmFLaTRYbW9vKzgyZ1JlWFc3WXJOY1AvZVVKSVlRUVF2eDdTbUhOUEFBME9rM2xvQTZLdm5iemN4MzkvZHBHZitxN2hweFBhYTJwNjhpcWI5bXJBUHJBY1V6YzZQbGd0aERQU1VxSmNVb01rMlpLaGZRSHJhSzFnanBhbXVob0tzZFptK1pCbjEzaWZGbXo2R3FDdElrV1FnZ2h4Q04zMTFHdGpwWmxZNGhtd2pGaTlMeTc4NlBtK2YzWWtGTkZWb3ZNNUJ6RFZMamREYWNrSnlGSFBDODVaYVlwTVU2RzZXNG16bis0dmxLS09scldpOGhtRVRtdmo3eGVXZjc2YXNGcTJWSlhGU0ZJaVpvUVFnZ2hIamVqRlpXM0xKckFzdFhVTHVOMXdocjlYWWQvL3Q0UERUbE5YYkZjS0ZTdzNPd20zbnl3YUFrNTR0N3pPSmlqbEtKUW9CUnlPUVdjVWxELzRtdTdPNWhuamFLT2huVm4rV2tUT1dzTWZ6bXYrVjkvZlUzVE5EOW81ZVdUdDAvN1p5Q0VFT0pMZmUxajhQTjREQmRmeitpNWdWTGZlTmE5b1kwVHdlb2YzdW4yaDRVY3BSUlZqQ3c2alEyR04xZEhxdWh3VmpOTUNrNnZkRXNQQXZFY3RFM05aajB5T1lkMUE3a1VEc2ZFbE9ZSGdGeE9yM1FFU3gwdGJUUmM5SERlakp3M0EyZUxRTmRVV1B2RGZrV0ZFRUlJSWI2YU1ab21XdFo5NEh6bFdYVHBRUm9tL2RDZG5Lb0tGRzJJeWRDLzNWTkhpN01hb3hVNTgwT0hOWXJIUmYzdThwUXBwV2lhbXZOMXdVWkRZYy8rTUhKMW96bU9lbTRmblF2V0tQckdzZTRqNjg1eFZvKzhXbnQrdVd6cDI1cTJyWC80cXg1Q0NDSEVsM2pxajluaTI3TmEwVVRMcWd1Y3J5cVdWYVo2emlGSEtVVU1BZTg5dVNqNjFsTUhpelVhclJXbGdQcURjd3RDUEJWTlhiTXBocXJSSENkNGYzc2srQjN1bUpqUzNHSE5XVTFYZXk1V0ZhODNrYk5tNHVmemh2LzlYMy9CT2ZkRDYxYUZFRUlJSWI0RmF6UjE1VmgzOHlpTXhoZXE2c2ZQOS91aHRUREdhTWdaVmNDcmdjcE5yRnNMcFhBWUVydkRSTW41Ni85SDRzbFJQSy9kSE84dGRVb29sVGhyTXVPWm9qV0IyNE5ubURSRDBtZ05xd1kyZldIVEpOWmRvRzlybkhNL3JQTUk4RStUcW1WaXRSQkN2Q3ovZEovL09ZOEJwK00zOTQ4Wjh2anhvdWxUYTJpakZkRm1BZ2VpT1ZMN2xpcFlyUDN4bFNrL05PUW9wVEI2THRkeGFxSnhtVlh2S2Nwd2RYdGtHQk1wL2ZEdmdSRGZuTE9XS2hTMEdqbGZSU3BmZUwwT2pGbWZRbzZobEVLMEkwMVFOSldoYXlxYXVwYmRHeUdFRUUvSHA3MEdKT0M4V0JxRnR4cnZESlhOZUhXa3NoTnRaZkhlNFozNzRXdjY0U0ZudmhTQ2d5YkNXUjhvSk1ZeGNiTWRmdmczUUlqdndYdVB0WllZQTAwZFNTbFR5dHh3SUJmRmxCV2xGSXpLV0ROdjdScGpzTlpLeUJGQ0NDSEVrMkswbWdOT3NGVHVTR1VUVFRRcytoYXQ5WSt0VURsNWtOWk5TaW1xNEZuMUZaUFNaQWEyK3dGcjVjbWRlQjZVVWhoak1NYmdQbm4xWWc0NkJRb1VDZ3FrdVlBUVFnZ2hualJuNTJZRHl5NndhUTE5cTZsaStNMXpvQi90d2ZyVDFuVmt2Y2dZRDBQU3ZMcys0SXhHSzZTVnRIaTJsRkpvN2dLT05CWVFRZ2doeE5Qbm5LWnJQT2VyaW91K3NGcVlCMmtiL2FrSEN6bFZqS3lXbWxqRDdsajRXKzF4Vm9OUzBtVk5QR3VmQmhzSk9VSUlJWVI0NnJ5ZGgzOWVyR3RlTFRUTFhoT0NmOUExUFZqSThkN1RvUEMrMEVaRjVRdVZWMFJyeUxrd3BqelBFeEV2d2t2cjdQVm93czNwZTYxNGVUOERJWVFRczYrOTcvOU5kMVI1L0hneGxEcDF3MVdLNERWdFBROEFYYThjZmEwSi9vV0dIR00wemhvZzRmVkVOQU45MUJ5N3dQNHd3WEhpbUtYVm1oQkNDQ0dFRUkrTlZ1cStkWFR3aHJxeUxEclBxby9VUWVQOHc1M0hnUWNNT1Zwcm5MTm9yUW0yVU5sTTN4aUdQSGRmR0ZQaU9EN285MGFJbDBOYWdBb2hoQkRpQ3lpbHNFYmhyQ0Y2UTF0YmxwMW4yVmQ0by9IdXdXSUc4TUFoUjJ1TnRSQ0RwYXN0cTA0eFlaaFNabmVRaENPRUVFSUlJY1JqWk0zY05qcDZTeE1OVFp6UDVTeWFDcTBmdnJuU3cwYXNreGdqeTBYTFFFWTVPSTZKcXh1Wm1TT0VFRUlJSWNSakZMeGgwUVlXcldmVkdXcVhzU3J6V0k0ZFA0NlFFenlyUlFjMmsvWEUxYzBSNTM3ODBDQWhoQkJDQ0NIRUg1dERqdWR5WGJQcG9QRUtkOXJCZWVoZEhIZ2tJU2ZFd0hJQlBtWVNSLzcrZG9lM01pQlJDQ0dFRUVLSXh5aTRlU2ZuWWwxejFtZTZ5bUh0NHdnNDhFaENqalVHNytiVzBVRWZDV3BINVNhNjJqRk5tU2xscGlTbm9aK3pUOXRQaWgvcjArKzcvQnlFRUVKOEtZVThmcndVU3MwTkJ4UVFnNkZ2SGVlcnlLYURybkU0KzdBZDFUNzFLRUtPTVliZ0hWb3JLbGNJWnFUeW1hNzI3SThUaCtQRWxLU2R0QkJDQ0NHRUVBOUZLWFZxSFExMXRDeGJ4OWtxc21vTnRUZTRCKzZvOXFsSHNSSnI3UngwY3FhdEhKWExOTDdRVkhNYW5GS0dRVUtPRUVJSUlZUVFEMFVyVHJOeG9BcUd2dldjTHlzV2pjY1loYldQSWxvQWp5VGt3SndNalRHRTRPbmJtczFTazZ4SEtUZ09FeFFwVjN2V0N2UFArUDRpRzk0L1Z2bnRSWDdmaEJEaTVTamxUOHhLK3hlUEczZVA1ZUpaVW9wNUprNndWTUhTaEVMUUNXL0JPWFBhNFhrOGpjTWVUY2k1WDVCekxQcUdpOEdodkdHYU1yZGJhU2N0eFBjbEQwcENDQ0dFK1BlVVVzUmdXYmFCUmVmcG9pTFloRkZnSGxGWHRUdVBMdVI0NStqN2xva1I1ZUYyTi9MbXcrR2hseVdFRUVJSUljU0xwWlFpZXNPaW05dEdMNXFSNkJUV2Fvd3hqeXJnd0NNTU9jNVptaXFRc21KTUk0MVBCSnZ2dTYvbFVzaFpYblVXUWdnaGhCRGlSMUFLaklMNnRKTnp1YTdaTkNOdEhYRDI4UVVjZUlRaHh4aERGVDBGT0I2UFZQWklaVWZheWpGTWlXSE1qQ1ZKeWFjUVFnZ2hoQkRmbVZaM1orY1ZUWFJzK3NqcnM0WStKdHJXWTh6am5HMzU2RUtPdFphNnJuRE9rYWFKSmhScW4ybnJ3TzZvS0dWa211UUVnUkJDQ0NIRXQvRDdlV2xDM0ZGcS9vL1dDbXMwVGJTcys4RHJzNGJLRitwb0plUjhMcTAxSVFSQ0NLUTAwVFdldnJZc3A0QldrS2JFSHZrbGZHN3U3MkFMVUJRcHcrRTRjSE56ODlCTGU3YkdjV0lZSjZZRUtSZEttUzhndjE5Q0NQSFMvSDZRNTU5OUhKREhqK2RGbzdCYTQ2eW1Eb1kyYXJyYXNGNEVuUDE0SHVjeGVuUWg1MVBHR1BxdTRmSU1pQjVyRk9PVXVka09KTm5LZVZibXp0SHptYXNwYTdaSHhUL2U3ZmovL0gvLys2R1g5bXlsbFBuMS9aSHRBWWFwTUtWTXprVktRWVVRUWdnQnpGM1Rtc3JTMXA1bGErbXFUREFUUm9NMUd2T0lXa2IvM2hNSU9TMFhvOEhXam1rcTNHd0h0RllrYVQ3d3JCUWdsMEpLaGJFWTlwUGovYTNHLzdwNzZLVTlXeWtWUHV3VXU5RXlqSVZ4eXZPT3prTXZUQWdoaEJDUGdqV2FPanJXZmVSczZlaHJpQUdjMVJpakg5VmNuSDlhKzBNdjREOHV6bHI2cmlFclM2ZzExN2NIL3ZITzNtK3B5aXZPejBndVpLV2dGRkoySEZMRjFiSEMzUGlIWHRtemxRdmNIRE9IQ2NaeFR4b3pPUldVN09ZSUljVEw4dWxjejYvOSsvTDQ4YXhvRFUxbFdTOENsNXZBc2t1MGxTTUUveWc3cW4zcVVZY2NyVFhCTzVxWUtIa2ttZ1BSSEdscnkzRW9qRk5obWhLeXFmUDBGYURrUXRZd2pJbWI3WUF4aXNOeGV1aWxQVnVsd1BYMnlPMXU1RGhtcGpTM1o1ZGZKeUdFRU9MbFV1cDBSa3NwZ2pOMHRlTnNlZXFvVm1XcU9qNzBFai9Mb3c0NVNpbGluRi9KTjBiUitFUVRNb3ZHY2FNTDZqaVI4L3pxczNqNlNpbVVETU9ZdWQwTlRDbHpjenM4OUxLZXJRSWNqaFBITVRHTWlaUmxCcFVRUW9qUDkvdXViSS83ZFgzeEpiU2VPNm81cCtrYXo5a3Fjbm5XVUh0bzZzZS9pd09QUE9Sb3JZa3hFa0tnbVNxNjJ0S0dRbHM1VWlua1ZEZ09DZGtiZmZwS09mMFVTMkVzaVdsSzNPNUc5T1AvSFhxeTVuTlFRSmwzYjZSRVRRZ2hoQkIzdXpoR2EveHBKMmV6ckhoMTFtRjB3YnRISFIvdVBmcFZLcVZRU3AzTzU5U3NWeTBITE81Nm9wVEMvampQelJIUHlDbndsRkxJRDcyV0YwVHlwQkJDaUQ5RDV1dzhMM2ZOQnVwb1dYZVdKaVNDU1RnN0J4OWpIbSt6Z2Q5OEhRKzlnTStsbEtKcGFzN1dDZVVOU3UvWkh5WStYQjhlZW1sQ0NDR0VFRUk4Qzg1cTJ0cXhYa1RPbG9ZbWdqTVpZK2FROHhSSzFlQUpoUnlBdHFrNVh5dGlyUmttZUg5OWVESnBVZ2doaEJCQ2lNZk9Xa1BiZURiTGl2T2xvYXNWTVJpOGN3QVNjcjQxcFJReGVMbzJvMjJpOFluS0phS0RnOWZ6b2VtVXBkT2FFRUlJSWNRWCtacit6d1hwSWYwODNIVlZDMDdUMTQ3elZlUmk3VmgxaXVvSnRJeit2U2NUY2dDY2MxUXhvOVJBN1NlaUhXaWlZa3lPNDVBNEFubVNVeHhDQ0NHRUVIK09oSlNYU0t1NW81cFNpdUFOZmVjNVc5VmNiQUp0cFlneFBQUVN2OWlUQ2praGVJelJ4T0JwSzAwVENtMWxtTXBjc2phbGpQUWdFRUlJSVlRUTR2TXBwVTV0b3pVeEdMb21zRmxHTGpZTjNrSUk3cUdYK01XZVZNZ3h4bUNNSVFUb21ramZlamFMQWxxVGMrRjRuRGpLQ3hCQ0NDR0VFSi92eno1M0traTEyak5odENaWVRmQ1d0akswRWZyRzBMVUJxOVdUUEFQL3BFTE9wK3E2NG15OUlPdUNEWm1VQzl2ZHdIYi8wQ3NUUWdnaGhCRGk2UWhPcytnQ2l5NXd0bkEwSWVOMHhwNUsySjdhZVJ4NEJpSEh4WUsyUjdhN2dUZnZ6VU12U3dnaGhCRGlTZm5OMDFmWmlYbVJncmNzdXNEbHB1RjhDVjJsOFc3ZXdaR1E4NFBGR0ZrdElWYVpjWUovdkxGRXAzRkczVTl4bDA1clFnZ2hoQkQvbWVMUEQvUlUvK0lpbm82NzdCS0RZZGtGTGpjMTV3dEYzeGxpY0JqemREY1FubXpJY2RZUXZhV1VrV2hIYWpmUU40cjlNWEljRTRkalloalRReTlUQ0NHRUVFS0lSOGRvaFRGenM0RzI5aXo3aXZOMXc5bEMwOWNhNzU5ZXM0RlBQZG1RWTYwbGhJSXhtanBxbWxoWU5JWWhPVzYyQXprWENUbENDQ0dFRUVMOEM4WW9yRFU0cTJscXg3SVBuSzlyTmd0TDlPcCsrT2RUOWFSRGpyWHo4aGZYTi9TTlpkVm5KaHc1Rnc1SGFTWXRoQkJDQ0NIRXY2S1Z3bGxOOUlhbWRpeTZ5TVc2WXIwSTZGTkw2YWZzeVlhY1Q4WGdXYTk2eGpMaHZDTG53bTQvY3FVR0tJWFRFUjBoaEJCQ0NQRjdYOVArdVh5RGYwUDhjRm9WNm1oWjlaRmxIOWgwaHNZbnJNNW9wVkNLSjlsczRGUFBJdVNFR0ZndmU0eEwrSkRaSFNiZWZ6aWd0YUprN29PT0VFSUlJWVFRTDU1UzFKVmpzNnI0NmJ6bGNxWHBLb1UxUFBrZG5EdlBJK1I0ejJyVlV6Y1o3MGZlZmRqelA5Rml0Q0lENlJSMGhCQkNDQ0dFZU9rVVVFZkwyYXJpbDljZHF4YjYxdUdkZmZJN09IZWVSY2l4MWhKOHdaak1majlReDB4ZmF6Wjk1REFrRHNlSnczR1MzUndoaEJCQ2lPL29lVHc5ZnA2VUFtTTBSaXU4VTFRdTBmcVJaUU45NDZpcmdESDZvWmY1elR5TGtLUFV4MkZGM2tFVE1xdGU4MnBvK0hCOTVBTndsSkFqaEJCQ0NDRmVLS1VVM21wQ3NGUkIwWVJFSFJKZHJXa2JUNHorU2MvRitiMW5FWEswMWxockthVVFnNld0TmV1Rko2bjVCM1VZSnE2VWtwSTFJWVFRUWdqeElta0YzaG5xYU9scVExdU50SlZpczJxcDZ3cHJMVnJMVHM2amMvZERDY0hSdHhYSFVXTzg1VGdrYnJZRDFpaW1YS0FVc21RZDhRM2NkUjZaeitkOXNrRi9keHU3ZXl0NzkwSUlJUjYxcjIyTjl2c1dhK0l4MGxwVFZaWlZIOWdzQSt2bHdLS3JhTnNHNy8xREwrK2JlelloNS80THNwYXVieW5hRTJyRnpmYkkreXRIOEFZMVFjcUZrckpzNm9pdnBwVENHbzIxR25NNnBGY0FTbUZLbVNtZGJtc1B2VkFoaEJCQ3ZHaEtnVFdLcnZGY2JHcCt2bXhZTnhOOTN6NnIzWnRQUGMrUTA5WjRINm1QbVhkWGUvN3gxaEc4cGxCZ3l1UWtyek9JcjZjVjJOTVFMV2YwYVlld2tET29NVkZLa3R1YUVFS0lSMC85N3ZKbi9oNWYrSGZGajNOWGVXS3RvbXNjRjV1YS8vcHBRUk1TZlJjbDVEd1Z4aGlhdXFLS2hUaE1MRnBIMTFpNnhxR1ZZbDlHMGlqSGM4U2ZvOVhjUDE1cmpYTlFCYWhDSmxoRndaS3pveFRMWGc4WU5hQVlTRGxSY2lHWFFpbnlFQ0NFRU9KeFVmREZyOGo5NXRHc2dQcmtJaDZQK1htTHhocEZkSnF1TXF4N3grV214anVvd3ZNNmgvT3BaeGR5WUU2clNoVzBLa1NYV1hXR1gxNzN2SDEvNE4zVm5tRk1KRG1ZSS80RTd3MTE1V2dxUngwS3RSdG9xa3dWREtVMGxMS2s1SjZyN1pidDhaYmRjTVgrZUdSL25EZ2NScWIwMEYrQkVFSUlJVjRLYXpWVmROVFJzdXdNVFVoRU94SGMzSVRnT1hWVCs2ZXYvYUVYOEQwb05iL1NiclNtam9iTndwUHhhS1VaeHNTSDZ5TWd6emJGbC9QV3NHZ0RtMlhGc3NuMHRXUGRPNWFMamxKYW9DZm5qdi81UjhYYks4dlZQbkYxcS9od2ZXQVkwbWt5clJCQ0NDSEU5MmVNcHE0Y3F6Nnk2VFY5bzZnalZORmhqTUZhQ1RsUGpsSUs1eXhkSFJoWG1WZ1p4akZ6ZGJQSEdNVnY5MldsaEVoOG51QTFpOVp6ZWRad3NWU2NyelMvL0h6R1Q2OHY3NitUYytILzlmOVcvUC8rVCtiWHF6MWFKNFloY1hNN01EejBGeUNFRUVLSUY4Tm9UVk01Vm92STJkS3c3QXBkRTJpYStxR1g5dDA5MjVCekp3UlBVMDNBU09VT1ZINmtid3hhS2NZcE00NUpYbHdYbjgxYVE5dDROc3ZJMmRxeTZBekJ1Mys2WGwwTnJKWVQySXBoR3JuZURtaWprUjFFSVlRUVFueFBIODhQSytyS3N1d2lsNXVHMTJlZVZjZUxDRGp3ekVPT1Vvb1lQYVVVdkRmMHRhS0xoVVhyVUtxd080emtuT1Y4anZoc3ptcWEyckZlUnM0MmtUcG9RZ3kvdVk1U1VOZVoxVUpqZmNWdVAvRG0zUTZqWmNkUUNDR0VFTitYVWdwajlGeXFGaDNMUG5DNWFmajVWVTBkb2FualF5L3hoM2oySWFlcUtrSUlsRkw0K3ovZTBMZWF4VTVUVUtSY09Cd1Q4dXE2K0Z6T2F0cmFzVmxWbkswYnJPR2ZkbktVVXRTVm9lQ3Bhcmk2T2M2MXJ4SnloQkJDQ1BHZEtUMkhITy9tcGdPclBuSjVWdlBUWlk4eDgzT1psK0JaaHh5NFM3UHpvYXF1YmJnNFcxSU1oQThUQlRnY0o0WXhReW1jaHRRTDhlK2RYaDF4MXVDc3daemFTZitlMWdwck5hVW9uTlh6T1RBbElVY0lJWVFRMzVlM21rWGo2THZBK2NyUk4xQ0ZndmNhZlhvZTh4STgrNUR6cWE1dHVEaUhVSVAxQnc1RDV2cjJ5RzQvVWNwOFlGd3lqdmhQbEZJb0ZQclV3VS9yK1hQLzZucnpkUlJLcTlNZ3JvZGV2UkJDQ0NHZXUrZ05xMFhrOHJ6bGN1Vll0SnJnNXlZRWQ0TkJYNElYRlhMYXRrRVp4MklKcUMxWE4wZis4Y1ppakNhbFBEZFprNjBjOFI4b1FDbU4wdm9VWVA3TjlUNEpRZjh1Q0FraGhCQkNmR3NoV0ZhTHlNK1hIUmNyeTdvM3A1YlIra1U5SDNsUkljZDdCMG9UVStGRHM2T3JGSXZHY3RnSERzZUovV0ZpU0hJK1Ivd242djYvbjNVM01hZWlqeDlLaGhaQ0NQSFlsTis5L1FLcW5DNmZ2QzkrUEdzK05odG9JclJWWWRuQ3FuZDByU2Q0OTZJQ0RyeXdrS08xeHBxQ1VwbGdNMzBERit1SVVwYjNWd2R5TGd5amhCd2hoQkJDQ1BGME9HZW9vcVdLamtVRGJaam9xa0xmZXFySzQ5eUxlc29Qdk1DUTQ1ekM1RXdkTGN2T2NqeXIwQ2FUYzJHN0gySDcwS3NVUWdnaGhCRGk4M2xyYUN2UG9nc3N1NUZGYTFqMmtlV2l4VG1MdFMvcUtUL3d3a0tPVXVyK3JFUmRlVlo5aGRZSmF5Y094eU5YMTRZcnF5bTVVRXBCeHVjSUlZUVFRb2pIU3FtNVZEQjZTOTk2empjMVo5M0lhaGxaTEZyYXRubm9KVDZZRnhWeVBoV0NaOUUzK0RCaHpJSHR6bkYxN2JqZU9vWXhNMDFwYmkwdGhCQkNDQ0hFSTZQVlBMSkNLVVZiTzg1WE5iKzg2bGgxbWZYUzQ1Mzcrdi9KRS9aaVE0NzNucjVUTkhYQ0tNWFY5WTQzbmVOdDdka2RSdmFsZ0lRY0lZUVFRanh6Nm5jWDhmaXBVOERSZXA3RjF6YWVzMVhGejY4NkZxMm1yUTBoK0lkZTVvTjYwU0hIKy9tSFg0RFYrMXVXdldmUkpSU0ZOR1VPTWpWSC9KTS9kNXY0K09BaHR5a2hoQkNQaTZMOEx0eDg3bU5WK2QzN1JSN25maERGZk5iY080VzFocTYyYkphUjErY05YZXV3VnMxZGhWK3dGeHR5UHFVVXhHQTVXMVVjUnNmZjNaYVVDN2ZiSTNENnRaWGZXU0dFRUVJSThRaG9QWmVvOVYyZ2J3UHJoYVlLRTlabWpKbDNlRjVheStqZms1QURXR05wbXNqRm1VYmJSTTZGMisyQTFvcGNRSlVpcjBzSUlZUVFRdndUZVliMEVKU0NwcDVmb0g5MTNyQlpRRk5ydk5OWXE5RmFmLzMvNUltVGtNTThKSFRSTjNnZnFadk03VzdnNzIrM2N5YzJDaGtsV3psQ0NDR0VFT0pSMEZyUjFKNnpkYzB2UHkzb3E0bEZING5SNDE1NHc0RTdFbks0cTJtMGxBTERNRktIaVZXbitPbWlZMzhZMlIwbWR2dVJMRDJseGRmY0JNcFgvbjBoaEJEaWV5ai80dkpuLzU0OHpuMDNXaXVjMVRpcmlaV2lEUk5OT05MWEUxMXRxYXNnT3ppZmtKRERQRC9IV2dOQUZReGRyVGhiT3Fia2VQdGhEeC8ySEk2VGhCd2hoQkJDaU4rUnptdy9odGFLRUN4MXRIU05wcTloVWNObUdhbWpwNm9peHBpSFh1YWpJU0dIMDA2TzkxaWJLYVd3N0FPSFk4WTZpMUp3UENZK1hCMGZlcGxDQ0NHRUVPS0Ywa29SZzZGckE2dE9zMmdUbTFYazllVUdZd3pHR05uSitZU0VuQk9sRk1ZWXZIZDBiY3R4Q0NqbHViNDIxS0ZRVjBlTUdra3BrMUpHSnVpOFRGL3pLcFc4eWlXRUVPSzVVY2ljbmU5SnFkUDM5UlJ3K2pad3NhazVYem5PbDVubG9xT3Fxb2RlNXFNa0llZDNqREUwZFUxS0JXYzk3OThyK2laeDIrN1phVGdjSnc3SElxVnJRZ2doaEJEaXUxSktZYlRDR0UwVkhhdEZ4ZXZMbHA4dWF4WjFvZXZxaDE3aW95VWg1M2UwMXJSdFJRaXc2QTN2M21XdXJvOXNEMWRvbFNqQU1HYkk2YUdYS29RUVFnZ2huakVGR0RNM0hLZ3F5M29aZVgzWjhiOSs3Z2dPNmtvNnFmMDdFbkorUnlsRkNJNFE1by9YYThYVnJXR2l4dHBNS29YOWNXS2FrZ3dKZlluK3pNKzdmUEpXYmk5Q0NDRWVtMi94K0NUZDFiNExheFZWdE5TVlk5MTdscjFoMVZuV3l3cWpGZGJLR1p4L1IwTE9IMWowRTY4dUlOWXRQa0RPaGQxdVpCcm5vYUU1RjZSeVRRZ2hoQkJDZkd2ZVcxYUxpdk5OemZuYXMrb01WU2dZcmRCYVNhT0IvMEJDemgvb09vM1NrY1hCZzFiczlpTnYzdS9ZNzBjbUNybGsyYzRSUWdnaGhCRGZqRHAxY0lqZXNGcEdmbjdWOGVvc3NPdzFUZVd3VnFPMVJpbHA5ZkR2U01qNUEyMFRDTjZ5eUxBL2pMeDU2K2theDJFL2NSd1NKUmV5N00wS0lZUVFRb2h2UU4vdDBpaEZGUTNMem5KNUZubDlVVk5IVGROVVdDdFA0ZitJZklmK2dOWWFiUXFXVFBTWlZhZjQrYkxHTzh2N0R3ZmVYeDBZZDhOREwxTUlJWVFRUWp3RHdSdnF5bEZGeTJaaDZLcE1FeEoxMUZTVngxa1orUGs1Sk9UOEFhMDF6a0pTaXFZeXJKZWVrZzNCRDFCZ3R4KzUzVDMwS29VUVFnZ2gvcHcvTytORzV1SjhIOEhQODNCV2k4aG1rVmwyaHI1MWRHMkZjeGJucEtQYTU1Q1E4d2Z1aG9RYVkraTdlWDVPWFJXY1A3RGJqYng1dDBPcmorVnFjanpuK2Z1c08zVDE2UUN2K1ZPYWdwSWJpQkJDaUVkbURpdmxZOWhSNmd2UGVwVFQzNTh2NHV0NForaGJ6OFdtWnJQSW5LMDltM1hIY3RrLzlOS2VGQWs1WDhCYVM0eVdsRVlxUDFESGtWV25HS2VhNDNFK296T01NajlIZ0ZZYVkrWk9tbTN0dWRnMC9OZGZsaXo3K05CTEUwSUlJWDVqczZvNFc5ZHNWaFhMcnRBMERpTWxVVCtVTVFwck5NWm9GbTNnYkZueCtyeGx0VkFzRnhiblpmZm1TMG5JK1FMT1dlb3FZclRoZG50TDM4SnlZVWs0cm0rUGxOdEJRbzRBNWpKSFl3QUZiVE8vR2pNTmllMUtRbzRRUW9qSHBXOERpejZ5NkFOTkJVMXRzVWFlSXY0b1NvRzFtdUF0d1JzV1hlQnNWZlA2dkdXNU5EUzFKZmp3ME10OGN1UVcvQVdjYzFocnFldk00YkRuWFgvRDdsQkFHM0l1SEk4U2NNUk1hNFZGb3hTMHRlTjgwK0NzNW5pY0hucHBRZ2doeEc5VTBWSkhSMTA1WW9BWURjN0pVOFFmeVJwOTMzQmcyVVhPMXpXdlg3WDB2WjkzZVdSbjdZdkpMZmdMM05Xb2FxMnBtNXJWcWlPcGlLc1V1Y0F3Sm5hN2taUXpPUmRTa3JyVWwycStyWURSNEIwMEVjb0VnMy9vbFFraGhCQy9GVHlFQURITTUwR2NNMTgyWkxMODdpSStpMUtuczk5YTBkYWU5YXBpdmF3NDMzamFWaEdqeG51TDFsOTZSa3FBaEp3L0xYalBlcjNBeFVTb0MrTlUyQjBtYms4bGE4T1F5RGxKSTRJWGFnN0RrSFBCTzAxZGFSU1dhWkk3S1NHRUVJL0wzTEhMNHF5NWYvK0xRbzc0WWtweFB3dkhPczJpQzd5K2FQbkw2NTcxd3RCM0ZtdVZCSnl2SUNIblQ0b3hzRmtiK3I3UU5DUDd3OGpWMVlIMzczZW92U0xuSXVkelhyQzdYVCtsQ3NFN3JOSFVWYUJJNmhWQ0NQSEkzRldwL1A0aXZpK2xGTm9vbkRVcytzRGxlY1AvL3E4bGRaekhsamhuSk9COEJRazVmNUsxODZzY29SUktnV1ZuT0Z0NjlydUdEMWNIbENvY2gwUk9HWkRXMHMrRktsQktvWlJDTGdWZC92T2RqMUlLYTYxTUpoWkNDUEhzbEFJbGwvc25PVEkzNS9OcHBhaUNwWXFPcm5Vc084dXF0NndXbmhnTTNobDU3dkNWNUx2M0ZaUlNhTUNhd3FJeHZMNm84TTd5MzMrN0laZkM3VzRrQWJrVWNpNFNkSjZGUWttRm5PWXpWNHBDMFhLWExvUVE0bVdaeng0bnBnUXBsVG5zaU05bXJhYnZBbWZybXJOMXhjV1pvYXNWM3MwN084Wm8yY1g1U2hKeXZzTGRqYzg3eTdLUEdHTllMQXE1d0c0Lzh1YnRubU11a0NETFNiem40ZlNxVlVxRm5ESkpLWXlrVnlHRUVDOU1PYjJBbTFJbTVibTZvY2h6bmMraTFOeE5iZEVGWGwrMi9PVjF5Nkl0TEJlQkt2cjdNMUVTY3I2T2hKeXZwSlRDT1V2ZjFjU1k2STZaOXgrMnZIM242RHZQYnFjNERoUDVtRWx5Uk9mSnl6a3pEb245Zm1TM0h3aGVvWldYTFdVaGhCRFBYczc1L2pLT0U4T1FPQTZGY2N4TUtVdkZ5aDlRZXU2a1pveW1yaTE5YXpoYmVWNWYxRFNWb3U4aU1RWUpOOStJUERQN0J1NE83RmxUY0RiUlZuQytja3gvWGZEMi9ZRjNIL1pNYWI1VGtEdUFwMjBjRXRlM1IvN3hab3ZXaWI2MXJKUWloTGszdE53eENTR0VlSTVLS1J3T1I0N0R3UEU0Y3JPZDJCN2c1blprdDgrbnJyTHlKT2MvY1ZaVDE0NjI4U3c2eTZwWHRIV2lxUlJWWlhGZW5wWi9TL0xkL0FibXcrWG0xT1lQRnIxbkhHdENWZVA5bHBRSzF6ZEhCakpLU1JPQ3Ayd1lFOWMzQi83KzZ5MWFKVFNScHY3WU5VMUNqaEJDaU9lb2xNTHhPTERkSGRrZkVydURabi9VM0d6MzdQYUZjWktRODBlczFmVHRmQTVudlRTc1Y0cGw3MWt1YXB5emVPL2tlY1EzSkNIbkd6SEdZTXpjQ1dPMWFMRFdzVmhBVG9Ycm13UE9HY3d4M1hmbEtrVnV4RS9SY05ySjhXKzNXQXQxWlZrdTB0d3V2R1JRYzhjVUlZUVE0am00ZXhGdm1pWjJ1d08zMjVIRFlEa01udVBnMkc0VCswTTZkUjU5Nk5VK1RuZFBDN3d6dEUxZ3MycTRQSE5zbG5DMjZWaXRGZys5eEdkSlFzNTM0TDJqbWpLVWtTWk9MTnZDNi9QSVZYVHM5aU83L2NndzVJZGVwdmdUeGltejNZMW9QYmNKenlteDNSN3AvK2M5MDdobm5BNmtORHowTW9VUVFvaHZvcFM1UlhUS2hlT2dHWklqNVpxLy9lT1dEOWVIMDFrY1NUZi9qclVhNXpUZUd2cW1wYXZXOU0yU2RlOVk5Qk5WckI1NmljK1doSnh2VENsMXY5MDR0d2UwckZlT0tXbENTTHg5djJNY2s0U2NKMnFjRXR2ZHlKUXl3ekJ5ZTN2Z3pkdGJZdENrNmNDVUR1UXNJVWNJSWNRemNCcC9rVXNtRjBYS2psUTh1ZXk1dVIyNDJSNUpTUUxPZitLc3BvNk9xbklzdXBabHQrQmkzWE41WVducWlhcVNwK0xmaTN4bnY0TVlJeUVVbXFibTluYkw0VEJpREJnN01veUptOXNCbUI1Nm1lSlBHTWZNTkEzczlvcWJhM2hqTmNab3JGRm9EY1lvalBVUHZVd2hoQkRpNjVWTXp2Tk1uRndLMDVRWmhoMVQydjF1QnFDVWFmODcxbXBpdFBSZFlOSFZiRllOcjE5Vi9OZGZEVnAvTEdVVDM1NkVuTzlFS1lWU2lycXVXUzRnRjhQeE1IRmRXYm9tazlQcHptSk04aXJJVTFQbTdmdnA5T3FXVG9YeHRIT25OWmhKN3JHRUVFSThCNHFTNS9sL3BTaW1xVEJPNVpPUkdFcml6YitndFVLZjJrVzN0ZWQ4WFhONTFyQlplaTdPSnRwMmt0RVRQNEI4aDcrenFxcFlMUzNXV29ianhQVjFZYmMvQWhPNzNVZ3BrSkxzNmp4VmQ1MWtpb0l5emQzemRKSlNSQ0dFRU0vQXFabEFvVURoazUwYjhaOFlyYkJPNDZ4aDBRY3VOdzEvL1huQlpoWHBPazFUeXpmeFI1Q1E4NTNWZGNCN3oyS2htYWJFemUzRVlkaFIyRU1wYzFldTQwT3ZVdndaZDNmMGM5Q1pYOW1TMW85Q0NDR2VqNDlQeHUrYUMwaDUyaC9UUnVHdHdYdkRvZzFjbmpmODExOFdyRllCNXhReHl0UHZIMEcreTkvWjNGb2FRb0RsY3VUaUhMTHkrS3JGT01XVU11TXdrZlBjdVNUbkl2Y2RUOHlucjJwSmh4a2hoQkRQbnp6Vy9VYjVlTFpHYTBWVE9mb3UwSGVCODAxZzBSdmExdEkwSHEzbjJZcmkrNU9ROHdNMWRlYjhIRnlNdEQwb3c2blQydWx5ZWw4SUlZUVFRandOU3AzTzRTaUZOb3ErRGJ5NmFIbDkyWEsyZHZTOXhmdlRPUjJqcGVyakI1R1E4d05WbGVIaUxMSlllTHFyd0RnbGR0dVIyNXNCcGVheXB3RUpPVUlJSVlRUVQ0azZCUnhyTkgwZmVIWFo4ci8vMTRwRloyaHFTMVU1ckRYM2phbkU5eWNoNXdjS3dXT3RvYzRGcFJVZnJqelhxOEJ4Vi9QaCtvQXFNQnduQ3Nqa1lDR0VFRUtJSjBBYlJmQ0dLanFxeXJKZU9EWkx4OFZaUlZzN3ZEZDQ3OUZhUC9SU1h4UUpPVCtZVXZNOEZXZGcwVnBlWDlaNDUvamIzMjlSS0E3SGlTbGxVaXFrbENYb0NDR0VFRUk4UWtweFAveDkwVWMyNjVxemRjWEZ4dEIzbXVEQk9YMi9neU4rTEFrNVA1aldtbElLTVRqV3l6bmdMUHFFVm5BOGpIeTRPc3puYzBwQ09rc0xJWVFRUWp3K2R3RkhLYkJtRGprL3ZXcjU1ZWVlcmltc2w1RzY4b1RnTU1iSUxzNERrSkR6QUpSU2hPQlpMaFZ0aytuN2lkM3V5SWNQZTk2ODM3UGRqUlJnbWpKWnl0YUVFRUlJSVI0VnhXa2VqdFZVbFdQWnorVnBmLzFMVC9UUU5wNm1xU1hjUENBSk9ROUlLNFV4Q21laGJSU1hGNEdpMXJ4NXUrUHR1ejA1WllZcG40WnZTZGdSUWdnaGhIZ01uTlYwWGFCckE4dUZZNzNTdEhXbUNoQzh3VGtwVVh0b0VuSWVpRklLWStaZkFKOHp5ejVTTW5ROWhHREp1WEI3TzVES0NFQktrbkNFRUVJSUlSNEQ1d3lMUG5KeDNuQytDV3lXbXVYQzB6UWVaeTNlT3drNUQweEN6Z1BTV3Q5Zk51dWV0cTBaSjBWS2M4RDV4eisyREdPaWxFek9TZ1pOQ2lHRUVFSThBbk96Z2NEcnk0NmZYOVYwYldHemFWa3RGdys5TkhFaUllY1JtSGQxTk01cGxDbzBWV2F6TXZ6MWw1NFBId2F1cmcvYzNCdzVIT2RPQkpKMWhCQkNDQ0Yrck9BTklWcXFhRm4ybG1XWGFldVJ0aWswalNjRy85QkxGSitRa1BNSXpPMEg1OUkxclJKOTY3ZzhpMWpyK2JVNm9QWGNXdm80SkVvcEtDVkJSd2doaEJEaVIzSitMbEZiTFNPcmhXS3p0cXhYanRXeUlzWkFrSkR6cUVqSWVTU3N0VmdMM2hkV3F3WmpESXVGd3J0YkRzZUpkKzkzYkJXQWxLMEpJWVFRUXZ4bzNoa1dmZUR5b3VWc3Jka3NEWmZuQ3k0dU52ZkhEOFRqSVNIbmtiZzduS2FVb3E0Q09SZU1TZlF0TEh2RitTWmlqT1p3bU5qdlI0NURldWdsQ3lHRUVFSThhOVpxbkRNNHAxbDBtcjdOTEx2RWV1RlpMaU50VytPOTdPQThSaEp5SGlGckxURjR0SjdvV3MzWjJwRnpRMVZGM3IzZmswdGhHT2VRSTVzNlFnZ2hoQkRmaHcrR3JnbTByV2UxS0hPWjJzcXlXVmQwWFUyTTRhR1hLUDROQ1RtUGtQY2VZd3d4SllaaElLVk1pSm1xbmhzUGJIY0ROemZIaDE2bUVFSUlJY1N6RnJ5bGF6MmJUYzE2bWJnNGM3eDZ0ZUR5NGd6bnJPemlQR0lTY2g2aHU3cE81eHhkVnpPT0NldEdjdGx6ZTZ1NXZyR01RMlFZRThPUUdDY3BYUk5DQ0NHRStCYU0wVmlqMEViVDFqVmQyN05lOUd4V0U1dU5ZYjFhMHZmZFF5OVQvQUVKT1krY3M1YW1ucmRDajhjRG01VW1UUlV4Qks2dmozeTRPbkIxSXlGSENDR0VFT0pyS2FXSXdWQkZSNHlXNVdMSlpybm1mTk56ZmpheFdoYnBvdlpFU01oNTVMejN0QzJFNkZFVTBwUndMdEEwOEgvL2RzTnhtTGkrbmE4cjUzT0VFRUlJSWY0OHBTQUVTOXQ2Rm4xa3ZlaTRPTy81NjE5YTF1dE1WUlZDTUErOVRQRVpKT1E4Y25OcjZmbkhwSlVtNTRMM0E4RlBIQThIYm04czE5ZVduREpUS3VTY0tVVTk5TEtGRUVJSUlaNkVBbWl0VUVyaG5LYXBQS3RGeGRtbVpyMk12THIwL09VdmhxNXpENzFVOFFVazVEd2gxaHJxZW00dm5kTEljbEhZN3gxYUw3amRIcm5kRHR6ZURyS2pJNFFRUWdqeG1iUldoR0FKM2xCVmp2T3podGVYSGE5ZmRiU05ZYjJhc0RZRE1nZm5LWkdRODRRNDUyamJCbXN0eGlnT2h3TzVLR0p0K2ZYWFcwcUI3WFprZmsxQ0NDR0VFRUw4RWFNVklSamF4dE4za1l1emhwOWVkZnoxbHlVeEtxcks0cHhVeVR3MUVuS2VFR3N0Yld0cDI0YTJyWmxTd3JvOVhXZklLYkhiRHhnTk9TdWd5STZPRUVJSUljUi9vQlJvbzZpaXBlODhtM1UxNytTODd2anJYeGNZbys0SHRvdW5SVUxPRTZXMXBxa2o0NWlBZ1VXZjJPOE5PZmRzdHhQNy9jUnVQNUpTZnVpbENpR0VFRUk4S3NZb25ETjRaNmdieDZ1TG1zdnpob3Z6aHMzYVVsY3dWOFpJd0htcUpPUThVY1lZbXFaR0tVWHdCNGJqbnBJTDNtdmV2VC95N3YyZVlaaEkwbDFhQ0NHRUVPSTNqTkhFWUtscngyb1plSFhSOE12UEMxNjlhcWtxUTl2NisyWUU0bW1Ta1BORUdXUG91cGEyYlppbWlaUXl4bTVwV28yeE80WXhjWFY5Z0VGU2poQkNDQ0hFcDR6UnhHanAyc0I2VmZIcW91VXZQeS80K2VjbFdpdU1tUWV6aTZkTFFzNFRkdmZMcDdXbTYycUdNYUVZMk8wU3V4NE9CMC8wbHVNd01ReUphWkxTTlNHRUVFSzhUTVlvck5FWXErbTd3UG1tNXV5czV1SzhZcm4wMUxYQis5UFlEZ2s0VDU2RW5HZEFLVVZkVjZTY2NjNXdIUFlNUjB1aDVpcG1ycStQWEYwZkpPUUlJWVFRNHNXeVJoT2lwWXJ1TlArbTRlZWZlczdPS3JyT0VvS1Y4clJuUkVMT005RTBOU0Y0bG91SmxDWnlLbGhYY0M2VGMyRy9IemtjcG9kZXBoQkNDQ0hFZ3pCV1UwVkgyM2pXNjRyTHk1WmZmbGx5ZnRiZ25NSTVDVG5QaVlTY1o4SmFpN1h6ajNPMTZrK0I1a0JLQjRZakhJOFdLSXhqWmh3VDB5VDlwWVVRUWdqeHZCbHpkNzVHMFhlQjlUS3lYdGRjbkVmV0s4K2k5M1JkbkZ0SlM0bmFzeUloNXhtcVltUzFiTkJhVWNwRVRoYXRGSFVWdWI0NWNuTnpaSnJHaDE2bUVFSUlJY1IzNVp3aGVFdU1sck5OeGF2TGx0ZVhIYXVWWTdrTWVLOVJDdG5CZVlZazVEeERkVjFoaktickdydzNhSzBJSVZQVkNxMFU0ekd4M1VySUVVSUlJY1R6cFFCbkRWWGw2RnJQK2JybTU5Y2RmLzNyaWtYdjhWNVQxd0d0dFlTY1owaEN6alBrdmNkN1Q5Zk5XNjhsZzdVSGpKazRIZzM3dldGL2RLUlVTQ2t6VFZsR1hRa2hoQkRpR1NnWU03K29hNHltYlJ5clZXQzlyRGcvcnpnN3E3ZzRiMmpidVVUTkdQUFFDeGJmaVlTY1o4NTdSOWZWcEZ3b2VXSTRLaWlCV0VWdWJnZHViNDdjM0E1UTVJeU9FRUlJSVo0MnJSWEIyN21MV3JCY1hOWmNuamRjWERTc2xwNitjMWlycEVUdEJaQ1E4OHlGRUZnc09yeDNCRzlSR2tJWWFUdkxyNzl1eVNsenV4MEF5VGxDQ0NHRWVOcVVVb1JnYVZ0UDN3VXVMNXJUa004RmRXV0kwZUtjbFNZREw0Q0VuR2ZPT2NkaTRWZ3NlcnF1d1JoRGpIdWFhMFZLRTl2ZEVmOUJrMU1tbDBMT1JjS09FRUlJSVo0VXBlYmRHZXMwc1hiMGk4aG1VM054MmZMNmRjZGZmbDdpdlQxZFQzWndYZ0lKT1MrSXRaYTZqb3hqb3BRRHEwVm1IQ3pPTHJuZERteTNBOXZiZ1NsbENUcENDQ0dFZUJLTTBRUnZDTUZTdFk3elZ6M25sOTFjb3RZYnFtcHV3aVRoNW1XUmtQT0NXR3RwMjNxK013aVdOSTFZYTJoYnc1czNPMzVWV3c2SGlTa1ZsSklkSFNHRUVFSThmc1pBVloxSzFGWTFGNjk2ZnZwNXdVK3ZXaHBmYUNvckllY0ZrcER6Z2hoajZQdU9ybXNaeHhGakRIV3paN3MxR0tNNUhDZmV2OTh6cUNRQlJ3Z2hoQkJQZ2pHYVdEbjZQbksycVhuMXF1T1huM3YrbjFmZFBPUlRCbjIrU0JKeVhpQ2wxS2wwTFRDT0NjVkkzMlUyYTgwME5kemVqT3oySTd2ZHlEaEs2Wm9RUWdnaEhoZG5OVDVZdkRmVWRjMnlYN0JhTHRnc0t4YVZvM1lLbzZXTDJrc21JZWVGVWtvUlk2UVVjTzdJNGJnbjUwZ0lnZmZ2Ujk2ODNUR05tWEdjUzlkQXVxOEpJWVFRNG5Gd3p0QzJucTRMZEUzUGFybmgvR0xKcTFlTzVUTFJCQ01CNTRXVGtQTkNLYVdvNjRvWUEzMmZnSG1JYU5kRGpBZW1LWE56YzJCL21NaFpBWkp3aEJCQ0NQRTRPR2RvRzg5bVhiTmE5SnlkTGZqbGw1YS8vTVZnYmNZNU9ZUHowa25JZWNHTU1SaGpjTzQwTURRVmpCa1lqckRiR283SGl1Z3RoLzNFL2pBeTNKZXVTVk1DSVlRUVF2eFl6aG1jMDNodjZEdkRZbEZZTFJPYmRlTHNiR0sxeW5TZEErVDhqWkNRSTA1QzhMUnRRbXZGT0I1SlU4Ujd4OVdIaWJmdmRyeDl1eWZkSE1rRmNnYloyUkZDQ0NIRWp4U2puY3ZUV2svZkZkWnJ6Y1c1NCt6TXNseENWZVdIWHFKNFJDVGtDQUJDQ0hPM3RickNXazN3bnVVeTgvNzloTmFLd3lHeDNZMlFDMUJJNmFGWExJUVFRb2lYSkFUTFloRTVQMnRZOUltek04dlBQNjlacjFlRTRBbEJudGFLaitUV0lJQjVobzYxODgxQktZVXhscm9lTVdiUGR1Zlo3andwWlE2SGljTmg1SGljS0FWS3VTdGRrN3BYSVlRUVFudzdXaXVzMWZkbGFvdmVzRnhvMWl2TmF1MDRQMjg0UDkrd1hDNGVlcW5pRVpLUUkvNkp0WVlZUGFVVXVzNXdmdTdScW1PeGFIajNic2Y3ZDN2ZXZkK1RVaWFsUWtxeVBTeUVFRUtJYjJQdUY2QXdSdE4xZ1VVZjZSZUJ2c3VzVm9iTlJyTmFWZlJkamZmdW9aY3JIaWtKT2VLZldHdXBxb0MxQm1zMXhtajZidUxtcHZCL2dpV253dTN0d0FoUU1qbkpDUjBoaEJCQ2ZCdEt6Zk50akZGMFhlRGlzdVhWWlV2VFRDeVhsck96bnE2cmlUSGd2WC9vNVlwSFNrS08rQ2QzWGRkaWhCZ0RJUVFXaTRuYjI0bHhITm50amx4ZkR4d09JNGZEUk03bGQ2VnJRZ2doaEJCZlJpblFHcXpWV0t1SjBiTG9IZWRuZ1o5K2FtZ2FXSzBxenMvWEVtN0VINUtRSS80anJlZGEySndMTVU0c2w0YWZmbXBPUTBQM3ZIKy80LzM3SGVPWUdjZk1OR1dLSkIwaGhCQkNmS2E3b1oxS0tVTFFMQmFSdm8vMHZXTzl0aXlYaXJhRnB2SEVHTkJhV2tTTFB5WWhSL3hIYzhoeEtLWFJHczdPV2tJSW5KMHAvdnUvcnpGR013eUovWDRFSm5MTzBubE5DQ0dFRUY5QW9mVjhpZEd4WHRlOGV0VnhmbDdSTklYbDByTmVOOFRvQ2NGTHlCR2ZSVUtPK0krVVVqam5jTTVSVlpFWUk1dE5ZcHJtQURTT2lldnJQVGtYVWlvTVF3S2tFWUVRUWdnaFBzKzhrek9mQVk3UnNscFYvUHp6Z2w5KzZZaHhQcGNqSGRURWw1S1FJNzdJM0Y1YUFabTJoZk56VHlscjNyOC9uTXJYOXV6M1I2WnBMbCtUem10Q0NDR0UrRDJ0NStjVFNpbnEydE4xa2I0UExKZU9pd3RIMXhWaWhCRE0vWWdMSWI2RTNHckVGekZtM2lMV1dyRllCQUM2cnVIWFgzZjNRN2lNZ2YxK0pPZFJTdGVFRUVJSThVL21HVGh6RjlldUMxeGVkcng2MWJKZWU3cE9zVjVINnRyanZjTTVlYm9xdnB6Y2FzUVhNY2JjMThKdU5qMTlQNWV1TmMwTlNpbUdJVkhLM0h4Z0xsMlRsQ09FRUVLSTM3b2I5Qm1Db2U4anIxNjEvTy8vdmViOHZNSjdxR3RQWFZmM0RRbUUrRklTY3NRWHU3dXpjYzZlR2hNVTJ0YlM5eFhydFNIbkRtTnVjZTZHL1c3TDhUZ3hESWxoa05JMUlZUVE0cVc2YXcxdGpLWnBQWDBmNkxyQTJWbGt2YlowbmFacExNNFpRbkFZWXg1NnllSUprNUFqL2pTbDVrNG9jejJ0NWV5c0JqcGlUTHgvWDdHOWRkemVhcTZ2RDF4ZEhSakhBVUJtNlFnaGhCQXZqRkxnbkNGR1M0eVd6YWJtN0x6aC9MeGx1YlFzRm82bWNYaHZzZFpJd0JGZlRVS08rTlBtSmdTR1VncGRWeEZDWkwzV3ZIMWIrUHZmRE84L0ZLNnZFa29yanNlSjI5dmhvWmNzaEJCQ2lBZWhjRTVUMVk2dURaeWZ0L3psbHdXLy9MS2s2eXplYTZwcVBvT2p0WllTTmZIVkpPU0lyellQNzNLRUFGMEh4b3lVQXVhMExUMk9tbW4wVUJURG1CaU9FK09ZeUJtZ3lNNk9FRUlJOFF3cE5aKzdzVTdqbldhMWpxeFhnZFc2NHV3OGNINFcyR3dpVFJQdUd4SElEQnp4clVqSUVkOWNDSVcrTDREQ2FFc3BIdTgxaTRYbTZzT2VEeC9tOHJWcHlwUUNSVktPRUVJSThld1lvNmhyUjlONjJ0WnplUm00dUtnNE82OXBHay9mTzV6VDk0TkFaZmRHZkVzU2NzUTNGNEptdVF4VVZVL1RXS3JLcytnVDI2M2hmLzdubXB3TDIrMUFLWVdVUUNuWnpSRkNDQ0dlRzJQbThyVFZxbUt6cWZucDU4anIxeTJYbHozT0daeHpoT0N4MWtnWE5mSE5TY2dSMzV5MUZtc3RUVlBUTkRYZWUrcm13SGFiR2Njais3MW50NHNjRHVPcDh4cWtWR1JYUndnaGhIakNsQUt0Tk1iTVpXcXh0dlNkWWJtMGJEYU9zN09LczdPV3pXWXBBejdGZHllM01QRmRHVE8zZ1d6cUJBeXMxNFpTR3RvMnptVnJIdzU4K0xEbmNFaWtsSm1tVE00U2RJUVFRb2luUWludWQySml0SFJ0b09zRGJXZm9PMWl1TmV1Tm9ta016aG5ac1JFL2hJUWM4VjFwcmFtcWlERWFIeHhhSzVwMjRPSlM4L2UvM2ZBLzdtWSttOFBBOFRpUlVnRWs1QWdoaEJCUGh6cDFYRlhFWUZsdmFpNHVXdFliVDEwbmxxdkFadE5SMTVHcUN0SmNRUHdRRW5MRWQ2VzFKc1pJakJHQXBxazVIRWFtYVI0S05vMloyKzFBVGdWZG9FeUZjZ282VXJrbWhCQkNQRjUzR3pMR2dEMlZxTldOWTdVT3ZQNnA1ZkpWVGRNb1ZzdUd6ZG42b1pjclhoZ0pPZUtITXNiZ1hFYXBSTnRxTGk0Q1JxMzRzQng0LzJIUGh3OTdicmNEdzNGaUdCUFRtQjk2eVVJSUlZVDRIV1BtTVJIR0tKclcwN1dCdmcvMEM4dm16TlAzME5TS3V2WTQ3eDU2dWVJRmtwQWpmaWhqTk01WnRGWXNGeEdqRmN0RngvczNCLzcrajl1NWxhVFI3TFlEWlR0SXlCRkNDQ0VlSVdNVTNodThONnlXRlJlWExaZVhIZjNDMExTS2ZoSHArNG9RUENINGgxNnVlSUVrNUlnZjZxN3pXaWtGN3gzTFZTWW5lTHZjWWIwaGxjS1VDNlVVanNmcG9aY3JoQkJDaUgvQldJMzNabTRSdmE3NStlY0YvL1gvckZndUF5Rm9RblRFR0tRMXRIZ3dFbkxFZzVnUEtCcEFVUXpFQ3BvdXMxeU9ETk9Jc3hCam9GOUVEdnVSdzJIaWNCanYyMHpMZVIwaGhCRGl4MUhxNDg2TkQ0YkZvbUt4cU9nWGdmWEdzMXBiNmtZVEszT2FnV09sd1lCNFVCSnl4SU9aZzQ0bTUweUlodVVxVUZSTHFPSDZhbUMzVmV5MmxuZnZkbng0djJjY0U3a1VTb2FjSmVnSUlZUVFQNHJXaXFxeXRGMmdiUVBuNXkxbkZ5MW5adzFOQTAxamFScUg5eFpqOU9tRlRDRWVqb1FjOFdEdXRyQ1ZValJ0alErTzlhYm45bmJIMnpjMzNONGtibTgxMW1tbUtYTjFmWUFwa3hWSW0ya2hoQkRpeDlGYUVhT2o3eU9iczRhZmYxN3c2cWVlMTY4N3ZGY1lBeUU0akRGU29pWWVCUWs1NHNFcHBlN1A2bFJWaGZjZUNuaC94UG1SL2Q0d2pSNmxldmI3a2YxdVpMOGZTVk1tcFVMT1dYWjFoQkJDaUc5Z3ppWUtyVG5OdUxNRWJ3alJzbHdaVml0WXJUS0xKZlM5b1dzZHpsdVVRc3JUeEtNaUlVYzhPc1lZcWpveUR4ZURhWXFFYUZpZktkNjkyL1ArN1k3MzczYnM5eVBqa0JpR2Nob2lLb1FRUW9pdk13LzFuTXZUSEl0bHhYSlYwZldPcGtsMHZXRzFEaXlYanFyU2FETS9Wc3ZPalhoc0pPU0lSOGRhUzlQVWVPK282a0RkQkRabmlXRXcvTi8vdnNaWnpUU2wrK3VQVXdJSk9VSUlJY1JYMDNvdVRiTldVMVdPOWFibTlVODlaK2NWVlpYb2VzZDYzUkZqeEh1UHRVWjJjTVNqSkNGSFBEcHpCeGVQOTU2NkxzUVlHWWFKbEdBYVI5SXdrbytGYVBiYytDTkdLUTZIaVpUeTZTS0JSd2doaFBoY1dzODdOOW9vbk5OVXRTTkV4MkxoMlp3RnpzOERsNjlxcXRyUWRSWHI5ZktobHl6RUg1S1FJeDY5dTZuS1NoWDZ6cEl2YWxwYjhXRng1TjJITFcvYVc2NXZEdXkyQTl2dFFNNlRuTkVSUWdnaFBwTjFtaEFzSVZpNlB0QXZJNnRWcE8wc3k0Vmx1YkxVdGFHcVBkNjdoMTZ1RUo5RlFvNTQxTzZhRWlpbHlMbXdXalhVTVRKdE5CL2VIbWpmZU1JYmczOW5lRzhVNDVnNEhoTktTWXRwSVlRUTRuTTRhNmhyVDlONHpzNXJMbDYzdkhyVjB5OGNNU3JxMmxIWEVXdXRoQnp4WkVqSUVZK2UxdnErM2pjRWZ6OE10RzRkeGhld0UxbVBUTlBFNFRBd0RwbVVNem5mTlNTUXdDT0VFRUxjbVR1aEtkU3BUQzFXbXJyUjlBdkwraXp3K25YTFgzNVpzbDdYYUEzT1dabDdJNTRjQ1RuaVNWSUt0QytFTnRNT2hYVldvQ3gxM1hPN0tXeHZqOXh1QjdhM0F5bG4wbFJJS1QvMHNvVVFRb2dIby9YY0NjMFlUVjA3cXRQdVRWVW5taGI2UldHOWdiYUZFRDZlMVpIT2FlSXBrcEFqbnB5N08xc2ZETjB5WWx3aFZwcTJDZXkyaXR0YmVQUHJMVzkrM1RKTm1YRk1RQ0puWkVkSENDSEVpM1RYNXZtdWMxcmJCVFpuRGV0TlRWV050TDFpdFlvc0ZpMzlvcVdxL0ttVnRKYVFJNTRrQ1RuaXlhcnFPTS9UT1lQOWZzLzExWmJkTG5Gem5YQk9NMDJaMjVzakFEa1ZSdEpYL2grRkVFS0lwMHRwTUVaaG5hSHJJdWZuTFQvL3NxQnRNNnQxNU5Yck02cXFldWhsQ3ZGTlNNZ1J6NEl4Qmg4Y09jTTBUYXcyaGtKRjB4bHVid2EyTndNMzF3UEhRK0p3R0RtZVdrNkQ3TzRJSVlSNG5yUlJXR3V3VGhPRHBlazhkUk5vV3NkcVpWaHZGRTJiYUR0UHJMeWN1eEhQaW9RYzhTd1lZd2pCbzVSQ2FVQmx1ajV3K2FydzRmMmVEKzhQdkg5ejRPckRnYXZyQXluTmpRbEtRVHF4Q1NHRWVKYTAxb1JvcVd0SDB3WTI1dzJiczRiVk9sSlZtYVl4OUl0SVZRV3FLa3JJRWMrS2hCenhMQmhqaURFUWdxZHBLdnErb1JSSXFmRHJyN2Y4K3ZjdFZkemluQ0hsd3ZaMjdzSW1uZGVFRUVJOFY4WW9ZclEwYldDOXFmbnA1NTZmZmw3dzZuV0hjeG5uTkhVZDBWcGpqTG52WkNyRWN5QWhSendiZDNmT3hoaXN0WlF5ZDFSclc4ZnhvQmtHR0NkRnhtRnR5MjZiT0J3bURvZVI0WmptdHRPcGtMT2tIaUdFRUUrSFV1cStzWUQzR2g4c0lSaENwV2dhUmROTkxOY1QvYUxRTHpSZDV6Qkc0WnpNdlJIUGw0UWM4U3pkZFlMUldoR0NvZXM4RUxFMjB6U1d6Wm5tNW1yaS9mc2RIOTd0dWJrNU1nNkpZVWprTEEwS2hCQkNQQjFhenkvMEdhdG91OEJpRVZtc0txcTZ6TzJoTzhOaVViSGVSTnJHWXEzR0dJM1cwalZOUEY4U2NzU3pOYmZLbkxmaW5UTjBmYzFpdVdlM0hUa2VGZS9mSG9uL2JTa1pwcFJSYW43TCtOQXJGMElJSVQ2ZjBncGo1eVlEYmVzNXUyaDU5YnFuWHlpcUJwYXJpc1dpeFh0UENCN3YzV24zUjBLT2VMNGs1SWhuYmQ2NjkzanZBUWdoVU5jRHc1QXdXakdNQTFOS1dLZTV2Um1JTndlMjI0RnBTcVFwTTQ1eWJrY0lJY1Rqb3BoRGpURWFheld4Y3NUb0NKVmxmUmJZbkh2T3poMkwxVjBudFo2dWF4OTYyVUw4VUJKeXhJdGlyY0U1ZzFMUWRKYnppd29mSE10MXkvV0hQZGRYZTI2dUR0emVIdG5lSHJtOUdjaTVuRHF4U2RJUlFnanhzSlFDb3hWVjVhaHJUMVU3dWtXa1gxWjBpMERiS3JyTzBLOHNUZXVvNjRCejhuUlB2RHh5cXhjdnlsMnJhV3NUV210aTlHdzJzTnNsM3I3ZDh2N3RqdmR2dDd4OXM2WGt6SDQvd0tTQVFzNHlVMGNJSWNURHVXc3VvTTBjY3ZwbFpMR3NPTHRvT2J0b09MdG9pUUY4Z0txYXk5S2NzemduelFYRXl5TWhSN3dvV211MDFqam5pQkg2SGtvcDdQY2ozaXU4QTJzVHBZeWtGSmlteERCa3hqRXhqWWswbGRQT1RxWVVxV1VXUWdqeC9keUZHcVVVeHN6bGFjWnF2TmQwQzhkaWFWbHZIT2VYa1ZldlcxNy90TVQ3dThjNWVZb25YamI1RFJDQ3VUTk5qSXFtZ3lrcGxQSTBqZWJpb21ON08zSnplMlIzTzdMYkRod09JNGY5eERSbDJka1JRZ2p4M1JpamNjNWduYUdxNW5rM1RldXBHMFBWRk5wTzAvVnFiakJRSzR5NWV6RlBYb1FUUWtLT2VQR1VVbGlycVJ1UE5pMVZOQ3dXTmNPaGtDYkR1N2Q3M3IzYjhlN05qZzhmOWx4L1VFeGpacG9LU2tsVEFpR0VFTitITmdvZkxGWHQ2UHZJMlhuRDVyeGhzZlQ0bUtocU5RZWZ1cVp1S3B3ekdLT2xhNW9RU01nUkFnQnJMVjNYM25lZkdjZUpOQ1ZTZ24vODdacXFuZ2VuUVdFYUUvdjl3RGhtU2xZVUNqQW5IUWs4UWdnaHZzWmRQbEVLdkROVVVkTTBsdFU2Y1BtNjVhZS9MRGkvYlBFQjZqclFOUFZETDFtSVIwbENqaEQvZ3RhS1l1WUE0ME9oYmpPTFZTYWpDRlZndVE3c2J3djcvY0J1TjNJOGpFeGpacHdTMDVnZmV2bENDQ0dlQ0tYbXh4eXROZG9vWW5SVWxTVldqaEFUb1M3VVRXSzVTblRMUk4yQTkrQzl4Ump6ME1zWDR0R1NrQ1BFdjNBM1NCUUtkUnRZMCtBRGRBdlBmcHM1SGd6Ym04ejdkenZldjl0eDlXSFBmajlTOWtWQ2poQkNpQzlpak1ZNmpiV0dmaEZaclN1V3E0cFFUY1E2MDNTV3hhS202MXY2UGhJcmg3VVdheVhrQ1BIdlNNZ1I0bCs0NjhJR1lHMUgxelhreTh4K2YrQ3dIeG1PaGFzUEkvL3pmNjdRUnBIVEhHem1nRE05OVBLRkVFSThHWE5MYUdzTklWZ1d5OGpGcTViTDF6MXRCMTF2V1ovTnd6enZIcHZ1SHAvazdJMFEvNTZFSENIK3dLY1BLQUJhYVl4TlROTkV0eXdzRG9rcFRmZ0s2c2F6V0ZRY2p5UEhRMkk0VHFTU0tmY0RSUi82cXhGQ0NQRVE1anlpNW1HZVJ1T0R3WHRMQ0phbURqUzFwMjRDL2NxdzNEaTZoYUxyUFcwWGFacWFFTUpEZndsQ1BDa1Njb1Q0QXNZWW5IZWdGTGwxck04aTJqWTBiZUgyWm1LL1ZZekh3TldIUGRjZkRseDlPRENNRTJuSzVKeTVhMUFnaEJEaXBWR25zemNLSHd4ZEgrbjZRTmRGbG91YVJWK3hXTmI0S2hFYmFEcFBWWHVxS21LdFBGMFQ0a3ZKYjQwUVgwQnJmVDlCMm50TDNRVE9MMWJzZG5zK3ZML2w1bXJpdUhmOC9XL1hhSzA0SHFlNSsxcUJsRElwUGZSWElJUVE0aUVvQlVxV0F4WHlBQUFXcGtsRVFWVFBiYUZEc0hSOTRPeThuZHRDcnp2T3pobzJGdzNhWm93RlkrY3pPc1lZYVRBZ3hKOGdJVWVJTDNBM2VScm1YWjI3OG9HMmJYRFdFZnlPM1RZekpZdlNubERWYkxjaisyMWl2MDBjRDRseFRJeGpKazJaVXFTTVRRZ2hucHU3MGpSakZjNGFqSjNMMDBLd2hHaHBHc3RpN1ZpdU5NdTFacmt4TERhT3hUcWdUcnM5Y3Q1R2lLOGpJVWVJYjBCclRhdzhLV2VNSFVCRjJsN3ordWVhN1hiaTlucms1aXB4ZlRWeWUzM2c1bXBndngrWXBneWxrSXAwWkJOQ2lPZGc3czQ1djQzQlVUZWV1bkduOGpSUDEwZXFSaE5pb1c0TmJlZG9lb09QV2dLT0VOK1FoQndodmdHdE5WVlZZYTJsYVNiNlJVMUtHUXJjM2g2NHZocTRlamZ3NXRjRGIvNXhTeW5iK2M5SmxKeElrbkdFRU9KWnVBczRXaXRpWmU5YlFxL1BHalpuTlp2emhxWnpHSnR4WGhHQ3d6dUg4MTRDamhEZmtJUWNJYjRCcFJUT09aeHovL1JuZGJNbHhoM0JIMUFhWUFRUzFzSnhQM0hZVHh5SHVUbEJtZ29wWlhJR09KV3h5ZU9kRUVJOFNuZDV4Smk1RGJUV0d1Y04xbW1jTTNRTHozTGxXRzBzNjNQSCtXWEYrV1ZMMTBlTTBhZUxuTGNSNG51UWtDUEVkNmExd25sTjFXaVdhNHUyRmUzQ3NkOTE3RzVHYm04R3RyY2p1KzNBN25aZ3Q1M0wySEthQTQ4YzF4RkNpTWRuUHFNSjFpcENkTVRLRWl0SDB3YWExdE4yQVI4elZRMU5hMWtzRFhXcmNWNWhqUDdOR1U4aHhMY25JVWVJNzh3NVIxMFhyRFZVbFdleGFwaEdHSTZaNjZ2ajNHcjYvWUgzYjNlOE0vdjVuQTZKaVVSS0NtazdMWVFRajR0U0g4dlNqTlgzWjI3NlpjVjZVN1BjMUt6WE5TNWtyTXZFYUloVklNWklqRjVDamhBL2dJUWNJYjZ6dXpLMnBway92dXVvTmd3akg5N3ZlUDl1UjlNNGpJV2NNOE00Y2RpTkhJOEsxRVMrNzhJR0tPbkVKb1FRRCtGdTUwWXBoVEh6YnN6Y05VM1Q5cDdseXJNNmkxeSthamwvMVhINXFzZDdqWFVHNzUwRUdpRitNQWs1UWp5QStWVkFoZk9LcW9aeGhIV3l1TkN3UEt2WjNneHN0d083bTJFT1BJZUp3MkZrSEJNNUYxSXFGRWs3UWdqeFhkMkZHcVhBZTRzL3RZQ09sYU91TFZYamlaVWhWcGxZYTdxKzBDNEtzWnJMMkxUUmFDM2hSb2lISUNGSGlCL3M0NXdkVFl3T3FIQk9VN2VCNHlFelRZYWJxN21FN2ZyOWZpNW4rM0JBWHlsMis0RnB6SlNTU1VsQ2poQkNmRTkzWGRLVVVvUm9hZnRBMTBYNlpXU3hpaXhYRlUzcjBIYkVld2lWcFcxcTZpYmkvTWZHQXJLTEk4U1BKeUZIaUFlZ2xNSmFTOXRhbXFZR0lLVjBHZ3lxZVBkdXk3dGZ0N3o5ZGN1YnVFVnJ6VFJseGlsUkNxU2NJVDMwVnlHRUVNL2IzVTZPTm5QSTZickk1cnpoN0tMaDRsWEgrV1hIY2hWUkd0enZ5dElrMkFqeHNDVGtDUEhBUHU3c0dKU2FCK1o0cndoMW9la3pLUmRjdEN6UEd2Yjd3RzZiMkc4eis5dkVjSnc0SGllR1k1cGJVS2Y1SXBWc1FnanhlWlFxOTAwQXRGRjRiM0RlNEwwbFZwNVlXVUxscUdxb1cwM2JGZHBGb21vS0lZSzFHbTBVMWhxMDFnLzk1UWdoVGlUa0NQRkl6R1VSbWxJS3dSdTYxbU4wUlZWck5tTjFhbFpRdUwwZXVibWV1UDJRdUw0NmNIMTE0T2Jxd0hDY0dJYnBWTVltS1VjSUlUN1BYSkptak1ZNlRkTUcyaTdRZElGK1VkRXRJbDBmOENGamZTWlVpcnFleTlaQ3RCZzduN3VSZ0NQRTR5SWhSNGhINU83VnhLcU9oT2haTER0eXpwUmNRTUU0VHR4Y0g3aDZmK1REdTVFM2Y3L0JXazFLR2FXWWc1QktzcE1qaEJDZlNTblFabTRGN2IybDdRS3JUY042VTdPNWFObWNOMnpPRzd4WGFGT3d6bUN0d1ppUGwvbmZrZkkwSVI0VENUbENQRUozRDV6T3VkOThmaGdHY2k2blMySVlZWmdTWXg2SkRUUUh4M0FJakdNaFRZbHh6RXhqSXFWOFAyQlVDQ0Zlb3J2V3owb3JySjFiT3p1bjhkN2dveVZVbGxBWjJ0YlE5WWJGRXZxVnBsOWEydDRUdkVVYmpiWFNTRUNJcDBCQ2poQlBpTllhNXl4VlpTbkZVVlRFaFpHbXp4ejJoWEV3NURHeTN5VzJ0MGQydHdPNzdjRGhNSExZajR4NTdsWWdPejFDaUpmR0dEVUhHMitvS2tmZGV1ckcwN2FldXZNMG5hZHFMTTRsZkZCVWxhSHJIRlZ0Y1ZiZnQ0T1dnQ1BFMHlBaFI0Z254QmhEakFGckRWVWQ2ZnVhNGRXS1lSalozaHc0N0RQVFlMbjZNUEQrN1k0UDczWVlxMUVLcGpFekR0S1NUUWp4TXQwMUZRalIwdldCNWJwbXVhNVpyU3Y2ZFdTeHFtaTdnTllKbzhGWWhYTWU1eXplT3psekk4UVRJeUZIaUNkRUtZVno3cC9LMkFDdXIyL1kzaDQ0SGpJdUtKUWVLQXBRQ3Vzc3ppa090WjlMMTFJbVRYTVpXMDZGbERMemxZdnM4Z2dobmlTbDVwWXJ4c3hkMHJUU0dLc3habTRxNEVMQmU0V1BpWDZaV1c0VTZ6UExhdU5acld1V3E0YXVyMDdEbXJYczJBanh4RW5JRWVLWmNHNXVkNnIwU0ROcFVyWm81Nm1hd3ZIZ0dmYVc4YWpaNytmU3RjTisrT1Q5a1p3S09RTlpnbzRRNG1tWm03Yk1BU2RFTzErQ282b2RWZVdJbFVPN0FldEdiTWkwWGFEckhYMXY2WHBMckRUV3FmdTVPRUtJcDA5Q2poRFBoSFB1dE5OajhkN1Fkb0hOb2VWd0dEZ2VNdE5nR0k2YXF3OTdycS8yM0h6WXorMm50WnBuN0tpNU9VSEtJQzJvaFJCUHhSeE1tTnRBVzAyc0hHMGZhTnZBWWxuUkx5TDlzc0w0a1JBenNUYkVLaENEeHdlUDk1NFEvSDFKbW9RY0laNEhDVGxDUEJQV1dxeTkrNVZ1N2o4L2ppUDcvWkhobU5qdkVuVnJpSlhDdVl3eUdhVUxCUmlIekRRa3hqR1JVNmJrdVNWMUtZVmNDaVZEa1MwZUljU0RLTXpaNCtOdWk5SnpzTkhHb0szR1dvMExpcTUxZEF0THYzQ3N6eUxyVGNQNnZDVldtcWIxOUl2Mlg1YjhDaUdlRndrNVFqeHpXbXVjTlpSY1NDRlJOekFsUUN0Q0hWbWVSWWFqWVRna2hzUEVlQmc1SGlZTys1SGpjZUo0bUJpR3hIQ2NtRWJwemlhRWVCaGFhNHlkejlmNGNGZVNaZ21uY3JSWU9YeFVPRC9oSTFTMW9sOUF1MURFU2hFcmkvTldHZ2dJOFVKSXlCSGltZE5hWTUxRmFUMGZ4alVOc2JZc2xuR2VwNU1zT1RzTys0bjk3WkhEYm1CN2MrVG13NEdibXlPMzF3ZDIyNEdTQzlPWUFWQkt6dTBJSVg0c2JSVHUxQUs2YVFOdEgraTZTTHVJZEl0SXY0aUVXcVBOaUxVRjV4VlZGWWt4RW1QQU9ZdVRMbWxDdkJnU2NvUjQ1ajUyWklNWUExM1gvdE4xU2luYzNnN2NYaC9aM2h6NDhHN0gyMzlzY1crMktBMkZ3akJNREVkRkthZWRuQUtRUDRZZEtXTVhRbnl0MC8zSmI0L0Z6Q1ZxMW1xYzE0Um9hYnE1STlycXJHWjkxckkrYTFpZk5YUjl3Qml3em54U3ZpdUVlSW5rSGtBSUFZRFJCZXN6UGhhcU50T09pYVFtdEU4MHZXTno0UmtPNWhSMkV1TnhZamhPakdOaUhCSlRTcWQyMUVYTzdnZ2hQcHRTb0xTYUd3ZG9mYjliNDczQmVUdS9Id3pLSE5GMndyaUpycC9vRjNNcjZMcExoQ3JqZkVFYlpHQ25FQUtRa0NPRVlON3RNVllUbzBPcmdqWVpGNkR0RGV0OXhYQ0VOQmpTNk5qZUR0emVITm5lSE5sdGoreTJBN3ZiZ1dGUWM5T0NraWd5YzFRSThabVVtc09Oc1FydkxYWGpxUnRQMDNqcU50QzBucnIxWVBab08rSkNvYW9pVlIzbnQxV2tiZ0loV0l6UmN6TUNLVWtUNHNXVGtDT0VBTUI3aDNPV3VvNzBpM2J1cXBZend6Q2VtZzRVeGtIeDRkMXV2cnpkOCtIOUR1djJjNG1KZ2x4QWo1a3NMYWlGRUo5cGZwRkZZYTBoUkVmYnorZHJsdXVLNWFwbXVhNVlyR3VzVDhUSzBMUVYxaHEwMXZjWHBkVDkrMElJQVJKeWhCQW44ekM5dWNUREdIUC9lZTg5Z3g4WWhqUzNtSjQwVTRKVU1zVWtsSnZRZnFBK0ZLYlJrYWVLTkNxbUtUR05tVFJscGpFeFRmTWNucHpMYWZDb0JDRWhucnU3SVoxS0thelZtRk9yWjJQMWZHN0dhWUozVk40UnZNTkhqVzhMc1ZVMFhhWmJGdHFGcHVrTVBqaGk1V21hV3NLTUVPSVBTY2dSUXZ4SFNpbU1NVGczMTg0M3JRVVZjQ0ZUZDRwK2JkaHZMY01JZVhLUVBOT2dPZXhHOXJ1QnczNWtmL2YrYmo3RE01RXBKVW1ITmlHZXNmbXN6V2xJcDVtSGRJWm9pWldqcWgxVjdhbHFSMTBGbWlyU1ZBRWJDcmdCRXhJMktKcW1vbTRjc2JieldSMW41YnlORU9LelNNZ1JRdnhIOHl1dzloUjBNczdONVNJcFphWnBJcWU1NmNEeE1ESWNNMmswSFBlRjZ3OTdicTRPWEYvTmI0MVJsQXlvdVp2Yk5DbVFzallobmpHRlZuUEFzYzVRMVk2bUM3UmRtRnMrTHl2NlJhUnJhN3AyYmdQdGdxTG9DYVV6eXR6ZDkyaXN0YjhwVFJOQ2lEOGlJVWNJOFlmdVN0bTAxdisyTGV2eGVPU3duOHZhZHRzQjR5YTBHMUZPbzJ5aG1BeDJKQTZhTkhxbVVaTVRwQ21mdXJKOThyWVVTcDVMMnFTc1RZakhSeWsxNzlJb05jL2YwaHBqRk5wOGZHdXR4amlEY3diakRGVURWYTJwbTBLL1VDeVdobjdwNlR0SDIzbmFQdUNqdlM5dkUwS0lyeUVoUndqeFRjdzdQZWEwVTJQSTJhR013MGRQMVNTYVpXYS9VNlRSa0NlUEtwSGhrRGtlUm82SGllRXdjVHhNSEk4VHd6QXhqWmx4U0ZMV0pzUWpaSXk2UDEvamc4VUhTd2dXSHkwaHp1K0hhUEdWdzBXSEN3WmpCNnlaY0w1UTE0R21kZFNOSVZZR0Z4VGEvSDQramhCQy9IbXF5RUFMSWNRM1VFb2hwVVRPbVdsS2pPUElPSTVNNDhUd3lmdUgvVFFIbmVUWjM0N2MzaHk1dlQ2d3ZSM1kzUjdaM2c3M1oza08rNUhqSVFGRmdvNFFqNGdQQm4rYVlWTzNucVlOODlzbTBQWjNiWjhEc2ZGVWJhQ3FMRENpZEVLcGpMTVc1eDNPT2F5MVdHdHd6a2xEQVNIRU55TTdPVUtJYitMdTdBNkE5d0RWdjd6ZTdlMld3MzVrR0RMYjZ5UFhIelNoS3ZncTQ4S0VzcUJ0T1EwRGhMRnlsRnhJZVE0Nk9SZEt6cWNXMStYajJ6eWY4WkV3Sk1TZk0rK2lmQ3hEUTgwRE91Zm1BUnFseWp5MFUybXNMeml2Y0Q3VGRORDFpcmEzOUF0SHR3ajBpNXFtaS9PbGpUU05seEkwSWNRUEpTRkhDUEZEV1d2d0lhTVVUTFdpeVpxaU5UWWFRbU9vZXNQeDRDbVRwYVM1VzlzNEpvWWhNVTU1bnRrelRQUEhRMkk0enU5L1BOc3pCeDhoeE9lNUR6Y0tqTlZ6RnpOdnNLZTNkNWU3M1JzZk5FVWRVR1pFMjVFWURYWHo4ZEkwaHJwVnhFcmh2TUthcjEyaEVFSjhPUWs1UW9nZnl0cTVCYXcxQ1dNVnNiSzBmV0FjUjRiaHJxd3RrU2NOeGFHeVo3OGIyZTBIRHZ1Si9YYmdzQnZZN1FaMnA5SzIzZTNBOFpDWW1NL3ZwQ1FoUjRqUDkzSDN4am96dDNxdUxQSFU0cm1xUFhYanFCdFAzYzd2bzQ4b00rRUNPR2R4enMwRGhiM0RPNGYzZmk1SHN4WmpwU09hRU9MSGs1QWpoUGloNXZwN0N3SHFmM09kVWdyak1ESk5tVFNWK2R6T3plSCs3ZmI2d08yTm5WOGxkcUJVUVZ2RmVGQ01ZMkljMWJ5YlUwQlJLS2QvODY1amRabi9KNENTOGpieGJDbDF1cTByeFdtekJwakR6TjNINmxTU2RuY0psYVZxNWt2VE9kbyswblp6ZStmKzFQYTVXMFNjVjRSb2Fkdm1vYjlNSVlUNGx5VGtDQ0VlSmFYbjFyU2xGSnlIVUVFdVVGUkJtWUlKbWRnYXBpbVNVMlFhRllkZDVyZ3JIUGVaYWNwTVl5YWx4RFRPNVd4emFKb2JJOHgvOXJGTmRaRlcxZUladUd1L3JMUTZkVUF6V0tkUG5kQU05dFFSemJyVHgyNXVDKytNd1RxSHNpUGFEUmcvRVdLbWJncFZuV21hVE5YTnY0Zk9LNXpUR0NOMWFFS0l4MHRDamhEaTBWRktZWXk1bjg4VEtvc3lBUmMwc1RaMGk4QXd6QU5KRmZPTWpwd1VoMjFtdjgwY2RubnV6SGFjT083SCs5YlVkKzJxajRmNTgrT1ltY1pFS1VYR2tvcG5RWjNtMXR3TjRMeHY2Unp0WElZV1Buay9Xa0owaE9BSndSR0NBejJRMVFITWlMVUs3ejArek5meElaeXVlemNjV0o1Q0NDRWVMN21IRWtJOFNuZlR6YTBGN3gwd2w1emROUlg0L2R1VU1vZjl3R0dYMkc4bnRyZEhkcmZEL2R2ZDlzaHVPOXkzcXA3cjFOSThkRFFWc3NRYzhSd281dEl6by9IQlVOVnVidS9jZUpvdTNKK3J1V3Z4M0xhZXFnNzM1MjYwdmZzM1BnNEJ2anRQOC92M2hSRGlNWk9RSTRSNDlEN25pWlZTRTg1YmNzNFVGQmxBRnpBWjdSSW1KbXcxNGVxUjBJNkVmbVFhQ3lWNVZQRlFMT2xVenBiU3FaUXRmZnArSWVlUG4vKzB6RzBPWHcvOVhSTFB3ZDFOL1A2c2pKa0RpejU5Ykl6R0dEM3YxbGlOc1dZdVN6TnpTVm91Z1V5a3FJZ0xJMVY5b0txUFZQVklYUnVxeWxEVmQyVm9oVkJEcUJTK1VyaWcwVWFqRkRLdlJnang1RW5JRVVJOEMzT0oyeng5WFNsUTJ1T0NJdGFhWWJBY2o1NWhDSXpEeVBFNGNEd081S1NnZUF3UmltYzRUQXpIdWJSdFBDYU94M0Z1V1gxcVlUME5pWEhNakVOaUhPZXpQbGxCU2lBcFIzd1RhbTdsck5VY1l1NWJPRnVOOC9hK3ZiUHpjeW1hRHc0ZkxDRllmRERrVXBOVUF6cGkzUkVmYnZCK1N3Z1o3eDArZUx3L2xaK2Qzczd0b2pWS3Evc3pQVUlJOGRSSnlCRkNQQXQzWjNpY3M4UllhSEpGenZrM2w3dkJvWGNmcHpRM0p5akpNSTJ3MzQ3c3RnTzc3ZHlhZXIrZEw4ZkR4T0V3enVkOERvbkRmZ1IxeWpWVG1uZDBIdm9iSUo0RnhhbjdtWjdiT1g4OE4yT0oxZngrckIyeG1sczZ4OXBUTjU2cW1kOGFXMkZjd0FlTGRSbXRlN1NlVHVWbkg4dEFQNzNNdTBiNk4rVm9RZ2p4MUVuSUVVSThHMTlhWXBOU1loaEcwbW5JcUF0Z1E4YUZoSThhRnhXdWd1TWg0L2VaY0VnY0R5TmhQM0E0ek9WdUZJc3FGUW8zbDY3bGp4M2I3Z0xWL0hudTM4OWxQa3VVeTIvTDNjb3BMRW1udDZkRktYNnpBM08zSXpJSGg3bFRvTkxxMUNUak5KUG1rN2JOMnN3aFl5NUJBK3ZtRG1hb2hES2dkY2E1aVJBMXNjckVxaEFqVkkybXFqVlZiZVk1TnJYSEJZdnptcnErNjM3bUh2cmJJNFFRRDBKQ2poRGl4ZEo2UHQ4QTREREVZbEU2WTEwbVZGQjFpdU5oTG5jYmg1Rng5UFBBMG1Ga0dDWnlBcTBpVmxWb0ZabE8zZHFtTVRGTmMxbmIvUEhjdGpwTitmN1AwcFJKZVc1cm5hZjVyRSs2TytzalozeWVqTHNRY3hkWTdzN0lXR3N3VnAzT3o4eWR6cXlkejgwNGQvcllHWnc3ZmV6TlhJb1d3UVh3RVZLYW1OSkltaWEwVWZOd1RXY0pwMEdiUGpoaURIUFpXVFQ0b0hHTys5bFI5NE54aEJEaUJWS2x5RU9wRU9MbCtsakdOcy9VU1NtVHBtbisrUDV6YVM1eFN4OUwzMUxPY3pPQ3BGSEZRbmIzcmFxSFQxcFZIdzRqNDkzbmp4UERNVEVjcDlPNW51bDB4bWYrK09NY255eTdPVS9FM1R3YWJlYjVNNStlbVhIT1lMM0JlNFB6OXY3c1RJajJONjJkNzByU1lyVDRTdUhqM0JrdDU0KzNQVGlWWkdwMUN1ZG12bWlOdm52ZmZDeEJreGsyUW9pWFRuWnloQkF2MmwySjJ6ejM0OHRLZTNMT0RNTjRQM2owdUI4NUhBWU8rM0Z1WjcwZk9ld1ZoejBjRDRYaklUTWNNOGNEREVOaE9HYUdNVEVlNThCRDB1UmtVZG5NNVd1Y0xtVXVkeXVuVDViQ0p4M2R5c2N5dDNtOFBkek4vYm03M3QyQ1A5a2htdit0ajM5Mi8yOXo5dytwSjdHYmRGY3FkdnJLNFc0WTV2MG5QdTNPTi8vbms3OHlYLy8waHgvLzNseFNCdHlYbWQzdmpOeVZwSjNlb2pKRkpRb1RtSVQzQlIvQSs3bGJtWGZnZ2lKRVRRaUdHQzJoY3NUb2lKVW5SRWRWZTJJMWYreURuWnNLZUNjZHpvUVE0aXRJeUJGQ2lEL3ByczJ2dFJwRklXZEZVWE41a25FR0h6T2hObFNEWXh4Z0dHQWNGZVBkMjFFelRSUFRxSm1TeFJKd0t1QjBUYzZRU2lFWE5aZXlUZk5PVXBybWtyYjd0K20wby9TYmx0YWNkcHhPbnl1Zm5BZTZQeDkwZDE0b3oyZUU4c2N6UW5kL2gvSjR6d2Y5NWh5TVZ2Yy9pMDlMeCs0L3AzNzcrVS9QeFNpdDV2Yk1ScUdVL3FSdDgybkh4T3A1cDBhcmo2MmJqY1pvaFRYenVaa2g3Um56bnNRUlkrY2htYzVackRWWVo3SFd6cDNOdkoxM2RPNHVZZDdsOFVFVHZNYjV1LytYaEJzaGhQaGFFbktFRU9KUFVrcGg3VHliNTM0QW96ZWs3Sm1tUkU2SjZhN2NMWjFLMy9MSDkrZVFraWhsRGlRR2g5RWVxOE9wYkszTVozdkczNTN2R2RQSGp6OHBjY3VubVQ3emVaK1BBZWp1N1hUcUJIY2ZrTWIwOFRyNTQzVXA4MmpVVFBuWVJlNFJ1Vzl6ZkFvNGM1bldhVzdNSjBGRWYvcjUwMXQ5bWpOakRQZlh1UXN5eHBqVGRkVDlHWnE1dmJMNWVJN21yaVROYWJ3ektGT1k4b0dwREdRbWpER25JR1h1ejN4OVdrSTJ6N094bUx1UDdWeHFabzA1bFoxOXZMNFFRb2cvVDBLT0VFSjhoVy81aFBTK0UxdmgvcHpPTUtSL09zc3puTTczekdWdTZUNzAzSVdkTkdXbTlMSFpRVHFWMDkwM1A3ajduRkgzSCt0SmtjaHpvdEdLUEtlY09lZzhNdXJ1b3VaZG1Mc0FZNncrSGU0Mzk0SEhmdko1Njh3bjE1bWJBK2pmL1ptejg4d1k2OHk4MHhMc3h4S3lZRTg3TC9iK2ZlczA2bTUzUjg3QkNDSEVveUV2RlFraGhCQkNDQ0dlbGY4L3dYUFFVd0FwS0c4QUFBQWxkRVZZZEdSaGRHVTZZM0psWVhSbEFESXdNalF0TURNdE1EaFVNVE02TWpFNk16UXJNREE2TURCdDA1Q2pBQUFBSlhSRldIUmtZWFJsT20xdlpHbG1lUUF5TURJMExUQXpMVEE0VkRFek9qSXhPak0wS3pBd09qQXdISTRvSHdBQUFDaDBSVmgwWkdGMFpUcDBhVzFsYzNSaGJYQUFNakF5TkMwd015MHdPRlF4TXpveU1Ub3pOQ3N3TURvd01FdWJDY0FBQUFBQVNVVk9SSzVDWUlJPSdcbmV4cG9ydCB7QkVSS0VMWUJSSURHRV9URVhUR0VORVJBVElPTl9QTFVHSU5fTE9HT19CQVNFNjR9O1xuIiwiLypcbiAqIENvcHlyaWdodCAyMDE1LTIwMjQuIFJpdGVuc2UgQlYsIHRoZSBOZXRoZXJsYW5kcy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciBFVVBMLCBWZXJzaW9uIDEuMiAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHBzOi8vam9pbnVwLmVjLmV1cm9wYS5ldS9jb2xsZWN0aW9uL2V1cGwvZXVwbC10ZXh0LWV1cGwtMTJcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgYmFzaXMsXG4gKlxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlclxuICogZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICovXG5cbmltcG9ydCB7TmdNb2R1bGV9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtDb21tb25Nb2R1bGV9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQge1BMVUdJTlNfVE9LRU4sIFBsdWdpblRyYW5zbGF0ZVBpcGVNb2R1bGV9IGZyb20gJ0B2YWx0aW1vL3BsdWdpbic7XG5cbmltcG9ydCB7Rm9ybXNNb2R1bGV9IGZyb20gXCJAYW5ndWxhci9mb3Jtc1wiO1xuaW1wb3J0IHtDYXJib25NdWx0aUlucHV0TW9kdWxlLCBGb3JtTW9kdWxlLCBJbnB1dE1vZHVsZX0gZnJvbSBcIkB2YWx0aW1vL2NvbXBvbmVudHNcIjtcbmltcG9ydCB7XG4gICAgVGV4dEdlbmVyYXRpb25Db25maWd1cmF0aW9uQ29tcG9uZW50XG59IGZyb20gXCIuL2NvbXBvbmVudHMvdGV4dC1nZW5lcmF0aW9uL3RleHQtZ2VuZXJhdGlvbi1jb25maWd1cmF0aW9uLmNvbXBvbmVudFwiO1xuaW1wb3J0IHtcbiAgICBCZXJrZWx5YnJpZGdlVGV4dGdlbmVyYXRvckNvbmZpZ3VyYXRpb25Db21wb25lbnRcbn0gZnJvbSAnLi9jb21wb25lbnRzL2JlcmtlbHlicmlkZ2UtdGV4dGdlbmVyYXRvci1jb25maWd1cmF0aW9uL2JlcmtlbHlicmlkZ2UtdGV4dGdlbmVyYXRvci1jb25maWd1cmF0aW9uLmNvbXBvbmVudCc7XG5pbXBvcnQge2JlcmtlbHlicmlkZ2VUZXh0Z2VuZXJhdG9yUGx1Z2luU3BlY2lmaWNhdGlvbn0gZnJvbSAnLi9iZXJrZWx5YnJpZGdlLXRleHRnZW5lcmF0b3ItcGx1Z2luLnNwZWNpZmljYXRpb24nO1xuXG5ATmdNb2R1bGUoe1xuICAgIGRlY2xhcmF0aW9uczogW1xuICAgICAgICBCZXJrZWx5YnJpZGdlVGV4dGdlbmVyYXRvckNvbmZpZ3VyYXRpb25Db21wb25lbnQsXG4gICAgICAgIFRleHRHZW5lcmF0aW9uQ29uZmlndXJhdGlvbkNvbXBvbmVudFxuICAgIF0sXG4gICAgaW1wb3J0czogW0NvbW1vbk1vZHVsZSwgUGx1Z2luVHJhbnNsYXRlUGlwZU1vZHVsZSxcbiAgICAgICAgRm9ybU1vZHVsZSwgSW5wdXRNb2R1bGUsIEZvcm1zTW9kdWxlLCBQbHVnaW5UcmFuc2xhdGVQaXBlTW9kdWxlLCBDYXJib25NdWx0aUlucHV0TW9kdWxlLF0sXG4gICAgZXhwb3J0czogW1xuICAgICAgICBCZXJrZWx5YnJpZGdlVGV4dGdlbmVyYXRvckNvbmZpZ3VyYXRpb25Db21wb25lbnQsXG4gICAgICAgIFRleHRHZW5lcmF0aW9uQ29uZmlndXJhdGlvbkNvbXBvbmVudFxuICAgIF0sXG4gICAgcHJvdmlkZXJzOiBbXG4gICAgICAgIHtcbiAgICAgICAgICAgIHByb3ZpZGU6IFBMVUdJTlNfVE9LRU4sXG4gICAgICAgICAgICB1c2VWYWx1ZTogW1xuICAgICAgICAgICAgICAgIGJlcmtlbHlicmlkZ2VUZXh0Z2VuZXJhdG9yUGx1Z2luU3BlY2lmaWNhdGlvbixcbiAgICAgICAgICAgIF1cbiAgICAgICAgfVxuICAgIF1cbn0pXG5leHBvcnQgY2xhc3MgQmVya2VseWJyaWRnZVRleHRnZW5lcmF0b3JQbHVnaW5Nb2R1bGUge1xufVxuIiwiLypcbiAqIENvcHlyaWdodCAyMDE1LTIwMjQuIFJpdGVuc2UgQlYsIHRoZSBOZXRoZXJsYW5kcy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciBFVVBMLCBWZXJzaW9uIDEuMiAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHBzOi8vam9pbnVwLmVjLmV1cm9wYS5ldS9jb2xsZWN0aW9uL2V1cGwvZXVwbC10ZXh0LWV1cGwtMTJcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgYmFzaXMsXG4gKlxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlclxuICogZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICovXG5cbmltcG9ydCB7UGx1Z2luU3BlY2lmaWNhdGlvbn0gZnJvbSAnQHZhbHRpbW8vcGx1Z2luJztcbmltcG9ydCB7QmVya2VseWJyaWRnZVRleHRnZW5lcmF0b3JDb25maWd1cmF0aW9uQ29tcG9uZW50fSBmcm9tICcuL2NvbXBvbmVudHMvYmVya2VseWJyaWRnZS10ZXh0Z2VuZXJhdG9yLWNvbmZpZ3VyYXRpb24vYmVya2VseWJyaWRnZS10ZXh0Z2VuZXJhdG9yLWNvbmZpZ3VyYXRpb24uY29tcG9uZW50JztcbmltcG9ydCB7VGV4dEdlbmVyYXRpb25Db25maWd1cmF0aW9uQ29tcG9uZW50fSBmcm9tIFwiLi9jb21wb25lbnRzL3RleHQtZ2VuZXJhdGlvbi90ZXh0LWdlbmVyYXRpb24tY29uZmlndXJhdGlvbi5jb21wb25lbnRcIjtcbmltcG9ydCB7QkVSS0VMWUJSSURHRV9URVhUR0VORVJBVElPTl9QTFVHSU5fTE9HT19CQVNFNjR9IGZyb20gXCIuL2Fzc2V0cy9iZXJrZWx5YnJpZGdlLXRleHRnZW5lcmF0aW9uLXBsdWdpbi1sb2dvXCI7XG5cbmNvbnN0IGJlcmtlbHlicmlkZ2VUZXh0Z2VuZXJhdG9yUGx1Z2luU3BlY2lmaWNhdGlvbjogUGx1Z2luU3BlY2lmaWNhdGlvbiA9IHtcbiAgcGx1Z2luSWQ6ICdiYnRleHRnZW5lcmF0b3InLFxuICBwbHVnaW5Db25maWd1cmF0aW9uQ29tcG9uZW50OiBCZXJrZWx5YnJpZGdlVGV4dGdlbmVyYXRvckNvbmZpZ3VyYXRpb25Db21wb25lbnQsXG4gIHBsdWdpbkxvZ29CYXNlNjQ6IEJFUktFTFlCUklER0VfVEVYVEdFTkVSQVRJT05fUExVR0lOX0xPR09fQkFTRTY0LFxuICBmdW5jdGlvbkNvbmZpZ3VyYXRpb25Db21wb25lbnRzOiB7XG4gICAgJ2dlbmVyZWVyLXRla3N0JzogVGV4dEdlbmVyYXRpb25Db25maWd1cmF0aW9uQ29tcG9uZW50XG4gIH0sXG4gIHBsdWdpblRyYW5zbGF0aW9uczoge1xuICAgIG5sOiB7XG4gICAgICAnZ2VuZXJlZXItdGVrc3QnOiAnR2VuZXJlZXIgdGVrc3QnLFxuICAgICAgdGl0bGU6ICdCZXJrZWx5IEJyaWRnZSB0ZWtzdCBlbiBQREYgZ2VuZXJhdG9yJyxcbiAgICAgIGRlc2NyaXB0aW9uOlxuICAgICAgICAgICdNZXQgZGUgQmVya2VseSBCcmlkZ2UgdGVrc3QgZW4gUERGIGdlbmVyYXRvciBwbHVnaW4ga3VuIGplIGluIGVlbiBwcm9jZXNzIHRla3N0IG9mIFBERlxcJ3MgZ2VuZXJlcmVuJyxcbiAgICAgIGNvbmZpZ3VyYXRpb25UaXRsZTogJ0NvbmZpZ3VyYXRpZW5hYW0nLFxuICAgICAgY29uZmlndXJhdGlvblRpdGxlVG9vbHRpcDpcbiAgICAgICAgICAnT25kZXIgZGV6ZSBuYWFtIHphbCBkZSBwbHVnaW4gdGUgaGVya2VubmVuIHppam4gaW4gZGUgcmVzdCB2YW4gZGUgYXBwbGljYXRpZScsXG4gICAgICBiZXJrZWx5YnJpZGdlQmFzZVVybDogJ0JlcmtlbHkgQnJpZGdlIGJhc2UgdXJsJyxcbiAgICAgIGJlcmtlbHlicmlkZ2VCYXNlVXJsVG9vbHRpcDpcbiAgICAgICAgICAnVnVsIGhpZXIgdXJsIGluIHdhYXJvcCBCZXJrZWx5IEJyaWRnZSBpcyB0ZSBiZXJlaWtlbi4nLFxuICAgICAgbW9kZWxJZDogJ01vZGVsIElEJyxcbiAgICAgIG1vZGVsSWRUb29sdGlwOiAnVnVsIGhldCBCZXJrZWx5IEJyaWRnZSBtb2RlbCBJRCBpbicsXG4gICAgICB0ZW1wbGF0ZUlkOiAnVGVtcGxhdGUgSUQnLFxuICAgICAgdGVtcGxhdGVJZFRvb2x0aXA6ICdWdWwgaGV0IHRlbXBsYXRlIElEIGluIG9tIGVlbiB0ZWtzdCBvZiBQREYgdGUgZ2VuZXJlcmVuJyxcbiAgICAgIG5hYW06ICdOYWFtJyxcbiAgICAgIG5hbWVUb29sdGlwOiAnVnVsIGhpZXIgZGUgbmFhbSBpbiB2YW4gZGUgdGUgZ2VuZXJlcmVuIGZpbGUuJyxcbiAgICAgIGZvcm1hdDogXCJGb3JtYWF0XCIsXG4gICAgICBmb3JtYXRUb29sdGlwOiAnVnVsIGhpZXIgaGV0IGZvcm1hYXQgaW4gdmFuIGRlIHRlIGdlbmVyZXJlbiB0ZWtzdCBvZiBmaWxlJyxcbiAgICAgIHBhcmFtZXRlcnM6IFwiUGFyYW1ldGVyc1wiLFxuICAgICAgcGFyYW1ldGVyc1Rvb2x0aXA6ICdWdWwgaGllciBkZSBwYXJhbWV0ZXJzIGRpZSB3b3JkZW4gZ2VicnVpa3QgaW4gZGUgdGVtcGxhdGUnLFxuICAgICAgdmFyaWFiZWxlTmFhbTogJ05hYW0gcHJvY2VzcyB2YXJpYWJlbGUnLFxuICAgICAgdmFyaWFiZWxlTmFhbVRvb2x0aXA6ICdOYWFtIHZhbiBkZSBwcm9jZXNzIHZhcmlhYmVsZSBkaWUgZGUgdGVrc3QgYmV2YXQnLFxuICAgICAgYWRkUGFyYW1ldGVyOiAnVm9lZyBlZW4gcGFyYW1ldGVyIHRvZScsXG4gICAgfSxcbiAgICBlbjoge1xuICAgICAgJ2dlbmVyZWVyLXRla3N0JzogJ0dlbmVyYXRlIHRleHQnLFxuICAgICAgdGl0bGU6ICdCZXJrZWx5IEJyaWRnZSB0ZXh0IGFuZCBQREYgZ2VuZXJhdG9yJyxcbiAgICAgIGRlc2NyaXB0aW9uOlxuICAgICAgICAgICdXaXRoIHRoZSBCZXJrZWx5IEJyaWRnZSB0ZWtzdCBhbmQgUERGIGdlbmVyYXRvciBwbHVnaW4geW91IGNhbiBnZW5lcmF0ZSBhIHRleHQgb3IgUERGIGluIGEgcHJvY2VzcyBzdGVwJyxcbiAgICAgIGNvbmZpZ3VyYXRpb25UaXRsZTogJ0NvbmZpZ3VyYXRpb24gbmFtZScsXG4gICAgICBjb25maWd1cmF0aW9uVGl0bGVUb29sdGlwOlxuICAgICAgICAgICdVbmRlciB0aGlzIG5hbWUsIHRoZSBwbHVnaW4gd2lsbCBiZSByZWNvZ25pemFibGUgaW4gdGhlIHJlc3Qgb2YgdGhlIGFwcGxpY2F0aW9uJyxcbiAgICAgIGJlcmtlbHlicmlkZ2VCYXNlVXJsOiAnQmVya2VseSBCcmlkZ2UgYmFzZSB1cmwnLFxuICAgICAgYmVya2VseWJyaWRnZUJhc2VVcmxUb29sdGlwOlxuICAgICAgICAgICdFbnRlciB0aGUgVVJMIGhlcmUgd2hlcmUgQmVya2VseSBCcmlkZ2UgY2FuIGJlIHJlYWNoZWQuJyxcbiAgICAgIG1vZGVsSWQ6ICdNb2RlbCBJRCcsXG4gICAgICBtb2RlbElkVG9vbHRpcDogJ0VudGVyIHRoZSBCZXJrZWx5IEJyaWRnZSBtb2RlbCBJRCcsXG4gICAgICB0ZW1wbGF0ZUlkOiAnVGVtcGxhdGUgSUQnLFxuICAgICAgdGVtcGxhdGVJZFRvb2x0aXA6ICdFbnRlciB0aGUgdGVtcGxhdGUgSUQgdG8gZ2VuZXJhdGUgYSB0ZXh0IG9yIFBERicsXG4gICAgICBuYWFtOiAnTmFhbScsXG4gICAgICBuYW1lVG9vbHRpcDogJ0VudGVyIHRoZSBuYW1lIG9mIHRoZSBmaWxlIHRvIGJlIGdlbmVyYXRlZCBoZXJlLicsXG4gICAgICBmb3JtYXQ6IFwiRm9ybWF0XCIsXG4gICAgICBmb3JtYXRUb29sdGlwOiAnRW50ZXIgdGhlIGZvcm1hdCBvZiB0aGUgdGV4dCBvciBmaWxlIHRvIGJlIGdlbmVyYXRlZCBoZXJlJyxcbiAgICAgIHBhcmFtZXRlcnM6IFwiUGFyYW1ldGVyc1wiLFxuICAgICAgcGFyYW1ldGVyc1Rvb2x0aXA6ICdFbnRlciB0aGUgcGFyYW1ldGVycyB1c2VkIGluIHRoZSB0ZW1wbGF0ZSBoZXJlJyxcbiAgICAgIHZhcmlhYmVsZU5hYW06ICdQcm9jZXNzIHZhcmlhYmxlIG5hbWUnLFxuICAgICAgdmFyaWFiZWxlTmFhbVRvb2x0aXA6ICdOYW1lIG9mIHRoZSBwcm9jZXNzIHZhcmlhYmxlIGNvbnRhaW5pbmcgdGhlIHRleHQnLFxuICAgICAgYWRkUGFyYW1ldGVyOiAnQWRkIGEgcGFyYW1ldGVyJyxcbiAgICB9LFxuICAgIGRlOiB7XG4gICAgICAnZ2VuZXJlZXItdGVrc3QnOiAnR2VuZXJhdGUgdGV4dCcsXG4gICAgICB0aXRsZTogJ0JlcmtlbHkgQnJpZGdlIHRla3N0IGVuIFBERiBnZW5lcmF0b3InLFxuICAgICAgZGVzY3JpcHRpb246XG4gICAgICAgICAgJ01ldCBkZSBCZXJrZWx5IEJyaWRnZSB0ZWtzdCBlbiBQREYgZ2VuZXJhdG9yIHBsdWdpbiBrdW4gamUgaW4gZWVuIHByb2Nlc3MgdGVrc3Qgb2YgUERGXFwncyBnZW5lcmVyZW4nLFxuICAgICAgY29uZmlndXJhdGlvblRpdGxlOiAnS29uZmlndXJhdGlvbnNuYW1lJyxcbiAgICAgIGNvbmZpZ3VyYXRpb25UaXRsZVRvb2x0aXA6XG4gICAgICAgICAgJ1VudGVyIGRpZXNlbSBOYW1lbiB3aXJkIGRhcyBQbHVnaW4gaW0gUmVzdCBkZXIgQW53ZW5kdW5nIGVya2VubmJhciBzZWluJyxcbiAgICAgIGJlcmtlbHlicmlkZ2VCYXNlVXJsOiAnQmVya2VseSBCcmlkZ2UgYmFzZSB1cmwnLFxuICAgICAgYmVya2VseWJyaWRnZUJhc2VVcmxUb29sdGlwOlxuICAgICAgICAgICdWdWwgaGllciB1cmwgaW4gd2Fhcm9wIEJlcmtlbHkgQnJpZGdlIGlzIHRlIGJlcmVpa2VuLicsXG4gICAgICBtb2RlbElkOiAnTW9kZWwgSUQnLFxuICAgICAgbW9kZWxJZFRvb2x0aXA6ICdWdWwgaGV0IEJlcmtlbHkgQnJpZGdlIG1vZGVsIElEIGluJyxcbiAgICAgIHRlbXBsYXRlSWQ6ICdUZW1wbGF0ZSBJRCcsXG4gICAgICB0ZW1wbGF0ZUlkVG9vbHRpcDogJ0dlYmVuIFNpZSBkaWUgVm9ybGFnZW4tSUQgZWluLCB1bSBlaW5lbiBUZXh0IG9kZXIgZWluIFBERiB6dSBnZW5lcmllcmVuJyxcbiAgICAgIG5hYW06ICdOYW1lJyxcbiAgICAgIG5hbWVUb29sdGlwOiAnR2ViZW4gU2llIGhpZXIgZGVuIE5hbWVuIGRlciB6dSBnZW5lcmllcmVuZGVuIERhdGVpIGVpbi4nLFxuICAgICAgZm9ybWF0OiBcIkZvcm1hdFwiLFxuICAgICAgZm9ybWF0VG9vbHRpcDogJ0dlYmVuIFNpZSBoaWVyIGRhcyBGb3JtYXQgZGVzIHp1IGdlbmVyaWVyZW5kZW4gVGV4dGVzIG9kZXIgZGVyIERhdGVpIGVpbicsXG4gICAgICBwYXJhbWV0ZXJzOiBcIlBhcmFtZXRlcnNcIixcbiAgICAgIHBhcmFtZXRlcnNUb29sdGlwOiAnR2ViZW4gU2llIGhpZXIgZGllIGluIGRlciBWb3JsYWdlIHZlcndlbmRldGVuIFBhcmFtZXRlciBlaW4nLFxuICAgICAgdmFyaWFiZWxlTmFhbTogJ05hbWUgZGVyIFByb3plc3N2YXJpYWJsZW4nLFxuICAgICAgdmFyaWFiZWxlTmFhbVRvb2x0aXA6ICdOYW1lIGRlciBQcm96ZXNzdmFyaWFibGVuLCBkaWUgZGVuIFRleHQgZW50aMOkbHQnLFxuICAgICAgYWRkUGFyYW1ldGVyOiAnRsO8Z2VuIFNpZSBlaW5lbiBQYXJhbWV0ZXIgaGluenUnLFxuICAgIH0sXG4gIH0sXG59O1xuXG5leHBvcnQge2JlcmtlbHlicmlkZ2VUZXh0Z2VuZXJhdG9yUGx1Z2luU3BlY2lmaWNhdGlvbn07XG4iLCIvKlxuICogQ29weXJpZ2h0IDIwMTUtMjAyNC4gUml0ZW5zZSBCViwgdGhlIE5ldGhlcmxhbmRzLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIEVVUEwsIFZlcnNpb24gMS4yICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cHM6Ly9qb2ludXAuZWMuZXVyb3BhLmV1L2NvbGxlY3Rpb24vZXVwbC9ldXBsLXRleHQtZXVwbC0xMlxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBiYXNpcyxcbiAqXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyXG4gKiBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKi9cblxuaW1wb3J0IHtDb21wb25lbnQsIEV2ZW50RW1pdHRlciwgSW5wdXQsIE9uRGVzdHJveSwgT25Jbml0LCBPdXRwdXR9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtQbHVnaW5Db25maWd1cmF0aW9uQ29tcG9uZW50fSBmcm9tICdAdmFsdGltby9wbHVnaW4nO1xuaW1wb3J0IHtCZWhhdmlvclN1YmplY3QsIGNvbWJpbmVMYXRlc3QsIE9ic2VydmFibGUsIFN1YnNjcmlwdGlvbiwgdGFrZX0gZnJvbSAncnhqcyc7XG5pbXBvcnQge0JlcmtlbHlCcmlkZ2VUZXh0R2VuZXJhdG9yQ29uZmlnfSBmcm9tIFwiLi4vLi4vbW9kZWxzXCI7XG5cbkBDb21wb25lbnQoe1xuICBzZWxlY3RvcjogJ3ZhbHRpbW8tYmVya2VseWJyaWRnZS10ZXh0Z2VuZXJhdG9yLWNvbmZpZ3VyYXRpb24nLFxuICB0ZW1wbGF0ZTogcmVxdWlyZSgnLi9iZXJrZWx5YnJpZGdlLXRleHRnZW5lcmF0b3ItY29uZmlndXJhdGlvbi5jb21wb25lbnQuaHRtbCcpLFxuICBzdHlsZXM6IFtyZXF1aXJlKCcuL2JlcmtlbHlicmlkZ2UtdGV4dGdlbmVyYXRvci1jb25maWd1cmF0aW9uLmNvbXBvbmVudC5zY3NzJyldLFxufSlcbmV4cG9ydCBjbGFzcyBCZXJrZWx5YnJpZGdlVGV4dGdlbmVyYXRvckNvbmZpZ3VyYXRpb25Db21wb25lbnRcbiAgaW1wbGVtZW50cyBQbHVnaW5Db25maWd1cmF0aW9uQ29tcG9uZW50LCBPbkluaXQsIE9uRGVzdHJveVxue1xuICBASW5wdXQoKSBzYXZlJDogT2JzZXJ2YWJsZTx2b2lkPjtcbiAgQElucHV0KCkgZGlzYWJsZWQkOiBPYnNlcnZhYmxlPGJvb2xlYW4+O1xuICBASW5wdXQoKSBwbHVnaW5JZDogc3RyaW5nO1xuICBASW5wdXQoKSBwcmVmaWxsQ29uZmlndXJhdGlvbiQ6IE9ic2VydmFibGU8QmVya2VseUJyaWRnZVRleHRHZW5lcmF0b3JDb25maWc+O1xuICBAT3V0cHV0KCkgdmFsaWQ6IEV2ZW50RW1pdHRlcjxib29sZWFuPiA9IG5ldyBFdmVudEVtaXR0ZXI8Ym9vbGVhbj4oKTtcbiAgQE91dHB1dCgpIGNvbmZpZ3VyYXRpb246IEV2ZW50RW1pdHRlcjxCZXJrZWx5QnJpZGdlVGV4dEdlbmVyYXRvckNvbmZpZz4gPVxuICAgICAgbmV3IEV2ZW50RW1pdHRlcjxCZXJrZWx5QnJpZGdlVGV4dEdlbmVyYXRvckNvbmZpZz4oKTtcblxuICBwcml2YXRlIHNhdmVTdWJzY3JpcHRpb24hOiBTdWJzY3JpcHRpb247XG5cbiAgcHJpdmF0ZSByZWFkb25seSBmb3JtVmFsdWUkID0gbmV3IEJlaGF2aW9yU3ViamVjdDxCZXJrZWx5QnJpZGdlVGV4dEdlbmVyYXRvckNvbmZpZyB8IG51bGw+KG51bGwpO1xuICBwcml2YXRlIHJlYWRvbmx5IHZhbGlkJCA9IG5ldyBCZWhhdmlvclN1YmplY3Q8Ym9vbGVhbj4oZmFsc2UpO1xuXG4gIG5nT25Jbml0KCk6IHZvaWQge1xuICAgIHRoaXMub3BlblNhdmVTdWJzY3JpcHRpb24oKTtcbiAgfVxuXG4gIG5nT25EZXN0cm95KCkge1xuICAgIHRoaXMuc2F2ZVN1YnNjcmlwdGlvbj8udW5zdWJzY3JpYmUoKTtcbiAgfVxuXG4gIGZvcm1WYWx1ZUNoYW5nZShmb3JtVmFsdWU6IEJlcmtlbHlCcmlkZ2VUZXh0R2VuZXJhdG9yQ29uZmlnKTogdm9pZCB7XG4gICAgdGhpcy5mb3JtVmFsdWUkLm5leHQoZm9ybVZhbHVlKTtcbiAgICB0aGlzLmhhbmRsZVZhbGlkKGZvcm1WYWx1ZSk7XG4gIH1cblxuICBwcml2YXRlIGhhbmRsZVZhbGlkKGZvcm1WYWx1ZTogQmVya2VseUJyaWRnZVRleHRHZW5lcmF0b3JDb25maWcpOiB2b2lkIHtcbiAgICBjb25zdCB2YWxpZCA9ICEhKGZvcm1WYWx1ZS5jb25maWd1cmF0aW9uVGl0bGVcbiAgICAgICAgJiYgZm9ybVZhbHVlLmJlcmtlbHlicmlkZ2VCYXNlVXJsKTtcblxuICAgIHRoaXMudmFsaWQkLm5leHQodmFsaWQpO1xuICAgIHRoaXMudmFsaWQuZW1pdCh2YWxpZCk7XG4gIH1cblxuICBwcml2YXRlIG9wZW5TYXZlU3Vic2NyaXB0aW9uKCk6IHZvaWQge1xuICAgIHRoaXMuc2F2ZVN1YnNjcmlwdGlvbiA9IHRoaXMuc2F2ZSQ/LnN1YnNjcmliZShzYXZlID0+IHtcbiAgICAgIGNvbWJpbmVMYXRlc3QoW3RoaXMuZm9ybVZhbHVlJCwgdGhpcy52YWxpZCRdKVxuICAgICAgICAgIC5waXBlKHRha2UoMSkpXG4gICAgICAgICAgLnN1YnNjcmliZSgoW2Zvcm1WYWx1ZSwgdmFsaWRdKSA9PiB7XG4gICAgICAgICAgICBpZiAodmFsaWQpIHtcbiAgICAgICAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uLmVtaXQoZm9ybVZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICB9KTtcbiAgfVxufVxuIiwiLypcbiAqIENvcHlyaWdodCAyMDE1LTIwMjQuIFJpdGVuc2UgQlYsIHRoZSBOZXRoZXJsYW5kcy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciBFVVBMLCBWZXJzaW9uIDEuMiAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHBzOi8vam9pbnVwLmVjLmV1cm9wYS5ldS9jb2xsZWN0aW9uL2V1cGwvZXVwbC10ZXh0LWV1cGwtMTJcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgYmFzaXMsXG4gKlxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlclxuICogZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICovXG5cbmltcG9ydCB7Q29tcG9uZW50LCBFdmVudEVtaXR0ZXIsIElucHV0LCBPbkRlc3Ryb3ksIE9uSW5pdCwgT3V0cHV0fSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7RnVuY3Rpb25Db25maWd1cmF0aW9uQ29tcG9uZW50fSBmcm9tICdAdmFsdGltby9wbHVnaW4nO1xuaW1wb3J0IHtCZWhhdmlvclN1YmplY3QsIGNvbWJpbmVMYXRlc3QsIE9ic2VydmFibGUsIFN1YnNjcmlwdGlvbiwgdGFrZX0gZnJvbSAncnhqcyc7XG5pbXBvcnQge1RleHRHZW5lcmF0aWVDb25maWd9IGZyb20gXCIuLi8uLi9tb2RlbHNcIjtcblxuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAndmFsdGltby10ZXh0LWdlbmVyYXRpb24tY29uZmlndXJhdGlvbicsXG4gIHRlbXBsYXRlOiByZXF1aXJlKCcuL3RleHQtZ2VuZXJhdGlvbi1jb25maWd1cmF0aW9uLmNvbXBvbmVudC5odG1sJyksXG4gIHN0eWxlczogW3JlcXVpcmUoJy4vdGV4dC1nZW5lcmF0aW9uLWNvbmZpZ3VyYXRpb24uY29tcG9uZW50LnNjc3MnKV0sXG59KVxuZXhwb3J0IGNsYXNzIFRleHRHZW5lcmF0aW9uQ29uZmlndXJhdGlvbkNvbXBvbmVudFxuICBpbXBsZW1lbnRzIEZ1bmN0aW9uQ29uZmlndXJhdGlvbkNvbXBvbmVudCwgT25Jbml0LCBPbkRlc3Ryb3lcbntcbiAgQElucHV0KCkgZGlzYWJsZWQkOiBPYnNlcnZhYmxlPGJvb2xlYW4+O1xuICBASW5wdXQoKSBwbHVnaW5JZDogc3RyaW5nO1xuICBASW5wdXQoKSBwcmVmaWxsQ29uZmlndXJhdGlvbiQ6IE9ic2VydmFibGU8VGV4dEdlbmVyYXRpZUNvbmZpZz47XG4gIEBJbnB1dCgpIHNhdmUkOiBPYnNlcnZhYmxlPHZvaWQ+O1xuICBAT3V0cHV0KCkgY29uZmlndXJhdGlvbjogRXZlbnRFbWl0dGVyPFRleHRHZW5lcmF0aWVDb25maWc+ID0gbmV3IEV2ZW50RW1pdHRlcjxUZXh0R2VuZXJhdGllQ29uZmlnPigpO1xuICBAT3V0cHV0KCkgdmFsaWQ6IEV2ZW50RW1pdHRlcjxib29sZWFuPiA9IG5ldyBFdmVudEVtaXR0ZXI8Ym9vbGVhbj4oKTtcblxuICBwcml2YXRlIHJlYWRvbmx5IGZvcm1WYWx1ZSQgPSBuZXcgQmVoYXZpb3JTdWJqZWN0PFRleHRHZW5lcmF0aWVDb25maWcgfCBudWxsPihudWxsKTtcbiAgcHJpdmF0ZSBzYXZlU3Vic2NyaXB0aW9uITogU3Vic2NyaXB0aW9uO1xuICBwcml2YXRlIHJlYWRvbmx5IHZhbGlkJCA9IG5ldyBCZWhhdmlvclN1YmplY3Q8Ym9vbGVhbj4oZmFsc2UpO1xuXG4gIHB1YmxpYyBuZ09uSW5pdCgpOiB2b2lkIHtcbiAgICB0aGlzLm9wZW5TYXZlU3Vic2NyaXB0aW9uKCk7XG4gIH1cblxuICBwdWJsaWMgbmdPbkRlc3Ryb3koKTogdm9pZCB7XG4gICAgdGhpcy5zYXZlU3Vic2NyaXB0aW9uPy51bnN1YnNjcmliZSgpO1xuICB9XG5cbiAgcHVibGljIGZvcm1WYWx1ZUNoYW5nZShmb3JtVmFsdWU6IFRleHRHZW5lcmF0aWVDb25maWcpOiB2b2lkIHtcbiAgICB0aGlzLmZvcm1WYWx1ZSQubmV4dChmb3JtVmFsdWUpO1xuICAgIHRoaXMuaGFuZGxlVmFsaWQoZm9ybVZhbHVlKTtcbiAgfVxuXG4gIHByaXZhdGUgaGFuZGxlVmFsaWQoZm9ybVZhbHVlOiBUZXh0R2VuZXJhdGllQ29uZmlnKTogdm9pZCB7XG4gICAgY29uc3QgdmFsaWQgPSAhIShmb3JtVmFsdWUubW9kZWxJZClcbiAgICAgICAgJiYgISEoZm9ybVZhbHVlLnRlbXBsYXRlSWQpO1xuXG4gICAgdGhpcy52YWxpZCQubmV4dCh2YWxpZCk7XG4gICAgdGhpcy52YWxpZC5lbWl0KHZhbGlkKTtcbiAgfVxuXG4gIHByaXZhdGUgb3BlblNhdmVTdWJzY3JpcHRpb24oKTogdm9pZCB7XG4gICAgdGhpcy5zYXZlU3Vic2NyaXB0aW9uID0gdGhpcy5zYXZlJD8uc3Vic2NyaWJlKHNhdmUgPT4ge1xuICAgICAgY29tYmluZUxhdGVzdChbdGhpcy5mb3JtVmFsdWUkLCB0aGlzLnZhbGlkJF0pXG4gICAgICAgICAgLnBpcGUodGFrZSgxKSlcbiAgICAgICAgICAuc3Vic2NyaWJlKChbZm9ybVZhbHVlLCB2YWxpZF0pID0+IHtcbiAgICAgICAgICAgIGlmICh2YWxpZCkge1xuICAgICAgICAgICAgICB0aGlzLmNvbmZpZ3VyYXRpb24uZW1pdChmb3JtVmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgIH0pO1xuICB9XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IDIwMTUtMjAyNC4gUml0ZW5zZSBCViwgdGhlIE5ldGhlcmxhbmRzLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIEVVUEwsIFZlcnNpb24gMS4yICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cHM6Ly9qb2ludXAuZWMuZXVyb3BhLmV1L2NvbGxlY3Rpb24vZXVwbC9ldXBsLXRleHQtZXVwbC0xMlxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBiYXNpcyxcbiAqXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyXG4gKiBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKi9cblxuaW1wb3J0IHtQbHVnaW5Db25maWd1cmF0aW9uRGF0YX0gZnJvbSAnQHZhbHRpbW8vcGx1Z2luJztcblxuaW50ZXJmYWNlIEJlcmtlbHlCcmlkZ2VUZXh0R2VuZXJhdG9yQ29uZmlnIGV4dGVuZHMgUGx1Z2luQ29uZmlndXJhdGlvbkRhdGEge1xuICBiZXJrZWx5YnJpZGdlQmFzZVVybDogc3RyaW5nO1xufVxuXG5pbnRlcmZhY2UgVGV4dEdlbmVyYXRpZUNvbmZpZyB7XG4gIG1vZGVsSWQ6IHN0cmluZztcbiAgdGVtcGxhdGVJZDogc3RyaW5nO1xuICBwYXJhbWV0ZXJzOiBBcnJheTx7a2V5OiBzdHJpbmc7IHZhbHVlOiBzdHJpbmd9PjtcbiAgbmFhbTogc3RyaW5nO1xuICBmb3JtYXQ6IHN0cmluZztcbiAgdmFyaWFiZWxlTmFhbTogc3RyaW5nO1xufVxuXG5cbmV4cG9ydCB7QmVya2VseUJyaWRnZVRleHRHZW5lcmF0b3JDb25maWcsIFRleHRHZW5lcmF0aWVDb25maWd9O1xuIiwiLypcbiAqIENvcHlyaWdodCAyMDE1LTIwMjQuIFJpdGVuc2UgQlYsIHRoZSBOZXRoZXJsYW5kcy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciBFVVBMLCBWZXJzaW9uIDEuMiAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHBzOi8vam9pbnVwLmVjLmV1cm9wYS5ldS9jb2xsZWN0aW9uL2V1cGwvZXVwbC10ZXh0LWV1cGwtMTJcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgYmFzaXMsXG4gKlxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlclxuICogZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICovXG5cbmV4cG9ydCAqIGZyb20gJy4vY29uZmlnJztcbiIsIm1vZHVsZS5leHBvcnRzID0gd2luZG93W1wiQGFuZ3VsYXIvY29tbW9uXCJdOyIsIm1vZHVsZS5leHBvcnRzID0gd2luZG93W1wiQGFuZ3VsYXIvY29yZVwiXTsiLCJtb2R1bGUuZXhwb3J0cyA9IHdpbmRvd1tcIkB2YWx0aW1vL2NvbXBvbmVudHNcIl07IiwibW9kdWxlLmV4cG9ydHMgPSB3aW5kb3dbXCJAdmFsdGltby9wbHVnaW5cIl07IiwibW9kdWxlLmV4cG9ydHMgPSB3aW5kb3dbXCJyeGpzXCJdOyIsIm1vZHVsZS5leHBvcnRzID0gd2luZG93W1widHNsaWJcIl07IiwiLyoqXG4gKiBAbGljZW5zZSBBbmd1bGFyIHYxNy4zLjEyXG4gKiAoYykgMjAxMC0yMDI0IEdvb2dsZSBMTEMuIGh0dHBzOi8vYW5ndWxhci5pby9cbiAqIExpY2Vuc2U6IE1JVFxuICovXG5cbmltcG9ydCAqIGFzIGkwIGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgRGlyZWN0aXZlLCBJbmplY3Rpb25Ub2tlbiwgZm9yd2FyZFJlZiwgT3B0aW9uYWwsIEluamVjdCwgybVpc1Byb21pc2UsIMm1aXNTdWJzY3JpYmFibGUsIMm1UnVudGltZUVycm9yLCBTZWxmLCBFdmVudEVtaXR0ZXIsIElucHV0LCBIb3N0LCBTa2lwU2VsZiwgYm9vbGVhbkF0dHJpYnV0ZSwgQ2hhbmdlRGV0ZWN0b3JSZWYsIE91dHB1dCwgSW5qZWN0YWJsZSwgaW5qZWN0LCBOZ01vZHVsZSwgVmVyc2lvbiB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgybVnZXRET00gfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHsgZnJvbSwgZm9ya0pvaW4gfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IG1hcCB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcblxuLyoqXG4gKiBCYXNlIGNsYXNzIGZvciBhbGwgQ29udHJvbFZhbHVlQWNjZXNzb3IgY2xhc3NlcyBkZWZpbmVkIGluIEZvcm1zIHBhY2thZ2UuXG4gKiBDb250YWlucyBjb21tb24gbG9naWMgYW5kIHV0aWxpdHkgZnVuY3Rpb25zLlxuICpcbiAqIE5vdGU6IHRoaXMgaXMgYW4gKmludGVybmFsLW9ubHkqIGNsYXNzIGFuZCBzaG91bGQgbm90IGJlIGV4dGVuZGVkIG9yIHVzZWQgZGlyZWN0bHkgaW5cbiAqIGFwcGxpY2F0aW9ucyBjb2RlLlxuICovXG5jbGFzcyBCYXNlQ29udHJvbFZhbHVlQWNjZXNzb3Ige1xuICAgIGNvbnN0cnVjdG9yKF9yZW5kZXJlciwgX2VsZW1lbnRSZWYpIHtcbiAgICAgICAgdGhpcy5fcmVuZGVyZXIgPSBfcmVuZGVyZXI7XG4gICAgICAgIHRoaXMuX2VsZW1lbnRSZWYgPSBfZWxlbWVudFJlZjtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSByZWdpc3RlcmVkIGNhbGxiYWNrIGZ1bmN0aW9uIGNhbGxlZCB3aGVuIGEgY2hhbmdlIG9yIGlucHV0IGV2ZW50IG9jY3VycyBvbiB0aGUgaW5wdXRcbiAgICAgICAgICogZWxlbWVudC5cbiAgICAgICAgICogQG5vZG9jXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm9uQ2hhbmdlID0gKF8pID0+IHsgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSByZWdpc3RlcmVkIGNhbGxiYWNrIGZ1bmN0aW9uIGNhbGxlZCB3aGVuIGEgYmx1ciBldmVudCBvY2N1cnMgb24gdGhlIGlucHV0IGVsZW1lbnQuXG4gICAgICAgICAqIEBub2RvY1xuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5vblRvdWNoZWQgPSAoKSA9PiB7IH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEhlbHBlciBtZXRob2QgdGhhdCBzZXRzIGEgcHJvcGVydHkgb24gYSB0YXJnZXQgZWxlbWVudCB1c2luZyB0aGUgY3VycmVudCBSZW5kZXJlclxuICAgICAqIGltcGxlbWVudGF0aW9uLlxuICAgICAqIEBub2RvY1xuICAgICAqL1xuICAgIHNldFByb3BlcnR5KGtleSwgdmFsdWUpIHtcbiAgICAgICAgdGhpcy5fcmVuZGVyZXIuc2V0UHJvcGVydHkodGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LCBrZXksIHZhbHVlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVnaXN0ZXJzIGEgZnVuY3Rpb24gY2FsbGVkIHdoZW4gdGhlIGNvbnRyb2wgaXMgdG91Y2hlZC5cbiAgICAgKiBAbm9kb2NcbiAgICAgKi9cbiAgICByZWdpc3Rlck9uVG91Y2hlZChmbikge1xuICAgICAgICB0aGlzLm9uVG91Y2hlZCA9IGZuO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWdpc3RlcnMgYSBmdW5jdGlvbiBjYWxsZWQgd2hlbiB0aGUgY29udHJvbCB2YWx1ZSBjaGFuZ2VzLlxuICAgICAqIEBub2RvY1xuICAgICAqL1xuICAgIHJlZ2lzdGVyT25DaGFuZ2UoZm4pIHtcbiAgICAgICAgdGhpcy5vbkNoYW5nZSA9IGZuO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBcImRpc2FibGVkXCIgcHJvcGVydHkgb24gdGhlIHJhbmdlIGlucHV0IGVsZW1lbnQuXG4gICAgICogQG5vZG9jXG4gICAgICovXG4gICAgc2V0RGlzYWJsZWRTdGF0ZShpc0Rpc2FibGVkKSB7XG4gICAgICAgIHRoaXMuc2V0UHJvcGVydHkoJ2Rpc2FibGVkJywgaXNEaXNhYmxlZCk7XG4gICAgfVxuICAgIHN0YXRpYyB7IHRoaXMuybVmYWMgPSBpMC7Jtcm1bmdEZWNsYXJlRmFjdG9yeSh7IG1pblZlcnNpb246IFwiMTIuMC4wXCIsIHZlcnNpb246IFwiMTcuMy4xMlwiLCBuZ0ltcG9ydDogaTAsIHR5cGU6IEJhc2VDb250cm9sVmFsdWVBY2Nlc3NvciwgZGVwczogW3sgdG9rZW46IGkwLlJlbmRlcmVyMiB9LCB7IHRva2VuOiBpMC5FbGVtZW50UmVmIH1dLCB0YXJnZXQ6IGkwLsm1ybVGYWN0b3J5VGFyZ2V0LkRpcmVjdGl2ZSB9KTsgfVxuICAgIHN0YXRpYyB7IHRoaXMuybVkaXIgPSBpMC7Jtcm1bmdEZWNsYXJlRGlyZWN0aXZlKHsgbWluVmVyc2lvbjogXCIxNC4wLjBcIiwgdmVyc2lvbjogXCIxNy4zLjEyXCIsIHR5cGU6IEJhc2VDb250cm9sVmFsdWVBY2Nlc3NvciwgbmdJbXBvcnQ6IGkwIH0pOyB9XG59XG5pMC7Jtcm1bmdEZWNsYXJlQ2xhc3NNZXRhZGF0YSh7IG1pblZlcnNpb246IFwiMTIuMC4wXCIsIHZlcnNpb246IFwiMTcuMy4xMlwiLCBuZ0ltcG9ydDogaTAsIHR5cGU6IEJhc2VDb250cm9sVmFsdWVBY2Nlc3NvciwgZGVjb3JhdG9yczogW3tcbiAgICAgICAgICAgIHR5cGU6IERpcmVjdGl2ZVxuICAgICAgICB9XSwgY3RvclBhcmFtZXRlcnM6ICgpID0+IFt7IHR5cGU6IGkwLlJlbmRlcmVyMiB9LCB7IHR5cGU6IGkwLkVsZW1lbnRSZWYgfV0gfSk7XG4vKipcbiAqIEJhc2UgY2xhc3MgZm9yIGFsbCBidWlsdC1pbiBDb250cm9sVmFsdWVBY2Nlc3NvciBjbGFzc2VzIChleGNlcHQgRGVmYXVsdFZhbHVlQWNjZXNzb3IsIHdoaWNoIGlzXG4gKiB1c2VkIGluIGNhc2Ugbm8gb3RoZXIgQ1ZBcyBjYW4gYmUgZm91bmQpLiBXZSB1c2UgdGhpcyBjbGFzcyB0byBkaXN0aW5ndWlzaCBiZXR3ZWVuIGRlZmF1bHQgQ1ZBLFxuICogYnVpbHQtaW4gQ1ZBcyBhbmQgY3VzdG9tIENWQXMsIHNvIHRoYXQgRm9ybXMgbG9naWMgY2FuIHJlY29nbml6ZSBidWlsdC1pbiBDVkFzIGFuZCB0cmVhdCBjdXN0b21cbiAqIG9uZXMgd2l0aCBoaWdoZXIgcHJpb3JpdHkgKHdoZW4gYm90aCBidWlsdC1pbiBhbmQgY3VzdG9tIENWQXMgYXJlIHByZXNlbnQpLlxuICpcbiAqIE5vdGU6IHRoaXMgaXMgYW4gKmludGVybmFsLW9ubHkqIGNsYXNzIGFuZCBzaG91bGQgbm90IGJlIGV4dGVuZGVkIG9yIHVzZWQgZGlyZWN0bHkgaW5cbiAqIGFwcGxpY2F0aW9ucyBjb2RlLlxuICovXG5jbGFzcyBCdWlsdEluQ29udHJvbFZhbHVlQWNjZXNzb3IgZXh0ZW5kcyBCYXNlQ29udHJvbFZhbHVlQWNjZXNzb3Ige1xuICAgIHN0YXRpYyB7IHRoaXMuybVmYWMgPSBpMC7Jtcm1bmdEZWNsYXJlRmFjdG9yeSh7IG1pblZlcnNpb246IFwiMTIuMC4wXCIsIHZlcnNpb246IFwiMTcuMy4xMlwiLCBuZ0ltcG9ydDogaTAsIHR5cGU6IEJ1aWx0SW5Db250cm9sVmFsdWVBY2Nlc3NvciwgZGVwczogbnVsbCwgdGFyZ2V0OiBpMC7Jtcm1RmFjdG9yeVRhcmdldC5EaXJlY3RpdmUgfSk7IH1cbiAgICBzdGF0aWMgeyB0aGlzLsm1ZGlyID0gaTAuybXJtW5nRGVjbGFyZURpcmVjdGl2ZSh7IG1pblZlcnNpb246IFwiMTQuMC4wXCIsIHZlcnNpb246IFwiMTcuMy4xMlwiLCB0eXBlOiBCdWlsdEluQ29udHJvbFZhbHVlQWNjZXNzb3IsIHVzZXNJbmhlcml0YW5jZTogdHJ1ZSwgbmdJbXBvcnQ6IGkwIH0pOyB9XG59XG5pMC7Jtcm1bmdEZWNsYXJlQ2xhc3NNZXRhZGF0YSh7IG1pblZlcnNpb246IFwiMTIuMC4wXCIsIHZlcnNpb246IFwiMTcuMy4xMlwiLCBuZ0ltcG9ydDogaTAsIHR5cGU6IEJ1aWx0SW5Db250cm9sVmFsdWVBY2Nlc3NvciwgZGVjb3JhdG9yczogW3tcbiAgICAgICAgICAgIHR5cGU6IERpcmVjdGl2ZVxuICAgICAgICB9XSB9KTtcbi8qKlxuICogVXNlZCB0byBwcm92aWRlIGEgYENvbnRyb2xWYWx1ZUFjY2Vzc29yYCBmb3IgZm9ybSBjb250cm9scy5cbiAqXG4gKiBTZWUgYERlZmF1bHRWYWx1ZUFjY2Vzc29yYCBmb3IgaG93IHRvIGltcGxlbWVudCBvbmUuXG4gKlxuICogQHB1YmxpY0FwaVxuICovXG5jb25zdCBOR19WQUxVRV9BQ0NFU1NPUiA9IG5ldyBJbmplY3Rpb25Ub2tlbihuZ0Rldk1vZGUgPyAnTmdWYWx1ZUFjY2Vzc29yJyA6ICcnKTtcblxuY29uc3QgQ0hFQ0tCT1hfVkFMVUVfQUNDRVNTT1IgPSB7XG4gICAgcHJvdmlkZTogTkdfVkFMVUVfQUNDRVNTT1IsXG4gICAgdXNlRXhpc3Rpbmc6IGZvcndhcmRSZWYoKCkgPT4gQ2hlY2tib3hDb250cm9sVmFsdWVBY2Nlc3NvciksXG4gICAgbXVsdGk6IHRydWUsXG59O1xuLyoqXG4gKiBAZGVzY3JpcHRpb25cbiAqIEEgYENvbnRyb2xWYWx1ZUFjY2Vzc29yYCBmb3Igd3JpdGluZyBhIHZhbHVlIGFuZCBsaXN0ZW5pbmcgdG8gY2hhbmdlcyBvbiBhIGNoZWNrYm94IGlucHV0XG4gKiBlbGVtZW50LlxuICpcbiAqIEB1c2FnZU5vdGVzXG4gKlxuICogIyMjIFVzaW5nIGEgY2hlY2tib3ggd2l0aCBhIHJlYWN0aXZlIGZvcm0uXG4gKlxuICogVGhlIGZvbGxvd2luZyBleGFtcGxlIHNob3dzIGhvdyB0byB1c2UgYSBjaGVja2JveCB3aXRoIGEgcmVhY3RpdmUgZm9ybS5cbiAqXG4gKiBgYGB0c1xuICogY29uc3QgcmVtZW1iZXJMb2dpbkNvbnRyb2wgPSBuZXcgRm9ybUNvbnRyb2woKTtcbiAqIGBgYFxuICpcbiAqIGBgYFxuICogPGlucHV0IHR5cGU9XCJjaGVja2JveFwiIFtmb3JtQ29udHJvbF09XCJyZW1lbWJlckxvZ2luQ29udHJvbFwiPlxuICogYGBgXG4gKlxuICogQG5nTW9kdWxlIFJlYWN0aXZlRm9ybXNNb2R1bGVcbiAqIEBuZ01vZHVsZSBGb3Jtc01vZHVsZVxuICogQHB1YmxpY0FwaVxuICovXG5jbGFzcyBDaGVja2JveENvbnRyb2xWYWx1ZUFjY2Vzc29yIGV4dGVuZHMgQnVpbHRJbkNvbnRyb2xWYWx1ZUFjY2Vzc29yIHtcbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBcImNoZWNrZWRcIiBwcm9wZXJ0eSBvbiB0aGUgaW5wdXQgZWxlbWVudC5cbiAgICAgKiBAbm9kb2NcbiAgICAgKi9cbiAgICB3cml0ZVZhbHVlKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuc2V0UHJvcGVydHkoJ2NoZWNrZWQnLCB2YWx1ZSk7XG4gICAgfVxuICAgIHN0YXRpYyB7IHRoaXMuybVmYWMgPSBpMC7Jtcm1bmdEZWNsYXJlRmFjdG9yeSh7IG1pblZlcnNpb246IFwiMTIuMC4wXCIsIHZlcnNpb246IFwiMTcuMy4xMlwiLCBuZ0ltcG9ydDogaTAsIHR5cGU6IENoZWNrYm94Q29udHJvbFZhbHVlQWNjZXNzb3IsIGRlcHM6IG51bGwsIHRhcmdldDogaTAuybXJtUZhY3RvcnlUYXJnZXQuRGlyZWN0aXZlIH0pOyB9XG4gICAgc3RhdGljIHsgdGhpcy7JtWRpciA9IGkwLsm1ybVuZ0RlY2xhcmVEaXJlY3RpdmUoeyBtaW5WZXJzaW9uOiBcIjE0LjAuMFwiLCB2ZXJzaW9uOiBcIjE3LjMuMTJcIiwgdHlwZTogQ2hlY2tib3hDb250cm9sVmFsdWVBY2Nlc3Nvciwgc2VsZWN0b3I6IFwiaW5wdXRbdHlwZT1jaGVja2JveF1bZm9ybUNvbnRyb2xOYW1lXSxpbnB1dFt0eXBlPWNoZWNrYm94XVtmb3JtQ29udHJvbF0saW5wdXRbdHlwZT1jaGVja2JveF1bbmdNb2RlbF1cIiwgaG9zdDogeyBsaXN0ZW5lcnM6IHsgXCJjaGFuZ2VcIjogXCJvbkNoYW5nZSgkZXZlbnQudGFyZ2V0LmNoZWNrZWQpXCIsIFwiYmx1clwiOiBcIm9uVG91Y2hlZCgpXCIgfSB9LCBwcm92aWRlcnM6IFtDSEVDS0JPWF9WQUxVRV9BQ0NFU1NPUl0sIHVzZXNJbmhlcml0YW5jZTogdHJ1ZSwgbmdJbXBvcnQ6IGkwIH0pOyB9XG59XG5pMC7Jtcm1bmdEZWNsYXJlQ2xhc3NNZXRhZGF0YSh7IG1pblZlcnNpb246IFwiMTIuMC4wXCIsIHZlcnNpb246IFwiMTcuMy4xMlwiLCBuZ0ltcG9ydDogaTAsIHR5cGU6IENoZWNrYm94Q29udHJvbFZhbHVlQWNjZXNzb3IsIGRlY29yYXRvcnM6IFt7XG4gICAgICAgICAgICB0eXBlOiBEaXJlY3RpdmUsXG4gICAgICAgICAgICBhcmdzOiBbe1xuICAgICAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ2lucHV0W3R5cGU9Y2hlY2tib3hdW2Zvcm1Db250cm9sTmFtZV0saW5wdXRbdHlwZT1jaGVja2JveF1bZm9ybUNvbnRyb2xdLGlucHV0W3R5cGU9Y2hlY2tib3hdW25nTW9kZWxdJyxcbiAgICAgICAgICAgICAgICAgICAgaG9zdDogeyAnKGNoYW5nZSknOiAnb25DaGFuZ2UoJGV2ZW50LnRhcmdldC5jaGVja2VkKScsICcoYmx1ciknOiAnb25Ub3VjaGVkKCknIH0sXG4gICAgICAgICAgICAgICAgICAgIHByb3ZpZGVyczogW0NIRUNLQk9YX1ZBTFVFX0FDQ0VTU09SXVxuICAgICAgICAgICAgICAgIH1dXG4gICAgICAgIH1dIH0pO1xuXG5jb25zdCBERUZBVUxUX1ZBTFVFX0FDQ0VTU09SID0ge1xuICAgIHByb3ZpZGU6IE5HX1ZBTFVFX0FDQ0VTU09SLFxuICAgIHVzZUV4aXN0aW5nOiBmb3J3YXJkUmVmKCgpID0+IERlZmF1bHRWYWx1ZUFjY2Vzc29yKSxcbiAgICBtdWx0aTogdHJ1ZVxufTtcbi8qKlxuICogV2UgbXVzdCBjaGVjayB3aGV0aGVyIHRoZSBhZ2VudCBpcyBBbmRyb2lkIGJlY2F1c2UgY29tcG9zaXRpb24gZXZlbnRzXG4gKiBiZWhhdmUgZGlmZmVyZW50bHkgYmV0d2VlbiBpT1MgYW5kIEFuZHJvaWQuXG4gKi9cbmZ1bmN0aW9uIF9pc0FuZHJvaWQoKSB7XG4gICAgY29uc3QgdXNlckFnZW50ID0gybVnZXRET00oKSA/IMm1Z2V0RE9NKCkuZ2V0VXNlckFnZW50KCkgOiAnJztcbiAgICByZXR1cm4gL2FuZHJvaWQgKFxcZCspLy50ZXN0KHVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpKTtcbn1cbi8qKlxuICogQGRlc2NyaXB0aW9uXG4gKiBQcm92aWRlIHRoaXMgdG9rZW4gdG8gY29udHJvbCBpZiBmb3JtIGRpcmVjdGl2ZXMgYnVmZmVyIElNRSBpbnB1dCB1bnRpbFxuICogdGhlIFwiY29tcG9zaXRpb25lbmRcIiBldmVudCBvY2N1cnMuXG4gKiBAcHVibGljQXBpXG4gKi9cbmNvbnN0IENPTVBPU0lUSU9OX0JVRkZFUl9NT0RFID0gbmV3IEluamVjdGlvblRva2VuKG5nRGV2TW9kZSA/ICdDb21wb3NpdGlvbkV2ZW50TW9kZScgOiAnJyk7XG4vKipcbiAqIFRoZSBkZWZhdWx0IGBDb250cm9sVmFsdWVBY2Nlc3NvcmAgZm9yIHdyaXRpbmcgYSB2YWx1ZSBhbmQgbGlzdGVuaW5nIHRvIGNoYW5nZXMgb24gaW5wdXRcbiAqIGVsZW1lbnRzLiBUaGUgYWNjZXNzb3IgaXMgdXNlZCBieSB0aGUgYEZvcm1Db250cm9sRGlyZWN0aXZlYCwgYEZvcm1Db250cm9sTmFtZWAsIGFuZFxuICogYE5nTW9kZWxgIGRpcmVjdGl2ZXMuXG4gKlxuICoge0BzZWFyY2hLZXl3b3JkcyBuZ0RlZmF1bHRDb250cm9sfVxuICpcbiAqIEB1c2FnZU5vdGVzXG4gKlxuICogIyMjIFVzaW5nIHRoZSBkZWZhdWx0IHZhbHVlIGFjY2Vzc29yXG4gKlxuICogVGhlIGZvbGxvd2luZyBleGFtcGxlIHNob3dzIGhvdyB0byB1c2UgYW4gaW5wdXQgZWxlbWVudCB0aGF0IGFjdGl2YXRlcyB0aGUgZGVmYXVsdCB2YWx1ZSBhY2Nlc3NvclxuICogKGluIHRoaXMgY2FzZSwgYSB0ZXh0IGZpZWxkKS5cbiAqXG4gKiBgYGB0c1xuICogY29uc3QgZmlyc3ROYW1lQ29udHJvbCA9IG5ldyBGb3JtQ29udHJvbCgpO1xuICogYGBgXG4gKlxuICogYGBgXG4gKiA8aW5wdXQgdHlwZT1cInRleHRcIiBbZm9ybUNvbnRyb2xdPVwiZmlyc3ROYW1lQ29udHJvbFwiPlxuICogYGBgXG4gKlxuICogVGhpcyB2YWx1ZSBhY2Nlc3NvciBpcyB1c2VkIGJ5IGRlZmF1bHQgZm9yIGA8aW5wdXQgdHlwZT1cInRleHRcIj5gIGFuZCBgPHRleHRhcmVhPmAgZWxlbWVudHMsIGJ1dFxuICogeW91IGNvdWxkIGFsc28gdXNlIGl0IGZvciBjdXN0b20gY29tcG9uZW50cyB0aGF0IGhhdmUgc2ltaWxhciBiZWhhdmlvciBhbmQgZG8gbm90IHJlcXVpcmUgc3BlY2lhbFxuICogcHJvY2Vzc2luZy4gSW4gb3JkZXIgdG8gYXR0YWNoIHRoZSBkZWZhdWx0IHZhbHVlIGFjY2Vzc29yIHRvIGEgY3VzdG9tIGVsZW1lbnQsIGFkZCB0aGVcbiAqIGBuZ0RlZmF1bHRDb250cm9sYCBhdHRyaWJ1dGUgYXMgc2hvd24gYmVsb3cuXG4gKlxuICogYGBgXG4gKiA8Y3VzdG9tLWlucHV0LWNvbXBvbmVudCBuZ0RlZmF1bHRDb250cm9sIFsobmdNb2RlbCldPVwidmFsdWVcIj48L2N1c3RvbS1pbnB1dC1jb21wb25lbnQ+XG4gKiBgYGBcbiAqXG4gKiBAbmdNb2R1bGUgUmVhY3RpdmVGb3Jtc01vZHVsZVxuICogQG5nTW9kdWxlIEZvcm1zTW9kdWxlXG4gKiBAcHVibGljQXBpXG4gKi9cbmNsYXNzIERlZmF1bHRWYWx1ZUFjY2Vzc29yIGV4dGVuZHMgQmFzZUNvbnRyb2xWYWx1ZUFjY2Vzc29yIHtcbiAgICBjb25zdHJ1Y3RvcihyZW5kZXJlciwgZWxlbWVudFJlZiwgX2NvbXBvc2l0aW9uTW9kZSkge1xuICAgICAgICBzdXBlcihyZW5kZXJlciwgZWxlbWVudFJlZik7XG4gICAgICAgIHRoaXMuX2NvbXBvc2l0aW9uTW9kZSA9IF9jb21wb3NpdGlvbk1vZGU7XG4gICAgICAgIC8qKiBXaGV0aGVyIHRoZSB1c2VyIGlzIGNyZWF0aW5nIGEgY29tcG9zaXRpb24gc3RyaW5nIChJTUUgZXZlbnRzKS4gKi9cbiAgICAgICAgdGhpcy5fY29tcG9zaW5nID0gZmFsc2U7XG4gICAgICAgIGlmICh0aGlzLl9jb21wb3NpdGlvbk1vZGUgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5fY29tcG9zaXRpb25Nb2RlID0gIV9pc0FuZHJvaWQoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBcInZhbHVlXCIgcHJvcGVydHkgb24gdGhlIGlucHV0IGVsZW1lbnQuXG4gICAgICogQG5vZG9jXG4gICAgICovXG4gICAgd3JpdGVWYWx1ZSh2YWx1ZSkge1xuICAgICAgICBjb25zdCBub3JtYWxpemVkVmFsdWUgPSB2YWx1ZSA9PSBudWxsID8gJycgOiB2YWx1ZTtcbiAgICAgICAgdGhpcy5zZXRQcm9wZXJ0eSgndmFsdWUnLCBub3JtYWxpemVkVmFsdWUpO1xuICAgIH1cbiAgICAvKiogQGludGVybmFsICovXG4gICAgX2hhbmRsZUlucHV0KHZhbHVlKSB7XG4gICAgICAgIGlmICghdGhpcy5fY29tcG9zaXRpb25Nb2RlIHx8ICh0aGlzLl9jb21wb3NpdGlvbk1vZGUgJiYgIXRoaXMuX2NvbXBvc2luZykpIHtcbiAgICAgICAgICAgIHRoaXMub25DaGFuZ2UodmFsdWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBfY29tcG9zaXRpb25TdGFydCgpIHtcbiAgICAgICAgdGhpcy5fY29tcG9zaW5nID0gdHJ1ZTtcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIF9jb21wb3NpdGlvbkVuZCh2YWx1ZSkge1xuICAgICAgICB0aGlzLl9jb21wb3NpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fY29tcG9zaXRpb25Nb2RlICYmIHRoaXMub25DaGFuZ2UodmFsdWUpO1xuICAgIH1cbiAgICBzdGF0aWMgeyB0aGlzLsm1ZmFjID0gaTAuybXJtW5nRGVjbGFyZUZhY3RvcnkoeyBtaW5WZXJzaW9uOiBcIjEyLjAuMFwiLCB2ZXJzaW9uOiBcIjE3LjMuMTJcIiwgbmdJbXBvcnQ6IGkwLCB0eXBlOiBEZWZhdWx0VmFsdWVBY2Nlc3NvciwgZGVwczogW3sgdG9rZW46IGkwLlJlbmRlcmVyMiB9LCB7IHRva2VuOiBpMC5FbGVtZW50UmVmIH0sIHsgdG9rZW46IENPTVBPU0lUSU9OX0JVRkZFUl9NT0RFLCBvcHRpb25hbDogdHJ1ZSB9XSwgdGFyZ2V0OiBpMC7Jtcm1RmFjdG9yeVRhcmdldC5EaXJlY3RpdmUgfSk7IH1cbiAgICBzdGF0aWMgeyB0aGlzLsm1ZGlyID0gaTAuybXJtW5nRGVjbGFyZURpcmVjdGl2ZSh7IG1pblZlcnNpb246IFwiMTQuMC4wXCIsIHZlcnNpb246IFwiMTcuMy4xMlwiLCB0eXBlOiBEZWZhdWx0VmFsdWVBY2Nlc3Nvciwgc2VsZWN0b3I6IFwiaW5wdXQ6bm90KFt0eXBlPWNoZWNrYm94XSlbZm9ybUNvbnRyb2xOYW1lXSx0ZXh0YXJlYVtmb3JtQ29udHJvbE5hbWVdLGlucHV0Om5vdChbdHlwZT1jaGVja2JveF0pW2Zvcm1Db250cm9sXSx0ZXh0YXJlYVtmb3JtQ29udHJvbF0saW5wdXQ6bm90KFt0eXBlPWNoZWNrYm94XSlbbmdNb2RlbF0sdGV4dGFyZWFbbmdNb2RlbF0sW25nRGVmYXVsdENvbnRyb2xdXCIsIGhvc3Q6IHsgbGlzdGVuZXJzOiB7IFwiaW5wdXRcIjogXCIkYW55KHRoaXMpLl9oYW5kbGVJbnB1dCgkZXZlbnQudGFyZ2V0LnZhbHVlKVwiLCBcImJsdXJcIjogXCJvblRvdWNoZWQoKVwiLCBcImNvbXBvc2l0aW9uc3RhcnRcIjogXCIkYW55KHRoaXMpLl9jb21wb3NpdGlvblN0YXJ0KClcIiwgXCJjb21wb3NpdGlvbmVuZFwiOiBcIiRhbnkodGhpcykuX2NvbXBvc2l0aW9uRW5kKCRldmVudC50YXJnZXQudmFsdWUpXCIgfSB9LCBwcm92aWRlcnM6IFtERUZBVUxUX1ZBTFVFX0FDQ0VTU09SXSwgdXNlc0luaGVyaXRhbmNlOiB0cnVlLCBuZ0ltcG9ydDogaTAgfSk7IH1cbn1cbmkwLsm1ybVuZ0RlY2xhcmVDbGFzc01ldGFkYXRhKHsgbWluVmVyc2lvbjogXCIxMi4wLjBcIiwgdmVyc2lvbjogXCIxNy4zLjEyXCIsIG5nSW1wb3J0OiBpMCwgdHlwZTogRGVmYXVsdFZhbHVlQWNjZXNzb3IsIGRlY29yYXRvcnM6IFt7XG4gICAgICAgICAgICB0eXBlOiBEaXJlY3RpdmUsXG4gICAgICAgICAgICBhcmdzOiBbe1xuICAgICAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ2lucHV0Om5vdChbdHlwZT1jaGVja2JveF0pW2Zvcm1Db250cm9sTmFtZV0sdGV4dGFyZWFbZm9ybUNvbnRyb2xOYW1lXSxpbnB1dDpub3QoW3R5cGU9Y2hlY2tib3hdKVtmb3JtQ29udHJvbF0sdGV4dGFyZWFbZm9ybUNvbnRyb2xdLGlucHV0Om5vdChbdHlwZT1jaGVja2JveF0pW25nTW9kZWxdLHRleHRhcmVhW25nTW9kZWxdLFtuZ0RlZmF1bHRDb250cm9sXScsXG4gICAgICAgICAgICAgICAgICAgIC8vIFRPRE86IHZzYXZraW4gcmVwbGFjZSB0aGUgYWJvdmUgc2VsZWN0b3Igd2l0aCB0aGUgb25lIGJlbG93IGl0IG9uY2VcbiAgICAgICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2FuZ3VsYXIvYW5ndWxhci9pc3N1ZXMvMzAxMSBpcyBpbXBsZW1lbnRlZFxuICAgICAgICAgICAgICAgICAgICAvLyBzZWxlY3RvcjogJ1tuZ01vZGVsXSxbZm9ybUNvbnRyb2xdLFtmb3JtQ29udHJvbE5hbWVdJyxcbiAgICAgICAgICAgICAgICAgICAgaG9zdDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgJyhpbnB1dCknOiAnJGFueSh0aGlzKS5faGFuZGxlSW5wdXQoJGV2ZW50LnRhcmdldC52YWx1ZSknLFxuICAgICAgICAgICAgICAgICAgICAgICAgJyhibHVyKSc6ICdvblRvdWNoZWQoKScsXG4gICAgICAgICAgICAgICAgICAgICAgICAnKGNvbXBvc2l0aW9uc3RhcnQpJzogJyRhbnkodGhpcykuX2NvbXBvc2l0aW9uU3RhcnQoKScsXG4gICAgICAgICAgICAgICAgICAgICAgICAnKGNvbXBvc2l0aW9uZW5kKSc6ICckYW55KHRoaXMpLl9jb21wb3NpdGlvbkVuZCgkZXZlbnQudGFyZ2V0LnZhbHVlKSdcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgcHJvdmlkZXJzOiBbREVGQVVMVF9WQUxVRV9BQ0NFU1NPUl1cbiAgICAgICAgICAgICAgICB9XVxuICAgICAgICB9XSwgY3RvclBhcmFtZXRlcnM6ICgpID0+IFt7IHR5cGU6IGkwLlJlbmRlcmVyMiB9LCB7IHR5cGU6IGkwLkVsZW1lbnRSZWYgfSwgeyB0eXBlOiB1bmRlZmluZWQsIGRlY29yYXRvcnM6IFt7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IE9wdGlvbmFsXG4gICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBJbmplY3QsXG4gICAgICAgICAgICAgICAgICAgIGFyZ3M6IFtDT01QT1NJVElPTl9CVUZGRVJfTU9ERV1cbiAgICAgICAgICAgICAgICB9XSB9XSB9KTtcblxuZnVuY3Rpb24gaXNFbXB0eUlucHV0VmFsdWUodmFsdWUpIHtcbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiB0aGUgb2JqZWN0IGlzIGEgc3RyaW5nIG9yIGFycmF5IGJlZm9yZSBldmFsdWF0aW5nIHRoZSBsZW5ndGggYXR0cmlidXRlLlxuICAgICAqIFRoaXMgYXZvaWRzIGZhbHNlbHkgcmVqZWN0aW5nIG9iamVjdHMgdGhhdCBjb250YWluIGEgY3VzdG9tIGxlbmd0aCBhdHRyaWJ1dGUuXG4gICAgICogRm9yIGV4YW1wbGUsIHRoZSBvYmplY3Qge2lkOiAxLCBsZW5ndGg6IDAsIHdpZHRoOiAwfSBzaG91bGQgbm90IGJlIHJldHVybmVkIGFzIGVtcHR5LlxuICAgICAqL1xuICAgIHJldHVybiB2YWx1ZSA9PSBudWxsIHx8XG4gICAgICAgICgodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyB8fCBBcnJheS5pc0FycmF5KHZhbHVlKSkgJiYgdmFsdWUubGVuZ3RoID09PSAwKTtcbn1cbmZ1bmN0aW9uIGhhc1ZhbGlkTGVuZ3RoKHZhbHVlKSB7XG4gICAgLy8gbm9uLXN0cmljdCBjb21wYXJpc29uIGlzIGludGVudGlvbmFsLCB0byBjaGVjayBmb3IgYm90aCBgbnVsbGAgYW5kIGB1bmRlZmluZWRgIHZhbHVlc1xuICAgIHJldHVybiB2YWx1ZSAhPSBudWxsICYmIHR5cGVvZiB2YWx1ZS5sZW5ndGggPT09ICdudW1iZXInO1xufVxuLyoqXG4gKiBAZGVzY3JpcHRpb25cbiAqIEFuIGBJbmplY3Rpb25Ub2tlbmAgZm9yIHJlZ2lzdGVyaW5nIGFkZGl0aW9uYWwgc3luY2hyb25vdXMgdmFsaWRhdG9ycyB1c2VkIHdpdGhcbiAqIGBBYnN0cmFjdENvbnRyb2xgcy5cbiAqXG4gKiBAc2VlIHtAbGluayBOR19BU1lOQ19WQUxJREFUT1JTfVxuICpcbiAqIEB1c2FnZU5vdGVzXG4gKlxuICogIyMjIFByb3ZpZGluZyBhIGN1c3RvbSB2YWxpZGF0b3JcbiAqXG4gKiBUaGUgZm9sbG93aW5nIGV4YW1wbGUgcmVnaXN0ZXJzIGEgY3VzdG9tIHZhbGlkYXRvciBkaXJlY3RpdmUuIEFkZGluZyB0aGUgdmFsaWRhdG9yIHRvIHRoZVxuICogZXhpc3RpbmcgY29sbGVjdGlvbiBvZiB2YWxpZGF0b3JzIHJlcXVpcmVzIHRoZSBgbXVsdGk6IHRydWVgIG9wdGlvbi5cbiAqXG4gKiBgYGB0eXBlc2NyaXB0XG4gKiBARGlyZWN0aXZlKHtcbiAqICAgc2VsZWN0b3I6ICdbY3VzdG9tVmFsaWRhdG9yXScsXG4gKiAgIHByb3ZpZGVyczogW3twcm92aWRlOiBOR19WQUxJREFUT1JTLCB1c2VFeGlzdGluZzogQ3VzdG9tVmFsaWRhdG9yRGlyZWN0aXZlLCBtdWx0aTogdHJ1ZX1dXG4gKiB9KVxuICogY2xhc3MgQ3VzdG9tVmFsaWRhdG9yRGlyZWN0aXZlIGltcGxlbWVudHMgVmFsaWRhdG9yIHtcbiAqICAgdmFsaWRhdGUoY29udHJvbDogQWJzdHJhY3RDb250cm9sKTogVmFsaWRhdGlvbkVycm9ycyB8IG51bGwge1xuICogICAgIHJldHVybiB7ICdjdXN0b20nOiB0cnVlIH07XG4gKiAgIH1cbiAqIH1cbiAqIGBgYFxuICpcbiAqIEBwdWJsaWNBcGlcbiAqL1xuY29uc3QgTkdfVkFMSURBVE9SUyA9IG5ldyBJbmplY3Rpb25Ub2tlbihuZ0Rldk1vZGUgPyAnTmdWYWxpZGF0b3JzJyA6ICcnKTtcbi8qKlxuICogQGRlc2NyaXB0aW9uXG4gKiBBbiBgSW5qZWN0aW9uVG9rZW5gIGZvciByZWdpc3RlcmluZyBhZGRpdGlvbmFsIGFzeW5jaHJvbm91cyB2YWxpZGF0b3JzIHVzZWQgd2l0aFxuICogYEFic3RyYWN0Q29udHJvbGBzLlxuICpcbiAqIEBzZWUge0BsaW5rIE5HX1ZBTElEQVRPUlN9XG4gKlxuICogQHVzYWdlTm90ZXNcbiAqXG4gKiAjIyMgUHJvdmlkZSBhIGN1c3RvbSBhc3luYyB2YWxpZGF0b3IgZGlyZWN0aXZlXG4gKlxuICogVGhlIGZvbGxvd2luZyBleGFtcGxlIGltcGxlbWVudHMgdGhlIGBBc3luY1ZhbGlkYXRvcmAgaW50ZXJmYWNlIHRvIGNyZWF0ZSBhblxuICogYXN5bmMgdmFsaWRhdG9yIGRpcmVjdGl2ZSB3aXRoIGEgY3VzdG9tIGVycm9yIGtleS5cbiAqXG4gKiBgYGB0eXBlc2NyaXB0XG4gKiBARGlyZWN0aXZlKHtcbiAqICAgc2VsZWN0b3I6ICdbY3VzdG9tQXN5bmNWYWxpZGF0b3JdJyxcbiAqICAgcHJvdmlkZXJzOiBbe3Byb3ZpZGU6IE5HX0FTWU5DX1ZBTElEQVRPUlMsIHVzZUV4aXN0aW5nOiBDdXN0b21Bc3luY1ZhbGlkYXRvckRpcmVjdGl2ZSwgbXVsdGk6XG4gKiB0cnVlfV1cbiAqIH0pXG4gKiBjbGFzcyBDdXN0b21Bc3luY1ZhbGlkYXRvckRpcmVjdGl2ZSBpbXBsZW1lbnRzIEFzeW5jVmFsaWRhdG9yIHtcbiAqICAgdmFsaWRhdGUoY29udHJvbDogQWJzdHJhY3RDb250cm9sKTogUHJvbWlzZTxWYWxpZGF0aW9uRXJyb3JzfG51bGw+IHtcbiAqICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHsnY3VzdG9tJzogdHJ1ZX0pO1xuICogICB9XG4gKiB9XG4gKiBgYGBcbiAqXG4gKiBAcHVibGljQXBpXG4gKi9cbmNvbnN0IE5HX0FTWU5DX1ZBTElEQVRPUlMgPSBuZXcgSW5qZWN0aW9uVG9rZW4obmdEZXZNb2RlID8gJ05nQXN5bmNWYWxpZGF0b3JzJyA6ICcnKTtcbi8qKlxuICogQSByZWd1bGFyIGV4cHJlc3Npb24gdGhhdCBtYXRjaGVzIHZhbGlkIGUtbWFpbCBhZGRyZXNzZXMuXG4gKlxuICogQXQgYSBoaWdoIGxldmVsLCB0aGlzIHJlZ2V4cCBtYXRjaGVzIGUtbWFpbCBhZGRyZXNzZXMgb2YgdGhlIGZvcm1hdCBgbG9jYWwtcGFydEB0bGRgLCB3aGVyZTpcbiAqIC0gYGxvY2FsLXBhcnRgIGNvbnNpc3RzIG9mIG9uZSBvciBtb3JlIG9mIHRoZSBhbGxvd2VkIGNoYXJhY3RlcnMgKGFscGhhbnVtZXJpYyBhbmQgc29tZVxuICogICBwdW5jdHVhdGlvbiBzeW1ib2xzKS5cbiAqIC0gYGxvY2FsLXBhcnRgIGNhbm5vdCBiZWdpbiBvciBlbmQgd2l0aCBhIHBlcmlvZCAoYC5gKS5cbiAqIC0gYGxvY2FsLXBhcnRgIGNhbm5vdCBiZSBsb25nZXIgdGhhbiA2NCBjaGFyYWN0ZXJzLlxuICogLSBgdGxkYCBjb25zaXN0cyBvZiBvbmUgb3IgbW9yZSBgbGFiZWxzYCBzZXBhcmF0ZWQgYnkgcGVyaW9kcyAoYC5gKS4gRm9yIGV4YW1wbGUgYGxvY2FsaG9zdGAgb3JcbiAqICAgYGZvby5jb21gLlxuICogLSBBIGBsYWJlbGAgY29uc2lzdHMgb2Ygb25lIG9yIG1vcmUgb2YgdGhlIGFsbG93ZWQgY2hhcmFjdGVycyAoYWxwaGFudW1lcmljLCBkYXNoZXMgKGAtYCkgYW5kXG4gKiAgIHBlcmlvZHMgKGAuYCkpLlxuICogLSBBIGBsYWJlbGAgY2Fubm90IGJlZ2luIG9yIGVuZCB3aXRoIGEgZGFzaCAoYC1gKSBvciBhIHBlcmlvZCAoYC5gKS5cbiAqIC0gQSBgbGFiZWxgIGNhbm5vdCBiZSBsb25nZXIgdGhhbiA2MyBjaGFyYWN0ZXJzLlxuICogLSBUaGUgd2hvbGUgYWRkcmVzcyBjYW5ub3QgYmUgbG9uZ2VyIHRoYW4gMjU0IGNoYXJhY3RlcnMuXG4gKlxuICogIyMgSW1wbGVtZW50YXRpb24gYmFja2dyb3VuZFxuICpcbiAqIFRoaXMgcmVnZXhwIHdhcyBwb3J0ZWQgb3ZlciBmcm9tIEFuZ3VsYXJKUyAoc2VlIHRoZXJlIGZvciBnaXQgaGlzdG9yeSk6XG4gKiBodHRwczovL2dpdGh1Yi5jb20vYW5ndWxhci9hbmd1bGFyLmpzL2Jsb2IvYzEzM2VmODM2L3NyYy9uZy9kaXJlY3RpdmUvaW5wdXQuanMjTDI3XG4gKiBJdCBpcyBiYXNlZCBvbiB0aGVcbiAqIFtXSEFUV0cgdmVyc2lvbl0oaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvaW5wdXQuaHRtbCN2YWxpZC1lLW1haWwtYWRkcmVzcykgd2l0aFxuICogc29tZSBlbmhhbmNlbWVudHMgdG8gaW5jb3Jwb3JhdGUgbW9yZSBSRkMgcnVsZXMgKHN1Y2ggYXMgcnVsZXMgcmVsYXRlZCB0byBkb21haW4gbmFtZXMgYW5kIHRoZVxuICogbGVuZ3RocyBvZiBkaWZmZXJlbnQgcGFydHMgb2YgdGhlIGFkZHJlc3MpLiBUaGUgbWFpbiBkaWZmZXJlbmNlcyBmcm9tIHRoZSBXSEFUV0cgdmVyc2lvbiBhcmU6XG4gKiAgIC0gRGlzYWxsb3cgYGxvY2FsLXBhcnRgIHRvIGJlZ2luIG9yIGVuZCB3aXRoIGEgcGVyaW9kIChgLmApLlxuICogICAtIERpc2FsbG93IGBsb2NhbC1wYXJ0YCBsZW5ndGggdG8gZXhjZWVkIDY0IGNoYXJhY3RlcnMuXG4gKiAgIC0gRGlzYWxsb3cgdG90YWwgYWRkcmVzcyBsZW5ndGggdG8gZXhjZWVkIDI1NCBjaGFyYWN0ZXJzLlxuICpcbiAqIFNlZSBbdGhpcyBjb21taXRdKGh0dHBzOi8vZ2l0aHViLmNvbS9hbmd1bGFyL2FuZ3VsYXIuanMvY29tbWl0L2YzZjVjZjcyZSkgZm9yIG1vcmUgZGV0YWlscy5cbiAqL1xuY29uc3QgRU1BSUxfUkVHRVhQID0gL14oPz0uezEsMjU0fSQpKD89LnsxLDY0fUApW2EtekEtWjAtOSEjJCUmJyorLz0/Xl9ge3x9fi1dKyg/OlxcLlthLXpBLVowLTkhIyQlJicqKy89P15fYHt8fX4tXSspKkBbYS16QS1aMC05XSg/OlthLXpBLVowLTktXXswLDYxfVthLXpBLVowLTldKT8oPzpcXC5bYS16QS1aMC05XSg/OlthLXpBLVowLTktXXswLDYxfVthLXpBLVowLTldKT8pKiQvO1xuLyoqXG4gKiBAZGVzY3JpcHRpb25cbiAqIFByb3ZpZGVzIGEgc2V0IG9mIGJ1aWx0LWluIHZhbGlkYXRvcnMgdGhhdCBjYW4gYmUgdXNlZCBieSBmb3JtIGNvbnRyb2xzLlxuICpcbiAqIEEgdmFsaWRhdG9yIGlzIGEgZnVuY3Rpb24gdGhhdCBwcm9jZXNzZXMgYSBgRm9ybUNvbnRyb2xgIG9yIGNvbGxlY3Rpb24gb2ZcbiAqIGNvbnRyb2xzIGFuZCByZXR1cm5zIGFuIGVycm9yIG1hcCBvciBudWxsLiBBIG51bGwgbWFwIG1lYW5zIHRoYXQgdmFsaWRhdGlvbiBoYXMgcGFzc2VkLlxuICpcbiAqIEBzZWUgW0Zvcm0gVmFsaWRhdGlvbl0oL2d1aWRlL2Zvcm0tdmFsaWRhdGlvbilcbiAqXG4gKiBAcHVibGljQXBpXG4gKi9cbmNsYXNzIFZhbGlkYXRvcnMge1xuICAgIC8qKlxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqIFZhbGlkYXRvciB0aGF0IHJlcXVpcmVzIHRoZSBjb250cm9sJ3MgdmFsdWUgdG8gYmUgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIHRoZSBwcm92aWRlZCBudW1iZXIuXG4gICAgICpcbiAgICAgKiBAdXNhZ2VOb3Rlc1xuICAgICAqXG4gICAgICogIyMjIFZhbGlkYXRlIGFnYWluc3QgYSBtaW5pbXVtIG9mIDNcbiAgICAgKlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBjb25zdCBjb250cm9sID0gbmV3IEZvcm1Db250cm9sKDIsIFZhbGlkYXRvcnMubWluKDMpKTtcbiAgICAgKlxuICAgICAqIGNvbnNvbGUubG9nKGNvbnRyb2wuZXJyb3JzKTsgLy8ge21pbjoge21pbjogMywgYWN0dWFsOiAyfX1cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIEEgdmFsaWRhdG9yIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhbiBlcnJvciBtYXAgd2l0aCB0aGVcbiAgICAgKiBgbWluYCBwcm9wZXJ0eSBpZiB0aGUgdmFsaWRhdGlvbiBjaGVjayBmYWlscywgb3RoZXJ3aXNlIGBudWxsYC5cbiAgICAgKlxuICAgICAqIEBzZWUge0BsaW5rIHVwZGF0ZVZhbHVlQW5kVmFsaWRpdHkoKX1cbiAgICAgKlxuICAgICAqL1xuICAgIHN0YXRpYyBtaW4obWluKSB7XG4gICAgICAgIHJldHVybiBtaW5WYWxpZGF0b3IobWluKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICogVmFsaWRhdG9yIHRoYXQgcmVxdWlyZXMgdGhlIGNvbnRyb2wncyB2YWx1ZSB0byBiZSBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gdGhlIHByb3ZpZGVkIG51bWJlci5cbiAgICAgKlxuICAgICAqIEB1c2FnZU5vdGVzXG4gICAgICpcbiAgICAgKiAjIyMgVmFsaWRhdGUgYWdhaW5zdCBhIG1heGltdW0gb2YgMTVcbiAgICAgKlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBjb25zdCBjb250cm9sID0gbmV3IEZvcm1Db250cm9sKDE2LCBWYWxpZGF0b3JzLm1heCgxNSkpO1xuICAgICAqXG4gICAgICogY29uc29sZS5sb2coY29udHJvbC5lcnJvcnMpOyAvLyB7bWF4OiB7bWF4OiAxNSwgYWN0dWFsOiAxNn19XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBBIHZhbGlkYXRvciBmdW5jdGlvbiB0aGF0IHJldHVybnMgYW4gZXJyb3IgbWFwIHdpdGggdGhlXG4gICAgICogYG1heGAgcHJvcGVydHkgaWYgdGhlIHZhbGlkYXRpb24gY2hlY2sgZmFpbHMsIG90aGVyd2lzZSBgbnVsbGAuXG4gICAgICpcbiAgICAgKiBAc2VlIHtAbGluayB1cGRhdGVWYWx1ZUFuZFZhbGlkaXR5KCl9XG4gICAgICpcbiAgICAgKi9cbiAgICBzdGF0aWMgbWF4KG1heCkge1xuICAgICAgICByZXR1cm4gbWF4VmFsaWRhdG9yKG1heCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqIFZhbGlkYXRvciB0aGF0IHJlcXVpcmVzIHRoZSBjb250cm9sIGhhdmUgYSBub24tZW1wdHkgdmFsdWUuXG4gICAgICpcbiAgICAgKiBAdXNhZ2VOb3Rlc1xuICAgICAqXG4gICAgICogIyMjIFZhbGlkYXRlIHRoYXQgdGhlIGZpZWxkIGlzIG5vbi1lbXB0eVxuICAgICAqXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGNvbnN0IGNvbnRyb2wgPSBuZXcgRm9ybUNvbnRyb2woJycsIFZhbGlkYXRvcnMucmVxdWlyZWQpO1xuICAgICAqXG4gICAgICogY29uc29sZS5sb2coY29udHJvbC5lcnJvcnMpOyAvLyB7cmVxdWlyZWQ6IHRydWV9XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBBbiBlcnJvciBtYXAgd2l0aCB0aGUgYHJlcXVpcmVkYCBwcm9wZXJ0eVxuICAgICAqIGlmIHRoZSB2YWxpZGF0aW9uIGNoZWNrIGZhaWxzLCBvdGhlcndpc2UgYG51bGxgLlxuICAgICAqXG4gICAgICogQHNlZSB7QGxpbmsgdXBkYXRlVmFsdWVBbmRWYWxpZGl0eSgpfVxuICAgICAqXG4gICAgICovXG4gICAgc3RhdGljIHJlcXVpcmVkKGNvbnRyb2wpIHtcbiAgICAgICAgcmV0dXJuIHJlcXVpcmVkVmFsaWRhdG9yKGNvbnRyb2wpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKiBWYWxpZGF0b3IgdGhhdCByZXF1aXJlcyB0aGUgY29udHJvbCdzIHZhbHVlIGJlIHRydWUuIFRoaXMgdmFsaWRhdG9yIGlzIGNvbW1vbmx5XG4gICAgICogdXNlZCBmb3IgcmVxdWlyZWQgY2hlY2tib3hlcy5cbiAgICAgKlxuICAgICAqIEB1c2FnZU5vdGVzXG4gICAgICpcbiAgICAgKiAjIyMgVmFsaWRhdGUgdGhhdCB0aGUgZmllbGQgdmFsdWUgaXMgdHJ1ZVxuICAgICAqXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGNvbnN0IGNvbnRyb2wgPSBuZXcgRm9ybUNvbnRyb2woJ3NvbWUgdmFsdWUnLCBWYWxpZGF0b3JzLnJlcXVpcmVkVHJ1ZSk7XG4gICAgICpcbiAgICAgKiBjb25zb2xlLmxvZyhjb250cm9sLmVycm9ycyk7IC8vIHtyZXF1aXJlZDogdHJ1ZX1cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIEFuIGVycm9yIG1hcCB0aGF0IGNvbnRhaW5zIHRoZSBgcmVxdWlyZWRgIHByb3BlcnR5XG4gICAgICogc2V0IHRvIGB0cnVlYCBpZiB0aGUgdmFsaWRhdGlvbiBjaGVjayBmYWlscywgb3RoZXJ3aXNlIGBudWxsYC5cbiAgICAgKlxuICAgICAqIEBzZWUge0BsaW5rIHVwZGF0ZVZhbHVlQW5kVmFsaWRpdHkoKX1cbiAgICAgKlxuICAgICAqL1xuICAgIHN0YXRpYyByZXF1aXJlZFRydWUoY29udHJvbCkge1xuICAgICAgICByZXR1cm4gcmVxdWlyZWRUcnVlVmFsaWRhdG9yKGNvbnRyb2wpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKiBWYWxpZGF0b3IgdGhhdCByZXF1aXJlcyB0aGUgY29udHJvbCdzIHZhbHVlIHBhc3MgYW4gZW1haWwgdmFsaWRhdGlvbiB0ZXN0LlxuICAgICAqXG4gICAgICogVGVzdHMgdGhlIHZhbHVlIHVzaW5nIGEgW3JlZ3VsYXJcbiAgICAgKiBleHByZXNzaW9uXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L0d1aWRlL1JlZ3VsYXJfRXhwcmVzc2lvbnMpXG4gICAgICogcGF0dGVybiBzdWl0YWJsZSBmb3IgY29tbW9uIHVzZSBjYXNlcy4gVGhlIHBhdHRlcm4gaXMgYmFzZWQgb24gdGhlIGRlZmluaXRpb24gb2YgYSB2YWxpZCBlbWFpbFxuICAgICAqIGFkZHJlc3MgaW4gdGhlIFtXSEFUV0cgSFRNTFxuICAgICAqIHNwZWNpZmljYXRpb25dKGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2lucHV0Lmh0bWwjdmFsaWQtZS1tYWlsLWFkZHJlc3MpIHdpdGhcbiAgICAgKiBzb21lIGVuaGFuY2VtZW50cyB0byBpbmNvcnBvcmF0ZSBtb3JlIFJGQyBydWxlcyAoc3VjaCBhcyBydWxlcyByZWxhdGVkIHRvIGRvbWFpbiBuYW1lcyBhbmQgdGhlXG4gICAgICogbGVuZ3RocyBvZiBkaWZmZXJlbnQgcGFydHMgb2YgdGhlIGFkZHJlc3MpLlxuICAgICAqXG4gICAgICogVGhlIGRpZmZlcmVuY2VzIGZyb20gdGhlIFdIQVRXRyB2ZXJzaW9uIGluY2x1ZGU6XG4gICAgICogLSBEaXNhbGxvdyBgbG9jYWwtcGFydGAgKHRoZSBwYXJ0IGJlZm9yZSB0aGUgYEBgIHN5bWJvbCkgdG8gYmVnaW4gb3IgZW5kIHdpdGggYSBwZXJpb2QgKGAuYCkuXG4gICAgICogLSBEaXNhbGxvdyBgbG9jYWwtcGFydGAgdG8gYmUgbG9uZ2VyIHRoYW4gNjQgY2hhcmFjdGVycy5cbiAgICAgKiAtIERpc2FsbG93IHRoZSB3aG9sZSBhZGRyZXNzIHRvIGJlIGxvbmdlciB0aGFuIDI1NCBjaGFyYWN0ZXJzLlxuICAgICAqXG4gICAgICogSWYgdGhpcyBwYXR0ZXJuIGRvZXMgbm90IHNhdGlzZnkgeW91ciBidXNpbmVzcyBuZWVkcywgeW91IGNhbiB1c2UgYFZhbGlkYXRvcnMucGF0dGVybigpYCB0b1xuICAgICAqIHZhbGlkYXRlIHRoZSB2YWx1ZSBhZ2FpbnN0IGEgZGlmZmVyZW50IHBhdHRlcm4uXG4gICAgICpcbiAgICAgKiBAdXNhZ2VOb3Rlc1xuICAgICAqXG4gICAgICogIyMjIFZhbGlkYXRlIHRoYXQgdGhlIGZpZWxkIG1hdGNoZXMgYSB2YWxpZCBlbWFpbCBwYXR0ZXJuXG4gICAgICpcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogY29uc3QgY29udHJvbCA9IG5ldyBGb3JtQ29udHJvbCgnYmFkQCcsIFZhbGlkYXRvcnMuZW1haWwpO1xuICAgICAqXG4gICAgICogY29uc29sZS5sb2coY29udHJvbC5lcnJvcnMpOyAvLyB7ZW1haWw6IHRydWV9XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBBbiBlcnJvciBtYXAgd2l0aCB0aGUgYGVtYWlsYCBwcm9wZXJ0eVxuICAgICAqIGlmIHRoZSB2YWxpZGF0aW9uIGNoZWNrIGZhaWxzLCBvdGhlcndpc2UgYG51bGxgLlxuICAgICAqXG4gICAgICogQHNlZSB7QGxpbmsgdXBkYXRlVmFsdWVBbmRWYWxpZGl0eSgpfVxuICAgICAqXG4gICAgICovXG4gICAgc3RhdGljIGVtYWlsKGNvbnRyb2wpIHtcbiAgICAgICAgcmV0dXJuIGVtYWlsVmFsaWRhdG9yKGNvbnRyb2wpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKiBWYWxpZGF0b3IgdGhhdCByZXF1aXJlcyB0aGUgbGVuZ3RoIG9mIHRoZSBjb250cm9sJ3MgdmFsdWUgdG8gYmUgZ3JlYXRlciB0aGFuIG9yIGVxdWFsXG4gICAgICogdG8gdGhlIHByb3ZpZGVkIG1pbmltdW0gbGVuZ3RoLiBUaGlzIHZhbGlkYXRvciBpcyBhbHNvIHByb3ZpZGVkIGJ5IGRlZmF1bHQgaWYgeW91IHVzZSB0aGVcbiAgICAgKiB0aGUgSFRNTDUgYG1pbmxlbmd0aGAgYXR0cmlidXRlLiBOb3RlIHRoYXQgdGhlIGBtaW5MZW5ndGhgIHZhbGlkYXRvciBpcyBpbnRlbmRlZCB0byBiZSB1c2VkXG4gICAgICogb25seSBmb3IgdHlwZXMgdGhhdCBoYXZlIGEgbnVtZXJpYyBgbGVuZ3RoYCBwcm9wZXJ0eSwgc3VjaCBhcyBzdHJpbmdzIG9yIGFycmF5cy4gVGhlXG4gICAgICogYG1pbkxlbmd0aGAgdmFsaWRhdG9yIGxvZ2ljIGlzIGFsc28gbm90IGludm9rZWQgZm9yIHZhbHVlcyB3aGVuIHRoZWlyIGBsZW5ndGhgIHByb3BlcnR5IGlzIDBcbiAgICAgKiAoZm9yIGV4YW1wbGUgaW4gY2FzZSBvZiBhbiBlbXB0eSBzdHJpbmcgb3IgYW4gZW1wdHkgYXJyYXkpLCB0byBzdXBwb3J0IG9wdGlvbmFsIGNvbnRyb2xzLiBZb3VcbiAgICAgKiBjYW4gdXNlIHRoZSBzdGFuZGFyZCBgcmVxdWlyZWRgIHZhbGlkYXRvciBpZiBlbXB0eSB2YWx1ZXMgc2hvdWxkIG5vdCBiZSBjb25zaWRlcmVkIHZhbGlkLlxuICAgICAqXG4gICAgICogQHVzYWdlTm90ZXNcbiAgICAgKlxuICAgICAqICMjIyBWYWxpZGF0ZSB0aGF0IHRoZSBmaWVsZCBoYXMgYSBtaW5pbXVtIG9mIDMgY2hhcmFjdGVyc1xuICAgICAqXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGNvbnN0IGNvbnRyb2wgPSBuZXcgRm9ybUNvbnRyb2woJ25nJywgVmFsaWRhdG9ycy5taW5MZW5ndGgoMykpO1xuICAgICAqXG4gICAgICogY29uc29sZS5sb2coY29udHJvbC5lcnJvcnMpOyAvLyB7bWlubGVuZ3RoOiB7cmVxdWlyZWRMZW5ndGg6IDMsIGFjdHVhbExlbmd0aDogMn19XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBgYGBodG1sXG4gICAgICogPGlucHV0IG1pbmxlbmd0aD1cIjVcIj5cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIEEgdmFsaWRhdG9yIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhbiBlcnJvciBtYXAgd2l0aCB0aGVcbiAgICAgKiBgbWlubGVuZ3RoYCBwcm9wZXJ0eSBpZiB0aGUgdmFsaWRhdGlvbiBjaGVjayBmYWlscywgb3RoZXJ3aXNlIGBudWxsYC5cbiAgICAgKlxuICAgICAqIEBzZWUge0BsaW5rIHVwZGF0ZVZhbHVlQW5kVmFsaWRpdHkoKX1cbiAgICAgKlxuICAgICAqL1xuICAgIHN0YXRpYyBtaW5MZW5ndGgobWluTGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBtaW5MZW5ndGhWYWxpZGF0b3IobWluTGVuZ3RoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICogVmFsaWRhdG9yIHRoYXQgcmVxdWlyZXMgdGhlIGxlbmd0aCBvZiB0aGUgY29udHJvbCdzIHZhbHVlIHRvIGJlIGxlc3MgdGhhbiBvciBlcXVhbFxuICAgICAqIHRvIHRoZSBwcm92aWRlZCBtYXhpbXVtIGxlbmd0aC4gVGhpcyB2YWxpZGF0b3IgaXMgYWxzbyBwcm92aWRlZCBieSBkZWZhdWx0IGlmIHlvdSB1c2UgdGhlXG4gICAgICogdGhlIEhUTUw1IGBtYXhsZW5ndGhgIGF0dHJpYnV0ZS4gTm90ZSB0aGF0IHRoZSBgbWF4TGVuZ3RoYCB2YWxpZGF0b3IgaXMgaW50ZW5kZWQgdG8gYmUgdXNlZFxuICAgICAqIG9ubHkgZm9yIHR5cGVzIHRoYXQgaGF2ZSBhIG51bWVyaWMgYGxlbmd0aGAgcHJvcGVydHksIHN1Y2ggYXMgc3RyaW5ncyBvciBhcnJheXMuXG4gICAgICpcbiAgICAgKiBAdXNhZ2VOb3Rlc1xuICAgICAqXG4gICAgICogIyMjIFZhbGlkYXRlIHRoYXQgdGhlIGZpZWxkIGhhcyBtYXhpbXVtIG9mIDUgY2hhcmFjdGVyc1xuICAgICAqXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGNvbnN0IGNvbnRyb2wgPSBuZXcgRm9ybUNvbnRyb2woJ0FuZ3VsYXInLCBWYWxpZGF0b3JzLm1heExlbmd0aCg1KSk7XG4gICAgICpcbiAgICAgKiBjb25zb2xlLmxvZyhjb250cm9sLmVycm9ycyk7IC8vIHttYXhsZW5ndGg6IHtyZXF1aXJlZExlbmd0aDogNSwgYWN0dWFsTGVuZ3RoOiA3fX1cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8aW5wdXQgbWF4bGVuZ3RoPVwiNVwiPlxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQHJldHVybnMgQSB2YWxpZGF0b3IgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGFuIGVycm9yIG1hcCB3aXRoIHRoZVxuICAgICAqIGBtYXhsZW5ndGhgIHByb3BlcnR5IGlmIHRoZSB2YWxpZGF0aW9uIGNoZWNrIGZhaWxzLCBvdGhlcndpc2UgYG51bGxgLlxuICAgICAqXG4gICAgICogQHNlZSB7QGxpbmsgdXBkYXRlVmFsdWVBbmRWYWxpZGl0eSgpfVxuICAgICAqXG4gICAgICovXG4gICAgc3RhdGljIG1heExlbmd0aChtYXhMZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIG1heExlbmd0aFZhbGlkYXRvcihtYXhMZW5ndGgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKiBWYWxpZGF0b3IgdGhhdCByZXF1aXJlcyB0aGUgY29udHJvbCdzIHZhbHVlIHRvIG1hdGNoIGEgcmVnZXggcGF0dGVybi4gVGhpcyB2YWxpZGF0b3IgaXMgYWxzb1xuICAgICAqIHByb3ZpZGVkIGJ5IGRlZmF1bHQgaWYgeW91IHVzZSB0aGUgSFRNTDUgYHBhdHRlcm5gIGF0dHJpYnV0ZS5cbiAgICAgKlxuICAgICAqIEB1c2FnZU5vdGVzXG4gICAgICpcbiAgICAgKiAjIyMgVmFsaWRhdGUgdGhhdCB0aGUgZmllbGQgb25seSBjb250YWlucyBsZXR0ZXJzIG9yIHNwYWNlc1xuICAgICAqXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGNvbnN0IGNvbnRyb2wgPSBuZXcgRm9ybUNvbnRyb2woJzEnLCBWYWxpZGF0b3JzLnBhdHRlcm4oJ1thLXpBLVogXSonKSk7XG4gICAgICpcbiAgICAgKiBjb25zb2xlLmxvZyhjb250cm9sLmVycm9ycyk7IC8vIHtwYXR0ZXJuOiB7cmVxdWlyZWRQYXR0ZXJuOiAnXlthLXpBLVogXSokJywgYWN0dWFsVmFsdWU6ICcxJ319XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBgYGBodG1sXG4gICAgICogPGlucHV0IHBhdHRlcm49XCJbYS16QS1aIF0qXCI+XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiAjIyMgUGF0dGVybiBtYXRjaGluZyB3aXRoIHRoZSBnbG9iYWwgb3Igc3RpY2t5IGZsYWdcbiAgICAgKlxuICAgICAqIGBSZWdFeHBgIG9iamVjdHMgY3JlYXRlZCB3aXRoIHRoZSBgZ2Agb3IgYHlgIGZsYWdzIHRoYXQgYXJlIHBhc3NlZCBpbnRvIGBWYWxpZGF0b3JzLnBhdHRlcm5gXG4gICAgICogY2FuIHByb2R1Y2UgZGlmZmVyZW50IHJlc3VsdHMgb24gdGhlIHNhbWUgaW5wdXQgd2hlbiB2YWxpZGF0aW9ucyBhcmUgcnVuIGNvbnNlY3V0aXZlbHkuIFRoaXMgaXNcbiAgICAgKiBkdWUgdG8gaG93IHRoZSBiZWhhdmlvciBvZiBgUmVnRXhwLnByb3RvdHlwZS50ZXN0YCBpc1xuICAgICAqIHNwZWNpZmllZCBpbiBbRUNNQS0yNjJdKGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtcmVnZXhwYnVpbHRpbmV4ZWMpXG4gICAgICogKGBSZWdFeHBgIHByZXNlcnZlcyB0aGUgaW5kZXggb2YgdGhlIGxhc3QgbWF0Y2ggd2hlbiB0aGUgZ2xvYmFsIG9yIHN0aWNreSBmbGFnIGlzIHVzZWQpLlxuICAgICAqIER1ZSB0byB0aGlzIGJlaGF2aW9yLCBpdCBpcyByZWNvbW1lbmRlZCB0aGF0IHdoZW4gdXNpbmdcbiAgICAgKiBgVmFsaWRhdG9ycy5wYXR0ZXJuYCB5b3UgKipkbyBub3QqKiBwYXNzIGluIGEgYFJlZ0V4cGAgb2JqZWN0IHdpdGggZWl0aGVyIHRoZSBnbG9iYWwgb3Igc3RpY2t5XG4gICAgICogZmxhZyBlbmFibGVkLlxuICAgICAqXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIC8vIE5vdCByZWNvbW1lbmRlZCAoc2luY2UgdGhlIGBnYCBmbGFnIGlzIHVzZWQpXG4gICAgICogY29uc3QgY29udHJvbE9uZSA9IG5ldyBGb3JtQ29udHJvbCgnMScsIFZhbGlkYXRvcnMucGF0dGVybigvZm9vL2cpKTtcbiAgICAgKlxuICAgICAqIC8vIEdvb2RcbiAgICAgKiBjb25zdCBjb250cm9sVHdvID0gbmV3IEZvcm1Db250cm9sKCcxJywgVmFsaWRhdG9ycy5wYXR0ZXJuKC9mb28vKSk7XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcGF0dGVybiBBIHJlZ3VsYXIgZXhwcmVzc2lvbiB0byBiZSB1c2VkIGFzIGlzIHRvIHRlc3QgdGhlIHZhbHVlcywgb3IgYSBzdHJpbmcuXG4gICAgICogSWYgYSBzdHJpbmcgaXMgcGFzc2VkLCB0aGUgYF5gIGNoYXJhY3RlciBpcyBwcmVwZW5kZWQgYW5kIHRoZSBgJGAgY2hhcmFjdGVyIGlzXG4gICAgICogYXBwZW5kZWQgdG8gdGhlIHByb3ZpZGVkIHN0cmluZyAoaWYgbm90IGFscmVhZHkgcHJlc2VudCksIGFuZCB0aGUgcmVzdWx0aW5nIHJlZ3VsYXJcbiAgICAgKiBleHByZXNzaW9uIGlzIHVzZWQgdG8gdGVzdCB0aGUgdmFsdWVzLlxuICAgICAqXG4gICAgICogQHJldHVybnMgQSB2YWxpZGF0b3IgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGFuIGVycm9yIG1hcCB3aXRoIHRoZVxuICAgICAqIGBwYXR0ZXJuYCBwcm9wZXJ0eSBpZiB0aGUgdmFsaWRhdGlvbiBjaGVjayBmYWlscywgb3RoZXJ3aXNlIGBudWxsYC5cbiAgICAgKlxuICAgICAqIEBzZWUge0BsaW5rIHVwZGF0ZVZhbHVlQW5kVmFsaWRpdHkoKX1cbiAgICAgKlxuICAgICAqL1xuICAgIHN0YXRpYyBwYXR0ZXJuKHBhdHRlcm4pIHtcbiAgICAgICAgcmV0dXJuIHBhdHRlcm5WYWxpZGF0b3IocGF0dGVybik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqIFZhbGlkYXRvciB0aGF0IHBlcmZvcm1zIG5vIG9wZXJhdGlvbi5cbiAgICAgKlxuICAgICAqIEBzZWUge0BsaW5rIHVwZGF0ZVZhbHVlQW5kVmFsaWRpdHkoKX1cbiAgICAgKlxuICAgICAqL1xuICAgIHN0YXRpYyBudWxsVmFsaWRhdG9yKGNvbnRyb2wpIHtcbiAgICAgICAgcmV0dXJuIG51bGxWYWxpZGF0b3IoY29udHJvbCk7XG4gICAgfVxuICAgIHN0YXRpYyBjb21wb3NlKHZhbGlkYXRvcnMpIHtcbiAgICAgICAgcmV0dXJuIGNvbXBvc2UodmFsaWRhdG9ycyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqIENvbXBvc2UgbXVsdGlwbGUgYXN5bmMgdmFsaWRhdG9ycyBpbnRvIGEgc2luZ2xlIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0aGUgdW5pb25cbiAgICAgKiBvZiB0aGUgaW5kaXZpZHVhbCBlcnJvciBvYmplY3RzIGZvciB0aGUgcHJvdmlkZWQgY29udHJvbC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIEEgdmFsaWRhdG9yIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhbiBlcnJvciBtYXAgd2l0aCB0aGVcbiAgICAgKiBtZXJnZWQgZXJyb3Igb2JqZWN0cyBvZiB0aGUgYXN5bmMgdmFsaWRhdG9ycyBpZiB0aGUgdmFsaWRhdGlvbiBjaGVjayBmYWlscywgb3RoZXJ3aXNlIGBudWxsYC5cbiAgICAgKlxuICAgICAqIEBzZWUge0BsaW5rIHVwZGF0ZVZhbHVlQW5kVmFsaWRpdHkoKX1cbiAgICAgKlxuICAgICAqL1xuICAgIHN0YXRpYyBjb21wb3NlQXN5bmModmFsaWRhdG9ycykge1xuICAgICAgICByZXR1cm4gY29tcG9zZUFzeW5jKHZhbGlkYXRvcnMpO1xuICAgIH1cbn1cbi8qKlxuICogVmFsaWRhdG9yIHRoYXQgcmVxdWlyZXMgdGhlIGNvbnRyb2wncyB2YWx1ZSB0byBiZSBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gdGhlIHByb3ZpZGVkIG51bWJlci5cbiAqIFNlZSBgVmFsaWRhdG9ycy5taW5gIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uLlxuICovXG5mdW5jdGlvbiBtaW5WYWxpZGF0b3IobWluKSB7XG4gICAgcmV0dXJuIChjb250cm9sKSA9PiB7XG4gICAgICAgIGlmIChpc0VtcHR5SW5wdXRWYWx1ZShjb250cm9sLnZhbHVlKSB8fCBpc0VtcHR5SW5wdXRWYWx1ZShtaW4pKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDsgLy8gZG9uJ3QgdmFsaWRhdGUgZW1wdHkgdmFsdWVzIHRvIGFsbG93IG9wdGlvbmFsIGNvbnRyb2xzXG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdmFsdWUgPSBwYXJzZUZsb2F0KGNvbnRyb2wudmFsdWUpO1xuICAgICAgICAvLyBDb250cm9scyB3aXRoIE5hTiB2YWx1ZXMgYWZ0ZXIgcGFyc2luZyBzaG91bGQgYmUgdHJlYXRlZCBhcyBub3QgaGF2aW5nIGFcbiAgICAgICAgLy8gbWluaW11bSwgcGVyIHRoZSBIVE1MIGZvcm1zIHNwZWM6IGh0dHBzOi8vd3d3LnczLm9yZy9UUi9odG1sNS9mb3Jtcy5odG1sI2F0dHItaW5wdXQtbWluXG4gICAgICAgIHJldHVybiAhaXNOYU4odmFsdWUpICYmIHZhbHVlIDwgbWluID8geyAnbWluJzogeyAnbWluJzogbWluLCAnYWN0dWFsJzogY29udHJvbC52YWx1ZSB9IH0gOiBudWxsO1xuICAgIH07XG59XG4vKipcbiAqIFZhbGlkYXRvciB0aGF0IHJlcXVpcmVzIHRoZSBjb250cm9sJ3MgdmFsdWUgdG8gYmUgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIHRoZSBwcm92aWRlZCBudW1iZXIuXG4gKiBTZWUgYFZhbGlkYXRvcnMubWF4YCBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvbi5cbiAqL1xuZnVuY3Rpb24gbWF4VmFsaWRhdG9yKG1heCkge1xuICAgIHJldHVybiAoY29udHJvbCkgPT4ge1xuICAgICAgICBpZiAoaXNFbXB0eUlucHV0VmFsdWUoY29udHJvbC52YWx1ZSkgfHwgaXNFbXB0eUlucHV0VmFsdWUobWF4KSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7IC8vIGRvbid0IHZhbGlkYXRlIGVtcHR5IHZhbHVlcyB0byBhbGxvdyBvcHRpb25hbCBjb250cm9sc1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHZhbHVlID0gcGFyc2VGbG9hdChjb250cm9sLnZhbHVlKTtcbiAgICAgICAgLy8gQ29udHJvbHMgd2l0aCBOYU4gdmFsdWVzIGFmdGVyIHBhcnNpbmcgc2hvdWxkIGJlIHRyZWF0ZWQgYXMgbm90IGhhdmluZyBhXG4gICAgICAgIC8vIG1heGltdW0sIHBlciB0aGUgSFRNTCBmb3JtcyBzcGVjOiBodHRwczovL3d3dy53My5vcmcvVFIvaHRtbDUvZm9ybXMuaHRtbCNhdHRyLWlucHV0LW1heFxuICAgICAgICByZXR1cm4gIWlzTmFOKHZhbHVlKSAmJiB2YWx1ZSA+IG1heCA/IHsgJ21heCc6IHsgJ21heCc6IG1heCwgJ2FjdHVhbCc6IGNvbnRyb2wudmFsdWUgfSB9IDogbnVsbDtcbiAgICB9O1xufVxuLyoqXG4gKiBWYWxpZGF0b3IgdGhhdCByZXF1aXJlcyB0aGUgY29udHJvbCBoYXZlIGEgbm9uLWVtcHR5IHZhbHVlLlxuICogU2VlIGBWYWxpZGF0b3JzLnJlcXVpcmVkYCBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvbi5cbiAqL1xuZnVuY3Rpb24gcmVxdWlyZWRWYWxpZGF0b3IoY29udHJvbCkge1xuICAgIHJldHVybiBpc0VtcHR5SW5wdXRWYWx1ZShjb250cm9sLnZhbHVlKSA/IHsgJ3JlcXVpcmVkJzogdHJ1ZSB9IDogbnVsbDtcbn1cbi8qKlxuICogVmFsaWRhdG9yIHRoYXQgcmVxdWlyZXMgdGhlIGNvbnRyb2wncyB2YWx1ZSBiZSB0cnVlLiBUaGlzIHZhbGlkYXRvciBpcyBjb21tb25seVxuICogdXNlZCBmb3IgcmVxdWlyZWQgY2hlY2tib3hlcy5cbiAqIFNlZSBgVmFsaWRhdG9ycy5yZXF1aXJlZFRydWVgIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uLlxuICovXG5mdW5jdGlvbiByZXF1aXJlZFRydWVWYWxpZGF0b3IoY29udHJvbCkge1xuICAgIHJldHVybiBjb250cm9sLnZhbHVlID09PSB0cnVlID8gbnVsbCA6IHsgJ3JlcXVpcmVkJzogdHJ1ZSB9O1xufVxuLyoqXG4gKiBWYWxpZGF0b3IgdGhhdCByZXF1aXJlcyB0aGUgY29udHJvbCdzIHZhbHVlIHBhc3MgYW4gZW1haWwgdmFsaWRhdGlvbiB0ZXN0LlxuICogU2VlIGBWYWxpZGF0b3JzLmVtYWlsYCBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvbi5cbiAqL1xuZnVuY3Rpb24gZW1haWxWYWxpZGF0b3IoY29udHJvbCkge1xuICAgIGlmIChpc0VtcHR5SW5wdXRWYWx1ZShjb250cm9sLnZhbHVlKSkge1xuICAgICAgICByZXR1cm4gbnVsbDsgLy8gZG9uJ3QgdmFsaWRhdGUgZW1wdHkgdmFsdWVzIHRvIGFsbG93IG9wdGlvbmFsIGNvbnRyb2xzXG4gICAgfVxuICAgIHJldHVybiBFTUFJTF9SRUdFWFAudGVzdChjb250cm9sLnZhbHVlKSA/IG51bGwgOiB7ICdlbWFpbCc6IHRydWUgfTtcbn1cbi8qKlxuICogVmFsaWRhdG9yIHRoYXQgcmVxdWlyZXMgdGhlIGxlbmd0aCBvZiB0aGUgY29udHJvbCdzIHZhbHVlIHRvIGJlIGdyZWF0ZXIgdGhhbiBvciBlcXVhbFxuICogdG8gdGhlIHByb3ZpZGVkIG1pbmltdW0gbGVuZ3RoLiBTZWUgYFZhbGlkYXRvcnMubWluTGVuZ3RoYCBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvbi5cbiAqL1xuZnVuY3Rpb24gbWluTGVuZ3RoVmFsaWRhdG9yKG1pbkxlbmd0aCkge1xuICAgIHJldHVybiAoY29udHJvbCkgPT4ge1xuICAgICAgICBpZiAoaXNFbXB0eUlucHV0VmFsdWUoY29udHJvbC52YWx1ZSkgfHwgIWhhc1ZhbGlkTGVuZ3RoKGNvbnRyb2wudmFsdWUpKSB7XG4gICAgICAgICAgICAvLyBkb24ndCB2YWxpZGF0ZSBlbXB0eSB2YWx1ZXMgdG8gYWxsb3cgb3B0aW9uYWwgY29udHJvbHNcbiAgICAgICAgICAgIC8vIGRvbid0IHZhbGlkYXRlIHZhbHVlcyB3aXRob3V0IGBsZW5ndGhgIHByb3BlcnR5XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29udHJvbC52YWx1ZS5sZW5ndGggPCBtaW5MZW5ndGggP1xuICAgICAgICAgICAgeyAnbWlubGVuZ3RoJzogeyAncmVxdWlyZWRMZW5ndGgnOiBtaW5MZW5ndGgsICdhY3R1YWxMZW5ndGgnOiBjb250cm9sLnZhbHVlLmxlbmd0aCB9IH0gOlxuICAgICAgICAgICAgbnVsbDtcbiAgICB9O1xufVxuLyoqXG4gKiBWYWxpZGF0b3IgdGhhdCByZXF1aXJlcyB0aGUgbGVuZ3RoIG9mIHRoZSBjb250cm9sJ3MgdmFsdWUgdG8gYmUgbGVzcyB0aGFuIG9yIGVxdWFsXG4gKiB0byB0aGUgcHJvdmlkZWQgbWF4aW11bSBsZW5ndGguIFNlZSBgVmFsaWRhdG9ycy5tYXhMZW5ndGhgIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uLlxuICovXG5mdW5jdGlvbiBtYXhMZW5ndGhWYWxpZGF0b3IobWF4TGVuZ3RoKSB7XG4gICAgcmV0dXJuIChjb250cm9sKSA9PiB7XG4gICAgICAgIHJldHVybiBoYXNWYWxpZExlbmd0aChjb250cm9sLnZhbHVlKSAmJiBjb250cm9sLnZhbHVlLmxlbmd0aCA+IG1heExlbmd0aCA/XG4gICAgICAgICAgICB7ICdtYXhsZW5ndGgnOiB7ICdyZXF1aXJlZExlbmd0aCc6IG1heExlbmd0aCwgJ2FjdHVhbExlbmd0aCc6IGNvbnRyb2wudmFsdWUubGVuZ3RoIH0gfSA6XG4gICAgICAgICAgICBudWxsO1xuICAgIH07XG59XG4vKipcbiAqIFZhbGlkYXRvciB0aGF0IHJlcXVpcmVzIHRoZSBjb250cm9sJ3MgdmFsdWUgdG8gbWF0Y2ggYSByZWdleCBwYXR0ZXJuLlxuICogU2VlIGBWYWxpZGF0b3JzLnBhdHRlcm5gIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uLlxuICovXG5mdW5jdGlvbiBwYXR0ZXJuVmFsaWRhdG9yKHBhdHRlcm4pIHtcbiAgICBpZiAoIXBhdHRlcm4pXG4gICAgICAgIHJldHVybiBudWxsVmFsaWRhdG9yO1xuICAgIGxldCByZWdleDtcbiAgICBsZXQgcmVnZXhTdHI7XG4gICAgaWYgKHR5cGVvZiBwYXR0ZXJuID09PSAnc3RyaW5nJykge1xuICAgICAgICByZWdleFN0ciA9ICcnO1xuICAgICAgICBpZiAocGF0dGVybi5jaGFyQXQoMCkgIT09ICdeJylcbiAgICAgICAgICAgIHJlZ2V4U3RyICs9ICdeJztcbiAgICAgICAgcmVnZXhTdHIgKz0gcGF0dGVybjtcbiAgICAgICAgaWYgKHBhdHRlcm4uY2hhckF0KHBhdHRlcm4ubGVuZ3RoIC0gMSkgIT09ICckJylcbiAgICAgICAgICAgIHJlZ2V4U3RyICs9ICckJztcbiAgICAgICAgcmVnZXggPSBuZXcgUmVnRXhwKHJlZ2V4U3RyKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJlZ2V4U3RyID0gcGF0dGVybi50b1N0cmluZygpO1xuICAgICAgICByZWdleCA9IHBhdHRlcm47XG4gICAgfVxuICAgIHJldHVybiAoY29udHJvbCkgPT4ge1xuICAgICAgICBpZiAoaXNFbXB0eUlucHV0VmFsdWUoY29udHJvbC52YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsOyAvLyBkb24ndCB2YWxpZGF0ZSBlbXB0eSB2YWx1ZXMgdG8gYWxsb3cgb3B0aW9uYWwgY29udHJvbHNcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB2YWx1ZSA9IGNvbnRyb2wudmFsdWU7XG4gICAgICAgIHJldHVybiByZWdleC50ZXN0KHZhbHVlKSA/IG51bGwgOlxuICAgICAgICAgICAgeyAncGF0dGVybic6IHsgJ3JlcXVpcmVkUGF0dGVybic6IHJlZ2V4U3RyLCAnYWN0dWFsVmFsdWUnOiB2YWx1ZSB9IH07XG4gICAgfTtcbn1cbi8qKlxuICogRnVuY3Rpb24gdGhhdCBoYXMgYFZhbGlkYXRvckZuYCBzaGFwZSwgYnV0IHBlcmZvcm1zIG5vIG9wZXJhdGlvbi5cbiAqL1xuZnVuY3Rpb24gbnVsbFZhbGlkYXRvcihjb250cm9sKSB7XG4gICAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBpc1ByZXNlbnQobykge1xuICAgIHJldHVybiBvICE9IG51bGw7XG59XG5mdW5jdGlvbiB0b09ic2VydmFibGUodmFsdWUpIHtcbiAgICBjb25zdCBvYnMgPSDJtWlzUHJvbWlzZSh2YWx1ZSkgPyBmcm9tKHZhbHVlKSA6IHZhbHVlO1xuICAgIGlmICgodHlwZW9mIG5nRGV2TW9kZSA9PT0gJ3VuZGVmaW5lZCcgfHwgbmdEZXZNb2RlKSAmJiAhKMm1aXNTdWJzY3JpYmFibGUob2JzKSkpIHtcbiAgICAgICAgbGV0IGVycm9yTWVzc2FnZSA9IGBFeHBlY3RlZCBhc3luYyB2YWxpZGF0b3IgdG8gcmV0dXJuIFByb21pc2Ugb3IgT2JzZXJ2YWJsZS5gO1xuICAgICAgICAvLyBBIHN5bmNocm9ub3VzIHZhbGlkYXRvciB3aWxsIHJldHVybiBvYmplY3Qgb3IgbnVsbC5cbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIGVycm9yTWVzc2FnZSArPVxuICAgICAgICAgICAgICAgICcgQXJlIHlvdSB1c2luZyBhIHN5bmNocm9ub3VzIHZhbGlkYXRvciB3aGVyZSBhbiBhc3luYyB2YWxpZGF0b3IgaXMgZXhwZWN0ZWQ/JztcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgybVSdW50aW1lRXJyb3IoLTExMDEgLyogUnVudGltZUVycm9yQ29kZS5XUk9OR19WQUxJREFUT1JfUkVUVVJOX1RZUEUgKi8sIGVycm9yTWVzc2FnZSk7XG4gICAgfVxuICAgIHJldHVybiBvYnM7XG59XG5mdW5jdGlvbiBtZXJnZUVycm9ycyhhcnJheU9mRXJyb3JzKSB7XG4gICAgbGV0IHJlcyA9IHt9O1xuICAgIGFycmF5T2ZFcnJvcnMuZm9yRWFjaCgoZXJyb3JzKSA9PiB7XG4gICAgICAgIHJlcyA9IGVycm9ycyAhPSBudWxsID8geyAuLi5yZXMsIC4uLmVycm9ycyB9IDogcmVzO1xuICAgIH0pO1xuICAgIHJldHVybiBPYmplY3Qua2V5cyhyZXMpLmxlbmd0aCA9PT0gMCA/IG51bGwgOiByZXM7XG59XG5mdW5jdGlvbiBleGVjdXRlVmFsaWRhdG9ycyhjb250cm9sLCB2YWxpZGF0b3JzKSB7XG4gICAgcmV0dXJuIHZhbGlkYXRvcnMubWFwKHZhbGlkYXRvciA9PiB2YWxpZGF0b3IoY29udHJvbCkpO1xufVxuZnVuY3Rpb24gaXNWYWxpZGF0b3JGbih2YWxpZGF0b3IpIHtcbiAgICByZXR1cm4gIXZhbGlkYXRvci52YWxpZGF0ZTtcbn1cbi8qKlxuICogR2l2ZW4gdGhlIGxpc3Qgb2YgdmFsaWRhdG9ycyB0aGF0IG1heSBjb250YWluIGJvdGggZnVuY3Rpb25zIGFzIHdlbGwgYXMgY2xhc3NlcywgcmV0dXJuIHRoZSBsaXN0XG4gKiBvZiB2YWxpZGF0b3IgZnVuY3Rpb25zIChjb252ZXJ0IHZhbGlkYXRvciBjbGFzc2VzIGludG8gdmFsaWRhdG9yIGZ1bmN0aW9ucykuIFRoaXMgaXMgbmVlZGVkIHRvXG4gKiBoYXZlIGNvbnNpc3RlbnQgc3RydWN0dXJlIGluIHZhbGlkYXRvcnMgbGlzdCBiZWZvcmUgY29tcG9zaW5nIHRoZW0uXG4gKlxuICogQHBhcmFtIHZhbGlkYXRvcnMgVGhlIHNldCBvZiB2YWxpZGF0b3JzIHRoYXQgbWF5IGNvbnRhaW4gdmFsaWRhdG9ycyBib3RoIGluIHBsYWluIGZ1bmN0aW9uIGZvcm1cbiAqICAgICBhcyB3ZWxsIGFzIHJlcHJlc2VudGVkIGFzIGEgdmFsaWRhdG9yIGNsYXNzLlxuICovXG5mdW5jdGlvbiBub3JtYWxpemVWYWxpZGF0b3JzKHZhbGlkYXRvcnMpIHtcbiAgICByZXR1cm4gdmFsaWRhdG9ycy5tYXAodmFsaWRhdG9yID0+IHtcbiAgICAgICAgcmV0dXJuIGlzVmFsaWRhdG9yRm4odmFsaWRhdG9yKSA/XG4gICAgICAgICAgICB2YWxpZGF0b3IgOlxuICAgICAgICAgICAgKChjKSA9PiB2YWxpZGF0b3IudmFsaWRhdGUoYykpO1xuICAgIH0pO1xufVxuLyoqXG4gKiBNZXJnZXMgc3luY2hyb25vdXMgdmFsaWRhdG9ycyBpbnRvIGEgc2luZ2xlIHZhbGlkYXRvciBmdW5jdGlvbi5cbiAqIFNlZSBgVmFsaWRhdG9ycy5jb21wb3NlYCBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvbi5cbiAqL1xuZnVuY3Rpb24gY29tcG9zZSh2YWxpZGF0b3JzKSB7XG4gICAgaWYgKCF2YWxpZGF0b3JzKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICBjb25zdCBwcmVzZW50VmFsaWRhdG9ycyA9IHZhbGlkYXRvcnMuZmlsdGVyKGlzUHJlc2VudCk7XG4gICAgaWYgKHByZXNlbnRWYWxpZGF0b3JzLmxlbmd0aCA9PSAwKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGNvbnRyb2wpIHtcbiAgICAgICAgcmV0dXJuIG1lcmdlRXJyb3JzKGV4ZWN1dGVWYWxpZGF0b3JzKGNvbnRyb2wsIHByZXNlbnRWYWxpZGF0b3JzKSk7XG4gICAgfTtcbn1cbi8qKlxuICogQWNjZXB0cyBhIGxpc3Qgb2YgdmFsaWRhdG9ycyBvZiBkaWZmZXJlbnQgcG9zc2libGUgc2hhcGVzIChgVmFsaWRhdG9yYCBhbmQgYFZhbGlkYXRvckZuYCksXG4gKiBub3JtYWxpemVzIHRoZSBsaXN0IChjb252ZXJ0cyBldmVyeXRoaW5nIHRvIGBWYWxpZGF0b3JGbmApIGFuZCBtZXJnZXMgdGhlbSBpbnRvIGEgc2luZ2xlXG4gKiB2YWxpZGF0b3IgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGNvbXBvc2VWYWxpZGF0b3JzKHZhbGlkYXRvcnMpIHtcbiAgICByZXR1cm4gdmFsaWRhdG9ycyAhPSBudWxsID8gY29tcG9zZShub3JtYWxpemVWYWxpZGF0b3JzKHZhbGlkYXRvcnMpKSA6IG51bGw7XG59XG4vKipcbiAqIE1lcmdlcyBhc3luY2hyb25vdXMgdmFsaWRhdG9ycyBpbnRvIGEgc2luZ2xlIHZhbGlkYXRvciBmdW5jdGlvbi5cbiAqIFNlZSBgVmFsaWRhdG9ycy5jb21wb3NlQXN5bmNgIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uLlxuICovXG5mdW5jdGlvbiBjb21wb3NlQXN5bmModmFsaWRhdG9ycykge1xuICAgIGlmICghdmFsaWRhdG9ycylcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgY29uc3QgcHJlc2VudFZhbGlkYXRvcnMgPSB2YWxpZGF0b3JzLmZpbHRlcihpc1ByZXNlbnQpO1xuICAgIGlmIChwcmVzZW50VmFsaWRhdG9ycy5sZW5ndGggPT0gMClcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChjb250cm9sKSB7XG4gICAgICAgIGNvbnN0IG9ic2VydmFibGVzID0gZXhlY3V0ZVZhbGlkYXRvcnMoY29udHJvbCwgcHJlc2VudFZhbGlkYXRvcnMpLm1hcCh0b09ic2VydmFibGUpO1xuICAgICAgICByZXR1cm4gZm9ya0pvaW4ob2JzZXJ2YWJsZXMpLnBpcGUobWFwKG1lcmdlRXJyb3JzKSk7XG4gICAgfTtcbn1cbi8qKlxuICogQWNjZXB0cyBhIGxpc3Qgb2YgYXN5bmMgdmFsaWRhdG9ycyBvZiBkaWZmZXJlbnQgcG9zc2libGUgc2hhcGVzIChgQXN5bmNWYWxpZGF0b3JgIGFuZFxuICogYEFzeW5jVmFsaWRhdG9yRm5gKSwgbm9ybWFsaXplcyB0aGUgbGlzdCAoY29udmVydHMgZXZlcnl0aGluZyB0byBgQXN5bmNWYWxpZGF0b3JGbmApIGFuZCBtZXJnZXNcbiAqIHRoZW0gaW50byBhIHNpbmdsZSB2YWxpZGF0b3IgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGNvbXBvc2VBc3luY1ZhbGlkYXRvcnModmFsaWRhdG9ycykge1xuICAgIHJldHVybiB2YWxpZGF0b3JzICE9IG51bGwgPyBjb21wb3NlQXN5bmMobm9ybWFsaXplVmFsaWRhdG9ycyh2YWxpZGF0b3JzKSkgOlxuICAgICAgICBudWxsO1xufVxuLyoqXG4gKiBNZXJnZXMgcmF3IGNvbnRyb2wgdmFsaWRhdG9ycyB3aXRoIGEgZ2l2ZW4gZGlyZWN0aXZlIHZhbGlkYXRvciBhbmQgcmV0dXJucyB0aGUgY29tYmluZWQgbGlzdCBvZlxuICogdmFsaWRhdG9ycyBhcyBhbiBhcnJheS5cbiAqL1xuZnVuY3Rpb24gbWVyZ2VWYWxpZGF0b3JzKGNvbnRyb2xWYWxpZGF0b3JzLCBkaXJWYWxpZGF0b3IpIHtcbiAgICBpZiAoY29udHJvbFZhbGlkYXRvcnMgPT09IG51bGwpXG4gICAgICAgIHJldHVybiBbZGlyVmFsaWRhdG9yXTtcbiAgICByZXR1cm4gQXJyYXkuaXNBcnJheShjb250cm9sVmFsaWRhdG9ycykgPyBbLi4uY29udHJvbFZhbGlkYXRvcnMsIGRpclZhbGlkYXRvcl0gOlxuICAgICAgICBbY29udHJvbFZhbGlkYXRvcnMsIGRpclZhbGlkYXRvcl07XG59XG4vKipcbiAqIFJldHJpZXZlcyB0aGUgbGlzdCBvZiByYXcgc3luY2hyb25vdXMgdmFsaWRhdG9ycyBhdHRhY2hlZCB0byBhIGdpdmVuIGNvbnRyb2wuXG4gKi9cbmZ1bmN0aW9uIGdldENvbnRyb2xWYWxpZGF0b3JzKGNvbnRyb2wpIHtcbiAgICByZXR1cm4gY29udHJvbC5fcmF3VmFsaWRhdG9ycztcbn1cbi8qKlxuICogUmV0cmlldmVzIHRoZSBsaXN0IG9mIHJhdyBhc3luY2hyb25vdXMgdmFsaWRhdG9ycyBhdHRhY2hlZCB0byBhIGdpdmVuIGNvbnRyb2wuXG4gKi9cbmZ1bmN0aW9uIGdldENvbnRyb2xBc3luY1ZhbGlkYXRvcnMoY29udHJvbCkge1xuICAgIHJldHVybiBjb250cm9sLl9yYXdBc3luY1ZhbGlkYXRvcnM7XG59XG4vKipcbiAqIEFjY2VwdHMgYSBzaW5nbGV0b24gdmFsaWRhdG9yLCBhbiBhcnJheSwgb3IgbnVsbCwgYW5kIHJldHVybnMgYW4gYXJyYXkgdHlwZSB3aXRoIHRoZSBwcm92aWRlZFxuICogdmFsaWRhdG9ycy5cbiAqXG4gKiBAcGFyYW0gdmFsaWRhdG9ycyBBIHZhbGlkYXRvciwgdmFsaWRhdG9ycywgb3IgbnVsbC5cbiAqIEByZXR1cm5zIEEgdmFsaWRhdG9ycyBhcnJheS5cbiAqL1xuZnVuY3Rpb24gbWFrZVZhbGlkYXRvcnNBcnJheSh2YWxpZGF0b3JzKSB7XG4gICAgaWYgKCF2YWxpZGF0b3JzKVxuICAgICAgICByZXR1cm4gW107XG4gICAgcmV0dXJuIEFycmF5LmlzQXJyYXkodmFsaWRhdG9ycykgPyB2YWxpZGF0b3JzIDogW3ZhbGlkYXRvcnNdO1xufVxuLyoqXG4gKiBEZXRlcm1pbmVzIHdoZXRoZXIgYSB2YWxpZGF0b3Igb3IgdmFsaWRhdG9ycyBhcnJheSBoYXMgYSBnaXZlbiB2YWxpZGF0b3IuXG4gKlxuICogQHBhcmFtIHZhbGlkYXRvcnMgVGhlIHZhbGlkYXRvciBvciB2YWxpZGF0b3JzIHRvIGNvbXBhcmUgYWdhaW5zdC5cbiAqIEBwYXJhbSB2YWxpZGF0b3IgVGhlIHZhbGlkYXRvciB0byBjaGVjay5cbiAqIEByZXR1cm5zIFdoZXRoZXIgdGhlIHZhbGlkYXRvciBpcyBwcmVzZW50LlxuICovXG5mdW5jdGlvbiBoYXNWYWxpZGF0b3IodmFsaWRhdG9ycywgdmFsaWRhdG9yKSB7XG4gICAgcmV0dXJuIEFycmF5LmlzQXJyYXkodmFsaWRhdG9ycykgPyB2YWxpZGF0b3JzLmluY2x1ZGVzKHZhbGlkYXRvcikgOiB2YWxpZGF0b3JzID09PSB2YWxpZGF0b3I7XG59XG4vKipcbiAqIENvbWJpbmVzIHR3byBhcnJheXMgb2YgdmFsaWRhdG9ycyBpbnRvIG9uZS4gSWYgZHVwbGljYXRlcyBhcmUgcHJvdmlkZWQsIG9ubHkgb25lIHdpbGwgYmUgYWRkZWQuXG4gKlxuICogQHBhcmFtIHZhbGlkYXRvcnMgVGhlIG5ldyB2YWxpZGF0b3JzLlxuICogQHBhcmFtIGN1cnJlbnRWYWxpZGF0b3JzIFRoZSBiYXNlIGFycmF5IG9mIGN1cnJlbnQgdmFsaWRhdG9ycy5cbiAqIEByZXR1cm5zIEFuIGFycmF5IG9mIHZhbGlkYXRvcnMuXG4gKi9cbmZ1bmN0aW9uIGFkZFZhbGlkYXRvcnModmFsaWRhdG9ycywgY3VycmVudFZhbGlkYXRvcnMpIHtcbiAgICBjb25zdCBjdXJyZW50ID0gbWFrZVZhbGlkYXRvcnNBcnJheShjdXJyZW50VmFsaWRhdG9ycyk7XG4gICAgY29uc3QgdmFsaWRhdG9yc1RvQWRkID0gbWFrZVZhbGlkYXRvcnNBcnJheSh2YWxpZGF0b3JzKTtcbiAgICB2YWxpZGF0b3JzVG9BZGQuZm9yRWFjaCgodikgPT4ge1xuICAgICAgICAvLyBOb3RlOiBpZiB0aGVyZSBhcmUgZHVwbGljYXRlIGVudHJpZXMgaW4gdGhlIG5ldyB2YWxpZGF0b3JzIGFycmF5LFxuICAgICAgICAvLyBvbmx5IHRoZSBmaXJzdCBvbmUgd291bGQgYmUgYWRkZWQgdG8gdGhlIGN1cnJlbnQgbGlzdCBvZiB2YWxpZGF0b3JzLlxuICAgICAgICAvLyBEdXBsaWNhdGUgb25lcyB3b3VsZCBiZSBpZ25vcmVkIHNpbmNlIGBoYXNWYWxpZGF0b3JgIHdvdWxkIGRldGVjdFxuICAgICAgICAvLyB0aGUgcHJlc2VuY2Ugb2YgYSB2YWxpZGF0b3IgZnVuY3Rpb24gYW5kIHdlIHVwZGF0ZSB0aGUgY3VycmVudCBsaXN0IGluIHBsYWNlLlxuICAgICAgICBpZiAoIWhhc1ZhbGlkYXRvcihjdXJyZW50LCB2KSkge1xuICAgICAgICAgICAgY3VycmVudC5wdXNoKHYpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGN1cnJlbnQ7XG59XG5mdW5jdGlvbiByZW1vdmVWYWxpZGF0b3JzKHZhbGlkYXRvcnMsIGN1cnJlbnRWYWxpZGF0b3JzKSB7XG4gICAgcmV0dXJuIG1ha2VWYWxpZGF0b3JzQXJyYXkoY3VycmVudFZhbGlkYXRvcnMpLmZpbHRlcih2ID0+ICFoYXNWYWxpZGF0b3IodmFsaWRhdG9ycywgdikpO1xufVxuXG4vKipcbiAqIEBkZXNjcmlwdGlvblxuICogQmFzZSBjbGFzcyBmb3IgY29udHJvbCBkaXJlY3RpdmVzLlxuICpcbiAqIFRoaXMgY2xhc3MgaXMgb25seSB1c2VkIGludGVybmFsbHkgaW4gdGhlIGBSZWFjdGl2ZUZvcm1zTW9kdWxlYCBhbmQgdGhlIGBGb3Jtc01vZHVsZWAuXG4gKlxuICogQHB1YmxpY0FwaVxuICovXG5jbGFzcyBBYnN0cmFjdENvbnRyb2xEaXJlY3RpdmUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICAvKipcbiAgICAgICAgICogU2V0IG9mIHN5bmNocm9ub3VzIHZhbGlkYXRvcnMgYXMgdGhleSB3ZXJlIHByb3ZpZGVkIHdoaWxlIGNhbGxpbmcgYHNldFZhbGlkYXRvcnNgIGZ1bmN0aW9uLlxuICAgICAgICAgKiBAaW50ZXJuYWxcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX3Jhd1ZhbGlkYXRvcnMgPSBbXTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldCBvZiBhc3luY2hyb25vdXMgdmFsaWRhdG9ycyBhcyB0aGV5IHdlcmUgcHJvdmlkZWQgd2hpbGUgY2FsbGluZyBgc2V0QXN5bmNWYWxpZGF0b3JzYFxuICAgICAgICAgKiBmdW5jdGlvbi5cbiAgICAgICAgICogQGludGVybmFsXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9yYXdBc3luY1ZhbGlkYXRvcnMgPSBbXTtcbiAgICAgICAgLypcbiAgICAgICAgICogVGhlIHNldCBvZiBjYWxsYmFja3MgdG8gYmUgaW52b2tlZCB3aGVuIGRpcmVjdGl2ZSBpbnN0YW5jZSBpcyBiZWluZyBkZXN0cm95ZWQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9vbkRlc3Ryb3lDYWxsYmFja3MgPSBbXTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICogUmVwb3J0cyB0aGUgdmFsdWUgb2YgdGhlIGNvbnRyb2wgaWYgaXQgaXMgcHJlc2VudCwgb3RoZXJ3aXNlIG51bGwuXG4gICAgICovXG4gICAgZ2V0IHZhbHVlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb250cm9sID8gdGhpcy5jb250cm9sLnZhbHVlIDogbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICogUmVwb3J0cyB3aGV0aGVyIHRoZSBjb250cm9sIGlzIHZhbGlkLiBBIGNvbnRyb2wgaXMgY29uc2lkZXJlZCB2YWxpZCBpZiBub1xuICAgICAqIHZhbGlkYXRpb24gZXJyb3JzIGV4aXN0IHdpdGggdGhlIGN1cnJlbnQgdmFsdWUuXG4gICAgICogSWYgdGhlIGNvbnRyb2wgaXMgbm90IHByZXNlbnQsIG51bGwgaXMgcmV0dXJuZWQuXG4gICAgICovXG4gICAgZ2V0IHZhbGlkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb250cm9sID8gdGhpcy5jb250cm9sLnZhbGlkIDogbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICogUmVwb3J0cyB3aGV0aGVyIHRoZSBjb250cm9sIGlzIGludmFsaWQsIG1lYW5pbmcgdGhhdCBhbiBlcnJvciBleGlzdHMgaW4gdGhlIGlucHV0IHZhbHVlLlxuICAgICAqIElmIHRoZSBjb250cm9sIGlzIG5vdCBwcmVzZW50LCBudWxsIGlzIHJldHVybmVkLlxuICAgICAqL1xuICAgIGdldCBpbnZhbGlkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb250cm9sID8gdGhpcy5jb250cm9sLmludmFsaWQgOiBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKiBSZXBvcnRzIHdoZXRoZXIgYSBjb250cm9sIGlzIHBlbmRpbmcsIG1lYW5pbmcgdGhhdCBhc3luYyB2YWxpZGF0aW9uIGlzIG9jY3VycmluZyBhbmRcbiAgICAgKiBlcnJvcnMgYXJlIG5vdCB5ZXQgYXZhaWxhYmxlIGZvciB0aGUgaW5wdXQgdmFsdWUuIElmIHRoZSBjb250cm9sIGlzIG5vdCBwcmVzZW50LCBudWxsIGlzXG4gICAgICogcmV0dXJuZWQuXG4gICAgICovXG4gICAgZ2V0IHBlbmRpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnRyb2wgPyB0aGlzLmNvbnRyb2wucGVuZGluZyA6IG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqIFJlcG9ydHMgd2hldGhlciB0aGUgY29udHJvbCBpcyBkaXNhYmxlZCwgbWVhbmluZyB0aGF0IHRoZSBjb250cm9sIGlzIGRpc2FibGVkXG4gICAgICogaW4gdGhlIFVJIGFuZCBpcyBleGVtcHQgZnJvbSB2YWxpZGF0aW9uIGNoZWNrcyBhbmQgZXhjbHVkZWQgZnJvbSBhZ2dyZWdhdGVcbiAgICAgKiB2YWx1ZXMgb2YgYW5jZXN0b3IgY29udHJvbHMuIElmIHRoZSBjb250cm9sIGlzIG5vdCBwcmVzZW50LCBudWxsIGlzIHJldHVybmVkLlxuICAgICAqL1xuICAgIGdldCBkaXNhYmxlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29udHJvbCA/IHRoaXMuY29udHJvbC5kaXNhYmxlZCA6IG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqIFJlcG9ydHMgd2hldGhlciB0aGUgY29udHJvbCBpcyBlbmFibGVkLCBtZWFuaW5nIHRoYXQgdGhlIGNvbnRyb2wgaXMgaW5jbHVkZWQgaW4gYW5jZXN0b3JcbiAgICAgKiBjYWxjdWxhdGlvbnMgb2YgdmFsaWRpdHkgb3IgdmFsdWUuIElmIHRoZSBjb250cm9sIGlzIG5vdCBwcmVzZW50LCBudWxsIGlzIHJldHVybmVkLlxuICAgICAqL1xuICAgIGdldCBlbmFibGVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb250cm9sID8gdGhpcy5jb250cm9sLmVuYWJsZWQgOiBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKiBSZXBvcnRzIHRoZSBjb250cm9sJ3MgdmFsaWRhdGlvbiBlcnJvcnMuIElmIHRoZSBjb250cm9sIGlzIG5vdCBwcmVzZW50LCBudWxsIGlzIHJldHVybmVkLlxuICAgICAqL1xuICAgIGdldCBlcnJvcnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnRyb2wgPyB0aGlzLmNvbnRyb2wuZXJyb3JzIDogbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICogUmVwb3J0cyB3aGV0aGVyIHRoZSBjb250cm9sIGlzIHByaXN0aW5lLCBtZWFuaW5nIHRoYXQgdGhlIHVzZXIgaGFzIG5vdCB5ZXQgY2hhbmdlZFxuICAgICAqIHRoZSB2YWx1ZSBpbiB0aGUgVUkuIElmIHRoZSBjb250cm9sIGlzIG5vdCBwcmVzZW50LCBudWxsIGlzIHJldHVybmVkLlxuICAgICAqL1xuICAgIGdldCBwcmlzdGluZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29udHJvbCA/IHRoaXMuY29udHJvbC5wcmlzdGluZSA6IG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqIFJlcG9ydHMgd2hldGhlciB0aGUgY29udHJvbCBpcyBkaXJ0eSwgbWVhbmluZyB0aGF0IHRoZSB1c2VyIGhhcyBjaGFuZ2VkXG4gICAgICogdGhlIHZhbHVlIGluIHRoZSBVSS4gSWYgdGhlIGNvbnRyb2wgaXMgbm90IHByZXNlbnQsIG51bGwgaXMgcmV0dXJuZWQuXG4gICAgICovXG4gICAgZ2V0IGRpcnR5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb250cm9sID8gdGhpcy5jb250cm9sLmRpcnR5IDogbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICogUmVwb3J0cyB3aGV0aGVyIHRoZSBjb250cm9sIGlzIHRvdWNoZWQsIG1lYW5pbmcgdGhhdCB0aGUgdXNlciBoYXMgdHJpZ2dlcmVkXG4gICAgICogYSBgYmx1cmAgZXZlbnQgb24gaXQuIElmIHRoZSBjb250cm9sIGlzIG5vdCBwcmVzZW50LCBudWxsIGlzIHJldHVybmVkLlxuICAgICAqL1xuICAgIGdldCB0b3VjaGVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb250cm9sID8gdGhpcy5jb250cm9sLnRvdWNoZWQgOiBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKiBSZXBvcnRzIHRoZSB2YWxpZGF0aW9uIHN0YXR1cyBvZiB0aGUgY29udHJvbC4gUG9zc2libGUgdmFsdWVzIGluY2x1ZGU6XG4gICAgICogJ1ZBTElEJywgJ0lOVkFMSUQnLCAnRElTQUJMRUQnLCBhbmQgJ1BFTkRJTkcnLlxuICAgICAqIElmIHRoZSBjb250cm9sIGlzIG5vdCBwcmVzZW50LCBudWxsIGlzIHJldHVybmVkLlxuICAgICAqL1xuICAgIGdldCBzdGF0dXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnRyb2wgPyB0aGlzLmNvbnRyb2wuc3RhdHVzIDogbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICogUmVwb3J0cyB3aGV0aGVyIHRoZSBjb250cm9sIGlzIHVudG91Y2hlZCwgbWVhbmluZyB0aGF0IHRoZSB1c2VyIGhhcyBub3QgeWV0IHRyaWdnZXJlZFxuICAgICAqIGEgYGJsdXJgIGV2ZW50IG9uIGl0LiBJZiB0aGUgY29udHJvbCBpcyBub3QgcHJlc2VudCwgbnVsbCBpcyByZXR1cm5lZC5cbiAgICAgKi9cbiAgICBnZXQgdW50b3VjaGVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb250cm9sID8gdGhpcy5jb250cm9sLnVudG91Y2hlZCA6IG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqIFJldHVybnMgYSBtdWx0aWNhc3Rpbmcgb2JzZXJ2YWJsZSB0aGF0IGVtaXRzIGEgdmFsaWRhdGlvbiBzdGF0dXMgd2hlbmV2ZXIgaXQgaXNcbiAgICAgKiBjYWxjdWxhdGVkIGZvciB0aGUgY29udHJvbC4gSWYgdGhlIGNvbnRyb2wgaXMgbm90IHByZXNlbnQsIG51bGwgaXMgcmV0dXJuZWQuXG4gICAgICovXG4gICAgZ2V0IHN0YXR1c0NoYW5nZXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnRyb2wgPyB0aGlzLmNvbnRyb2wuc3RhdHVzQ2hhbmdlcyA6IG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqIFJldHVybnMgYSBtdWx0aWNhc3Rpbmcgb2JzZXJ2YWJsZSBvZiB2YWx1ZSBjaGFuZ2VzIGZvciB0aGUgY29udHJvbCB0aGF0IGVtaXRzIGV2ZXJ5IHRpbWUgdGhlXG4gICAgICogdmFsdWUgb2YgdGhlIGNvbnRyb2wgY2hhbmdlcyBpbiB0aGUgVUkgb3IgcHJvZ3JhbW1hdGljYWxseS5cbiAgICAgKiBJZiB0aGUgY29udHJvbCBpcyBub3QgcHJlc2VudCwgbnVsbCBpcyByZXR1cm5lZC5cbiAgICAgKi9cbiAgICBnZXQgdmFsdWVDaGFuZ2VzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb250cm9sID8gdGhpcy5jb250cm9sLnZhbHVlQ2hhbmdlcyA6IG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqIFJldHVybnMgYW4gYXJyYXkgdGhhdCByZXByZXNlbnRzIHRoZSBwYXRoIGZyb20gdGhlIHRvcC1sZXZlbCBmb3JtIHRvIHRoaXMgY29udHJvbC5cbiAgICAgKiBFYWNoIGluZGV4IGlzIHRoZSBzdHJpbmcgbmFtZSBvZiB0aGUgY29udHJvbCBvbiB0aGF0IGxldmVsLlxuICAgICAqL1xuICAgIGdldCBwYXRoKCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyBzeW5jaHJvbm91cyB2YWxpZGF0b3JzIGZvciB0aGlzIGRpcmVjdGl2ZS5cbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBfc2V0VmFsaWRhdG9ycyh2YWxpZGF0b3JzKSB7XG4gICAgICAgIHRoaXMuX3Jhd1ZhbGlkYXRvcnMgPSB2YWxpZGF0b3JzIHx8IFtdO1xuICAgICAgICB0aGlzLl9jb21wb3NlZFZhbGlkYXRvckZuID0gY29tcG9zZVZhbGlkYXRvcnModGhpcy5fcmF3VmFsaWRhdG9ycyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgYXN5bmNocm9ub3VzIHZhbGlkYXRvcnMgZm9yIHRoaXMgZGlyZWN0aXZlLlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIF9zZXRBc3luY1ZhbGlkYXRvcnModmFsaWRhdG9ycykge1xuICAgICAgICB0aGlzLl9yYXdBc3luY1ZhbGlkYXRvcnMgPSB2YWxpZGF0b3JzIHx8IFtdO1xuICAgICAgICB0aGlzLl9jb21wb3NlZEFzeW5jVmFsaWRhdG9yRm4gPSBjb21wb3NlQXN5bmNWYWxpZGF0b3JzKHRoaXMuX3Jhd0FzeW5jVmFsaWRhdG9ycyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqIFN5bmNocm9ub3VzIHZhbGlkYXRvciBmdW5jdGlvbiBjb21wb3NlZCBvZiBhbGwgdGhlIHN5bmNocm9ub3VzIHZhbGlkYXRvcnMgcmVnaXN0ZXJlZCB3aXRoIHRoaXNcbiAgICAgKiBkaXJlY3RpdmUuXG4gICAgICovXG4gICAgZ2V0IHZhbGlkYXRvcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NvbXBvc2VkVmFsaWRhdG9yRm4gfHwgbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICogQXN5bmNocm9ub3VzIHZhbGlkYXRvciBmdW5jdGlvbiBjb21wb3NlZCBvZiBhbGwgdGhlIGFzeW5jaHJvbm91cyB2YWxpZGF0b3JzIHJlZ2lzdGVyZWQgd2l0aFxuICAgICAqIHRoaXMgZGlyZWN0aXZlLlxuICAgICAqL1xuICAgIGdldCBhc3luY1ZhbGlkYXRvcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NvbXBvc2VkQXN5bmNWYWxpZGF0b3JGbiB8fCBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbnRlcm5hbCBmdW5jdGlvbiB0byByZWdpc3RlciBjYWxsYmFja3MgdGhhdCBzaG91bGQgYmUgaW52b2tlZFxuICAgICAqIHdoZW4gZGlyZWN0aXZlIGluc3RhbmNlIGlzIGJlaW5nIGRlc3Ryb3llZC5cbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBfcmVnaXN0ZXJPbkRlc3Ryb3koZm4pIHtcbiAgICAgICAgdGhpcy5fb25EZXN0cm95Q2FsbGJhY2tzLnB1c2goZm4pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbnRlcm5hbCBmdW5jdGlvbiB0byBpbnZva2UgYWxsIHJlZ2lzdGVyZWQgXCJvbiBkZXN0cm95XCIgY2FsbGJhY2tzLlxuICAgICAqIE5vdGU6IGNhbGxpbmcgdGhpcyBmdW5jdGlvbiBhbHNvIGNsZWFycyB0aGUgbGlzdCBvZiBjYWxsYmFja3MuXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgX2ludm9rZU9uRGVzdHJveUNhbGxiYWNrcygpIHtcbiAgICAgICAgdGhpcy5fb25EZXN0cm95Q2FsbGJhY2tzLmZvckVhY2goZm4gPT4gZm4oKSk7XG4gICAgICAgIHRoaXMuX29uRGVzdHJveUNhbGxiYWNrcyA9IFtdO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKiBSZXNldHMgdGhlIGNvbnRyb2wgd2l0aCB0aGUgcHJvdmlkZWQgdmFsdWUgaWYgdGhlIGNvbnRyb2wgaXMgcHJlc2VudC5cbiAgICAgKi9cbiAgICByZXNldCh2YWx1ZSA9IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAodGhpcy5jb250cm9sKVxuICAgICAgICAgICAgdGhpcy5jb250cm9sLnJlc2V0KHZhbHVlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICogUmVwb3J0cyB3aGV0aGVyIHRoZSBjb250cm9sIHdpdGggdGhlIGdpdmVuIHBhdGggaGFzIHRoZSBlcnJvciBzcGVjaWZpZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZXJyb3JDb2RlIFRoZSBjb2RlIG9mIHRoZSBlcnJvciB0byBjaGVja1xuICAgICAqIEBwYXJhbSBwYXRoIEEgbGlzdCBvZiBjb250cm9sIG5hbWVzIHRoYXQgZGVzaWduYXRlcyBob3cgdG8gbW92ZSBmcm9tIHRoZSBjdXJyZW50IGNvbnRyb2xcbiAgICAgKiB0byB0aGUgY29udHJvbCB0aGF0IHNob3VsZCBiZSBxdWVyaWVkIGZvciBlcnJvcnMuXG4gICAgICpcbiAgICAgKiBAdXNhZ2VOb3Rlc1xuICAgICAqIEZvciBleGFtcGxlLCBmb3IgdGhlIGZvbGxvd2luZyBgRm9ybUdyb3VwYDpcbiAgICAgKlxuICAgICAqIGBgYFxuICAgICAqIGZvcm0gPSBuZXcgRm9ybUdyb3VwKHtcbiAgICAgKiAgIGFkZHJlc3M6IG5ldyBGb3JtR3JvdXAoeyBzdHJlZXQ6IG5ldyBGb3JtQ29udHJvbCgpIH0pXG4gICAgICogfSk7XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBUaGUgcGF0aCB0byB0aGUgJ3N0cmVldCcgY29udHJvbCBmcm9tIHRoZSByb290IGZvcm0gd291bGQgYmUgJ2FkZHJlc3MnIC0+ICdzdHJlZXQnLlxuICAgICAqXG4gICAgICogSXQgY2FuIGJlIHByb3ZpZGVkIHRvIHRoaXMgbWV0aG9kIGluIG9uZSBvZiB0d28gZm9ybWF0czpcbiAgICAgKlxuICAgICAqIDEuIEFuIGFycmF5IG9mIHN0cmluZyBjb250cm9sIG5hbWVzLCBlLmcuIGBbJ2FkZHJlc3MnLCAnc3RyZWV0J11gXG4gICAgICogMS4gQSBwZXJpb2QtZGVsaW1pdGVkIGxpc3Qgb2YgY29udHJvbCBuYW1lcyBpbiBvbmUgc3RyaW5nLCBlLmcuIGAnYWRkcmVzcy5zdHJlZXQnYFxuICAgICAqXG4gICAgICogSWYgbm8gcGF0aCBpcyBnaXZlbiwgdGhpcyBtZXRob2QgY2hlY2tzIGZvciB0aGUgZXJyb3Igb24gdGhlIGN1cnJlbnQgY29udHJvbC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHdoZXRoZXIgdGhlIGdpdmVuIGVycm9yIGlzIHByZXNlbnQgaW4gdGhlIGNvbnRyb2wgYXQgdGhlIGdpdmVuIHBhdGguXG4gICAgICpcbiAgICAgKiBJZiB0aGUgY29udHJvbCBpcyBub3QgcHJlc2VudCwgZmFsc2UgaXMgcmV0dXJuZWQuXG4gICAgICovXG4gICAgaGFzRXJyb3IoZXJyb3JDb2RlLCBwYXRoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnRyb2wgPyB0aGlzLmNvbnRyb2wuaGFzRXJyb3IoZXJyb3JDb2RlLCBwYXRoKSA6IGZhbHNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKiBSZXBvcnRzIGVycm9yIGRhdGEgZm9yIHRoZSBjb250cm9sIHdpdGggdGhlIGdpdmVuIHBhdGguXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZXJyb3JDb2RlIFRoZSBjb2RlIG9mIHRoZSBlcnJvciB0byBjaGVja1xuICAgICAqIEBwYXJhbSBwYXRoIEEgbGlzdCBvZiBjb250cm9sIG5hbWVzIHRoYXQgZGVzaWduYXRlcyBob3cgdG8gbW92ZSBmcm9tIHRoZSBjdXJyZW50IGNvbnRyb2xcbiAgICAgKiB0byB0aGUgY29udHJvbCB0aGF0IHNob3VsZCBiZSBxdWVyaWVkIGZvciBlcnJvcnMuXG4gICAgICpcbiAgICAgKiBAdXNhZ2VOb3Rlc1xuICAgICAqIEZvciBleGFtcGxlLCBmb3IgdGhlIGZvbGxvd2luZyBgRm9ybUdyb3VwYDpcbiAgICAgKlxuICAgICAqIGBgYFxuICAgICAqIGZvcm0gPSBuZXcgRm9ybUdyb3VwKHtcbiAgICAgKiAgIGFkZHJlc3M6IG5ldyBGb3JtR3JvdXAoeyBzdHJlZXQ6IG5ldyBGb3JtQ29udHJvbCgpIH0pXG4gICAgICogfSk7XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBUaGUgcGF0aCB0byB0aGUgJ3N0cmVldCcgY29udHJvbCBmcm9tIHRoZSByb290IGZvcm0gd291bGQgYmUgJ2FkZHJlc3MnIC0+ICdzdHJlZXQnLlxuICAgICAqXG4gICAgICogSXQgY2FuIGJlIHByb3ZpZGVkIHRvIHRoaXMgbWV0aG9kIGluIG9uZSBvZiB0d28gZm9ybWF0czpcbiAgICAgKlxuICAgICAqIDEuIEFuIGFycmF5IG9mIHN0cmluZyBjb250cm9sIG5hbWVzLCBlLmcuIGBbJ2FkZHJlc3MnLCAnc3RyZWV0J11gXG4gICAgICogMS4gQSBwZXJpb2QtZGVsaW1pdGVkIGxpc3Qgb2YgY29udHJvbCBuYW1lcyBpbiBvbmUgc3RyaW5nLCBlLmcuIGAnYWRkcmVzcy5zdHJlZXQnYFxuICAgICAqXG4gICAgICogQHJldHVybnMgZXJyb3IgZGF0YSBmb3IgdGhhdCBwYXJ0aWN1bGFyIGVycm9yLiBJZiB0aGUgY29udHJvbCBvciBlcnJvciBpcyBub3QgcHJlc2VudCxcbiAgICAgKiBudWxsIGlzIHJldHVybmVkLlxuICAgICAqL1xuICAgIGdldEVycm9yKGVycm9yQ29kZSwgcGF0aCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb250cm9sID8gdGhpcy5jb250cm9sLmdldEVycm9yKGVycm9yQ29kZSwgcGF0aCkgOiBudWxsO1xuICAgIH1cbn1cblxuLyoqXG4gKiBAZGVzY3JpcHRpb25cbiAqIEEgYmFzZSBjbGFzcyBmb3IgZGlyZWN0aXZlcyB0aGF0IGNvbnRhaW4gbXVsdGlwbGUgcmVnaXN0ZXJlZCBpbnN0YW5jZXMgb2YgYE5nQ29udHJvbGAuXG4gKiBPbmx5IHVzZWQgYnkgdGhlIGZvcm1zIG1vZHVsZS5cbiAqXG4gKiBAcHVibGljQXBpXG4gKi9cbmNsYXNzIENvbnRyb2xDb250YWluZXIgZXh0ZW5kcyBBYnN0cmFjdENvbnRyb2xEaXJlY3RpdmUge1xuICAgIC8qKlxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqIFRoZSB0b3AtbGV2ZWwgZm9ybSBkaXJlY3RpdmUgZm9yIHRoZSBjb250cm9sLlxuICAgICAqL1xuICAgIGdldCBmb3JtRGlyZWN0aXZlKCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICogVGhlIHBhdGggdG8gdGhpcyBncm91cC5cbiAgICAgKi9cbiAgICBnZXQgcGF0aCgpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxufVxuXG4vKipcbiAqIEBkZXNjcmlwdGlvblxuICogQSBiYXNlIGNsYXNzIHRoYXQgYWxsIGBGb3JtQ29udHJvbGAtYmFzZWQgZGlyZWN0aXZlcyBleHRlbmQuIEl0IGJpbmRzIGEgYEZvcm1Db250cm9sYFxuICogb2JqZWN0IHRvIGEgRE9NIGVsZW1lbnQuXG4gKlxuICogQHB1YmxpY0FwaVxuICovXG5jbGFzcyBOZ0NvbnRyb2wgZXh0ZW5kcyBBYnN0cmFjdENvbnRyb2xEaXJlY3RpdmUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICAvKipcbiAgICAgICAgICogQGRlc2NyaXB0aW9uXG4gICAgICAgICAqIFRoZSBwYXJlbnQgZm9ybSBmb3IgdGhlIGNvbnRyb2wuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBpbnRlcm5hbFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fcGFyZW50ID0gbnVsbDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAgICAgKiBUaGUgbmFtZSBmb3IgdGhlIGNvbnRyb2xcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubmFtZSA9IG51bGw7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgICAgICogVGhlIHZhbHVlIGFjY2Vzc29yIGZvciB0aGUgY29udHJvbFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy52YWx1ZUFjY2Vzc29yID0gbnVsbDtcbiAgICB9XG59XG5cbi8vIERPIE5PVCBSRUZBQ1RPUiFcbi8vIEVhY2ggc3RhdHVzIGlzIHJlcHJlc2VudGVkIGJ5IGEgc2VwYXJhdGUgZnVuY3Rpb24gdG8gbWFrZSBzdXJlIHRoYXRcbi8vIGFkdmFuY2VkIENsb3N1cmUgQ29tcGlsZXIgb3B0aW1pemF0aW9ucyByZWxhdGVkIHRvIHByb3BlcnR5IHJlbmFtaW5nXG4vLyBjYW4gd29yayBjb3JyZWN0bHkuXG5jbGFzcyBBYnN0cmFjdENvbnRyb2xTdGF0dXMge1xuICAgIGNvbnN0cnVjdG9yKGNkKSB7XG4gICAgICAgIHRoaXMuX2NkID0gY2Q7XG4gICAgfVxuICAgIGdldCBpc1RvdWNoZWQoKSB7XG4gICAgICAgIHJldHVybiAhIXRoaXMuX2NkPy5jb250cm9sPy50b3VjaGVkO1xuICAgIH1cbiAgICBnZXQgaXNVbnRvdWNoZWQoKSB7XG4gICAgICAgIHJldHVybiAhIXRoaXMuX2NkPy5jb250cm9sPy51bnRvdWNoZWQ7XG4gICAgfVxuICAgIGdldCBpc1ByaXN0aW5lKCkge1xuICAgICAgICByZXR1cm4gISF0aGlzLl9jZD8uY29udHJvbD8ucHJpc3RpbmU7XG4gICAgfVxuICAgIGdldCBpc0RpcnR5KCkge1xuICAgICAgICByZXR1cm4gISF0aGlzLl9jZD8uY29udHJvbD8uZGlydHk7XG4gICAgfVxuICAgIGdldCBpc1ZhbGlkKCkge1xuICAgICAgICByZXR1cm4gISF0aGlzLl9jZD8uY29udHJvbD8udmFsaWQ7XG4gICAgfVxuICAgIGdldCBpc0ludmFsaWQoKSB7XG4gICAgICAgIHJldHVybiAhIXRoaXMuX2NkPy5jb250cm9sPy5pbnZhbGlkO1xuICAgIH1cbiAgICBnZXQgaXNQZW5kaW5nKCkge1xuICAgICAgICByZXR1cm4gISF0aGlzLl9jZD8uY29udHJvbD8ucGVuZGluZztcbiAgICB9XG4gICAgZ2V0IGlzU3VibWl0dGVkKCkge1xuICAgICAgICAvLyBXZSBjaGVjayBmb3IgdGhlIGBzdWJtaXR0ZWRgIGZpZWxkIGZyb20gYE5nRm9ybWAgYW5kIGBGb3JtR3JvdXBEaXJlY3RpdmVgIGNsYXNzZXMsIGJ1dFxuICAgICAgICAvLyB3ZSBhdm9pZCBpbnN0YW5jZW9mIGNoZWNrcyB0byBwcmV2ZW50IG5vbi10cmVlLXNoYWthYmxlIHJlZmVyZW5jZXMgdG8gdGhvc2UgdHlwZXMuXG4gICAgICAgIHJldHVybiAhIXRoaXMuX2NkPy5zdWJtaXR0ZWQ7XG4gICAgfVxufVxuY29uc3QgbmdDb250cm9sU3RhdHVzSG9zdCA9IHtcbiAgICAnW2NsYXNzLm5nLXVudG91Y2hlZF0nOiAnaXNVbnRvdWNoZWQnLFxuICAgICdbY2xhc3MubmctdG91Y2hlZF0nOiAnaXNUb3VjaGVkJyxcbiAgICAnW2NsYXNzLm5nLXByaXN0aW5lXSc6ICdpc1ByaXN0aW5lJyxcbiAgICAnW2NsYXNzLm5nLWRpcnR5XSc6ICdpc0RpcnR5JyxcbiAgICAnW2NsYXNzLm5nLXZhbGlkXSc6ICdpc1ZhbGlkJyxcbiAgICAnW2NsYXNzLm5nLWludmFsaWRdJzogJ2lzSW52YWxpZCcsXG4gICAgJ1tjbGFzcy5uZy1wZW5kaW5nXSc6ICdpc1BlbmRpbmcnLFxufTtcbmNvbnN0IG5nR3JvdXBTdGF0dXNIb3N0ID0ge1xuICAgIC4uLm5nQ29udHJvbFN0YXR1c0hvc3QsXG4gICAgJ1tjbGFzcy5uZy1zdWJtaXR0ZWRdJzogJ2lzU3VibWl0dGVkJyxcbn07XG4vKipcbiAqIEBkZXNjcmlwdGlvblxuICogRGlyZWN0aXZlIGF1dG9tYXRpY2FsbHkgYXBwbGllZCB0byBBbmd1bGFyIGZvcm0gY29udHJvbHMgdGhhdCBzZXRzIENTUyBjbGFzc2VzXG4gKiBiYXNlZCBvbiBjb250cm9sIHN0YXR1cy5cbiAqXG4gKiBAdXNhZ2VOb3Rlc1xuICpcbiAqICMjIyBDU1MgY2xhc3NlcyBhcHBsaWVkXG4gKlxuICogVGhlIGZvbGxvd2luZyBjbGFzc2VzIGFyZSBhcHBsaWVkIGFzIHRoZSBwcm9wZXJ0aWVzIGJlY29tZSB0cnVlOlxuICpcbiAqICogbmctdmFsaWRcbiAqICogbmctaW52YWxpZFxuICogKiBuZy1wZW5kaW5nXG4gKiAqIG5nLXByaXN0aW5lXG4gKiAqIG5nLWRpcnR5XG4gKiAqIG5nLXVudG91Y2hlZFxuICogKiBuZy10b3VjaGVkXG4gKlxuICogQG5nTW9kdWxlIFJlYWN0aXZlRm9ybXNNb2R1bGVcbiAqIEBuZ01vZHVsZSBGb3Jtc01vZHVsZVxuICogQHB1YmxpY0FwaVxuICovXG5jbGFzcyBOZ0NvbnRyb2xTdGF0dXMgZXh0ZW5kcyBBYnN0cmFjdENvbnRyb2xTdGF0dXMge1xuICAgIGNvbnN0cnVjdG9yKGNkKSB7XG4gICAgICAgIHN1cGVyKGNkKTtcbiAgICB9XG4gICAgc3RhdGljIHsgdGhpcy7JtWZhYyA9IGkwLsm1ybVuZ0RlY2xhcmVGYWN0b3J5KHsgbWluVmVyc2lvbjogXCIxMi4wLjBcIiwgdmVyc2lvbjogXCIxNy4zLjEyXCIsIG5nSW1wb3J0OiBpMCwgdHlwZTogTmdDb250cm9sU3RhdHVzLCBkZXBzOiBbeyB0b2tlbjogTmdDb250cm9sLCBzZWxmOiB0cnVlIH1dLCB0YXJnZXQ6IGkwLsm1ybVGYWN0b3J5VGFyZ2V0LkRpcmVjdGl2ZSB9KTsgfVxuICAgIHN0YXRpYyB7IHRoaXMuybVkaXIgPSBpMC7Jtcm1bmdEZWNsYXJlRGlyZWN0aXZlKHsgbWluVmVyc2lvbjogXCIxNC4wLjBcIiwgdmVyc2lvbjogXCIxNy4zLjEyXCIsIHR5cGU6IE5nQ29udHJvbFN0YXR1cywgc2VsZWN0b3I6IFwiW2Zvcm1Db250cm9sTmFtZV0sW25nTW9kZWxdLFtmb3JtQ29udHJvbF1cIiwgaG9zdDogeyBwcm9wZXJ0aWVzOiB7IFwiY2xhc3MubmctdW50b3VjaGVkXCI6IFwiaXNVbnRvdWNoZWRcIiwgXCJjbGFzcy5uZy10b3VjaGVkXCI6IFwiaXNUb3VjaGVkXCIsIFwiY2xhc3MubmctcHJpc3RpbmVcIjogXCJpc1ByaXN0aW5lXCIsIFwiY2xhc3MubmctZGlydHlcIjogXCJpc0RpcnR5XCIsIFwiY2xhc3MubmctdmFsaWRcIjogXCJpc1ZhbGlkXCIsIFwiY2xhc3MubmctaW52YWxpZFwiOiBcImlzSW52YWxpZFwiLCBcImNsYXNzLm5nLXBlbmRpbmdcIjogXCJpc1BlbmRpbmdcIiB9IH0sIHVzZXNJbmhlcml0YW5jZTogdHJ1ZSwgbmdJbXBvcnQ6IGkwIH0pOyB9XG59XG5pMC7Jtcm1bmdEZWNsYXJlQ2xhc3NNZXRhZGF0YSh7IG1pblZlcnNpb246IFwiMTIuMC4wXCIsIHZlcnNpb246IFwiMTcuMy4xMlwiLCBuZ0ltcG9ydDogaTAsIHR5cGU6IE5nQ29udHJvbFN0YXR1cywgZGVjb3JhdG9yczogW3tcbiAgICAgICAgICAgIHR5cGU6IERpcmVjdGl2ZSxcbiAgICAgICAgICAgIGFyZ3M6IFt7IHNlbGVjdG9yOiAnW2Zvcm1Db250cm9sTmFtZV0sW25nTW9kZWxdLFtmb3JtQ29udHJvbF0nLCBob3N0OiBuZ0NvbnRyb2xTdGF0dXNIb3N0IH1dXG4gICAgICAgIH1dLCBjdG9yUGFyYW1ldGVyczogKCkgPT4gW3sgdHlwZTogTmdDb250cm9sLCBkZWNvcmF0b3JzOiBbe1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBTZWxmXG4gICAgICAgICAgICAgICAgfV0gfV0gfSk7XG4vKipcbiAqIEBkZXNjcmlwdGlvblxuICogRGlyZWN0aXZlIGF1dG9tYXRpY2FsbHkgYXBwbGllZCB0byBBbmd1bGFyIGZvcm0gZ3JvdXBzIHRoYXQgc2V0cyBDU1MgY2xhc3Nlc1xuICogYmFzZWQgb24gY29udHJvbCBzdGF0dXMgKHZhbGlkL2ludmFsaWQvZGlydHkvZXRjKS4gT24gZ3JvdXBzLCB0aGlzIGluY2x1ZGVzIHRoZSBhZGRpdGlvbmFsXG4gKiBjbGFzcyBuZy1zdWJtaXR0ZWQuXG4gKlxuICogQHNlZSB7QGxpbmsgTmdDb250cm9sU3RhdHVzfVxuICpcbiAqIEBuZ01vZHVsZSBSZWFjdGl2ZUZvcm1zTW9kdWxlXG4gKiBAbmdNb2R1bGUgRm9ybXNNb2R1bGVcbiAqIEBwdWJsaWNBcGlcbiAqL1xuY2xhc3MgTmdDb250cm9sU3RhdHVzR3JvdXAgZXh0ZW5kcyBBYnN0cmFjdENvbnRyb2xTdGF0dXMge1xuICAgIGNvbnN0cnVjdG9yKGNkKSB7XG4gICAgICAgIHN1cGVyKGNkKTtcbiAgICB9XG4gICAgc3RhdGljIHsgdGhpcy7JtWZhYyA9IGkwLsm1ybVuZ0RlY2xhcmVGYWN0b3J5KHsgbWluVmVyc2lvbjogXCIxMi4wLjBcIiwgdmVyc2lvbjogXCIxNy4zLjEyXCIsIG5nSW1wb3J0OiBpMCwgdHlwZTogTmdDb250cm9sU3RhdHVzR3JvdXAsIGRlcHM6IFt7IHRva2VuOiBDb250cm9sQ29udGFpbmVyLCBvcHRpb25hbDogdHJ1ZSwgc2VsZjogdHJ1ZSB9XSwgdGFyZ2V0OiBpMC7Jtcm1RmFjdG9yeVRhcmdldC5EaXJlY3RpdmUgfSk7IH1cbiAgICBzdGF0aWMgeyB0aGlzLsm1ZGlyID0gaTAuybXJtW5nRGVjbGFyZURpcmVjdGl2ZSh7IG1pblZlcnNpb246IFwiMTQuMC4wXCIsIHZlcnNpb246IFwiMTcuMy4xMlwiLCB0eXBlOiBOZ0NvbnRyb2xTdGF0dXNHcm91cCwgc2VsZWN0b3I6IFwiW2Zvcm1Hcm91cE5hbWVdLFtmb3JtQXJyYXlOYW1lXSxbbmdNb2RlbEdyb3VwXSxbZm9ybUdyb3VwXSxmb3JtOm5vdChbbmdOb0Zvcm1dKSxbbmdGb3JtXVwiLCBob3N0OiB7IHByb3BlcnRpZXM6IHsgXCJjbGFzcy5uZy11bnRvdWNoZWRcIjogXCJpc1VudG91Y2hlZFwiLCBcImNsYXNzLm5nLXRvdWNoZWRcIjogXCJpc1RvdWNoZWRcIiwgXCJjbGFzcy5uZy1wcmlzdGluZVwiOiBcImlzUHJpc3RpbmVcIiwgXCJjbGFzcy5uZy1kaXJ0eVwiOiBcImlzRGlydHlcIiwgXCJjbGFzcy5uZy12YWxpZFwiOiBcImlzVmFsaWRcIiwgXCJjbGFzcy5uZy1pbnZhbGlkXCI6IFwiaXNJbnZhbGlkXCIsIFwiY2xhc3MubmctcGVuZGluZ1wiOiBcImlzUGVuZGluZ1wiLCBcImNsYXNzLm5nLXN1Ym1pdHRlZFwiOiBcImlzU3VibWl0dGVkXCIgfSB9LCB1c2VzSW5oZXJpdGFuY2U6IHRydWUsIG5nSW1wb3J0OiBpMCB9KTsgfVxufVxuaTAuybXJtW5nRGVjbGFyZUNsYXNzTWV0YWRhdGEoeyBtaW5WZXJzaW9uOiBcIjEyLjAuMFwiLCB2ZXJzaW9uOiBcIjE3LjMuMTJcIiwgbmdJbXBvcnQ6IGkwLCB0eXBlOiBOZ0NvbnRyb2xTdGF0dXNHcm91cCwgZGVjb3JhdG9yczogW3tcbiAgICAgICAgICAgIHR5cGU6IERpcmVjdGl2ZSxcbiAgICAgICAgICAgIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnW2Zvcm1Hcm91cE5hbWVdLFtmb3JtQXJyYXlOYW1lXSxbbmdNb2RlbEdyb3VwXSxbZm9ybUdyb3VwXSxmb3JtOm5vdChbbmdOb0Zvcm1dKSxbbmdGb3JtXScsXG4gICAgICAgICAgICAgICAgICAgIGhvc3Q6IG5nR3JvdXBTdGF0dXNIb3N0XG4gICAgICAgICAgICAgICAgfV1cbiAgICAgICAgfV0sIGN0b3JQYXJhbWV0ZXJzOiAoKSA9PiBbeyB0eXBlOiBDb250cm9sQ29udGFpbmVyLCBkZWNvcmF0b3JzOiBbe1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBPcHRpb25hbFxuICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogU2VsZlxuICAgICAgICAgICAgICAgIH1dIH1dIH0pO1xuXG5jb25zdCBmb3JtQ29udHJvbE5hbWVFeGFtcGxlID0gYFxuICA8ZGl2IFtmb3JtR3JvdXBdPVwibXlHcm91cFwiPlxuICAgIDxpbnB1dCBmb3JtQ29udHJvbE5hbWU9XCJmaXJzdE5hbWVcIj5cbiAgPC9kaXY+XG5cbiAgSW4geW91ciBjbGFzczpcblxuICB0aGlzLm15R3JvdXAgPSBuZXcgRm9ybUdyb3VwKHtcbiAgICAgIGZpcnN0TmFtZTogbmV3IEZvcm1Db250cm9sKClcbiAgfSk7YDtcbmNvbnN0IGZvcm1Hcm91cE5hbWVFeGFtcGxlID0gYFxuICA8ZGl2IFtmb3JtR3JvdXBdPVwibXlHcm91cFwiPlxuICAgICAgPGRpdiBmb3JtR3JvdXBOYW1lPVwicGVyc29uXCI+XG4gICAgICAgIDxpbnB1dCBmb3JtQ29udHJvbE5hbWU9XCJmaXJzdE5hbWVcIj5cbiAgICAgIDwvZGl2PlxuICA8L2Rpdj5cblxuICBJbiB5b3VyIGNsYXNzOlxuXG4gIHRoaXMubXlHcm91cCA9IG5ldyBGb3JtR3JvdXAoe1xuICAgICAgcGVyc29uOiBuZXcgRm9ybUdyb3VwKHsgZmlyc3ROYW1lOiBuZXcgRm9ybUNvbnRyb2woKSB9KVxuICB9KTtgO1xuY29uc3QgZm9ybUFycmF5TmFtZUV4YW1wbGUgPSBgXG4gIDxkaXYgW2Zvcm1Hcm91cF09XCJteUdyb3VwXCI+XG4gICAgPGRpdiBmb3JtQXJyYXlOYW1lPVwiY2l0aWVzXCI+XG4gICAgICA8ZGl2ICpuZ0Zvcj1cImxldCBjaXR5IG9mIGNpdHlBcnJheS5jb250cm9sczsgaW5kZXggYXMgaVwiPlxuICAgICAgICA8aW5wdXQgW2Zvcm1Db250cm9sTmFtZV09XCJpXCI+XG4gICAgICA8L2Rpdj5cbiAgICA8L2Rpdj5cbiAgPC9kaXY+XG5cbiAgSW4geW91ciBjbGFzczpcblxuICB0aGlzLmNpdHlBcnJheSA9IG5ldyBGb3JtQXJyYXkoW25ldyBGb3JtQ29udHJvbCgnU0YnKV0pO1xuICB0aGlzLm15R3JvdXAgPSBuZXcgRm9ybUdyb3VwKHtcbiAgICBjaXRpZXM6IHRoaXMuY2l0eUFycmF5XG4gIH0pO2A7XG5jb25zdCBuZ01vZGVsR3JvdXBFeGFtcGxlID0gYFxuICA8Zm9ybT5cbiAgICAgIDxkaXYgbmdNb2RlbEdyb3VwPVwicGVyc29uXCI+XG4gICAgICAgIDxpbnB1dCBbKG5nTW9kZWwpXT1cInBlcnNvbi5uYW1lXCIgbmFtZT1cImZpcnN0TmFtZVwiPlxuICAgICAgPC9kaXY+XG4gIDwvZm9ybT5gO1xuY29uc3QgbmdNb2RlbFdpdGhGb3JtR3JvdXBFeGFtcGxlID0gYFxuICA8ZGl2IFtmb3JtR3JvdXBdPVwibXlHcm91cFwiPlxuICAgICAgPGlucHV0IGZvcm1Db250cm9sTmFtZT1cImZpcnN0TmFtZVwiPlxuICAgICAgPGlucHV0IFsobmdNb2RlbCldPVwic2hvd01vcmVDb250cm9sc1wiIFtuZ01vZGVsT3B0aW9uc109XCJ7c3RhbmRhbG9uZTogdHJ1ZX1cIj5cbiAgPC9kaXY+XG5gO1xuXG5mdW5jdGlvbiBjb250cm9sUGFyZW50RXhjZXB0aW9uKCkge1xuICAgIHJldHVybiBuZXcgybVSdW50aW1lRXJyb3IoMTA1MCAvKiBSdW50aW1lRXJyb3JDb2RlLkZPUk1fQ09OVFJPTF9OQU1FX01JU1NJTkdfUEFSRU5UICovLCBgZm9ybUNvbnRyb2xOYW1lIG11c3QgYmUgdXNlZCB3aXRoIGEgcGFyZW50IGZvcm1Hcm91cCBkaXJlY3RpdmUuICBZb3UnbGwgd2FudCB0byBhZGQgYSBmb3JtR3JvdXBcbiAgICAgIGRpcmVjdGl2ZSBhbmQgcGFzcyBpdCBhbiBleGlzdGluZyBGb3JtR3JvdXAgaW5zdGFuY2UgKHlvdSBjYW4gY3JlYXRlIG9uZSBpbiB5b3VyIGNsYXNzKS5cblxuICAgIEV4YW1wbGU6XG5cbiAgICAke2Zvcm1Db250cm9sTmFtZUV4YW1wbGV9YCk7XG59XG5mdW5jdGlvbiBuZ01vZGVsR3JvdXBFeGNlcHRpb24oKSB7XG4gICAgcmV0dXJuIG5ldyDJtVJ1bnRpbWVFcnJvcigxMDUxIC8qIFJ1bnRpbWVFcnJvckNvZGUuRk9STV9DT05UUk9MX05BTUVfSU5TSURFX01PREVMX0dST1VQICovLCBgZm9ybUNvbnRyb2xOYW1lIGNhbm5vdCBiZSB1c2VkIHdpdGggYW4gbmdNb2RlbEdyb3VwIHBhcmVudC4gSXQgaXMgb25seSBjb21wYXRpYmxlIHdpdGggcGFyZW50c1xuICAgICAgdGhhdCBhbHNvIGhhdmUgYSBcImZvcm1cIiBwcmVmaXg6IGZvcm1Hcm91cE5hbWUsIGZvcm1BcnJheU5hbWUsIG9yIGZvcm1Hcm91cC5cblxuICAgICAgT3B0aW9uIDE6ICBVcGRhdGUgdGhlIHBhcmVudCB0byBiZSBmb3JtR3JvdXBOYW1lIChyZWFjdGl2ZSBmb3JtIHN0cmF0ZWd5KVxuXG4gICAgICAke2Zvcm1Hcm91cE5hbWVFeGFtcGxlfVxuXG4gICAgICBPcHRpb24gMjogVXNlIG5nTW9kZWwgaW5zdGVhZCBvZiBmb3JtQ29udHJvbE5hbWUgKHRlbXBsYXRlLWRyaXZlbiBzdHJhdGVneSlcblxuICAgICAgJHtuZ01vZGVsR3JvdXBFeGFtcGxlfWApO1xufVxuZnVuY3Rpb24gbWlzc2luZ0Zvcm1FeGNlcHRpb24oKSB7XG4gICAgcmV0dXJuIG5ldyDJtVJ1bnRpbWVFcnJvcigxMDUyIC8qIFJ1bnRpbWVFcnJvckNvZGUuRk9STV9HUk9VUF9NSVNTSU5HX0lOU1RBTkNFICovLCBgZm9ybUdyb3VwIGV4cGVjdHMgYSBGb3JtR3JvdXAgaW5zdGFuY2UuIFBsZWFzZSBwYXNzIG9uZSBpbi5cblxuICAgICAgRXhhbXBsZTpcblxuICAgICAgJHtmb3JtQ29udHJvbE5hbWVFeGFtcGxlfWApO1xufVxuZnVuY3Rpb24gZ3JvdXBQYXJlbnRFeGNlcHRpb24oKSB7XG4gICAgcmV0dXJuIG5ldyDJtVJ1bnRpbWVFcnJvcigxMDUzIC8qIFJ1bnRpbWVFcnJvckNvZGUuRk9STV9HUk9VUF9OQU1FX01JU1NJTkdfUEFSRU5UICovLCBgZm9ybUdyb3VwTmFtZSBtdXN0IGJlIHVzZWQgd2l0aCBhIHBhcmVudCBmb3JtR3JvdXAgZGlyZWN0aXZlLiAgWW91J2xsIHdhbnQgdG8gYWRkIGEgZm9ybUdyb3VwXG4gICAgZGlyZWN0aXZlIGFuZCBwYXNzIGl0IGFuIGV4aXN0aW5nIEZvcm1Hcm91cCBpbnN0YW5jZSAoeW91IGNhbiBjcmVhdGUgb25lIGluIHlvdXIgY2xhc3MpLlxuXG4gICAgRXhhbXBsZTpcblxuICAgICR7Zm9ybUdyb3VwTmFtZUV4YW1wbGV9YCk7XG59XG5mdW5jdGlvbiBhcnJheVBhcmVudEV4Y2VwdGlvbigpIHtcbiAgICByZXR1cm4gbmV3IMm1UnVudGltZUVycm9yKDEwNTQgLyogUnVudGltZUVycm9yQ29kZS5GT1JNX0FSUkFZX05BTUVfTUlTU0lOR19QQVJFTlQgKi8sIGBmb3JtQXJyYXlOYW1lIG11c3QgYmUgdXNlZCB3aXRoIGEgcGFyZW50IGZvcm1Hcm91cCBkaXJlY3RpdmUuICBZb3UnbGwgd2FudCB0byBhZGQgYSBmb3JtR3JvdXBcbiAgICAgIGRpcmVjdGl2ZSBhbmQgcGFzcyBpdCBhbiBleGlzdGluZyBGb3JtR3JvdXAgaW5zdGFuY2UgKHlvdSBjYW4gY3JlYXRlIG9uZSBpbiB5b3VyIGNsYXNzKS5cblxuICAgICAgRXhhbXBsZTpcblxuICAgICAgJHtmb3JtQXJyYXlOYW1lRXhhbXBsZX1gKTtcbn1cbmNvbnN0IGRpc2FibGVkQXR0cldhcm5pbmcgPSBgXG4gIEl0IGxvb2tzIGxpa2UgeW91J3JlIHVzaW5nIHRoZSBkaXNhYmxlZCBhdHRyaWJ1dGUgd2l0aCBhIHJlYWN0aXZlIGZvcm0gZGlyZWN0aXZlLiBJZiB5b3Ugc2V0IGRpc2FibGVkIHRvIHRydWVcbiAgd2hlbiB5b3Ugc2V0IHVwIHRoaXMgY29udHJvbCBpbiB5b3VyIGNvbXBvbmVudCBjbGFzcywgdGhlIGRpc2FibGVkIGF0dHJpYnV0ZSB3aWxsIGFjdHVhbGx5IGJlIHNldCBpbiB0aGUgRE9NIGZvclxuICB5b3UuIFdlIHJlY29tbWVuZCB1c2luZyB0aGlzIGFwcHJvYWNoIHRvIGF2b2lkICdjaGFuZ2VkIGFmdGVyIGNoZWNrZWQnIGVycm9ycy5cblxuICBFeGFtcGxlOlxuICAvLyBTcGVjaWZ5IHRoZSBcXGBkaXNhYmxlZFxcYCBwcm9wZXJ0eSBhdCBjb250cm9sIGNyZWF0aW9uIHRpbWU6XG4gIGZvcm0gPSBuZXcgRm9ybUdyb3VwKHtcbiAgICBmaXJzdDogbmV3IEZvcm1Db250cm9sKHt2YWx1ZTogJ05hbmN5JywgZGlzYWJsZWQ6IHRydWV9LCBWYWxpZGF0b3JzLnJlcXVpcmVkKSxcbiAgICBsYXN0OiBuZXcgRm9ybUNvbnRyb2woJ0RyZXcnLCBWYWxpZGF0b3JzLnJlcXVpcmVkKVxuICB9KTtcblxuICAvLyBDb250cm9scyBjYW4gYWxzbyBiZSBlbmFibGVkL2Rpc2FibGVkIGFmdGVyIGNyZWF0aW9uOlxuICBmb3JtLmdldCgnZmlyc3QnKT8uZW5hYmxlKCk7XG4gIGZvcm0uZ2V0KCdsYXN0Jyk/LmRpc2FibGUoKTtcbmA7XG5jb25zdCBhc3luY1ZhbGlkYXRvcnNEcm9wcGVkV2l0aE9wdHNXYXJuaW5nID0gYFxuICBJdCBsb29rcyBsaWtlIHlvdSdyZSBjb25zdHJ1Y3RpbmcgdXNpbmcgYSBGb3JtQ29udHJvbCB3aXRoIGJvdGggYW4gb3B0aW9ucyBhcmd1bWVudCBhbmQgYW5cbiAgYXN5bmMgdmFsaWRhdG9ycyBhcmd1bWVudC4gTWl4aW5nIHRoZXNlIGFyZ3VtZW50cyB3aWxsIGNhdXNlIHlvdXIgYXN5bmMgdmFsaWRhdG9ycyB0byBiZSBkcm9wcGVkLlxuICBZb3Ugc2hvdWxkIGVpdGhlciBwdXQgYWxsIHlvdXIgdmFsaWRhdG9ycyBpbiB0aGUgb3B0aW9ucyBvYmplY3QsIG9yIGluIHNlcGFyYXRlIHZhbGlkYXRvcnNcbiAgYXJndW1lbnRzLiBGb3IgZXhhbXBsZTpcblxuICAvLyBVc2luZyB2YWxpZGF0b3JzIGFyZ3VtZW50c1xuICBmYyA9IG5ldyBGb3JtQ29udHJvbCg0MiwgVmFsaWRhdG9ycy5yZXF1aXJlZCwgbXlBc3luY1ZhbGlkYXRvcik7XG5cbiAgLy8gVXNpbmcgQWJzdHJhY3RDb250cm9sT3B0aW9uc1xuICBmYyA9IG5ldyBGb3JtQ29udHJvbCg0Miwge3ZhbGlkYXRvcnM6IFZhbGlkYXRvcnMucmVxdWlyZWQsIGFzeW5jVmFsaWRhdG9yczogbXlBVn0pO1xuXG4gIC8vIERvIE5PVCBtaXggdGhlbTogYXN5bmMgdmFsaWRhdG9ycyB3aWxsIGJlIGRyb3BwZWQhXG4gIGZjID0gbmV3IEZvcm1Db250cm9sKDQyLCB7dmFsaWRhdG9yczogVmFsaWRhdG9ycy5yZXF1aXJlZH0sIC8qIE9vcHMhICovIG15QXN5bmNWYWxpZGF0b3IpO1xuYDtcbmZ1bmN0aW9uIG5nTW9kZWxXYXJuaW5nKGRpcmVjdGl2ZU5hbWUpIHtcbiAgICByZXR1cm4gYFxuICBJdCBsb29rcyBsaWtlIHlvdSdyZSB1c2luZyBuZ01vZGVsIG9uIHRoZSBzYW1lIGZvcm0gZmllbGQgYXMgJHtkaXJlY3RpdmVOYW1lfS5cbiAgU3VwcG9ydCBmb3IgdXNpbmcgdGhlIG5nTW9kZWwgaW5wdXQgcHJvcGVydHkgYW5kIG5nTW9kZWxDaGFuZ2UgZXZlbnQgd2l0aFxuICByZWFjdGl2ZSBmb3JtIGRpcmVjdGl2ZXMgaGFzIGJlZW4gZGVwcmVjYXRlZCBpbiBBbmd1bGFyIHY2IGFuZCB3aWxsIGJlIHJlbW92ZWRcbiAgaW4gYSBmdXR1cmUgdmVyc2lvbiBvZiBBbmd1bGFyLlxuXG4gIEZvciBtb3JlIGluZm9ybWF0aW9uIG9uIHRoaXMsIHNlZSBvdXIgQVBJIGRvY3MgaGVyZTpcbiAgaHR0cHM6Ly9hbmd1bGFyLmlvL2FwaS9mb3Jtcy8ke2RpcmVjdGl2ZU5hbWUgPT09ICdmb3JtQ29udHJvbCcgPyAnRm9ybUNvbnRyb2xEaXJlY3RpdmUnIDogJ0Zvcm1Db250cm9sTmFtZSd9I3VzZS13aXRoLW5nbW9kZWxcbiAgYDtcbn1cbmZ1bmN0aW9uIGRlc2NyaWJlS2V5KGlzRm9ybUdyb3VwLCBrZXkpIHtcbiAgICByZXR1cm4gaXNGb3JtR3JvdXAgPyBgd2l0aCBuYW1lOiAnJHtrZXl9J2AgOiBgYXQgaW5kZXg6ICR7a2V5fWA7XG59XG5mdW5jdGlvbiBub0NvbnRyb2xzRXJyb3IoaXNGb3JtR3JvdXApIHtcbiAgICByZXR1cm4gYFxuICAgIFRoZXJlIGFyZSBubyBmb3JtIGNvbnRyb2xzIHJlZ2lzdGVyZWQgd2l0aCB0aGlzICR7aXNGb3JtR3JvdXAgPyAnZ3JvdXAnIDogJ2FycmF5J30geWV0LiBJZiB5b3UncmUgdXNpbmcgbmdNb2RlbCxcbiAgICB5b3UgbWF5IHdhbnQgdG8gY2hlY2sgbmV4dCB0aWNrIChlLmcuIHVzZSBzZXRUaW1lb3V0KS5cbiAgYDtcbn1cbmZ1bmN0aW9uIG1pc3NpbmdDb250cm9sRXJyb3IoaXNGb3JtR3JvdXAsIGtleSkge1xuICAgIHJldHVybiBgQ2Fubm90IGZpbmQgZm9ybSBjb250cm9sICR7ZGVzY3JpYmVLZXkoaXNGb3JtR3JvdXAsIGtleSl9YDtcbn1cbmZ1bmN0aW9uIG1pc3NpbmdDb250cm9sVmFsdWVFcnJvcihpc0Zvcm1Hcm91cCwga2V5KSB7XG4gICAgcmV0dXJuIGBNdXN0IHN1cHBseSBhIHZhbHVlIGZvciBmb3JtIGNvbnRyb2wgJHtkZXNjcmliZUtleShpc0Zvcm1Hcm91cCwga2V5KX1gO1xufVxuXG4vKipcbiAqIFJlcG9ydHMgdGhhdCBhIGNvbnRyb2wgaXMgdmFsaWQsIG1lYW5pbmcgdGhhdCBubyBlcnJvcnMgZXhpc3QgaW4gdGhlIGlucHV0IHZhbHVlLlxuICpcbiAqIEBzZWUge0BsaW5rIHN0YXR1c31cbiAqL1xuY29uc3QgVkFMSUQgPSAnVkFMSUQnO1xuLyoqXG4gKiBSZXBvcnRzIHRoYXQgYSBjb250cm9sIGlzIGludmFsaWQsIG1lYW5pbmcgdGhhdCBhbiBlcnJvciBleGlzdHMgaW4gdGhlIGlucHV0IHZhbHVlLlxuICpcbiAqIEBzZWUge0BsaW5rIHN0YXR1c31cbiAqL1xuY29uc3QgSU5WQUxJRCA9ICdJTlZBTElEJztcbi8qKlxuICogUmVwb3J0cyB0aGF0IGEgY29udHJvbCBpcyBwZW5kaW5nLCBtZWFuaW5nIHRoYXQgYXN5bmMgdmFsaWRhdGlvbiBpcyBvY2N1cnJpbmcgYW5kXG4gKiBlcnJvcnMgYXJlIG5vdCB5ZXQgYXZhaWxhYmxlIGZvciB0aGUgaW5wdXQgdmFsdWUuXG4gKlxuICogQHNlZSB7QGxpbmsgbWFya0FzUGVuZGluZ31cbiAqIEBzZWUge0BsaW5rIHN0YXR1c31cbiAqL1xuY29uc3QgUEVORElORyA9ICdQRU5ESU5HJztcbi8qKlxuICogUmVwb3J0cyB0aGF0IGEgY29udHJvbCBpcyBkaXNhYmxlZCwgbWVhbmluZyB0aGF0IHRoZSBjb250cm9sIGlzIGV4ZW1wdCBmcm9tIGFuY2VzdG9yXG4gKiBjYWxjdWxhdGlvbnMgb2YgdmFsaWRpdHkgb3IgdmFsdWUuXG4gKlxuICogQHNlZSB7QGxpbmsgbWFya0FzRGlzYWJsZWR9XG4gKiBAc2VlIHtAbGluayBzdGF0dXN9XG4gKi9cbmNvbnN0IERJU0FCTEVEID0gJ0RJU0FCTEVEJztcbi8qKlxuICogR2V0cyB2YWxpZGF0b3JzIGZyb20gZWl0aGVyIGFuIG9wdGlvbnMgb2JqZWN0IG9yIGdpdmVuIHZhbGlkYXRvcnMuXG4gKi9cbmZ1bmN0aW9uIHBpY2tWYWxpZGF0b3JzKHZhbGlkYXRvck9yT3B0cykge1xuICAgIHJldHVybiAoaXNPcHRpb25zT2JqKHZhbGlkYXRvck9yT3B0cykgPyB2YWxpZGF0b3JPck9wdHMudmFsaWRhdG9ycyA6IHZhbGlkYXRvck9yT3B0cykgfHwgbnVsbDtcbn1cbi8qKlxuICogQ3JlYXRlcyB2YWxpZGF0b3IgZnVuY3Rpb24gYnkgY29tYmluaW5nIHByb3ZpZGVkIHZhbGlkYXRvcnMuXG4gKi9cbmZ1bmN0aW9uIGNvZXJjZVRvVmFsaWRhdG9yKHZhbGlkYXRvcikge1xuICAgIHJldHVybiBBcnJheS5pc0FycmF5KHZhbGlkYXRvcikgPyBjb21wb3NlVmFsaWRhdG9ycyh2YWxpZGF0b3IpIDogdmFsaWRhdG9yIHx8IG51bGw7XG59XG4vKipcbiAqIEdldHMgYXN5bmMgdmFsaWRhdG9ycyBmcm9tIGVpdGhlciBhbiBvcHRpb25zIG9iamVjdCBvciBnaXZlbiB2YWxpZGF0b3JzLlxuICovXG5mdW5jdGlvbiBwaWNrQXN5bmNWYWxpZGF0b3JzKGFzeW5jVmFsaWRhdG9yLCB2YWxpZGF0b3JPck9wdHMpIHtcbiAgICBpZiAodHlwZW9mIG5nRGV2TW9kZSA9PT0gJ3VuZGVmaW5lZCcgfHwgbmdEZXZNb2RlKSB7XG4gICAgICAgIGlmIChpc09wdGlvbnNPYmoodmFsaWRhdG9yT3JPcHRzKSAmJiBhc3luY1ZhbGlkYXRvcikge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKGFzeW5jVmFsaWRhdG9yc0Ryb3BwZWRXaXRoT3B0c1dhcm5pbmcpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiAoaXNPcHRpb25zT2JqKHZhbGlkYXRvck9yT3B0cykgPyB2YWxpZGF0b3JPck9wdHMuYXN5bmNWYWxpZGF0b3JzIDogYXN5bmNWYWxpZGF0b3IpIHx8IG51bGw7XG59XG4vKipcbiAqIENyZWF0ZXMgYXN5bmMgdmFsaWRhdG9yIGZ1bmN0aW9uIGJ5IGNvbWJpbmluZyBwcm92aWRlZCBhc3luYyB2YWxpZGF0b3JzLlxuICovXG5mdW5jdGlvbiBjb2VyY2VUb0FzeW5jVmFsaWRhdG9yKGFzeW5jVmFsaWRhdG9yKSB7XG4gICAgcmV0dXJuIEFycmF5LmlzQXJyYXkoYXN5bmNWYWxpZGF0b3IpID8gY29tcG9zZUFzeW5jVmFsaWRhdG9ycyhhc3luY1ZhbGlkYXRvcikgOlxuICAgICAgICBhc3luY1ZhbGlkYXRvciB8fCBudWxsO1xufVxuZnVuY3Rpb24gaXNPcHRpb25zT2JqKHZhbGlkYXRvck9yT3B0cykge1xuICAgIHJldHVybiB2YWxpZGF0b3JPck9wdHMgIT0gbnVsbCAmJiAhQXJyYXkuaXNBcnJheSh2YWxpZGF0b3JPck9wdHMpICYmXG4gICAgICAgIHR5cGVvZiB2YWxpZGF0b3JPck9wdHMgPT09ICdvYmplY3QnO1xufVxuZnVuY3Rpb24gYXNzZXJ0Q29udHJvbFByZXNlbnQocGFyZW50LCBpc0dyb3VwLCBrZXkpIHtcbiAgICBjb25zdCBjb250cm9scyA9IHBhcmVudC5jb250cm9scztcbiAgICBjb25zdCBjb2xsZWN0aW9uID0gaXNHcm91cCA/IE9iamVjdC5rZXlzKGNvbnRyb2xzKSA6IGNvbnRyb2xzO1xuICAgIGlmICghY29sbGVjdGlvbi5sZW5ndGgpIHtcbiAgICAgICAgdGhyb3cgbmV3IMm1UnVudGltZUVycm9yKDEwMDAgLyogUnVudGltZUVycm9yQ29kZS5OT19DT05UUk9MUyAqLywgKHR5cGVvZiBuZ0Rldk1vZGUgPT09ICd1bmRlZmluZWQnIHx8IG5nRGV2TW9kZSkgPyBub0NvbnRyb2xzRXJyb3IoaXNHcm91cCkgOiAnJyk7XG4gICAgfVxuICAgIGlmICghY29udHJvbHNba2V5XSkge1xuICAgICAgICB0aHJvdyBuZXcgybVSdW50aW1lRXJyb3IoMTAwMSAvKiBSdW50aW1lRXJyb3JDb2RlLk1JU1NJTkdfQ09OVFJPTCAqLywgKHR5cGVvZiBuZ0Rldk1vZGUgPT09ICd1bmRlZmluZWQnIHx8IG5nRGV2TW9kZSkgPyBtaXNzaW5nQ29udHJvbEVycm9yKGlzR3JvdXAsIGtleSkgOiAnJyk7XG4gICAgfVxufVxuZnVuY3Rpb24gYXNzZXJ0QWxsVmFsdWVzUHJlc2VudChjb250cm9sLCBpc0dyb3VwLCB2YWx1ZSkge1xuICAgIGNvbnRyb2wuX2ZvckVhY2hDaGlsZCgoXywga2V5KSA9PiB7XG4gICAgICAgIGlmICh2YWx1ZVtrZXldID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyDJtVJ1bnRpbWVFcnJvcigxMDAyIC8qIFJ1bnRpbWVFcnJvckNvZGUuTUlTU0lOR19DT05UUk9MX1ZBTFVFICovLCAodHlwZW9mIG5nRGV2TW9kZSA9PT0gJ3VuZGVmaW5lZCcgfHwgbmdEZXZNb2RlKSA/IG1pc3NpbmdDb250cm9sVmFsdWVFcnJvcihpc0dyb3VwLCBrZXkpIDpcbiAgICAgICAgICAgICAgICAnJyk7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbi8vIGNsYW5nLWZvcm1hdCBvblxuLyoqXG4gKiBUaGlzIGlzIHRoZSBiYXNlIGNsYXNzIGZvciBgRm9ybUNvbnRyb2xgLCBgRm9ybUdyb3VwYCwgYW5kIGBGb3JtQXJyYXlgLlxuICpcbiAqIEl0IHByb3ZpZGVzIHNvbWUgb2YgdGhlIHNoYXJlZCBiZWhhdmlvciB0aGF0IGFsbCBjb250cm9scyBhbmQgZ3JvdXBzIG9mIGNvbnRyb2xzIGhhdmUsIGxpa2VcbiAqIHJ1bm5pbmcgdmFsaWRhdG9ycywgY2FsY3VsYXRpbmcgc3RhdHVzLCBhbmQgcmVzZXR0aW5nIHN0YXRlLiBJdCBhbHNvIGRlZmluZXMgdGhlIHByb3BlcnRpZXNcbiAqIHRoYXQgYXJlIHNoYXJlZCBiZXR3ZWVuIGFsbCBzdWItY2xhc3NlcywgbGlrZSBgdmFsdWVgLCBgdmFsaWRgLCBhbmQgYGRpcnR5YC4gSXQgc2hvdWxkbid0IGJlXG4gKiBpbnN0YW50aWF0ZWQgZGlyZWN0bHkuXG4gKlxuICogVGhlIGZpcnN0IHR5cGUgcGFyYW1ldGVyIFRWYWx1ZSByZXByZXNlbnRzIHRoZSB2YWx1ZSB0eXBlIG9mIHRoZSBjb250cm9sIChgY29udHJvbC52YWx1ZWApLlxuICogVGhlIG9wdGlvbmFsIHR5cGUgcGFyYW1ldGVyIFRSYXdWYWx1ZSAgcmVwcmVzZW50cyB0aGUgcmF3IHZhbHVlIHR5cGUgKGBjb250cm9sLmdldFJhd1ZhbHVlKClgKS5cbiAqXG4gKiBAc2VlIFtGb3JtcyBHdWlkZV0oL2d1aWRlL2Zvcm1zKVxuICogQHNlZSBbUmVhY3RpdmUgRm9ybXMgR3VpZGVdKC9ndWlkZS9yZWFjdGl2ZS1mb3JtcylcbiAqIEBzZWUgW0R5bmFtaWMgRm9ybXMgR3VpZGVdKC9ndWlkZS9keW5hbWljLWZvcm0pXG4gKlxuICogQHB1YmxpY0FwaVxuICovXG5jbGFzcyBBYnN0cmFjdENvbnRyb2wge1xuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemUgdGhlIEFic3RyYWN0Q29udHJvbCBpbnN0YW5jZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB2YWxpZGF0b3JzIFRoZSBmdW5jdGlvbiBvciBhcnJheSBvZiBmdW5jdGlvbnMgdGhhdCBpcyB1c2VkIHRvIGRldGVybWluZSB0aGUgdmFsaWRpdHkgb2ZcbiAgICAgKiAgICAgdGhpcyBjb250cm9sIHN5bmNocm9ub3VzbHkuXG4gICAgICogQHBhcmFtIGFzeW5jVmFsaWRhdG9ycyBUaGUgZnVuY3Rpb24gb3IgYXJyYXkgb2YgZnVuY3Rpb25zIHRoYXQgaXMgdXNlZCB0byBkZXRlcm1pbmUgdmFsaWRpdHkgb2ZcbiAgICAgKiAgICAgdGhpcyBjb250cm9sIGFzeW5jaHJvbm91c2x5LlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHZhbGlkYXRvcnMsIGFzeW5jVmFsaWRhdG9ycykge1xuICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgIHRoaXMuX3BlbmRpbmdEaXJ0eSA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogSW5kaWNhdGVzIHRoYXQgYSBjb250cm9sIGhhcyBpdHMgb3duIHBlbmRpbmcgYXN5bmNocm9ub3VzIHZhbGlkYXRpb24gaW4gcHJvZ3Jlc3MuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBpbnRlcm5hbFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5faGFzT3duUGVuZGluZ0FzeW5jVmFsaWRhdG9yID0gZmFsc2U7XG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgdGhpcy5fcGVuZGluZ1RvdWNoZWQgPSBmYWxzZTtcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICB0aGlzLl9vbkNvbGxlY3Rpb25DaGFuZ2UgPSAoKSA9PiB7IH07XG4gICAgICAgIHRoaXMuX3BhcmVudCA9IG51bGw7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIGNvbnRyb2wgaXMgYHByaXN0aW5lYCBpZiB0aGUgdXNlciBoYXMgbm90IHlldCBjaGFuZ2VkXG4gICAgICAgICAqIHRoZSB2YWx1ZSBpbiB0aGUgVUkuXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm5zIFRydWUgaWYgdGhlIHVzZXIgaGFzIG5vdCB5ZXQgY2hhbmdlZCB0aGUgdmFsdWUgaW4gdGhlIFVJOyBjb21wYXJlIGBkaXJ0eWAuXG4gICAgICAgICAqIFByb2dyYW1tYXRpYyBjaGFuZ2VzIHRvIGEgY29udHJvbCdzIHZhbHVlIGRvIG5vdCBtYXJrIGl0IGRpcnR5LlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5wcmlzdGluZSA9IHRydWU7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUcnVlIGlmIHRoZSBjb250cm9sIGlzIG1hcmtlZCBhcyBgdG91Y2hlZGAuXG4gICAgICAgICAqXG4gICAgICAgICAqIEEgY29udHJvbCBpcyBtYXJrZWQgYHRvdWNoZWRgIG9uY2UgdGhlIHVzZXIgaGFzIHRyaWdnZXJlZFxuICAgICAgICAgKiBhIGBibHVyYCBldmVudCBvbiBpdC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudG91Y2hlZCA9IGZhbHNlO1xuICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgIHRoaXMuX29uRGlzYWJsZWRDaGFuZ2UgPSBbXTtcbiAgICAgICAgdGhpcy5fYXNzaWduVmFsaWRhdG9ycyh2YWxpZGF0b3JzKTtcbiAgICAgICAgdGhpcy5fYXNzaWduQXN5bmNWYWxpZGF0b3JzKGFzeW5jVmFsaWRhdG9ycyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGZ1bmN0aW9uIHRoYXQgaXMgdXNlZCB0byBkZXRlcm1pbmUgdGhlIHZhbGlkaXR5IG9mIHRoaXMgY29udHJvbCBzeW5jaHJvbm91c2x5LlxuICAgICAqIElmIG11bHRpcGxlIHZhbGlkYXRvcnMgaGF2ZSBiZWVuIGFkZGVkLCB0aGlzIHdpbGwgYmUgYSBzaW5nbGUgY29tcG9zZWQgZnVuY3Rpb24uXG4gICAgICogU2VlIGBWYWxpZGF0b3JzLmNvbXBvc2UoKWAgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb24uXG4gICAgICovXG4gICAgZ2V0IHZhbGlkYXRvcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NvbXBvc2VkVmFsaWRhdG9yRm47XG4gICAgfVxuICAgIHNldCB2YWxpZGF0b3IodmFsaWRhdG9yRm4pIHtcbiAgICAgICAgdGhpcy5fcmF3VmFsaWRhdG9ycyA9IHRoaXMuX2NvbXBvc2VkVmFsaWRhdG9yRm4gPSB2YWxpZGF0b3JGbjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgZnVuY3Rpb24gdGhhdCBpcyB1c2VkIHRvIGRldGVybWluZSB0aGUgdmFsaWRpdHkgb2YgdGhpcyBjb250cm9sIGFzeW5jaHJvbm91c2x5LlxuICAgICAqIElmIG11bHRpcGxlIHZhbGlkYXRvcnMgaGF2ZSBiZWVuIGFkZGVkLCB0aGlzIHdpbGwgYmUgYSBzaW5nbGUgY29tcG9zZWQgZnVuY3Rpb24uXG4gICAgICogU2VlIGBWYWxpZGF0b3JzLmNvbXBvc2UoKWAgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb24uXG4gICAgICovXG4gICAgZ2V0IGFzeW5jVmFsaWRhdG9yKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY29tcG9zZWRBc3luY1ZhbGlkYXRvckZuO1xuICAgIH1cbiAgICBzZXQgYXN5bmNWYWxpZGF0b3IoYXN5bmNWYWxpZGF0b3JGbikge1xuICAgICAgICB0aGlzLl9yYXdBc3luY1ZhbGlkYXRvcnMgPSB0aGlzLl9jb21wb3NlZEFzeW5jVmFsaWRhdG9yRm4gPSBhc3luY1ZhbGlkYXRvckZuO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgcGFyZW50IGNvbnRyb2wuXG4gICAgICovXG4gICAgZ2V0IHBhcmVudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BhcmVudDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQSBjb250cm9sIGlzIGB2YWxpZGAgd2hlbiBpdHMgYHN0YXR1c2AgaXMgYFZBTElEYC5cbiAgICAgKlxuICAgICAqIEBzZWUge0BsaW5rIEFic3RyYWN0Q29udHJvbC5zdGF0dXN9XG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUcnVlIGlmIHRoZSBjb250cm9sIGhhcyBwYXNzZWQgYWxsIG9mIGl0cyB2YWxpZGF0aW9uIHRlc3RzLFxuICAgICAqIGZhbHNlIG90aGVyd2lzZS5cbiAgICAgKi9cbiAgICBnZXQgdmFsaWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXR1cyA9PT0gVkFMSUQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEEgY29udHJvbCBpcyBgaW52YWxpZGAgd2hlbiBpdHMgYHN0YXR1c2AgaXMgYElOVkFMSURgLlxuICAgICAqXG4gICAgICogQHNlZSB7QGxpbmsgQWJzdHJhY3RDb250cm9sLnN0YXR1c31cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRydWUgaWYgdGhpcyBjb250cm9sIGhhcyBmYWlsZWQgb25lIG9yIG1vcmUgb2YgaXRzIHZhbGlkYXRpb24gY2hlY2tzLFxuICAgICAqIGZhbHNlIG90aGVyd2lzZS5cbiAgICAgKi9cbiAgICBnZXQgaW52YWxpZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdHVzID09PSBJTlZBTElEO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBIGNvbnRyb2wgaXMgYHBlbmRpbmdgIHdoZW4gaXRzIGBzdGF0dXNgIGlzIGBQRU5ESU5HYC5cbiAgICAgKlxuICAgICAqIEBzZWUge0BsaW5rIEFic3RyYWN0Q29udHJvbC5zdGF0dXN9XG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUcnVlIGlmIHRoaXMgY29udHJvbCBpcyBpbiB0aGUgcHJvY2VzcyBvZiBjb25kdWN0aW5nIGEgdmFsaWRhdGlvbiBjaGVjayxcbiAgICAgKiBmYWxzZSBvdGhlcndpc2UuXG4gICAgICovXG4gICAgZ2V0IHBlbmRpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXR1cyA9PSBQRU5ESU5HO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBIGNvbnRyb2wgaXMgYGRpc2FibGVkYCB3aGVuIGl0cyBgc3RhdHVzYCBpcyBgRElTQUJMRURgLlxuICAgICAqXG4gICAgICogRGlzYWJsZWQgY29udHJvbHMgYXJlIGV4ZW1wdCBmcm9tIHZhbGlkYXRpb24gY2hlY2tzIGFuZFxuICAgICAqIGFyZSBub3QgaW5jbHVkZWQgaW4gdGhlIGFnZ3JlZ2F0ZSB2YWx1ZSBvZiB0aGVpciBhbmNlc3RvclxuICAgICAqIGNvbnRyb2xzLlxuICAgICAqXG4gICAgICogQHNlZSB7QGxpbmsgQWJzdHJhY3RDb250cm9sLnN0YXR1c31cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRydWUgaWYgdGhlIGNvbnRyb2wgaXMgZGlzYWJsZWQsIGZhbHNlIG90aGVyd2lzZS5cbiAgICAgKi9cbiAgICBnZXQgZGlzYWJsZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXR1cyA9PT0gRElTQUJMRUQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEEgY29udHJvbCBpcyBgZW5hYmxlZGAgYXMgbG9uZyBhcyBpdHMgYHN0YXR1c2AgaXMgbm90IGBESVNBQkxFRGAuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUcnVlIGlmIHRoZSBjb250cm9sIGhhcyBhbnkgc3RhdHVzIG90aGVyIHRoYW4gJ0RJU0FCTEVEJyxcbiAgICAgKiBmYWxzZSBpZiB0aGUgc3RhdHVzIGlzICdESVNBQkxFRCcuXG4gICAgICpcbiAgICAgKiBAc2VlIHtAbGluayBBYnN0cmFjdENvbnRyb2wuc3RhdHVzfVxuICAgICAqXG4gICAgICovXG4gICAgZ2V0IGVuYWJsZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXR1cyAhPT0gRElTQUJMRUQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEEgY29udHJvbCBpcyBgZGlydHlgIGlmIHRoZSB1c2VyIGhhcyBjaGFuZ2VkIHRoZSB2YWx1ZVxuICAgICAqIGluIHRoZSBVSS5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRydWUgaWYgdGhlIHVzZXIgaGFzIGNoYW5nZWQgdGhlIHZhbHVlIG9mIHRoaXMgY29udHJvbCBpbiB0aGUgVUk7IGNvbXBhcmUgYHByaXN0aW5lYC5cbiAgICAgKiBQcm9ncmFtbWF0aWMgY2hhbmdlcyB0byBhIGNvbnRyb2wncyB2YWx1ZSBkbyBub3QgbWFyayBpdCBkaXJ0eS5cbiAgICAgKi9cbiAgICBnZXQgZGlydHkoKSB7XG4gICAgICAgIHJldHVybiAhdGhpcy5wcmlzdGluZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVHJ1ZSBpZiB0aGUgY29udHJvbCBoYXMgbm90IGJlZW4gbWFya2VkIGFzIHRvdWNoZWRcbiAgICAgKlxuICAgICAqIEEgY29udHJvbCBpcyBgdW50b3VjaGVkYCBpZiB0aGUgdXNlciBoYXMgbm90IHlldCB0cmlnZ2VyZWRcbiAgICAgKiBhIGBibHVyYCBldmVudCBvbiBpdC5cbiAgICAgKi9cbiAgICBnZXQgdW50b3VjaGVkKCkge1xuICAgICAgICByZXR1cm4gIXRoaXMudG91Y2hlZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVwb3J0cyB0aGUgdXBkYXRlIHN0cmF0ZWd5IG9mIHRoZSBgQWJzdHJhY3RDb250cm9sYCAobWVhbmluZ1xuICAgICAqIHRoZSBldmVudCBvbiB3aGljaCB0aGUgY29udHJvbCB1cGRhdGVzIGl0c2VsZikuXG4gICAgICogUG9zc2libGUgdmFsdWVzOiBgJ2NoYW5nZSdgIHwgYCdibHVyJ2AgfCBgJ3N1Ym1pdCdgXG4gICAgICogRGVmYXVsdCB2YWx1ZTogYCdjaGFuZ2UnYFxuICAgICAqL1xuICAgIGdldCB1cGRhdGVPbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3VwZGF0ZU9uID8gdGhpcy5fdXBkYXRlT24gOiAodGhpcy5wYXJlbnQgPyB0aGlzLnBhcmVudC51cGRhdGVPbiA6ICdjaGFuZ2UnKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgc3luY2hyb25vdXMgdmFsaWRhdG9ycyB0aGF0IGFyZSBhY3RpdmUgb24gdGhpcyBjb250cm9sLiAgQ2FsbGluZ1xuICAgICAqIHRoaXMgb3ZlcndyaXRlcyBhbnkgZXhpc3Rpbmcgc3luY2hyb25vdXMgdmFsaWRhdG9ycy5cbiAgICAgKlxuICAgICAqIFdoZW4geW91IGFkZCBvciByZW1vdmUgYSB2YWxpZGF0b3IgYXQgcnVuIHRpbWUsIHlvdSBtdXN0IGNhbGxcbiAgICAgKiBgdXBkYXRlVmFsdWVBbmRWYWxpZGl0eSgpYCBmb3IgdGhlIG5ldyB2YWxpZGF0aW9uIHRvIHRha2UgZWZmZWN0LlxuICAgICAqXG4gICAgICogSWYgeW91IHdhbnQgdG8gYWRkIGEgbmV3IHZhbGlkYXRvciB3aXRob3V0IGFmZmVjdGluZyBleGlzdGluZyBvbmVzLCBjb25zaWRlclxuICAgICAqIHVzaW5nIGBhZGRWYWxpZGF0b3JzKClgIG1ldGhvZCBpbnN0ZWFkLlxuICAgICAqL1xuICAgIHNldFZhbGlkYXRvcnModmFsaWRhdG9ycykge1xuICAgICAgICB0aGlzLl9hc3NpZ25WYWxpZGF0b3JzKHZhbGlkYXRvcnMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBhc3luY2hyb25vdXMgdmFsaWRhdG9ycyB0aGF0IGFyZSBhY3RpdmUgb24gdGhpcyBjb250cm9sLiBDYWxsaW5nIHRoaXNcbiAgICAgKiBvdmVyd3JpdGVzIGFueSBleGlzdGluZyBhc3luY2hyb25vdXMgdmFsaWRhdG9ycy5cbiAgICAgKlxuICAgICAqIFdoZW4geW91IGFkZCBvciByZW1vdmUgYSB2YWxpZGF0b3IgYXQgcnVuIHRpbWUsIHlvdSBtdXN0IGNhbGxcbiAgICAgKiBgdXBkYXRlVmFsdWVBbmRWYWxpZGl0eSgpYCBmb3IgdGhlIG5ldyB2YWxpZGF0aW9uIHRvIHRha2UgZWZmZWN0LlxuICAgICAqXG4gICAgICogSWYgeW91IHdhbnQgdG8gYWRkIGEgbmV3IHZhbGlkYXRvciB3aXRob3V0IGFmZmVjdGluZyBleGlzdGluZyBvbmVzLCBjb25zaWRlclxuICAgICAqIHVzaW5nIGBhZGRBc3luY1ZhbGlkYXRvcnMoKWAgbWV0aG9kIGluc3RlYWQuXG4gICAgICovXG4gICAgc2V0QXN5bmNWYWxpZGF0b3JzKHZhbGlkYXRvcnMpIHtcbiAgICAgICAgdGhpcy5fYXNzaWduQXN5bmNWYWxpZGF0b3JzKHZhbGlkYXRvcnMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGQgYSBzeW5jaHJvbm91cyB2YWxpZGF0b3Igb3IgdmFsaWRhdG9ycyB0byB0aGlzIGNvbnRyb2wsIHdpdGhvdXQgYWZmZWN0aW5nIG90aGVyIHZhbGlkYXRvcnMuXG4gICAgICpcbiAgICAgKiBXaGVuIHlvdSBhZGQgb3IgcmVtb3ZlIGEgdmFsaWRhdG9yIGF0IHJ1biB0aW1lLCB5b3UgbXVzdCBjYWxsXG4gICAgICogYHVwZGF0ZVZhbHVlQW5kVmFsaWRpdHkoKWAgZm9yIHRoZSBuZXcgdmFsaWRhdGlvbiB0byB0YWtlIGVmZmVjdC5cbiAgICAgKlxuICAgICAqIEFkZGluZyBhIHZhbGlkYXRvciB0aGF0IGFscmVhZHkgZXhpc3RzIHdpbGwgaGF2ZSBubyBlZmZlY3QuIElmIGR1cGxpY2F0ZSB2YWxpZGF0b3IgZnVuY3Rpb25zXG4gICAgICogYXJlIHByZXNlbnQgaW4gdGhlIGB2YWxpZGF0b3JzYCBhcnJheSwgb25seSB0aGUgZmlyc3QgaW5zdGFuY2Ugd291bGQgYmUgYWRkZWQgdG8gYSBmb3JtXG4gICAgICogY29udHJvbC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB2YWxpZGF0b3JzIFRoZSBuZXcgdmFsaWRhdG9yIGZ1bmN0aW9uIG9yIGZ1bmN0aW9ucyB0byBhZGQgdG8gdGhpcyBjb250cm9sLlxuICAgICAqL1xuICAgIGFkZFZhbGlkYXRvcnModmFsaWRhdG9ycykge1xuICAgICAgICB0aGlzLnNldFZhbGlkYXRvcnMoYWRkVmFsaWRhdG9ycyh2YWxpZGF0b3JzLCB0aGlzLl9yYXdWYWxpZGF0b3JzKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZCBhbiBhc3luY2hyb25vdXMgdmFsaWRhdG9yIG9yIHZhbGlkYXRvcnMgdG8gdGhpcyBjb250cm9sLCB3aXRob3V0IGFmZmVjdGluZyBvdGhlclxuICAgICAqIHZhbGlkYXRvcnMuXG4gICAgICpcbiAgICAgKiBXaGVuIHlvdSBhZGQgb3IgcmVtb3ZlIGEgdmFsaWRhdG9yIGF0IHJ1biB0aW1lLCB5b3UgbXVzdCBjYWxsXG4gICAgICogYHVwZGF0ZVZhbHVlQW5kVmFsaWRpdHkoKWAgZm9yIHRoZSBuZXcgdmFsaWRhdGlvbiB0byB0YWtlIGVmZmVjdC5cbiAgICAgKlxuICAgICAqIEFkZGluZyBhIHZhbGlkYXRvciB0aGF0IGFscmVhZHkgZXhpc3RzIHdpbGwgaGF2ZSBubyBlZmZlY3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdmFsaWRhdG9ycyBUaGUgbmV3IGFzeW5jaHJvbm91cyB2YWxpZGF0b3IgZnVuY3Rpb24gb3IgZnVuY3Rpb25zIHRvIGFkZCB0byB0aGlzIGNvbnRyb2wuXG4gICAgICovXG4gICAgYWRkQXN5bmNWYWxpZGF0b3JzKHZhbGlkYXRvcnMpIHtcbiAgICAgICAgdGhpcy5zZXRBc3luY1ZhbGlkYXRvcnMoYWRkVmFsaWRhdG9ycyh2YWxpZGF0b3JzLCB0aGlzLl9yYXdBc3luY1ZhbGlkYXRvcnMpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVtb3ZlIGEgc3luY2hyb25vdXMgdmFsaWRhdG9yIGZyb20gdGhpcyBjb250cm9sLCB3aXRob3V0IGFmZmVjdGluZyBvdGhlciB2YWxpZGF0b3JzLlxuICAgICAqIFZhbGlkYXRvcnMgYXJlIGNvbXBhcmVkIGJ5IGZ1bmN0aW9uIHJlZmVyZW5jZTsgeW91IG11c3QgcGFzcyBhIHJlZmVyZW5jZSB0byB0aGUgZXhhY3Qgc2FtZVxuICAgICAqIHZhbGlkYXRvciBmdW5jdGlvbiBhcyB0aGUgb25lIHRoYXQgd2FzIG9yaWdpbmFsbHkgc2V0LiBJZiBhIHByb3ZpZGVkIHZhbGlkYXRvciBpcyBub3QgZm91bmQsXG4gICAgICogaXQgaXMgaWdub3JlZC5cbiAgICAgKlxuICAgICAqIEB1c2FnZU5vdGVzXG4gICAgICpcbiAgICAgKiAjIyMgUmVmZXJlbmNlIHRvIGEgVmFsaWRhdG9yRm5cbiAgICAgKlxuICAgICAqIGBgYFxuICAgICAqIC8vIFJlZmVyZW5jZSB0byB0aGUgUmVxdWlyZWRWYWxpZGF0b3JcbiAgICAgKiBjb25zdCBjdHJsID0gbmV3IEZvcm1Db250cm9sPHN0cmluZyB8IG51bGw+KCcnLCBWYWxpZGF0b3JzLnJlcXVpcmVkKTtcbiAgICAgKiBjdHJsLnJlbW92ZVZhbGlkYXRvcnMoVmFsaWRhdG9ycy5yZXF1aXJlZCk7XG4gICAgICpcbiAgICAgKiAvLyBSZWZlcmVuY2UgdG8gYW5vbnltb3VzIGZ1bmN0aW9uIGluc2lkZSBNaW5WYWxpZGF0b3JcbiAgICAgKiBjb25zdCBtaW5WYWxpZGF0b3IgPSBWYWxpZGF0b3JzLm1pbigzKTtcbiAgICAgKiBjb25zdCBjdHJsID0gbmV3IEZvcm1Db250cm9sPHN0cmluZyB8IG51bGw+KCcnLCBtaW5WYWxpZGF0b3IpO1xuICAgICAqIGV4cGVjdChjdHJsLmhhc1ZhbGlkYXRvcihtaW5WYWxpZGF0b3IpKS50b0VxdWFsKHRydWUpXG4gICAgICogZXhwZWN0KGN0cmwuaGFzVmFsaWRhdG9yKFZhbGlkYXRvcnMubWluKDMpKSkudG9FcXVhbChmYWxzZSlcbiAgICAgKlxuICAgICAqIGN0cmwucmVtb3ZlVmFsaWRhdG9ycyhtaW5WYWxpZGF0b3IpO1xuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogV2hlbiB5b3UgYWRkIG9yIHJlbW92ZSBhIHZhbGlkYXRvciBhdCBydW4gdGltZSwgeW91IG11c3QgY2FsbFxuICAgICAqIGB1cGRhdGVWYWx1ZUFuZFZhbGlkaXR5KClgIGZvciB0aGUgbmV3IHZhbGlkYXRpb24gdG8gdGFrZSBlZmZlY3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdmFsaWRhdG9ycyBUaGUgdmFsaWRhdG9yIG9yIHZhbGlkYXRvcnMgdG8gcmVtb3ZlLlxuICAgICAqL1xuICAgIHJlbW92ZVZhbGlkYXRvcnModmFsaWRhdG9ycykge1xuICAgICAgICB0aGlzLnNldFZhbGlkYXRvcnMocmVtb3ZlVmFsaWRhdG9ycyh2YWxpZGF0b3JzLCB0aGlzLl9yYXdWYWxpZGF0b3JzKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbW92ZSBhbiBhc3luY2hyb25vdXMgdmFsaWRhdG9yIGZyb20gdGhpcyBjb250cm9sLCB3aXRob3V0IGFmZmVjdGluZyBvdGhlciB2YWxpZGF0b3JzLlxuICAgICAqIFZhbGlkYXRvcnMgYXJlIGNvbXBhcmVkIGJ5IGZ1bmN0aW9uIHJlZmVyZW5jZTsgeW91IG11c3QgcGFzcyBhIHJlZmVyZW5jZSB0byB0aGUgZXhhY3Qgc2FtZVxuICAgICAqIHZhbGlkYXRvciBmdW5jdGlvbiBhcyB0aGUgb25lIHRoYXQgd2FzIG9yaWdpbmFsbHkgc2V0LiBJZiBhIHByb3ZpZGVkIHZhbGlkYXRvciBpcyBub3QgZm91bmQsIGl0XG4gICAgICogaXMgaWdub3JlZC5cbiAgICAgKlxuICAgICAqIFdoZW4geW91IGFkZCBvciByZW1vdmUgYSB2YWxpZGF0b3IgYXQgcnVuIHRpbWUsIHlvdSBtdXN0IGNhbGxcbiAgICAgKiBgdXBkYXRlVmFsdWVBbmRWYWxpZGl0eSgpYCBmb3IgdGhlIG5ldyB2YWxpZGF0aW9uIHRvIHRha2UgZWZmZWN0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHZhbGlkYXRvcnMgVGhlIGFzeW5jaHJvbm91cyB2YWxpZGF0b3Igb3IgdmFsaWRhdG9ycyB0byByZW1vdmUuXG4gICAgICovXG4gICAgcmVtb3ZlQXN5bmNWYWxpZGF0b3JzKHZhbGlkYXRvcnMpIHtcbiAgICAgICAgdGhpcy5zZXRBc3luY1ZhbGlkYXRvcnMocmVtb3ZlVmFsaWRhdG9ycyh2YWxpZGF0b3JzLCB0aGlzLl9yYXdBc3luY1ZhbGlkYXRvcnMpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hlY2sgd2hldGhlciBhIHN5bmNocm9ub3VzIHZhbGlkYXRvciBmdW5jdGlvbiBpcyBwcmVzZW50IG9uIHRoaXMgY29udHJvbC4gVGhlIHByb3ZpZGVkXG4gICAgICogdmFsaWRhdG9yIG11c3QgYmUgYSByZWZlcmVuY2UgdG8gdGhlIGV4YWN0IHNhbWUgZnVuY3Rpb24gdGhhdCB3YXMgcHJvdmlkZWQuXG4gICAgICpcbiAgICAgKiBAdXNhZ2VOb3Rlc1xuICAgICAqXG4gICAgICogIyMjIFJlZmVyZW5jZSB0byBhIFZhbGlkYXRvckZuXG4gICAgICpcbiAgICAgKiBgYGBcbiAgICAgKiAvLyBSZWZlcmVuY2UgdG8gdGhlIFJlcXVpcmVkVmFsaWRhdG9yXG4gICAgICogY29uc3QgY3RybCA9IG5ldyBGb3JtQ29udHJvbDxudW1iZXIgfCBudWxsPigwLCBWYWxpZGF0b3JzLnJlcXVpcmVkKTtcbiAgICAgKiBleHBlY3QoY3RybC5oYXNWYWxpZGF0b3IoVmFsaWRhdG9ycy5yZXF1aXJlZCkpLnRvRXF1YWwodHJ1ZSlcbiAgICAgKlxuICAgICAqIC8vIFJlZmVyZW5jZSB0byBhbm9ueW1vdXMgZnVuY3Rpb24gaW5zaWRlIE1pblZhbGlkYXRvclxuICAgICAqIGNvbnN0IG1pblZhbGlkYXRvciA9IFZhbGlkYXRvcnMubWluKDMpO1xuICAgICAqIGNvbnN0IGN0cmwgPSBuZXcgRm9ybUNvbnRyb2w8bnVtYmVyIHwgbnVsbD4oMCwgbWluVmFsaWRhdG9yKTtcbiAgICAgKiBleHBlY3QoY3RybC5oYXNWYWxpZGF0b3IobWluVmFsaWRhdG9yKSkudG9FcXVhbCh0cnVlKVxuICAgICAqIGV4cGVjdChjdHJsLmhhc1ZhbGlkYXRvcihWYWxpZGF0b3JzLm1pbigzKSkpLnRvRXF1YWwoZmFsc2UpXG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdmFsaWRhdG9yIFRoZSB2YWxpZGF0b3IgdG8gY2hlY2sgZm9yIHByZXNlbmNlLiBDb21wYXJlZCBieSBmdW5jdGlvbiByZWZlcmVuY2UuXG4gICAgICogQHJldHVybnMgV2hldGhlciB0aGUgcHJvdmlkZWQgdmFsaWRhdG9yIHdhcyBmb3VuZCBvbiB0aGlzIGNvbnRyb2wuXG4gICAgICovXG4gICAgaGFzVmFsaWRhdG9yKHZhbGlkYXRvcikge1xuICAgICAgICByZXR1cm4gaGFzVmFsaWRhdG9yKHRoaXMuX3Jhd1ZhbGlkYXRvcnMsIHZhbGlkYXRvcik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoZWNrIHdoZXRoZXIgYW4gYXN5bmNocm9ub3VzIHZhbGlkYXRvciBmdW5jdGlvbiBpcyBwcmVzZW50IG9uIHRoaXMgY29udHJvbC4gVGhlIHByb3ZpZGVkXG4gICAgICogdmFsaWRhdG9yIG11c3QgYmUgYSByZWZlcmVuY2UgdG8gdGhlIGV4YWN0IHNhbWUgZnVuY3Rpb24gdGhhdCB3YXMgcHJvdmlkZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdmFsaWRhdG9yIFRoZSBhc3luY2hyb25vdXMgdmFsaWRhdG9yIHRvIGNoZWNrIGZvciBwcmVzZW5jZS4gQ29tcGFyZWQgYnkgZnVuY3Rpb25cbiAgICAgKiAgICAgcmVmZXJlbmNlLlxuICAgICAqIEByZXR1cm5zIFdoZXRoZXIgdGhlIHByb3ZpZGVkIGFzeW5jaHJvbm91cyB2YWxpZGF0b3Igd2FzIGZvdW5kIG9uIHRoaXMgY29udHJvbC5cbiAgICAgKi9cbiAgICBoYXNBc3luY1ZhbGlkYXRvcih2YWxpZGF0b3IpIHtcbiAgICAgICAgcmV0dXJuIGhhc1ZhbGlkYXRvcih0aGlzLl9yYXdBc3luY1ZhbGlkYXRvcnMsIHZhbGlkYXRvcik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVtcHRpZXMgb3V0IHRoZSBzeW5jaHJvbm91cyB2YWxpZGF0b3IgbGlzdC5cbiAgICAgKlxuICAgICAqIFdoZW4geW91IGFkZCBvciByZW1vdmUgYSB2YWxpZGF0b3IgYXQgcnVuIHRpbWUsIHlvdSBtdXN0IGNhbGxcbiAgICAgKiBgdXBkYXRlVmFsdWVBbmRWYWxpZGl0eSgpYCBmb3IgdGhlIG5ldyB2YWxpZGF0aW9uIHRvIHRha2UgZWZmZWN0LlxuICAgICAqXG4gICAgICovXG4gICAgY2xlYXJWYWxpZGF0b3JzKCkge1xuICAgICAgICB0aGlzLnZhbGlkYXRvciA9IG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVtcHRpZXMgb3V0IHRoZSBhc3luYyB2YWxpZGF0b3IgbGlzdC5cbiAgICAgKlxuICAgICAqIFdoZW4geW91IGFkZCBvciByZW1vdmUgYSB2YWxpZGF0b3IgYXQgcnVuIHRpbWUsIHlvdSBtdXN0IGNhbGxcbiAgICAgKiBgdXBkYXRlVmFsdWVBbmRWYWxpZGl0eSgpYCBmb3IgdGhlIG5ldyB2YWxpZGF0aW9uIHRvIHRha2UgZWZmZWN0LlxuICAgICAqXG4gICAgICovXG4gICAgY2xlYXJBc3luY1ZhbGlkYXRvcnMoKSB7XG4gICAgICAgIHRoaXMuYXN5bmNWYWxpZGF0b3IgPSBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNYXJrcyB0aGUgY29udHJvbCBhcyBgdG91Y2hlZGAuIEEgY29udHJvbCBpcyB0b3VjaGVkIGJ5IGZvY3VzIGFuZFxuICAgICAqIGJsdXIgZXZlbnRzIHRoYXQgZG8gbm90IGNoYW5nZSB0aGUgdmFsdWUuXG4gICAgICpcbiAgICAgKiBAc2VlIHtAbGluayBtYXJrQXNVbnRvdWNoZWQoKX1cbiAgICAgKiBAc2VlIHtAbGluayBtYXJrQXNEaXJ0eSgpfVxuICAgICAqIEBzZWUge0BsaW5rIG1hcmtBc1ByaXN0aW5lKCl9XG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3B0cyBDb25maWd1cmF0aW9uIG9wdGlvbnMgdGhhdCBkZXRlcm1pbmUgaG93IHRoZSBjb250cm9sIHByb3BhZ2F0ZXMgY2hhbmdlc1xuICAgICAqIGFuZCBlbWl0cyBldmVudHMgYWZ0ZXIgbWFya2luZyBpcyBhcHBsaWVkLlxuICAgICAqICogYG9ubHlTZWxmYDogV2hlbiB0cnVlLCBtYXJrIG9ubHkgdGhpcyBjb250cm9sLiBXaGVuIGZhbHNlIG9yIG5vdCBzdXBwbGllZCxcbiAgICAgKiBtYXJrcyBhbGwgZGlyZWN0IGFuY2VzdG9ycy4gRGVmYXVsdCBpcyBmYWxzZS5cbiAgICAgKi9cbiAgICBtYXJrQXNUb3VjaGVkKG9wdHMgPSB7fSkge1xuICAgICAgICB0aGlzLnRvdWNoZWQgPSB0cnVlO1xuICAgICAgICBpZiAodGhpcy5fcGFyZW50ICYmICFvcHRzLm9ubHlTZWxmKSB7XG4gICAgICAgICAgICB0aGlzLl9wYXJlbnQubWFya0FzVG91Y2hlZChvcHRzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBNYXJrcyB0aGUgY29udHJvbCBhbmQgYWxsIGl0cyBkZXNjZW5kYW50IGNvbnRyb2xzIGFzIGB0b3VjaGVkYC5cbiAgICAgKiBAc2VlIHtAbGluayBtYXJrQXNUb3VjaGVkKCl9XG4gICAgICovXG4gICAgbWFya0FsbEFzVG91Y2hlZCgpIHtcbiAgICAgICAgdGhpcy5tYXJrQXNUb3VjaGVkKHsgb25seVNlbGY6IHRydWUgfSk7XG4gICAgICAgIHRoaXMuX2ZvckVhY2hDaGlsZCgoY29udHJvbCkgPT4gY29udHJvbC5tYXJrQWxsQXNUb3VjaGVkKCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNYXJrcyB0aGUgY29udHJvbCBhcyBgdW50b3VjaGVkYC5cbiAgICAgKlxuICAgICAqIElmIHRoZSBjb250cm9sIGhhcyBhbnkgY2hpbGRyZW4sIGFsc28gbWFya3MgYWxsIGNoaWxkcmVuIGFzIGB1bnRvdWNoZWRgXG4gICAgICogYW5kIHJlY2FsY3VsYXRlcyB0aGUgYHRvdWNoZWRgIHN0YXR1cyBvZiBhbGwgcGFyZW50IGNvbnRyb2xzLlxuICAgICAqXG4gICAgICogQHNlZSB7QGxpbmsgbWFya0FzVG91Y2hlZCgpfVxuICAgICAqIEBzZWUge0BsaW5rIG1hcmtBc0RpcnR5KCl9XG4gICAgICogQHNlZSB7QGxpbmsgbWFya0FzUHJpc3RpbmUoKX1cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRzIENvbmZpZ3VyYXRpb24gb3B0aW9ucyB0aGF0IGRldGVybWluZSBob3cgdGhlIGNvbnRyb2wgcHJvcGFnYXRlcyBjaGFuZ2VzXG4gICAgICogYW5kIGVtaXRzIGV2ZW50cyBhZnRlciB0aGUgbWFya2luZyBpcyBhcHBsaWVkLlxuICAgICAqICogYG9ubHlTZWxmYDogV2hlbiB0cnVlLCBtYXJrIG9ubHkgdGhpcyBjb250cm9sLiBXaGVuIGZhbHNlIG9yIG5vdCBzdXBwbGllZCxcbiAgICAgKiBtYXJrcyBhbGwgZGlyZWN0IGFuY2VzdG9ycy4gRGVmYXVsdCBpcyBmYWxzZS5cbiAgICAgKi9cbiAgICBtYXJrQXNVbnRvdWNoZWQob3B0cyA9IHt9KSB7XG4gICAgICAgIHRoaXMudG91Y2hlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9wZW5kaW5nVG91Y2hlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9mb3JFYWNoQ2hpbGQoKGNvbnRyb2wpID0+IHtcbiAgICAgICAgICAgIGNvbnRyb2wubWFya0FzVW50b3VjaGVkKHsgb25seVNlbGY6IHRydWUgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAodGhpcy5fcGFyZW50ICYmICFvcHRzLm9ubHlTZWxmKSB7XG4gICAgICAgICAgICB0aGlzLl9wYXJlbnQuX3VwZGF0ZVRvdWNoZWQob3B0cyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogTWFya3MgdGhlIGNvbnRyb2wgYXMgYGRpcnR5YC4gQSBjb250cm9sIGJlY29tZXMgZGlydHkgd2hlblxuICAgICAqIHRoZSBjb250cm9sJ3MgdmFsdWUgaXMgY2hhbmdlZCB0aHJvdWdoIHRoZSBVSTsgY29tcGFyZSBgbWFya0FzVG91Y2hlZGAuXG4gICAgICpcbiAgICAgKiBAc2VlIHtAbGluayBtYXJrQXNUb3VjaGVkKCl9XG4gICAgICogQHNlZSB7QGxpbmsgbWFya0FzVW50b3VjaGVkKCl9XG4gICAgICogQHNlZSB7QGxpbmsgbWFya0FzUHJpc3RpbmUoKX1cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRzIENvbmZpZ3VyYXRpb24gb3B0aW9ucyB0aGF0IGRldGVybWluZSBob3cgdGhlIGNvbnRyb2wgcHJvcGFnYXRlcyBjaGFuZ2VzXG4gICAgICogYW5kIGVtaXRzIGV2ZW50cyBhZnRlciBtYXJraW5nIGlzIGFwcGxpZWQuXG4gICAgICogKiBgb25seVNlbGZgOiBXaGVuIHRydWUsIG1hcmsgb25seSB0aGlzIGNvbnRyb2wuIFdoZW4gZmFsc2Ugb3Igbm90IHN1cHBsaWVkLFxuICAgICAqIG1hcmtzIGFsbCBkaXJlY3QgYW5jZXN0b3JzLiBEZWZhdWx0IGlzIGZhbHNlLlxuICAgICAqL1xuICAgIG1hcmtBc0RpcnR5KG9wdHMgPSB7fSkge1xuICAgICAgICB0aGlzLnByaXN0aW5lID0gZmFsc2U7XG4gICAgICAgIGlmICh0aGlzLl9wYXJlbnQgJiYgIW9wdHMub25seVNlbGYpIHtcbiAgICAgICAgICAgIHRoaXMuX3BhcmVudC5tYXJrQXNEaXJ0eShvcHRzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBNYXJrcyB0aGUgY29udHJvbCBhcyBgcHJpc3RpbmVgLlxuICAgICAqXG4gICAgICogSWYgdGhlIGNvbnRyb2wgaGFzIGFueSBjaGlsZHJlbiwgbWFya3MgYWxsIGNoaWxkcmVuIGFzIGBwcmlzdGluZWAsXG4gICAgICogYW5kIHJlY2FsY3VsYXRlcyB0aGUgYHByaXN0aW5lYCBzdGF0dXMgb2YgYWxsIHBhcmVudFxuICAgICAqIGNvbnRyb2xzLlxuICAgICAqXG4gICAgICogQHNlZSB7QGxpbmsgbWFya0FzVG91Y2hlZCgpfVxuICAgICAqIEBzZWUge0BsaW5rIG1hcmtBc1VudG91Y2hlZCgpfVxuICAgICAqIEBzZWUge0BsaW5rIG1hcmtBc0RpcnR5KCl9XG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3B0cyBDb25maWd1cmF0aW9uIG9wdGlvbnMgdGhhdCBkZXRlcm1pbmUgaG93IHRoZSBjb250cm9sIGVtaXRzIGV2ZW50cyBhZnRlclxuICAgICAqIG1hcmtpbmcgaXMgYXBwbGllZC5cbiAgICAgKiAqIGBvbmx5U2VsZmA6IFdoZW4gdHJ1ZSwgbWFyayBvbmx5IHRoaXMgY29udHJvbC4gV2hlbiBmYWxzZSBvciBub3Qgc3VwcGxpZWQsXG4gICAgICogbWFya3MgYWxsIGRpcmVjdCBhbmNlc3RvcnMuIERlZmF1bHQgaXMgZmFsc2UuXG4gICAgICovXG4gICAgbWFya0FzUHJpc3RpbmUob3B0cyA9IHt9KSB7XG4gICAgICAgIHRoaXMucHJpc3RpbmUgPSB0cnVlO1xuICAgICAgICB0aGlzLl9wZW5kaW5nRGlydHkgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fZm9yRWFjaENoaWxkKChjb250cm9sKSA9PiB7XG4gICAgICAgICAgICBjb250cm9sLm1hcmtBc1ByaXN0aW5lKHsgb25seVNlbGY6IHRydWUgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAodGhpcy5fcGFyZW50ICYmICFvcHRzLm9ubHlTZWxmKSB7XG4gICAgICAgICAgICB0aGlzLl9wYXJlbnQuX3VwZGF0ZVByaXN0aW5lKG9wdHMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1hcmtzIHRoZSBjb250cm9sIGFzIGBwZW5kaW5nYC5cbiAgICAgKlxuICAgICAqIEEgY29udHJvbCBpcyBwZW5kaW5nIHdoaWxlIHRoZSBjb250cm9sIHBlcmZvcm1zIGFzeW5jIHZhbGlkYXRpb24uXG4gICAgICpcbiAgICAgKiBAc2VlIHtAbGluayBBYnN0cmFjdENvbnRyb2wuc3RhdHVzfVxuICAgICAqXG4gICAgICogQHBhcmFtIG9wdHMgQ29uZmlndXJhdGlvbiBvcHRpb25zIHRoYXQgZGV0ZXJtaW5lIGhvdyB0aGUgY29udHJvbCBwcm9wYWdhdGVzIGNoYW5nZXMgYW5kXG4gICAgICogZW1pdHMgZXZlbnRzIGFmdGVyIG1hcmtpbmcgaXMgYXBwbGllZC5cbiAgICAgKiAqIGBvbmx5U2VsZmA6IFdoZW4gdHJ1ZSwgbWFyayBvbmx5IHRoaXMgY29udHJvbC4gV2hlbiBmYWxzZSBvciBub3Qgc3VwcGxpZWQsXG4gICAgICogbWFya3MgYWxsIGRpcmVjdCBhbmNlc3RvcnMuIERlZmF1bHQgaXMgZmFsc2UuXG4gICAgICogKiBgZW1pdEV2ZW50YDogV2hlbiB0cnVlIG9yIG5vdCBzdXBwbGllZCAodGhlIGRlZmF1bHQpLCB0aGUgYHN0YXR1c0NoYW5nZXNgXG4gICAgICogb2JzZXJ2YWJsZSBlbWl0cyBhbiBldmVudCB3aXRoIHRoZSBsYXRlc3Qgc3RhdHVzIHRoZSBjb250cm9sIGlzIG1hcmtlZCBwZW5kaW5nLlxuICAgICAqIFdoZW4gZmFsc2UsIG5vIGV2ZW50cyBhcmUgZW1pdHRlZC5cbiAgICAgKlxuICAgICAqL1xuICAgIG1hcmtBc1BlbmRpbmcob3B0cyA9IHt9KSB7XG4gICAgICAgIHRoaXMuc3RhdHVzID0gUEVORElORztcbiAgICAgICAgaWYgKG9wdHMuZW1pdEV2ZW50ICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgdGhpcy5zdGF0dXNDaGFuZ2VzLmVtaXQodGhpcy5zdGF0dXMpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9wYXJlbnQgJiYgIW9wdHMub25seVNlbGYpIHtcbiAgICAgICAgICAgIHRoaXMuX3BhcmVudC5tYXJrQXNQZW5kaW5nKG9wdHMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERpc2FibGVzIHRoZSBjb250cm9sLiBUaGlzIG1lYW5zIHRoZSBjb250cm9sIGlzIGV4ZW1wdCBmcm9tIHZhbGlkYXRpb24gY2hlY2tzIGFuZFxuICAgICAqIGV4Y2x1ZGVkIGZyb20gdGhlIGFnZ3JlZ2F0ZSB2YWx1ZSBvZiBhbnkgcGFyZW50LiBJdHMgc3RhdHVzIGlzIGBESVNBQkxFRGAuXG4gICAgICpcbiAgICAgKiBJZiB0aGUgY29udHJvbCBoYXMgY2hpbGRyZW4sIGFsbCBjaGlsZHJlbiBhcmUgYWxzbyBkaXNhYmxlZC5cbiAgICAgKlxuICAgICAqIEBzZWUge0BsaW5rIEFic3RyYWN0Q29udHJvbC5zdGF0dXN9XG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3B0cyBDb25maWd1cmF0aW9uIG9wdGlvbnMgdGhhdCBkZXRlcm1pbmUgaG93IHRoZSBjb250cm9sIHByb3BhZ2F0ZXNcbiAgICAgKiBjaGFuZ2VzIGFuZCBlbWl0cyBldmVudHMgYWZ0ZXIgdGhlIGNvbnRyb2wgaXMgZGlzYWJsZWQuXG4gICAgICogKiBgb25seVNlbGZgOiBXaGVuIHRydWUsIG1hcmsgb25seSB0aGlzIGNvbnRyb2wuIFdoZW4gZmFsc2Ugb3Igbm90IHN1cHBsaWVkLFxuICAgICAqIG1hcmtzIGFsbCBkaXJlY3QgYW5jZXN0b3JzLiBEZWZhdWx0IGlzIGZhbHNlLlxuICAgICAqICogYGVtaXRFdmVudGA6IFdoZW4gdHJ1ZSBvciBub3Qgc3VwcGxpZWQgKHRoZSBkZWZhdWx0KSwgYm90aCB0aGUgYHN0YXR1c0NoYW5nZXNgIGFuZFxuICAgICAqIGB2YWx1ZUNoYW5nZXNgXG4gICAgICogb2JzZXJ2YWJsZXMgZW1pdCBldmVudHMgd2l0aCB0aGUgbGF0ZXN0IHN0YXR1cyBhbmQgdmFsdWUgd2hlbiB0aGUgY29udHJvbCBpcyBkaXNhYmxlZC5cbiAgICAgKiBXaGVuIGZhbHNlLCBubyBldmVudHMgYXJlIGVtaXR0ZWQuXG4gICAgICovXG4gICAgZGlzYWJsZShvcHRzID0ge30pIHtcbiAgICAgICAgLy8gSWYgcGFyZW50IGhhcyBiZWVuIG1hcmtlZCBhcnRpZmljaWFsbHkgZGlydHkgd2UgZG9uJ3Qgd2FudCB0byByZS1jYWxjdWxhdGUgdGhlXG4gICAgICAgIC8vIHBhcmVudCdzIGRpcnRpbmVzcyBiYXNlZCBvbiB0aGUgY2hpbGRyZW4uXG4gICAgICAgIGNvbnN0IHNraXBQcmlzdGluZUNoZWNrID0gdGhpcy5fcGFyZW50TWFya2VkRGlydHkob3B0cy5vbmx5U2VsZik7XG4gICAgICAgIHRoaXMuc3RhdHVzID0gRElTQUJMRUQ7XG4gICAgICAgIHRoaXMuZXJyb3JzID0gbnVsbDtcbiAgICAgICAgdGhpcy5fZm9yRWFjaENoaWxkKChjb250cm9sKSA9PiB7XG4gICAgICAgICAgICBjb250cm9sLmRpc2FibGUoeyAuLi5vcHRzLCBvbmx5U2VsZjogdHJ1ZSB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX3VwZGF0ZVZhbHVlKCk7XG4gICAgICAgIGlmIChvcHRzLmVtaXRFdmVudCAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHRoaXMudmFsdWVDaGFuZ2VzLmVtaXQodGhpcy52YWx1ZSk7XG4gICAgICAgICAgICB0aGlzLnN0YXR1c0NoYW5nZXMuZW1pdCh0aGlzLnN0YXR1cyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fdXBkYXRlQW5jZXN0b3JzKHsgLi4ub3B0cywgc2tpcFByaXN0aW5lQ2hlY2sgfSk7XG4gICAgICAgIHRoaXMuX29uRGlzYWJsZWRDaGFuZ2UuZm9yRWFjaCgoY2hhbmdlRm4pID0+IGNoYW5nZUZuKHRydWUpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRW5hYmxlcyB0aGUgY29udHJvbC4gVGhpcyBtZWFucyB0aGUgY29udHJvbCBpcyBpbmNsdWRlZCBpbiB2YWxpZGF0aW9uIGNoZWNrcyBhbmRcbiAgICAgKiB0aGUgYWdncmVnYXRlIHZhbHVlIG9mIGl0cyBwYXJlbnQuIEl0cyBzdGF0dXMgcmVjYWxjdWxhdGVzIGJhc2VkIG9uIGl0cyB2YWx1ZSBhbmRcbiAgICAgKiBpdHMgdmFsaWRhdG9ycy5cbiAgICAgKlxuICAgICAqIEJ5IGRlZmF1bHQsIGlmIHRoZSBjb250cm9sIGhhcyBjaGlsZHJlbiwgYWxsIGNoaWxkcmVuIGFyZSBlbmFibGVkLlxuICAgICAqXG4gICAgICogQHNlZSB7QGxpbmsgQWJzdHJhY3RDb250cm9sLnN0YXR1c31cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRzIENvbmZpZ3VyZSBvcHRpb25zIHRoYXQgY29udHJvbCBob3cgdGhlIGNvbnRyb2wgcHJvcGFnYXRlcyBjaGFuZ2VzIGFuZFxuICAgICAqIGVtaXRzIGV2ZW50cyB3aGVuIG1hcmtlZCBhcyB1bnRvdWNoZWRcbiAgICAgKiAqIGBvbmx5U2VsZmA6IFdoZW4gdHJ1ZSwgbWFyayBvbmx5IHRoaXMgY29udHJvbC4gV2hlbiBmYWxzZSBvciBub3Qgc3VwcGxpZWQsXG4gICAgICogbWFya3MgYWxsIGRpcmVjdCBhbmNlc3RvcnMuIERlZmF1bHQgaXMgZmFsc2UuXG4gICAgICogKiBgZW1pdEV2ZW50YDogV2hlbiB0cnVlIG9yIG5vdCBzdXBwbGllZCAodGhlIGRlZmF1bHQpLCBib3RoIHRoZSBgc3RhdHVzQ2hhbmdlc2AgYW5kXG4gICAgICogYHZhbHVlQ2hhbmdlc2BcbiAgICAgKiBvYnNlcnZhYmxlcyBlbWl0IGV2ZW50cyB3aXRoIHRoZSBsYXRlc3Qgc3RhdHVzIGFuZCB2YWx1ZSB3aGVuIHRoZSBjb250cm9sIGlzIGVuYWJsZWQuXG4gICAgICogV2hlbiBmYWxzZSwgbm8gZXZlbnRzIGFyZSBlbWl0dGVkLlxuICAgICAqL1xuICAgIGVuYWJsZShvcHRzID0ge30pIHtcbiAgICAgICAgLy8gSWYgcGFyZW50IGhhcyBiZWVuIG1hcmtlZCBhcnRpZmljaWFsbHkgZGlydHkgd2UgZG9uJ3Qgd2FudCB0byByZS1jYWxjdWxhdGUgdGhlXG4gICAgICAgIC8vIHBhcmVudCdzIGRpcnRpbmVzcyBiYXNlZCBvbiB0aGUgY2hpbGRyZW4uXG4gICAgICAgIGNvbnN0IHNraXBQcmlzdGluZUNoZWNrID0gdGhpcy5fcGFyZW50TWFya2VkRGlydHkob3B0cy5vbmx5U2VsZik7XG4gICAgICAgIHRoaXMuc3RhdHVzID0gVkFMSUQ7XG4gICAgICAgIHRoaXMuX2ZvckVhY2hDaGlsZCgoY29udHJvbCkgPT4ge1xuICAgICAgICAgICAgY29udHJvbC5lbmFibGUoeyAuLi5vcHRzLCBvbmx5U2VsZjogdHJ1ZSB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMudXBkYXRlVmFsdWVBbmRWYWxpZGl0eSh7IG9ubHlTZWxmOiB0cnVlLCBlbWl0RXZlbnQ6IG9wdHMuZW1pdEV2ZW50IH0pO1xuICAgICAgICB0aGlzLl91cGRhdGVBbmNlc3RvcnMoeyAuLi5vcHRzLCBza2lwUHJpc3RpbmVDaGVjayB9KTtcbiAgICAgICAgdGhpcy5fb25EaXNhYmxlZENoYW5nZS5mb3JFYWNoKChjaGFuZ2VGbikgPT4gY2hhbmdlRm4oZmFsc2UpKTtcbiAgICB9XG4gICAgX3VwZGF0ZUFuY2VzdG9ycyhvcHRzKSB7XG4gICAgICAgIGlmICh0aGlzLl9wYXJlbnQgJiYgIW9wdHMub25seVNlbGYpIHtcbiAgICAgICAgICAgIHRoaXMuX3BhcmVudC51cGRhdGVWYWx1ZUFuZFZhbGlkaXR5KG9wdHMpO1xuICAgICAgICAgICAgaWYgKCFvcHRzLnNraXBQcmlzdGluZUNoZWNrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcGFyZW50Ll91cGRhdGVQcmlzdGluZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fcGFyZW50Ll91cGRhdGVUb3VjaGVkKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgcGFyZW50IG9mIHRoZSBjb250cm9sXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcGFyZW50IFRoZSBuZXcgcGFyZW50LlxuICAgICAqL1xuICAgIHNldFBhcmVudChwYXJlbnQpIHtcbiAgICAgICAgdGhpcy5fcGFyZW50ID0gcGFyZW50O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgcmF3IHZhbHVlIG9mIHRoaXMgY29udHJvbC4gRm9yIG1vc3QgY29udHJvbCBpbXBsZW1lbnRhdGlvbnMsIHRoZSByYXcgdmFsdWUgd2lsbCBpbmNsdWRlXG4gICAgICogZGlzYWJsZWQgY2hpbGRyZW4uXG4gICAgICovXG4gICAgZ2V0UmF3VmFsdWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZhbHVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWNhbGN1bGF0ZXMgdGhlIHZhbHVlIGFuZCB2YWxpZGF0aW9uIHN0YXR1cyBvZiB0aGUgY29udHJvbC5cbiAgICAgKlxuICAgICAqIEJ5IGRlZmF1bHQsIGl0IGFsc28gdXBkYXRlcyB0aGUgdmFsdWUgYW5kIHZhbGlkaXR5IG9mIGl0cyBhbmNlc3RvcnMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3B0cyBDb25maWd1cmF0aW9uIG9wdGlvbnMgZGV0ZXJtaW5lIGhvdyB0aGUgY29udHJvbCBwcm9wYWdhdGVzIGNoYW5nZXMgYW5kIGVtaXRzIGV2ZW50c1xuICAgICAqIGFmdGVyIHVwZGF0ZXMgYW5kIHZhbGlkaXR5IGNoZWNrcyBhcmUgYXBwbGllZC5cbiAgICAgKiAqIGBvbmx5U2VsZmA6IFdoZW4gdHJ1ZSwgb25seSB1cGRhdGUgdGhpcyBjb250cm9sLiBXaGVuIGZhbHNlIG9yIG5vdCBzdXBwbGllZCxcbiAgICAgKiB1cGRhdGUgYWxsIGRpcmVjdCBhbmNlc3RvcnMuIERlZmF1bHQgaXMgZmFsc2UuXG4gICAgICogKiBgZW1pdEV2ZW50YDogV2hlbiB0cnVlIG9yIG5vdCBzdXBwbGllZCAodGhlIGRlZmF1bHQpLCBib3RoIHRoZSBgc3RhdHVzQ2hhbmdlc2AgYW5kXG4gICAgICogYHZhbHVlQ2hhbmdlc2BcbiAgICAgKiBvYnNlcnZhYmxlcyBlbWl0IGV2ZW50cyB3aXRoIHRoZSBsYXRlc3Qgc3RhdHVzIGFuZCB2YWx1ZSB3aGVuIHRoZSBjb250cm9sIGlzIHVwZGF0ZWQuXG4gICAgICogV2hlbiBmYWxzZSwgbm8gZXZlbnRzIGFyZSBlbWl0dGVkLlxuICAgICAqL1xuICAgIHVwZGF0ZVZhbHVlQW5kVmFsaWRpdHkob3B0cyA9IHt9KSB7XG4gICAgICAgIHRoaXMuX3NldEluaXRpYWxTdGF0dXMoKTtcbiAgICAgICAgdGhpcy5fdXBkYXRlVmFsdWUoKTtcbiAgICAgICAgaWYgKHRoaXMuZW5hYmxlZCkge1xuICAgICAgICAgICAgdGhpcy5fY2FuY2VsRXhpc3RpbmdTdWJzY3JpcHRpb24oKTtcbiAgICAgICAgICAgIHRoaXMuZXJyb3JzID0gdGhpcy5fcnVuVmFsaWRhdG9yKCk7XG4gICAgICAgICAgICB0aGlzLnN0YXR1cyA9IHRoaXMuX2NhbGN1bGF0ZVN0YXR1cygpO1xuICAgICAgICAgICAgaWYgKHRoaXMuc3RhdHVzID09PSBWQUxJRCB8fCB0aGlzLnN0YXR1cyA9PT0gUEVORElORykge1xuICAgICAgICAgICAgICAgIHRoaXMuX3J1bkFzeW5jVmFsaWRhdG9yKG9wdHMuZW1pdEV2ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0cy5lbWl0RXZlbnQgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICB0aGlzLnZhbHVlQ2hhbmdlcy5lbWl0KHRoaXMudmFsdWUpO1xuICAgICAgICAgICAgdGhpcy5zdGF0dXNDaGFuZ2VzLmVtaXQodGhpcy5zdGF0dXMpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9wYXJlbnQgJiYgIW9wdHMub25seVNlbGYpIHtcbiAgICAgICAgICAgIHRoaXMuX3BhcmVudC51cGRhdGVWYWx1ZUFuZFZhbGlkaXR5KG9wdHMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBfdXBkYXRlVHJlZVZhbGlkaXR5KG9wdHMgPSB7IGVtaXRFdmVudDogdHJ1ZSB9KSB7XG4gICAgICAgIHRoaXMuX2ZvckVhY2hDaGlsZCgoY3RybCkgPT4gY3RybC5fdXBkYXRlVHJlZVZhbGlkaXR5KG9wdHMpKTtcbiAgICAgICAgdGhpcy51cGRhdGVWYWx1ZUFuZFZhbGlkaXR5KHsgb25seVNlbGY6IHRydWUsIGVtaXRFdmVudDogb3B0cy5lbWl0RXZlbnQgfSk7XG4gICAgfVxuICAgIF9zZXRJbml0aWFsU3RhdHVzKCkge1xuICAgICAgICB0aGlzLnN0YXR1cyA9IHRoaXMuX2FsbENvbnRyb2xzRGlzYWJsZWQoKSA/IERJU0FCTEVEIDogVkFMSUQ7XG4gICAgfVxuICAgIF9ydW5WYWxpZGF0b3IoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZhbGlkYXRvciA/IHRoaXMudmFsaWRhdG9yKHRoaXMpIDogbnVsbDtcbiAgICB9XG4gICAgX3J1bkFzeW5jVmFsaWRhdG9yKGVtaXRFdmVudCkge1xuICAgICAgICBpZiAodGhpcy5hc3luY1ZhbGlkYXRvcikge1xuICAgICAgICAgICAgdGhpcy5zdGF0dXMgPSBQRU5ESU5HO1xuICAgICAgICAgICAgdGhpcy5faGFzT3duUGVuZGluZ0FzeW5jVmFsaWRhdG9yID0gdHJ1ZTtcbiAgICAgICAgICAgIGNvbnN0IG9icyA9IHRvT2JzZXJ2YWJsZSh0aGlzLmFzeW5jVmFsaWRhdG9yKHRoaXMpKTtcbiAgICAgICAgICAgIHRoaXMuX2FzeW5jVmFsaWRhdGlvblN1YnNjcmlwdGlvbiA9IG9icy5zdWJzY3JpYmUoKGVycm9ycykgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuX2hhc093blBlbmRpbmdBc3luY1ZhbGlkYXRvciA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIC8vIFRoaXMgd2lsbCB0cmlnZ2VyIHRoZSByZWNhbGN1bGF0aW9uIG9mIHRoZSB2YWxpZGF0aW9uIHN0YXR1cywgd2hpY2ggZGVwZW5kcyBvblxuICAgICAgICAgICAgICAgIC8vIHRoZSBzdGF0ZSBvZiB0aGUgYXN5bmNocm9ub3VzIHZhbGlkYXRpb24gKHdoZXRoZXIgaXQgaXMgaW4gcHJvZ3Jlc3Mgb3Igbm90KS4gU28sIGl0IGlzXG4gICAgICAgICAgICAgICAgLy8gbmVjZXNzYXJ5IHRoYXQgd2UgaGF2ZSB1cGRhdGVkIHRoZSBgX2hhc093blBlbmRpbmdBc3luY1ZhbGlkYXRvcmAgYm9vbGVhbiBmbGFnIGZpcnN0LlxuICAgICAgICAgICAgICAgIHRoaXMuc2V0RXJyb3JzKGVycm9ycywgeyBlbWl0RXZlbnQgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfY2FuY2VsRXhpc3RpbmdTdWJzY3JpcHRpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLl9hc3luY1ZhbGlkYXRpb25TdWJzY3JpcHRpb24pIHtcbiAgICAgICAgICAgIHRoaXMuX2FzeW5jVmFsaWRhdGlvblN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgdGhpcy5faGFzT3duUGVuZGluZ0FzeW5jVmFsaWRhdG9yID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyBlcnJvcnMgb24gYSBmb3JtIGNvbnRyb2wgd2hlbiBydW5uaW5nIHZhbGlkYXRpb25zIG1hbnVhbGx5LCByYXRoZXIgdGhhbiBhdXRvbWF0aWNhbGx5LlxuICAgICAqXG4gICAgICogQ2FsbGluZyBgc2V0RXJyb3JzYCBhbHNvIHVwZGF0ZXMgdGhlIHZhbGlkaXR5IG9mIHRoZSBwYXJlbnQgY29udHJvbC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRzIENvbmZpZ3VyYXRpb24gb3B0aW9ucyB0aGF0IGRldGVybWluZSBob3cgdGhlIGNvbnRyb2wgcHJvcGFnYXRlc1xuICAgICAqIGNoYW5nZXMgYW5kIGVtaXRzIGV2ZW50cyBhZnRlciB0aGUgY29udHJvbCBlcnJvcnMgYXJlIHNldC5cbiAgICAgKiAqIGBlbWl0RXZlbnRgOiBXaGVuIHRydWUgb3Igbm90IHN1cHBsaWVkICh0aGUgZGVmYXVsdCksIHRoZSBgc3RhdHVzQ2hhbmdlc2BcbiAgICAgKiBvYnNlcnZhYmxlIGVtaXRzIGFuIGV2ZW50IGFmdGVyIHRoZSBlcnJvcnMgYXJlIHNldC5cbiAgICAgKlxuICAgICAqIEB1c2FnZU5vdGVzXG4gICAgICpcbiAgICAgKiAjIyMgTWFudWFsbHkgc2V0IHRoZSBlcnJvcnMgZm9yIGEgY29udHJvbFxuICAgICAqXG4gICAgICogYGBgXG4gICAgICogY29uc3QgbG9naW4gPSBuZXcgRm9ybUNvbnRyb2woJ3NvbWVMb2dpbicpO1xuICAgICAqIGxvZ2luLnNldEVycm9ycyh7XG4gICAgICogICBub3RVbmlxdWU6IHRydWVcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIGV4cGVjdChsb2dpbi52YWxpZCkudG9FcXVhbChmYWxzZSk7XG4gICAgICogZXhwZWN0KGxvZ2luLmVycm9ycykudG9FcXVhbCh7IG5vdFVuaXF1ZTogdHJ1ZSB9KTtcbiAgICAgKlxuICAgICAqIGxvZ2luLnNldFZhbHVlKCdzb21lT3RoZXJMb2dpbicpO1xuICAgICAqXG4gICAgICogZXhwZWN0KGxvZ2luLnZhbGlkKS50b0VxdWFsKHRydWUpO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIHNldEVycm9ycyhlcnJvcnMsIG9wdHMgPSB7fSkge1xuICAgICAgICB0aGlzLmVycm9ycyA9IGVycm9ycztcbiAgICAgICAgdGhpcy5fdXBkYXRlQ29udHJvbHNFcnJvcnMob3B0cy5lbWl0RXZlbnQgIT09IGZhbHNlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIGEgY2hpbGQgY29udHJvbCBnaXZlbiB0aGUgY29udHJvbCdzIG5hbWUgb3IgcGF0aC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBwYXRoIEEgZG90LWRlbGltaXRlZCBzdHJpbmcgb3IgYXJyYXkgb2Ygc3RyaW5nL251bWJlciB2YWx1ZXMgdGhhdCBkZWZpbmUgdGhlIHBhdGggdG8gdGhlXG4gICAgICogY29udHJvbC4gSWYgYSBzdHJpbmcgaXMgcHJvdmlkZWQsIHBhc3NpbmcgaXQgYXMgYSBzdHJpbmcgbGl0ZXJhbCB3aWxsIHJlc3VsdCBpbiBpbXByb3ZlZCB0eXBlXG4gICAgICogaW5mb3JtYXRpb24uIExpa2V3aXNlLCBpZiBhbiBhcnJheSBpcyBwcm92aWRlZCwgcGFzc2luZyBpdCBgYXMgY29uc3RgIHdpbGwgY2F1c2UgaW1wcm92ZWQgdHlwZVxuICAgICAqIGluZm9ybWF0aW9uIHRvIGJlIGF2YWlsYWJsZS5cbiAgICAgKlxuICAgICAqIEB1c2FnZU5vdGVzXG4gICAgICogIyMjIFJldHJpZXZlIGEgbmVzdGVkIGNvbnRyb2xcbiAgICAgKlxuICAgICAqIEZvciBleGFtcGxlLCB0byBnZXQgYSBgbmFtZWAgY29udHJvbCBuZXN0ZWQgd2l0aGluIGEgYHBlcnNvbmAgc3ViLWdyb3VwOlxuICAgICAqXG4gICAgICogKiBgdGhpcy5mb3JtLmdldCgncGVyc29uLm5hbWUnKTtgXG4gICAgICpcbiAgICAgKiAtT1ItXG4gICAgICpcbiAgICAgKiAqIGB0aGlzLmZvcm0uZ2V0KFsncGVyc29uJywgJ25hbWUnXSBhcyBjb25zdCk7YCAvLyBgYXMgY29uc3RgIGdpdmVzIGltcHJvdmVkIHR5cGluZ3NcbiAgICAgKlxuICAgICAqICMjIyBSZXRyaWV2ZSBhIGNvbnRyb2wgaW4gYSBGb3JtQXJyYXlcbiAgICAgKlxuICAgICAqIFdoZW4gYWNjZXNzaW5nIGFuIGVsZW1lbnQgaW5zaWRlIGEgRm9ybUFycmF5LCB5b3UgY2FuIHVzZSBhbiBlbGVtZW50IGluZGV4LlxuICAgICAqIEZvciBleGFtcGxlLCB0byBnZXQgYSBgcHJpY2VgIGNvbnRyb2wgZnJvbSB0aGUgZmlyc3QgZWxlbWVudCBpbiBhbiBgaXRlbXNgIGFycmF5IHlvdSBjYW4gdXNlOlxuICAgICAqXG4gICAgICogKiBgdGhpcy5mb3JtLmdldCgnaXRlbXMuMC5wcmljZScpO2BcbiAgICAgKlxuICAgICAqIC1PUi1cbiAgICAgKlxuICAgICAqICogYHRoaXMuZm9ybS5nZXQoWydpdGVtcycsIDAsICdwcmljZSddKTtgXG4gICAgICovXG4gICAgZ2V0KHBhdGgpIHtcbiAgICAgICAgbGV0IGN1cnJQYXRoID0gcGF0aDtcbiAgICAgICAgaWYgKGN1cnJQYXRoID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGN1cnJQYXRoKSlcbiAgICAgICAgICAgIGN1cnJQYXRoID0gY3VyclBhdGguc3BsaXQoJy4nKTtcbiAgICAgICAgaWYgKGN1cnJQYXRoLmxlbmd0aCA9PT0gMClcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICByZXR1cm4gY3VyclBhdGgucmVkdWNlKChjb250cm9sLCBuYW1lKSA9PiBjb250cm9sICYmIGNvbnRyb2wuX2ZpbmQobmFtZSksIHRoaXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKiBSZXBvcnRzIGVycm9yIGRhdGEgZm9yIHRoZSBjb250cm9sIHdpdGggdGhlIGdpdmVuIHBhdGguXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZXJyb3JDb2RlIFRoZSBjb2RlIG9mIHRoZSBlcnJvciB0byBjaGVja1xuICAgICAqIEBwYXJhbSBwYXRoIEEgbGlzdCBvZiBjb250cm9sIG5hbWVzIHRoYXQgZGVzaWduYXRlcyBob3cgdG8gbW92ZSBmcm9tIHRoZSBjdXJyZW50IGNvbnRyb2xcbiAgICAgKiB0byB0aGUgY29udHJvbCB0aGF0IHNob3VsZCBiZSBxdWVyaWVkIGZvciBlcnJvcnMuXG4gICAgICpcbiAgICAgKiBAdXNhZ2VOb3Rlc1xuICAgICAqIEZvciBleGFtcGxlLCBmb3IgdGhlIGZvbGxvd2luZyBgRm9ybUdyb3VwYDpcbiAgICAgKlxuICAgICAqIGBgYFxuICAgICAqIGZvcm0gPSBuZXcgRm9ybUdyb3VwKHtcbiAgICAgKiAgIGFkZHJlc3M6IG5ldyBGb3JtR3JvdXAoeyBzdHJlZXQ6IG5ldyBGb3JtQ29udHJvbCgpIH0pXG4gICAgICogfSk7XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBUaGUgcGF0aCB0byB0aGUgJ3N0cmVldCcgY29udHJvbCBmcm9tIHRoZSByb290IGZvcm0gd291bGQgYmUgJ2FkZHJlc3MnIC0+ICdzdHJlZXQnLlxuICAgICAqXG4gICAgICogSXQgY2FuIGJlIHByb3ZpZGVkIHRvIHRoaXMgbWV0aG9kIGluIG9uZSBvZiB0d28gZm9ybWF0czpcbiAgICAgKlxuICAgICAqIDEuIEFuIGFycmF5IG9mIHN0cmluZyBjb250cm9sIG5hbWVzLCBlLmcuIGBbJ2FkZHJlc3MnLCAnc3RyZWV0J11gXG4gICAgICogMS4gQSBwZXJpb2QtZGVsaW1pdGVkIGxpc3Qgb2YgY29udHJvbCBuYW1lcyBpbiBvbmUgc3RyaW5nLCBlLmcuIGAnYWRkcmVzcy5zdHJlZXQnYFxuICAgICAqXG4gICAgICogQHJldHVybnMgZXJyb3IgZGF0YSBmb3IgdGhhdCBwYXJ0aWN1bGFyIGVycm9yLiBJZiB0aGUgY29udHJvbCBvciBlcnJvciBpcyBub3QgcHJlc2VudCxcbiAgICAgKiBudWxsIGlzIHJldHVybmVkLlxuICAgICAqL1xuICAgIGdldEVycm9yKGVycm9yQ29kZSwgcGF0aCkge1xuICAgICAgICBjb25zdCBjb250cm9sID0gcGF0aCA/IHRoaXMuZ2V0KHBhdGgpIDogdGhpcztcbiAgICAgICAgcmV0dXJuIGNvbnRyb2wgJiYgY29udHJvbC5lcnJvcnMgPyBjb250cm9sLmVycm9yc1tlcnJvckNvZGVdIDogbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICogUmVwb3J0cyB3aGV0aGVyIHRoZSBjb250cm9sIHdpdGggdGhlIGdpdmVuIHBhdGggaGFzIHRoZSBlcnJvciBzcGVjaWZpZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZXJyb3JDb2RlIFRoZSBjb2RlIG9mIHRoZSBlcnJvciB0byBjaGVja1xuICAgICAqIEBwYXJhbSBwYXRoIEEgbGlzdCBvZiBjb250cm9sIG5hbWVzIHRoYXQgZGVzaWduYXRlcyBob3cgdG8gbW92ZSBmcm9tIHRoZSBjdXJyZW50IGNvbnRyb2xcbiAgICAgKiB0byB0aGUgY29udHJvbCB0aGF0IHNob3VsZCBiZSBxdWVyaWVkIGZvciBlcnJvcnMuXG4gICAgICpcbiAgICAgKiBAdXNhZ2VOb3Rlc1xuICAgICAqIEZvciBleGFtcGxlLCBmb3IgdGhlIGZvbGxvd2luZyBgRm9ybUdyb3VwYDpcbiAgICAgKlxuICAgICAqIGBgYFxuICAgICAqIGZvcm0gPSBuZXcgRm9ybUdyb3VwKHtcbiAgICAgKiAgIGFkZHJlc3M6IG5ldyBGb3JtR3JvdXAoeyBzdHJlZXQ6IG5ldyBGb3JtQ29udHJvbCgpIH0pXG4gICAgICogfSk7XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBUaGUgcGF0aCB0byB0aGUgJ3N0cmVldCcgY29udHJvbCBmcm9tIHRoZSByb290IGZvcm0gd291bGQgYmUgJ2FkZHJlc3MnIC0+ICdzdHJlZXQnLlxuICAgICAqXG4gICAgICogSXQgY2FuIGJlIHByb3ZpZGVkIHRvIHRoaXMgbWV0aG9kIGluIG9uZSBvZiB0d28gZm9ybWF0czpcbiAgICAgKlxuICAgICAqIDEuIEFuIGFycmF5IG9mIHN0cmluZyBjb250cm9sIG5hbWVzLCBlLmcuIGBbJ2FkZHJlc3MnLCAnc3RyZWV0J11gXG4gICAgICogMS4gQSBwZXJpb2QtZGVsaW1pdGVkIGxpc3Qgb2YgY29udHJvbCBuYW1lcyBpbiBvbmUgc3RyaW5nLCBlLmcuIGAnYWRkcmVzcy5zdHJlZXQnYFxuICAgICAqXG4gICAgICogSWYgbm8gcGF0aCBpcyBnaXZlbiwgdGhpcyBtZXRob2QgY2hlY2tzIGZvciB0aGUgZXJyb3Igb24gdGhlIGN1cnJlbnQgY29udHJvbC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHdoZXRoZXIgdGhlIGdpdmVuIGVycm9yIGlzIHByZXNlbnQgaW4gdGhlIGNvbnRyb2wgYXQgdGhlIGdpdmVuIHBhdGguXG4gICAgICpcbiAgICAgKiBJZiB0aGUgY29udHJvbCBpcyBub3QgcHJlc2VudCwgZmFsc2UgaXMgcmV0dXJuZWQuXG4gICAgICovXG4gICAgaGFzRXJyb3IoZXJyb3JDb2RlLCBwYXRoKSB7XG4gICAgICAgIHJldHVybiAhIXRoaXMuZ2V0RXJyb3IoZXJyb3JDb2RlLCBwYXRoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIHRoZSB0b3AtbGV2ZWwgYW5jZXN0b3Igb2YgdGhpcyBjb250cm9sLlxuICAgICAqL1xuICAgIGdldCByb290KCkge1xuICAgICAgICBsZXQgeCA9IHRoaXM7XG4gICAgICAgIHdoaWxlICh4Ll9wYXJlbnQpIHtcbiAgICAgICAgICAgIHggPSB4Ll9wYXJlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHg7XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBfdXBkYXRlQ29udHJvbHNFcnJvcnMoZW1pdEV2ZW50KSB7XG4gICAgICAgIHRoaXMuc3RhdHVzID0gdGhpcy5fY2FsY3VsYXRlU3RhdHVzKCk7XG4gICAgICAgIGlmIChlbWl0RXZlbnQpIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdHVzQ2hhbmdlcy5lbWl0KHRoaXMuc3RhdHVzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fcGFyZW50KSB7XG4gICAgICAgICAgICB0aGlzLl9wYXJlbnQuX3VwZGF0ZUNvbnRyb2xzRXJyb3JzKGVtaXRFdmVudCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIF9pbml0T2JzZXJ2YWJsZXMoKSB7XG4gICAgICAgIHRoaXMudmFsdWVDaGFuZ2VzID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICB0aGlzLnN0YXR1c0NoYW5nZXMgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgfVxuICAgIF9jYWxjdWxhdGVTdGF0dXMoKSB7XG4gICAgICAgIGlmICh0aGlzLl9hbGxDb250cm9sc0Rpc2FibGVkKCkpXG4gICAgICAgICAgICByZXR1cm4gRElTQUJMRUQ7XG4gICAgICAgIGlmICh0aGlzLmVycm9ycylcbiAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICBpZiAodGhpcy5faGFzT3duUGVuZGluZ0FzeW5jVmFsaWRhdG9yIHx8IHRoaXMuX2FueUNvbnRyb2xzSGF2ZVN0YXR1cyhQRU5ESU5HKSlcbiAgICAgICAgICAgIHJldHVybiBQRU5ESU5HO1xuICAgICAgICBpZiAodGhpcy5fYW55Q29udHJvbHNIYXZlU3RhdHVzKElOVkFMSUQpKVxuICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgIHJldHVybiBWQUxJRDtcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIF9hbnlDb250cm9sc0hhdmVTdGF0dXMoc3RhdHVzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hbnlDb250cm9scygoY29udHJvbCkgPT4gY29udHJvbC5zdGF0dXMgPT09IHN0YXR1cyk7XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBfYW55Q29udHJvbHNEaXJ0eSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FueUNvbnRyb2xzKChjb250cm9sKSA9PiBjb250cm9sLmRpcnR5KTtcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIF9hbnlDb250cm9sc1RvdWNoZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hbnlDb250cm9scygoY29udHJvbCkgPT4gY29udHJvbC50b3VjaGVkKTtcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIF91cGRhdGVQcmlzdGluZShvcHRzID0ge30pIHtcbiAgICAgICAgdGhpcy5wcmlzdGluZSA9ICF0aGlzLl9hbnlDb250cm9sc0RpcnR5KCk7XG4gICAgICAgIGlmICh0aGlzLl9wYXJlbnQgJiYgIW9wdHMub25seVNlbGYpIHtcbiAgICAgICAgICAgIHRoaXMuX3BhcmVudC5fdXBkYXRlUHJpc3RpbmUob3B0cyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIF91cGRhdGVUb3VjaGVkKG9wdHMgPSB7fSkge1xuICAgICAgICB0aGlzLnRvdWNoZWQgPSB0aGlzLl9hbnlDb250cm9sc1RvdWNoZWQoKTtcbiAgICAgICAgaWYgKHRoaXMuX3BhcmVudCAmJiAhb3B0cy5vbmx5U2VsZikge1xuICAgICAgICAgICAgdGhpcy5fcGFyZW50Ll91cGRhdGVUb3VjaGVkKG9wdHMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBfcmVnaXN0ZXJPbkNvbGxlY3Rpb25DaGFuZ2UoZm4pIHtcbiAgICAgICAgdGhpcy5fb25Db2xsZWN0aW9uQ2hhbmdlID0gZm47XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBfc2V0VXBkYXRlU3RyYXRlZ3kob3B0cykge1xuICAgICAgICBpZiAoaXNPcHRpb25zT2JqKG9wdHMpICYmIG9wdHMudXBkYXRlT24gIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5fdXBkYXRlT24gPSBvcHRzLnVwZGF0ZU9uO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoZWNrIHRvIHNlZSBpZiBwYXJlbnQgaGFzIGJlZW4gbWFya2VkIGFydGlmaWNpYWxseSBkaXJ0eS5cbiAgICAgKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIF9wYXJlbnRNYXJrZWREaXJ0eShvbmx5U2VsZikge1xuICAgICAgICBjb25zdCBwYXJlbnREaXJ0eSA9IHRoaXMuX3BhcmVudCAmJiB0aGlzLl9wYXJlbnQuZGlydHk7XG4gICAgICAgIHJldHVybiAhb25seVNlbGYgJiYgISFwYXJlbnREaXJ0eSAmJiAhdGhpcy5fcGFyZW50Ll9hbnlDb250cm9sc0RpcnR5KCk7XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBfZmluZChuYW1lKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbnRlcm5hbCBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgYHNldFZhbGlkYXRvcnNgIG1ldGhvZC4gTmVlZHMgdG8gYmUgc2VwYXJhdGVkIG91dCBpbnRvIGFcbiAgICAgKiBkaWZmZXJlbnQgbWV0aG9kLCBiZWNhdXNlIGl0IGlzIGNhbGxlZCBpbiB0aGUgY29uc3RydWN0b3IgYW5kIGl0IGNhbiBicmVhayBjYXNlcyB3aGVyZVxuICAgICAqIGEgY29udHJvbCBpcyBleHRlbmRlZC5cbiAgICAgKi9cbiAgICBfYXNzaWduVmFsaWRhdG9ycyh2YWxpZGF0b3JzKSB7XG4gICAgICAgIHRoaXMuX3Jhd1ZhbGlkYXRvcnMgPSBBcnJheS5pc0FycmF5KHZhbGlkYXRvcnMpID8gdmFsaWRhdG9ycy5zbGljZSgpIDogdmFsaWRhdG9ycztcbiAgICAgICAgdGhpcy5fY29tcG9zZWRWYWxpZGF0b3JGbiA9IGNvZXJjZVRvVmFsaWRhdG9yKHRoaXMuX3Jhd1ZhbGlkYXRvcnMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbnRlcm5hbCBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgYHNldEFzeW5jVmFsaWRhdG9yc2AgbWV0aG9kLiBOZWVkcyB0byBiZSBzZXBhcmF0ZWQgb3V0IGludG8gYVxuICAgICAqIGRpZmZlcmVudCBtZXRob2QsIGJlY2F1c2UgaXQgaXMgY2FsbGVkIGluIHRoZSBjb25zdHJ1Y3RvciBhbmQgaXQgY2FuIGJyZWFrIGNhc2VzIHdoZXJlXG4gICAgICogYSBjb250cm9sIGlzIGV4dGVuZGVkLlxuICAgICAqL1xuICAgIF9hc3NpZ25Bc3luY1ZhbGlkYXRvcnModmFsaWRhdG9ycykge1xuICAgICAgICB0aGlzLl9yYXdBc3luY1ZhbGlkYXRvcnMgPSBBcnJheS5pc0FycmF5KHZhbGlkYXRvcnMpID8gdmFsaWRhdG9ycy5zbGljZSgpIDogdmFsaWRhdG9ycztcbiAgICAgICAgdGhpcy5fY29tcG9zZWRBc3luY1ZhbGlkYXRvckZuID0gY29lcmNlVG9Bc3luY1ZhbGlkYXRvcih0aGlzLl9yYXdBc3luY1ZhbGlkYXRvcnMpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBUcmFja3MgdGhlIHZhbHVlIGFuZCB2YWxpZGl0eSBzdGF0ZSBvZiBhIGdyb3VwIG9mIGBGb3JtQ29udHJvbGAgaW5zdGFuY2VzLlxuICpcbiAqIEEgYEZvcm1Hcm91cGAgYWdncmVnYXRlcyB0aGUgdmFsdWVzIG9mIGVhY2ggY2hpbGQgYEZvcm1Db250cm9sYCBpbnRvIG9uZSBvYmplY3QsXG4gKiB3aXRoIGVhY2ggY29udHJvbCBuYW1lIGFzIHRoZSBrZXkuICBJdCBjYWxjdWxhdGVzIGl0cyBzdGF0dXMgYnkgcmVkdWNpbmcgdGhlIHN0YXR1cyB2YWx1ZXNcbiAqIG9mIGl0cyBjaGlsZHJlbi4gRm9yIGV4YW1wbGUsIGlmIG9uZSBvZiB0aGUgY29udHJvbHMgaW4gYSBncm91cCBpcyBpbnZhbGlkLCB0aGUgZW50aXJlXG4gKiBncm91cCBiZWNvbWVzIGludmFsaWQuXG4gKlxuICogYEZvcm1Hcm91cGAgaXMgb25lIG9mIHRoZSBmb3VyIGZ1bmRhbWVudGFsIGJ1aWxkaW5nIGJsb2NrcyB1c2VkIHRvIGRlZmluZSBmb3JtcyBpbiBBbmd1bGFyLFxuICogYWxvbmcgd2l0aCBgRm9ybUNvbnRyb2xgLCBgRm9ybUFycmF5YCwgYW5kIGBGb3JtUmVjb3JkYC5cbiAqXG4gKiBXaGVuIGluc3RhbnRpYXRpbmcgYSBgRm9ybUdyb3VwYCwgcGFzcyBpbiBhIGNvbGxlY3Rpb24gb2YgY2hpbGQgY29udHJvbHMgYXMgdGhlIGZpcnN0XG4gKiBhcmd1bWVudC4gVGhlIGtleSBmb3IgZWFjaCBjaGlsZCByZWdpc3RlcnMgdGhlIG5hbWUgZm9yIHRoZSBjb250cm9sLlxuICpcbiAqIGBGb3JtR3JvdXBgIGlzIGludGVuZGVkIGZvciB1c2UgY2FzZXMgd2hlcmUgdGhlIGtleXMgYXJlIGtub3duIGFoZWFkIG9mIHRpbWUuXG4gKiBJZiB5b3UgbmVlZCB0byBkeW5hbWljYWxseSBhZGQgYW5kIHJlbW92ZSBjb250cm9scywgdXNlIHtAbGluayBGb3JtUmVjb3JkfSBpbnN0ZWFkLlxuICpcbiAqIGBGb3JtR3JvdXBgIGFjY2VwdHMgYW4gb3B0aW9uYWwgdHlwZSBwYXJhbWV0ZXIgYFRDb250cm9sYCwgd2hpY2ggaXMgYW4gb2JqZWN0IHR5cGUgd2l0aCBpbm5lclxuICogY29udHJvbCB0eXBlcyBhcyB2YWx1ZXMuXG4gKlxuICogQHVzYWdlTm90ZXNcbiAqXG4gKiAjIyMgQ3JlYXRlIGEgZm9ybSBncm91cCB3aXRoIDIgY29udHJvbHNcbiAqXG4gKiBgYGBcbiAqIGNvbnN0IGZvcm0gPSBuZXcgRm9ybUdyb3VwKHtcbiAqICAgZmlyc3Q6IG5ldyBGb3JtQ29udHJvbCgnTmFuY3knLCBWYWxpZGF0b3JzLm1pbkxlbmd0aCgyKSksXG4gKiAgIGxhc3Q6IG5ldyBGb3JtQ29udHJvbCgnRHJldycpLFxuICogfSk7XG4gKlxuICogY29uc29sZS5sb2coZm9ybS52YWx1ZSk7ICAgLy8ge2ZpcnN0OiAnTmFuY3knLCBsYXN0OyAnRHJldyd9XG4gKiBjb25zb2xlLmxvZyhmb3JtLnN0YXR1cyk7ICAvLyAnVkFMSUQnXG4gKiBgYGBcbiAqXG4gKiAjIyMgVGhlIHR5cGUgYXJndW1lbnQsIGFuZCBvcHRpb25hbCBjb250cm9sc1xuICpcbiAqIGBGb3JtR3JvdXBgIGFjY2VwdHMgb25lIGdlbmVyaWMgYXJndW1lbnQsIHdoaWNoIGlzIGFuIG9iamVjdCBjb250YWluaW5nIGl0cyBpbm5lciBjb250cm9scy5cbiAqIFRoaXMgdHlwZSB3aWxsIHVzdWFsbHkgYmUgaW5mZXJyZWQgYXV0b21hdGljYWxseSwgYnV0IHlvdSBjYW4gYWx3YXlzIHNwZWNpZnkgaXQgZXhwbGljaXRseSBpZiB5b3VcbiAqIHdpc2guXG4gKlxuICogSWYgeW91IGhhdmUgY29udHJvbHMgdGhhdCBhcmUgb3B0aW9uYWwgKGkuZS4gdGhleSBjYW4gYmUgcmVtb3ZlZCwgeW91IGNhbiB1c2UgdGhlIGA/YCBpbiB0aGVcbiAqIHR5cGUpOlxuICpcbiAqIGBgYFxuICogY29uc3QgZm9ybSA9IG5ldyBGb3JtR3JvdXA8e1xuICogICBmaXJzdDogRm9ybUNvbnRyb2w8c3RyaW5nfG51bGw+LFxuICogICBtaWRkbGU/OiBGb3JtQ29udHJvbDxzdHJpbmd8bnVsbD4sIC8vIE1pZGRsZSBuYW1lIGlzIG9wdGlvbmFsLlxuICogICBsYXN0OiBGb3JtQ29udHJvbDxzdHJpbmd8bnVsbD4sXG4gKiB9Pih7XG4gKiAgIGZpcnN0OiBuZXcgRm9ybUNvbnRyb2woJ05hbmN5JyksXG4gKiAgIGxhc3Q6IG5ldyBGb3JtQ29udHJvbCgnRHJldycpLFxuICogfSk7XG4gKiBgYGBcbiAqXG4gKiAjIyMgQ3JlYXRlIGEgZm9ybSBncm91cCB3aXRoIGEgZ3JvdXAtbGV2ZWwgdmFsaWRhdG9yXG4gKlxuICogWW91IGluY2x1ZGUgZ3JvdXAtbGV2ZWwgdmFsaWRhdG9ycyBhcyB0aGUgc2Vjb25kIGFyZywgb3IgZ3JvdXAtbGV2ZWwgYXN5bmNcbiAqIHZhbGlkYXRvcnMgYXMgdGhlIHRoaXJkIGFyZy4gVGhlc2UgY29tZSBpbiBoYW5keSB3aGVuIHlvdSB3YW50IHRvIHBlcmZvcm0gdmFsaWRhdGlvblxuICogdGhhdCBjb25zaWRlcnMgdGhlIHZhbHVlIG9mIG1vcmUgdGhhbiBvbmUgY2hpbGQgY29udHJvbC5cbiAqXG4gKiBgYGBcbiAqIGNvbnN0IGZvcm0gPSBuZXcgRm9ybUdyb3VwKHtcbiAqICAgcGFzc3dvcmQ6IG5ldyBGb3JtQ29udHJvbCgnJywgVmFsaWRhdG9ycy5taW5MZW5ndGgoMikpLFxuICogICBwYXNzd29yZENvbmZpcm06IG5ldyBGb3JtQ29udHJvbCgnJywgVmFsaWRhdG9ycy5taW5MZW5ndGgoMikpLFxuICogfSwgcGFzc3dvcmRNYXRjaFZhbGlkYXRvcik7XG4gKlxuICpcbiAqIGZ1bmN0aW9uIHBhc3N3b3JkTWF0Y2hWYWxpZGF0b3IoZzogRm9ybUdyb3VwKSB7XG4gKiAgICByZXR1cm4gZy5nZXQoJ3Bhc3N3b3JkJykudmFsdWUgPT09IGcuZ2V0KCdwYXNzd29yZENvbmZpcm0nKS52YWx1ZVxuICogICAgICAgPyBudWxsIDogeydtaXNtYXRjaCc6IHRydWV9O1xuICogfVxuICogYGBgXG4gKlxuICogTGlrZSBgRm9ybUNvbnRyb2xgIGluc3RhbmNlcywgeW91IGNob29zZSB0byBwYXNzIGluXG4gKiB2YWxpZGF0b3JzIGFuZCBhc3luYyB2YWxpZGF0b3JzIGFzIHBhcnQgb2YgYW4gb3B0aW9ucyBvYmplY3QuXG4gKlxuICogYGBgXG4gKiBjb25zdCBmb3JtID0gbmV3IEZvcm1Hcm91cCh7XG4gKiAgIHBhc3N3b3JkOiBuZXcgRm9ybUNvbnRyb2woJycpXG4gKiAgIHBhc3N3b3JkQ29uZmlybTogbmV3IEZvcm1Db250cm9sKCcnKVxuICogfSwgeyB2YWxpZGF0b3JzOiBwYXNzd29yZE1hdGNoVmFsaWRhdG9yLCBhc3luY1ZhbGlkYXRvcnM6IG90aGVyVmFsaWRhdG9yIH0pO1xuICogYGBgXG4gKlxuICogIyMjIFNldCB0aGUgdXBkYXRlT24gcHJvcGVydHkgZm9yIGFsbCBjb250cm9scyBpbiBhIGZvcm0gZ3JvdXBcbiAqXG4gKiBUaGUgb3B0aW9ucyBvYmplY3QgaXMgdXNlZCB0byBzZXQgYSBkZWZhdWx0IHZhbHVlIGZvciBlYWNoIGNoaWxkXG4gKiBjb250cm9sJ3MgYHVwZGF0ZU9uYCBwcm9wZXJ0eS4gSWYgeW91IHNldCBgdXBkYXRlT25gIHRvIGAnYmx1cidgIGF0IHRoZVxuICogZ3JvdXAgbGV2ZWwsIGFsbCBjaGlsZCBjb250cm9scyBkZWZhdWx0IHRvICdibHVyJywgdW5sZXNzIHRoZSBjaGlsZFxuICogaGFzIGV4cGxpY2l0bHkgc3BlY2lmaWVkIGEgZGlmZmVyZW50IGB1cGRhdGVPbmAgdmFsdWUuXG4gKlxuICogYGBgdHNcbiAqIGNvbnN0IGMgPSBuZXcgRm9ybUdyb3VwKHtcbiAqICAgb25lOiBuZXcgRm9ybUNvbnRyb2woKVxuICogfSwgeyB1cGRhdGVPbjogJ2JsdXInIH0pO1xuICogYGBgXG4gKlxuICogIyMjIFVzaW5nIGEgRm9ybUdyb3VwIHdpdGggb3B0aW9uYWwgY29udHJvbHNcbiAqXG4gKiBJdCBpcyBwb3NzaWJsZSB0byBoYXZlIG9wdGlvbmFsIGNvbnRyb2xzIGluIGEgRm9ybUdyb3VwLiBBbiBvcHRpb25hbCBjb250cm9sIGNhbiBiZSByZW1vdmVkIGxhdGVyXG4gKiB1c2luZyBgcmVtb3ZlQ29udHJvbGAsIGFuZCBjYW4gYmUgb21pdHRlZCB3aGVuIGNhbGxpbmcgYHJlc2V0YC4gT3B0aW9uYWwgY29udHJvbHMgbXVzdCBiZVxuICogZGVjbGFyZWQgb3B0aW9uYWwgaW4gdGhlIGdyb3VwJ3MgdHlwZS5cbiAqXG4gKiBgYGB0c1xuICogY29uc3QgYyA9IG5ldyBGb3JtR3JvdXA8e29uZT86IEZvcm1Db250cm9sPHN0cmluZz59Pih7XG4gKiAgIG9uZTogbmV3IEZvcm1Db250cm9sKCcnKVxuICogfSk7XG4gKiBgYGBcbiAqXG4gKiBOb3RpY2UgdGhhdCBgYy52YWx1ZS5vbmVgIGhhcyB0eXBlIGBzdHJpbmd8bnVsbHx1bmRlZmluZWRgLiBUaGlzIGlzIGJlY2F1c2UgY2FsbGluZyBgYy5yZXNldCh7fSlgXG4gKiB3aXRob3V0IHByb3ZpZGluZyB0aGUgb3B0aW9uYWwga2V5IGBvbmVgIHdpbGwgY2F1c2UgaXQgdG8gYmVjb21lIGBudWxsYC5cbiAqXG4gKiBAcHVibGljQXBpXG4gKi9cbmNsYXNzIEZvcm1Hcm91cCBleHRlbmRzIEFic3RyYWN0Q29udHJvbCB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBgRm9ybUdyb3VwYCBpbnN0YW5jZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBjb250cm9scyBBIGNvbGxlY3Rpb24gb2YgY2hpbGQgY29udHJvbHMuIFRoZSBrZXkgZm9yIGVhY2ggY2hpbGQgaXMgdGhlIG5hbWVcbiAgICAgKiB1bmRlciB3aGljaCBpdCBpcyByZWdpc3RlcmVkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHZhbGlkYXRvck9yT3B0cyBBIHN5bmNocm9ub3VzIHZhbGlkYXRvciBmdW5jdGlvbiwgb3IgYW4gYXJyYXkgb2ZcbiAgICAgKiBzdWNoIGZ1bmN0aW9ucywgb3IgYW4gYEFic3RyYWN0Q29udHJvbE9wdGlvbnNgIG9iamVjdCB0aGF0IGNvbnRhaW5zIHZhbGlkYXRpb24gZnVuY3Rpb25zXG4gICAgICogYW5kIGEgdmFsaWRhdGlvbiB0cmlnZ2VyLlxuICAgICAqXG4gICAgICogQHBhcmFtIGFzeW5jVmFsaWRhdG9yIEEgc2luZ2xlIGFzeW5jIHZhbGlkYXRvciBvciBhcnJheSBvZiBhc3luYyB2YWxpZGF0b3IgZnVuY3Rpb25zXG4gICAgICpcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihjb250cm9scywgdmFsaWRhdG9yT3JPcHRzLCBhc3luY1ZhbGlkYXRvcikge1xuICAgICAgICBzdXBlcihwaWNrVmFsaWRhdG9ycyh2YWxpZGF0b3JPck9wdHMpLCBwaWNrQXN5bmNWYWxpZGF0b3JzKGFzeW5jVmFsaWRhdG9yLCB2YWxpZGF0b3JPck9wdHMpKTtcbiAgICAgICAgKHR5cGVvZiBuZ0Rldk1vZGUgPT09ICd1bmRlZmluZWQnIHx8IG5nRGV2TW9kZSkgJiYgdmFsaWRhdGVGb3JtR3JvdXBDb250cm9scyhjb250cm9scyk7XG4gICAgICAgIHRoaXMuY29udHJvbHMgPSBjb250cm9scztcbiAgICAgICAgdGhpcy5faW5pdE9ic2VydmFibGVzKCk7XG4gICAgICAgIHRoaXMuX3NldFVwZGF0ZVN0cmF0ZWd5KHZhbGlkYXRvck9yT3B0cyk7XG4gICAgICAgIHRoaXMuX3NldFVwQ29udHJvbHMoKTtcbiAgICAgICAgdGhpcy51cGRhdGVWYWx1ZUFuZFZhbGlkaXR5KHtcbiAgICAgICAgICAgIG9ubHlTZWxmOiB0cnVlLFxuICAgICAgICAgICAgLy8gSWYgYGFzeW5jVmFsaWRhdG9yYCBpcyBwcmVzZW50LCBpdCB3aWxsIHRyaWdnZXIgY29udHJvbCBzdGF0dXMgY2hhbmdlIGZyb20gYFBFTkRJTkdgIHRvXG4gICAgICAgICAgICAvLyBgVkFMSURgIG9yIGBJTlZBTElEYC4gVGhlIHN0YXR1cyBzaG91bGQgYmUgYnJvYWRjYXN0ZWQgdmlhIHRoZSBgc3RhdHVzQ2hhbmdlc2Agb2JzZXJ2YWJsZSxcbiAgICAgICAgICAgIC8vIHNvIHdlIHNldCBgZW1pdEV2ZW50YCB0byBgdHJ1ZWAgdG8gYWxsb3cgdGhhdCBkdXJpbmcgdGhlIGNvbnRyb2wgY3JlYXRpb24gcHJvY2Vzcy5cbiAgICAgICAgICAgIGVtaXRFdmVudDogISF0aGlzLmFzeW5jVmFsaWRhdG9yXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZWdpc3RlckNvbnRyb2wobmFtZSwgY29udHJvbCkge1xuICAgICAgICBpZiAodGhpcy5jb250cm9sc1tuYW1lXSlcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbnRyb2xzW25hbWVdO1xuICAgICAgICB0aGlzLmNvbnRyb2xzW25hbWVdID0gY29udHJvbDtcbiAgICAgICAgY29udHJvbC5zZXRQYXJlbnQodGhpcyk7XG4gICAgICAgIGNvbnRyb2wuX3JlZ2lzdGVyT25Db2xsZWN0aW9uQ2hhbmdlKHRoaXMuX29uQ29sbGVjdGlvbkNoYW5nZSk7XG4gICAgICAgIHJldHVybiBjb250cm9sO1xuICAgIH1cbiAgICBhZGRDb250cm9sKG5hbWUsIGNvbnRyb2wsIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICB0aGlzLnJlZ2lzdGVyQ29udHJvbChuYW1lLCBjb250cm9sKTtcbiAgICAgICAgdGhpcy51cGRhdGVWYWx1ZUFuZFZhbGlkaXR5KHsgZW1pdEV2ZW50OiBvcHRpb25zLmVtaXRFdmVudCB9KTtcbiAgICAgICAgdGhpcy5fb25Db2xsZWN0aW9uQ2hhbmdlKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbW92ZSBhIGNvbnRyb2wgZnJvbSB0aGlzIGdyb3VwLiBJbiBhIHN0cm9uZ2x5LXR5cGVkIGdyb3VwLCByZXF1aXJlZCBjb250cm9scyBjYW5ub3QgYmVcbiAgICAgKiByZW1vdmVkLlxuICAgICAqXG4gICAgICogVGhpcyBtZXRob2QgYWxzbyB1cGRhdGVzIHRoZSB2YWx1ZSBhbmQgdmFsaWRpdHkgb2YgdGhlIGNvbnRyb2wuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbmFtZSBUaGUgY29udHJvbCBuYW1lIHRvIHJlbW92ZSBmcm9tIHRoZSBjb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIG9wdGlvbnMgU3BlY2lmaWVzIHdoZXRoZXIgdGhpcyBGb3JtR3JvdXAgaW5zdGFuY2Ugc2hvdWxkIGVtaXQgZXZlbnRzIGFmdGVyIGFcbiAgICAgKiAgICAgY29udHJvbCBpcyByZW1vdmVkLlxuICAgICAqICogYGVtaXRFdmVudGA6IFdoZW4gdHJ1ZSBvciBub3Qgc3VwcGxpZWQgKHRoZSBkZWZhdWx0KSwgYm90aCB0aGUgYHN0YXR1c0NoYW5nZXNgIGFuZFxuICAgICAqIGB2YWx1ZUNoYW5nZXNgIG9ic2VydmFibGVzIGVtaXQgZXZlbnRzIHdpdGggdGhlIGxhdGVzdCBzdGF0dXMgYW5kIHZhbHVlIHdoZW4gdGhlIGNvbnRyb2wgaXNcbiAgICAgKiByZW1vdmVkLiBXaGVuIGZhbHNlLCBubyBldmVudHMgYXJlIGVtaXR0ZWQuXG4gICAgICovXG4gICAgcmVtb3ZlQ29udHJvbChuYW1lLCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgaWYgKHRoaXMuY29udHJvbHNbbmFtZV0pXG4gICAgICAgICAgICB0aGlzLmNvbnRyb2xzW25hbWVdLl9yZWdpc3Rlck9uQ29sbGVjdGlvbkNoYW5nZSgoKSA9PiB7IH0pO1xuICAgICAgICBkZWxldGUgKHRoaXMuY29udHJvbHNbbmFtZV0pO1xuICAgICAgICB0aGlzLnVwZGF0ZVZhbHVlQW5kVmFsaWRpdHkoeyBlbWl0RXZlbnQ6IG9wdGlvbnMuZW1pdEV2ZW50IH0pO1xuICAgICAgICB0aGlzLl9vbkNvbGxlY3Rpb25DaGFuZ2UoKTtcbiAgICB9XG4gICAgc2V0Q29udHJvbChuYW1lLCBjb250cm9sLCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgaWYgKHRoaXMuY29udHJvbHNbbmFtZV0pXG4gICAgICAgICAgICB0aGlzLmNvbnRyb2xzW25hbWVdLl9yZWdpc3Rlck9uQ29sbGVjdGlvbkNoYW5nZSgoKSA9PiB7IH0pO1xuICAgICAgICBkZWxldGUgKHRoaXMuY29udHJvbHNbbmFtZV0pO1xuICAgICAgICBpZiAoY29udHJvbClcbiAgICAgICAgICAgIHRoaXMucmVnaXN0ZXJDb250cm9sKG5hbWUsIGNvbnRyb2wpO1xuICAgICAgICB0aGlzLnVwZGF0ZVZhbHVlQW5kVmFsaWRpdHkoeyBlbWl0RXZlbnQ6IG9wdGlvbnMuZW1pdEV2ZW50IH0pO1xuICAgICAgICB0aGlzLl9vbkNvbGxlY3Rpb25DaGFuZ2UoKTtcbiAgICB9XG4gICAgY29udGFpbnMoY29udHJvbE5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29udHJvbHMuaGFzT3duUHJvcGVydHkoY29udHJvbE5hbWUpICYmIHRoaXMuY29udHJvbHNbY29udHJvbE5hbWVdLmVuYWJsZWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHZhbHVlIG9mIHRoZSBgRm9ybUdyb3VwYC4gSXQgYWNjZXB0cyBhbiBvYmplY3QgdGhhdCBtYXRjaGVzXG4gICAgICogdGhlIHN0cnVjdHVyZSBvZiB0aGUgZ3JvdXAsIHdpdGggY29udHJvbCBuYW1lcyBhcyBrZXlzLlxuICAgICAqXG4gICAgICogQHVzYWdlTm90ZXNcbiAgICAgKiAjIyMgU2V0IHRoZSBjb21wbGV0ZSB2YWx1ZSBmb3IgdGhlIGZvcm0gZ3JvdXBcbiAgICAgKlxuICAgICAqIGBgYFxuICAgICAqIGNvbnN0IGZvcm0gPSBuZXcgRm9ybUdyb3VwKHtcbiAgICAgKiAgIGZpcnN0OiBuZXcgRm9ybUNvbnRyb2woKSxcbiAgICAgKiAgIGxhc3Q6IG5ldyBGb3JtQ29udHJvbCgpXG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBjb25zb2xlLmxvZyhmb3JtLnZhbHVlKTsgICAvLyB7Zmlyc3Q6IG51bGwsIGxhc3Q6IG51bGx9XG4gICAgICpcbiAgICAgKiBmb3JtLnNldFZhbHVlKHtmaXJzdDogJ05hbmN5JywgbGFzdDogJ0RyZXcnfSk7XG4gICAgICogY29uc29sZS5sb2coZm9ybS52YWx1ZSk7ICAgLy8ge2ZpcnN0OiAnTmFuY3knLCBsYXN0OiAnRHJldyd9XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAdGhyb3dzIFdoZW4gc3RyaWN0IGNoZWNrcyBmYWlsLCBzdWNoIGFzIHNldHRpbmcgdGhlIHZhbHVlIG9mIGEgY29udHJvbFxuICAgICAqIHRoYXQgZG9lc24ndCBleGlzdCBvciBpZiB5b3UgZXhjbHVkZSBhIHZhbHVlIG9mIGEgY29udHJvbCB0aGF0IGRvZXMgZXhpc3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdmFsdWUgVGhlIG5ldyB2YWx1ZSBmb3IgdGhlIGNvbnRyb2wgdGhhdCBtYXRjaGVzIHRoZSBzdHJ1Y3R1cmUgb2YgdGhlIGdyb3VwLlxuICAgICAqIEBwYXJhbSBvcHRpb25zIENvbmZpZ3VyYXRpb24gb3B0aW9ucyB0aGF0IGRldGVybWluZSBob3cgdGhlIGNvbnRyb2wgcHJvcGFnYXRlcyBjaGFuZ2VzXG4gICAgICogYW5kIGVtaXRzIGV2ZW50cyBhZnRlciB0aGUgdmFsdWUgY2hhbmdlcy5cbiAgICAgKiBUaGUgY29uZmlndXJhdGlvbiBvcHRpb25zIGFyZSBwYXNzZWQgdG8gdGhlIHtAbGluayBBYnN0cmFjdENvbnRyb2wjdXBkYXRlVmFsdWVBbmRWYWxpZGl0eVxuICAgICAqIHVwZGF0ZVZhbHVlQW5kVmFsaWRpdHl9IG1ldGhvZC5cbiAgICAgKlxuICAgICAqICogYG9ubHlTZWxmYDogV2hlbiB0cnVlLCBlYWNoIGNoYW5nZSBvbmx5IGFmZmVjdHMgdGhpcyBjb250cm9sLCBhbmQgbm90IGl0cyBwYXJlbnQuIERlZmF1bHQgaXNcbiAgICAgKiBmYWxzZS5cbiAgICAgKiAqIGBlbWl0RXZlbnRgOiBXaGVuIHRydWUgb3Igbm90IHN1cHBsaWVkICh0aGUgZGVmYXVsdCksIGJvdGggdGhlIGBzdGF0dXNDaGFuZ2VzYCBhbmRcbiAgICAgKiBgdmFsdWVDaGFuZ2VzYFxuICAgICAqIG9ic2VydmFibGVzIGVtaXQgZXZlbnRzIHdpdGggdGhlIGxhdGVzdCBzdGF0dXMgYW5kIHZhbHVlIHdoZW4gdGhlIGNvbnRyb2wgdmFsdWUgaXMgdXBkYXRlZC5cbiAgICAgKiBXaGVuIGZhbHNlLCBubyBldmVudHMgYXJlIGVtaXR0ZWQuXG4gICAgICovXG4gICAgc2V0VmFsdWUodmFsdWUsIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICBhc3NlcnRBbGxWYWx1ZXNQcmVzZW50KHRoaXMsIHRydWUsIHZhbHVlKTtcbiAgICAgICAgT2JqZWN0LmtleXModmFsdWUpLmZvckVhY2gobmFtZSA9PiB7XG4gICAgICAgICAgICBhc3NlcnRDb250cm9sUHJlc2VudCh0aGlzLCB0cnVlLCBuYW1lKTtcbiAgICAgICAgICAgIHRoaXMuY29udHJvbHNbbmFtZV0uc2V0VmFsdWUodmFsdWVbbmFtZV0sIHsgb25seVNlbGY6IHRydWUsIGVtaXRFdmVudDogb3B0aW9ucy5lbWl0RXZlbnQgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnVwZGF0ZVZhbHVlQW5kVmFsaWRpdHkob3B0aW9ucyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBhdGNoZXMgdGhlIHZhbHVlIG9mIHRoZSBgRm9ybUdyb3VwYC4gSXQgYWNjZXB0cyBhbiBvYmplY3Qgd2l0aCBjb250cm9sXG4gICAgICogbmFtZXMgYXMga2V5cywgYW5kIGRvZXMgaXRzIGJlc3QgdG8gbWF0Y2ggdGhlIHZhbHVlcyB0byB0aGUgY29ycmVjdCBjb250cm9sc1xuICAgICAqIGluIHRoZSBncm91cC5cbiAgICAgKlxuICAgICAqIEl0IGFjY2VwdHMgYm90aCBzdXBlci1zZXRzIGFuZCBzdWItc2V0cyBvZiB0aGUgZ3JvdXAgd2l0aG91dCB0aHJvd2luZyBhbiBlcnJvci5cbiAgICAgKlxuICAgICAqIEB1c2FnZU5vdGVzXG4gICAgICogIyMjIFBhdGNoIHRoZSB2YWx1ZSBmb3IgYSBmb3JtIGdyb3VwXG4gICAgICpcbiAgICAgKiBgYGBcbiAgICAgKiBjb25zdCBmb3JtID0gbmV3IEZvcm1Hcm91cCh7XG4gICAgICogICAgZmlyc3Q6IG5ldyBGb3JtQ29udHJvbCgpLFxuICAgICAqICAgIGxhc3Q6IG5ldyBGb3JtQ29udHJvbCgpXG4gICAgICogfSk7XG4gICAgICogY29uc29sZS5sb2coZm9ybS52YWx1ZSk7ICAgLy8ge2ZpcnN0OiBudWxsLCBsYXN0OiBudWxsfVxuICAgICAqXG4gICAgICogZm9ybS5wYXRjaFZhbHVlKHtmaXJzdDogJ05hbmN5J30pO1xuICAgICAqIGNvbnNvbGUubG9nKGZvcm0udmFsdWUpOyAgIC8vIHtmaXJzdDogJ05hbmN5JywgbGFzdDogbnVsbH1cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBwYXJhbSB2YWx1ZSBUaGUgb2JqZWN0IHRoYXQgbWF0Y2hlcyB0aGUgc3RydWN0dXJlIG9mIHRoZSBncm91cC5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBDb25maWd1cmF0aW9uIG9wdGlvbnMgdGhhdCBkZXRlcm1pbmUgaG93IHRoZSBjb250cm9sIHByb3BhZ2F0ZXMgY2hhbmdlcyBhbmRcbiAgICAgKiBlbWl0cyBldmVudHMgYWZ0ZXIgdGhlIHZhbHVlIGlzIHBhdGNoZWQuXG4gICAgICogKiBgb25seVNlbGZgOiBXaGVuIHRydWUsIGVhY2ggY2hhbmdlIG9ubHkgYWZmZWN0cyB0aGlzIGNvbnRyb2wgYW5kIG5vdCBpdHMgcGFyZW50LiBEZWZhdWx0IGlzXG4gICAgICogdHJ1ZS5cbiAgICAgKiAqIGBlbWl0RXZlbnRgOiBXaGVuIHRydWUgb3Igbm90IHN1cHBsaWVkICh0aGUgZGVmYXVsdCksIGJvdGggdGhlIGBzdGF0dXNDaGFuZ2VzYCBhbmRcbiAgICAgKiBgdmFsdWVDaGFuZ2VzYCBvYnNlcnZhYmxlcyBlbWl0IGV2ZW50cyB3aXRoIHRoZSBsYXRlc3Qgc3RhdHVzIGFuZCB2YWx1ZSB3aGVuIHRoZSBjb250cm9sIHZhbHVlXG4gICAgICogaXMgdXBkYXRlZC4gV2hlbiBmYWxzZSwgbm8gZXZlbnRzIGFyZSBlbWl0dGVkLiBUaGUgY29uZmlndXJhdGlvbiBvcHRpb25zIGFyZSBwYXNzZWQgdG9cbiAgICAgKiB0aGUge0BsaW5rIEFic3RyYWN0Q29udHJvbCN1cGRhdGVWYWx1ZUFuZFZhbGlkaXR5IHVwZGF0ZVZhbHVlQW5kVmFsaWRpdHl9IG1ldGhvZC5cbiAgICAgKi9cbiAgICBwYXRjaFZhbHVlKHZhbHVlLCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgLy8gRXZlbiB0aG91Z2ggdGhlIGB2YWx1ZWAgYXJndW1lbnQgdHlwZSBkb2Vzbid0IGFsbG93IGBudWxsYCBhbmQgYHVuZGVmaW5lZGAgdmFsdWVzLCB0aGVcbiAgICAgICAgLy8gYHBhdGNoVmFsdWVgIGNhbiBiZSBjYWxsZWQgcmVjdXJzaXZlbHkgYW5kIGlubmVyIGRhdGEgc3RydWN0dXJlcyBtaWdodCBoYXZlIHRoZXNlIHZhbHVlcywgc29cbiAgICAgICAgLy8gd2UganVzdCBpZ25vcmUgc3VjaCBjYXNlcyB3aGVuIGEgZmllbGQgY29udGFpbmluZyBGb3JtR3JvdXAgaW5zdGFuY2UgcmVjZWl2ZXMgYG51bGxgIG9yXG4gICAgICAgIC8vIGB1bmRlZmluZWRgIGFzIGEgdmFsdWUuXG4gICAgICAgIGlmICh2YWx1ZSA9PSBudWxsIC8qIGJvdGggYG51bGxgIGFuZCBgdW5kZWZpbmVkYCAqLylcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgT2JqZWN0LmtleXModmFsdWUpLmZvckVhY2gobmFtZSA9PiB7XG4gICAgICAgICAgICAvLyBUaGUgY29tcGlsZXIgY2Fubm90IHNlZSB0aHJvdWdoIHRoZSB1bmluc3RhbnRpYXRlZCBjb25kaXRpb25hbCB0eXBlIG9mIGB0aGlzLmNvbnRyb2xzYCwgc29cbiAgICAgICAgICAgIC8vIGBhcyBhbnlgIGlzIHJlcXVpcmVkLlxuICAgICAgICAgICAgY29uc3QgY29udHJvbCA9IHRoaXMuY29udHJvbHNbbmFtZV07XG4gICAgICAgICAgICBpZiAoY29udHJvbCkge1xuICAgICAgICAgICAgICAgIGNvbnRyb2wucGF0Y2hWYWx1ZShcbiAgICAgICAgICAgICAgICAvKiBHdWFyYW50ZWVkIHRvIGJlIHByZXNlbnQsIGR1ZSB0byB0aGUgb3V0ZXIgZm9yRWFjaC4gKi8gdmFsdWVbbmFtZV0sIHsgb25seVNlbGY6IHRydWUsIGVtaXRFdmVudDogb3B0aW9ucy5lbWl0RXZlbnQgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnVwZGF0ZVZhbHVlQW5kVmFsaWRpdHkob3B0aW9ucyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlc2V0cyB0aGUgYEZvcm1Hcm91cGAsIG1hcmtzIGFsbCBkZXNjZW5kYW50cyBgcHJpc3RpbmVgIGFuZCBgdW50b3VjaGVkYCBhbmQgc2V0c1xuICAgICAqIHRoZSB2YWx1ZSBvZiBhbGwgZGVzY2VuZGFudHMgdG8gdGhlaXIgZGVmYXVsdCB2YWx1ZXMsIG9yIG51bGwgaWYgbm8gZGVmYXVsdHMgd2VyZSBwcm92aWRlZC5cbiAgICAgKlxuICAgICAqIFlvdSByZXNldCB0byBhIHNwZWNpZmljIGZvcm0gc3RhdGUgYnkgcGFzc2luZyBpbiBhIG1hcCBvZiBzdGF0ZXNcbiAgICAgKiB0aGF0IG1hdGNoZXMgdGhlIHN0cnVjdHVyZSBvZiB5b3VyIGZvcm0sIHdpdGggY29udHJvbCBuYW1lcyBhcyBrZXlzLiBUaGUgc3RhdGVcbiAgICAgKiBpcyBhIHN0YW5kYWxvbmUgdmFsdWUgb3IgYSBmb3JtIHN0YXRlIG9iamVjdCB3aXRoIGJvdGggYSB2YWx1ZSBhbmQgYSBkaXNhYmxlZFxuICAgICAqIHN0YXR1cy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB2YWx1ZSBSZXNldHMgdGhlIGNvbnRyb2wgd2l0aCBhbiBpbml0aWFsIHZhbHVlLFxuICAgICAqIG9yIGFuIG9iamVjdCB0aGF0IGRlZmluZXMgdGhlIGluaXRpYWwgdmFsdWUgYW5kIGRpc2FibGVkIHN0YXRlLlxuICAgICAqXG4gICAgICogQHBhcmFtIG9wdGlvbnMgQ29uZmlndXJhdGlvbiBvcHRpb25zIHRoYXQgZGV0ZXJtaW5lIGhvdyB0aGUgY29udHJvbCBwcm9wYWdhdGVzIGNoYW5nZXNcbiAgICAgKiBhbmQgZW1pdHMgZXZlbnRzIHdoZW4gdGhlIGdyb3VwIGlzIHJlc2V0LlxuICAgICAqICogYG9ubHlTZWxmYDogV2hlbiB0cnVlLCBlYWNoIGNoYW5nZSBvbmx5IGFmZmVjdHMgdGhpcyBjb250cm9sLCBhbmQgbm90IGl0cyBwYXJlbnQuIERlZmF1bHQgaXNcbiAgICAgKiBmYWxzZS5cbiAgICAgKiAqIGBlbWl0RXZlbnRgOiBXaGVuIHRydWUgb3Igbm90IHN1cHBsaWVkICh0aGUgZGVmYXVsdCksIGJvdGggdGhlIGBzdGF0dXNDaGFuZ2VzYCBhbmRcbiAgICAgKiBgdmFsdWVDaGFuZ2VzYFxuICAgICAqIG9ic2VydmFibGVzIGVtaXQgZXZlbnRzIHdpdGggdGhlIGxhdGVzdCBzdGF0dXMgYW5kIHZhbHVlIHdoZW4gdGhlIGNvbnRyb2wgaXMgcmVzZXQuXG4gICAgICogV2hlbiBmYWxzZSwgbm8gZXZlbnRzIGFyZSBlbWl0dGVkLlxuICAgICAqIFRoZSBjb25maWd1cmF0aW9uIG9wdGlvbnMgYXJlIHBhc3NlZCB0byB0aGUge0BsaW5rIEFic3RyYWN0Q29udHJvbCN1cGRhdGVWYWx1ZUFuZFZhbGlkaXR5XG4gICAgICogdXBkYXRlVmFsdWVBbmRWYWxpZGl0eX0gbWV0aG9kLlxuICAgICAqXG4gICAgICogQHVzYWdlTm90ZXNcbiAgICAgKlxuICAgICAqICMjIyBSZXNldCB0aGUgZm9ybSBncm91cCB2YWx1ZXNcbiAgICAgKlxuICAgICAqIGBgYHRzXG4gICAgICogY29uc3QgZm9ybSA9IG5ldyBGb3JtR3JvdXAoe1xuICAgICAqICAgZmlyc3Q6IG5ldyBGb3JtQ29udHJvbCgnZmlyc3QgbmFtZScpLFxuICAgICAqICAgbGFzdDogbmV3IEZvcm1Db250cm9sKCdsYXN0IG5hbWUnKVxuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogY29uc29sZS5sb2coZm9ybS52YWx1ZSk7ICAvLyB7Zmlyc3Q6ICdmaXJzdCBuYW1lJywgbGFzdDogJ2xhc3QgbmFtZSd9XG4gICAgICpcbiAgICAgKiBmb3JtLnJlc2V0KHsgZmlyc3Q6ICduYW1lJywgbGFzdDogJ2xhc3QgbmFtZScgfSk7XG4gICAgICpcbiAgICAgKiBjb25zb2xlLmxvZyhmb3JtLnZhbHVlKTsgIC8vIHtmaXJzdDogJ25hbWUnLCBsYXN0OiAnbGFzdCBuYW1lJ31cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqICMjIyBSZXNldCB0aGUgZm9ybSBncm91cCB2YWx1ZXMgYW5kIGRpc2FibGVkIHN0YXR1c1xuICAgICAqXG4gICAgICogYGBgXG4gICAgICogY29uc3QgZm9ybSA9IG5ldyBGb3JtR3JvdXAoe1xuICAgICAqICAgZmlyc3Q6IG5ldyBGb3JtQ29udHJvbCgnZmlyc3QgbmFtZScpLFxuICAgICAqICAgbGFzdDogbmV3IEZvcm1Db250cm9sKCdsYXN0IG5hbWUnKVxuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogZm9ybS5yZXNldCh7XG4gICAgICogICBmaXJzdDoge3ZhbHVlOiAnbmFtZScsIGRpc2FibGVkOiB0cnVlfSxcbiAgICAgKiAgIGxhc3Q6ICdsYXN0J1xuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogY29uc29sZS5sb2coZm9ybS52YWx1ZSk7ICAvLyB7bGFzdDogJ2xhc3QnfVxuICAgICAqIGNvbnNvbGUubG9nKGZvcm0uZ2V0KCdmaXJzdCcpLnN0YXR1cyk7ICAvLyAnRElTQUJMRUQnXG4gICAgICogYGBgXG4gICAgICovXG4gICAgcmVzZXQodmFsdWUgPSB7fSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIHRoaXMuX2ZvckVhY2hDaGlsZCgoY29udHJvbCwgbmFtZSkgPT4ge1xuICAgICAgICAgICAgY29udHJvbC5yZXNldCh2YWx1ZSA/IHZhbHVlW25hbWVdIDogbnVsbCwgeyBvbmx5U2VsZjogdHJ1ZSwgZW1pdEV2ZW50OiBvcHRpb25zLmVtaXRFdmVudCB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX3VwZGF0ZVByaXN0aW5lKG9wdGlvbnMpO1xuICAgICAgICB0aGlzLl91cGRhdGVUb3VjaGVkKG9wdGlvbnMpO1xuICAgICAgICB0aGlzLnVwZGF0ZVZhbHVlQW5kVmFsaWRpdHkob3B0aW9ucyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBhZ2dyZWdhdGUgdmFsdWUgb2YgdGhlIGBGb3JtR3JvdXBgLCBpbmNsdWRpbmcgYW55IGRpc2FibGVkIGNvbnRyb2xzLlxuICAgICAqXG4gICAgICogUmV0cmlldmVzIGFsbCB2YWx1ZXMgcmVnYXJkbGVzcyBvZiBkaXNhYmxlZCBzdGF0dXMuXG4gICAgICovXG4gICAgZ2V0UmF3VmFsdWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yZWR1Y2VDaGlsZHJlbih7fSwgKGFjYywgY29udHJvbCwgbmFtZSkgPT4ge1xuICAgICAgICAgICAgYWNjW25hbWVdID0gY29udHJvbC5nZXRSYXdWYWx1ZSgpO1xuICAgICAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBfc3luY1BlbmRpbmdDb250cm9scygpIHtcbiAgICAgICAgbGV0IHN1YnRyZWVVcGRhdGVkID0gdGhpcy5fcmVkdWNlQ2hpbGRyZW4oZmFsc2UsICh1cGRhdGVkLCBjaGlsZCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGNoaWxkLl9zeW5jUGVuZGluZ0NvbnRyb2xzKCkgPyB0cnVlIDogdXBkYXRlZDtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChzdWJ0cmVlVXBkYXRlZClcbiAgICAgICAgICAgIHRoaXMudXBkYXRlVmFsdWVBbmRWYWxpZGl0eSh7IG9ubHlTZWxmOiB0cnVlIH0pO1xuICAgICAgICByZXR1cm4gc3VidHJlZVVwZGF0ZWQ7XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBfZm9yRWFjaENoaWxkKGNiKSB7XG4gICAgICAgIE9iamVjdC5rZXlzKHRoaXMuY29udHJvbHMpLmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgICAgIC8vIFRoZSBsaXN0IG9mIGNvbnRyb2xzIGNhbiBjaGFuZ2UgKGZvciBleC4gY29udHJvbHMgbWlnaHQgYmUgcmVtb3ZlZCkgd2hpbGUgdGhlIGxvb3BcbiAgICAgICAgICAgIC8vIGlzIHJ1bm5pbmcgKGFzIGEgcmVzdWx0IG9mIGludm9raW5nIEZvcm1zIEFQSSBpbiBgdmFsdWVDaGFuZ2VzYCBzdWJzY3JpcHRpb24pLCBzbyB3ZVxuICAgICAgICAgICAgLy8gaGF2ZSB0byBudWxsIGNoZWNrIGJlZm9yZSBpbnZva2luZyB0aGUgY2FsbGJhY2suXG4gICAgICAgICAgICBjb25zdCBjb250cm9sID0gdGhpcy5jb250cm9sc1trZXldO1xuICAgICAgICAgICAgY29udHJvbCAmJiBjYihjb250cm9sLCBrZXkpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIF9zZXRVcENvbnRyb2xzKCkge1xuICAgICAgICB0aGlzLl9mb3JFYWNoQ2hpbGQoKGNvbnRyb2wpID0+IHtcbiAgICAgICAgICAgIGNvbnRyb2wuc2V0UGFyZW50KHRoaXMpO1xuICAgICAgICAgICAgY29udHJvbC5fcmVnaXN0ZXJPbkNvbGxlY3Rpb25DaGFuZ2UodGhpcy5fb25Db2xsZWN0aW9uQ2hhbmdlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBfdXBkYXRlVmFsdWUoKSB7XG4gICAgICAgIHRoaXMudmFsdWUgPSB0aGlzLl9yZWR1Y2VWYWx1ZSgpO1xuICAgIH1cbiAgICAvKiogQGludGVybmFsICovXG4gICAgX2FueUNvbnRyb2xzKGNvbmRpdGlvbikge1xuICAgICAgICBmb3IgKGNvbnN0IFtjb250cm9sTmFtZSwgY29udHJvbF0gb2YgT2JqZWN0LmVudHJpZXModGhpcy5jb250cm9scykpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbnRhaW5zKGNvbnRyb2xOYW1lKSAmJiBjb25kaXRpb24oY29udHJvbCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBfcmVkdWNlVmFsdWUoKSB7XG4gICAgICAgIGxldCBhY2MgPSB7fTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlZHVjZUNoaWxkcmVuKGFjYywgKGFjYywgY29udHJvbCwgbmFtZSkgPT4ge1xuICAgICAgICAgICAgaWYgKGNvbnRyb2wuZW5hYmxlZCB8fCB0aGlzLmRpc2FibGVkKSB7XG4gICAgICAgICAgICAgICAgYWNjW25hbWVdID0gY29udHJvbC52YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBhY2M7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKiogQGludGVybmFsICovXG4gICAgX3JlZHVjZUNoaWxkcmVuKGluaXRWYWx1ZSwgZm4pIHtcbiAgICAgICAgbGV0IHJlcyA9IGluaXRWYWx1ZTtcbiAgICAgICAgdGhpcy5fZm9yRWFjaENoaWxkKChjb250cm9sLCBuYW1lKSA9PiB7XG4gICAgICAgICAgICByZXMgPSBmbihyZXMsIGNvbnRyb2wsIG5hbWUpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIF9hbGxDb250cm9sc0Rpc2FibGVkKCkge1xuICAgICAgICBmb3IgKGNvbnN0IGNvbnRyb2xOYW1lIG9mIE9iamVjdC5rZXlzKHRoaXMuY29udHJvbHMpKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5jb250cm9sc1tjb250cm9sTmFtZV0uZW5hYmxlZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gT2JqZWN0LmtleXModGhpcy5jb250cm9scykubGVuZ3RoID4gMCB8fCB0aGlzLmRpc2FibGVkO1xuICAgIH1cbiAgICAvKiogQGludGVybmFsICovXG4gICAgX2ZpbmQobmFtZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb250cm9scy5oYXNPd25Qcm9wZXJ0eShuYW1lKSA/XG4gICAgICAgICAgICB0aGlzLmNvbnRyb2xzW25hbWVdIDpcbiAgICAgICAgICAgIG51bGw7XG4gICAgfVxufVxuLyoqXG4gKiBXaWxsIHZhbGlkYXRlIHRoYXQgbm9uZSBvZiB0aGUgY29udHJvbHMgaGFzIGEga2V5IHdpdGggYSBkb3RcbiAqIFRocm93cyBvdGhlciB3aXNlXG4gKi9cbmZ1bmN0aW9uIHZhbGlkYXRlRm9ybUdyb3VwQ29udHJvbHMoY29udHJvbHMpIHtcbiAgICBjb25zdCBpbnZhbGlkS2V5cyA9IE9iamVjdC5rZXlzKGNvbnRyb2xzKS5maWx0ZXIoa2V5ID0+IGtleS5pbmNsdWRlcygnLicpKTtcbiAgICBpZiAoaW52YWxpZEtleXMubGVuZ3RoID4gMCkge1xuICAgICAgICAvLyBUT0RPOiBtYWtlIHRoaXMgYW4gZXJyb3Igb25jZSB0aGVyZSBhcmUgbm8gbW9yZSB1c2VzIGluIEczXG4gICAgICAgIGNvbnNvbGUud2FybihgRm9ybUdyb3VwIGtleXMgY2Fubm90IGluY2x1ZGUgXFxgLlxcYCwgcGxlYXNlIHJlcGxhY2UgdGhlIGtleXMgZm9yOiAke2ludmFsaWRLZXlzLmpvaW4oJywnKX0uYCk7XG4gICAgfVxufVxuY29uc3QgVW50eXBlZEZvcm1Hcm91cCA9IEZvcm1Hcm91cDtcbi8qKlxuICogQGRlc2NyaXB0aW9uXG4gKiBBc3NlcnRzIHRoYXQgdGhlIGdpdmVuIGNvbnRyb2wgaXMgYW4gaW5zdGFuY2Ugb2YgYEZvcm1Hcm91cGBcbiAqXG4gKiBAcHVibGljQXBpXG4gKi9cbmNvbnN0IGlzRm9ybUdyb3VwID0gKGNvbnRyb2wpID0+IGNvbnRyb2wgaW5zdGFuY2VvZiBGb3JtR3JvdXA7XG4vKipcbiAqIFRyYWNrcyB0aGUgdmFsdWUgYW5kIHZhbGlkaXR5IHN0YXRlIG9mIGEgY29sbGVjdGlvbiBvZiBgRm9ybUNvbnRyb2xgIGluc3RhbmNlcywgZWFjaCBvZiB3aGljaCBoYXNcbiAqIHRoZSBzYW1lIHZhbHVlIHR5cGUuXG4gKlxuICogYEZvcm1SZWNvcmRgIGlzIHZlcnkgc2ltaWxhciB0byB7QGxpbmsgRm9ybUdyb3VwfSwgZXhjZXB0IGl0IGNhbiBiZSB1c2VkIHdpdGggYSBkeW5hbWljIGtleXMsXG4gKiB3aXRoIGNvbnRyb2xzIGFkZGVkIGFuZCByZW1vdmVkIGFzIG5lZWRlZC5cbiAqXG4gKiBgRm9ybVJlY29yZGAgYWNjZXB0cyBvbmUgZ2VuZXJpYyBhcmd1bWVudCwgd2hpY2ggZGVzY3JpYmVzIHRoZSB0eXBlIG9mIHRoZSBjb250cm9scyBpdCBjb250YWlucy5cbiAqXG4gKiBAdXNhZ2VOb3Rlc1xuICpcbiAqIGBgYFxuICogbGV0IG51bWJlcnMgPSBuZXcgRm9ybVJlY29yZCh7YmlsbDogbmV3IEZvcm1Db250cm9sKCc0MTUtMTIzLTQ1NicpfSk7XG4gKiBudW1iZXJzLmFkZENvbnRyb2woJ2JvYicsIG5ldyBGb3JtQ29udHJvbCgnNDE1LTIzNC01NjcnKSk7XG4gKiBudW1iZXJzLnJlbW92ZUNvbnRyb2woJ2JpbGwnKTtcbiAqIGBgYFxuICpcbiAqIEBwdWJsaWNBcGlcbiAqL1xuY2xhc3MgRm9ybVJlY29yZCBleHRlbmRzIEZvcm1Hcm91cCB7XG59XG4vKipcbiAqIEBkZXNjcmlwdGlvblxuICogQXNzZXJ0cyB0aGF0IHRoZSBnaXZlbiBjb250cm9sIGlzIGFuIGluc3RhbmNlIG9mIGBGb3JtUmVjb3JkYFxuICpcbiAqIEBwdWJsaWNBcGlcbiAqL1xuY29uc3QgaXNGb3JtUmVjb3JkID0gKGNvbnRyb2wpID0+IGNvbnRyb2wgaW5zdGFuY2VvZiBGb3JtUmVjb3JkO1xuXG4vKipcbiAqIFRva2VuIHRvIHByb3ZpZGUgdG8gYWxsb3cgU2V0RGlzYWJsZWRTdGF0ZSB0byBhbHdheXMgYmUgY2FsbGVkIHdoZW4gYSBDVkEgaXMgYWRkZWQsIHJlZ2FyZGxlc3Mgb2ZcbiAqIHdoZXRoZXIgdGhlIGNvbnRyb2wgaXMgZGlzYWJsZWQgb3IgZW5hYmxlZC5cbiAqXG4gKiBAc2VlIHtAbGluayBGb3Jtc01vZHVsZSN3aXRoY29uZmlnfVxuICovXG5jb25zdCBDQUxMX1NFVF9ESVNBQkxFRF9TVEFURSA9IG5ldyBJbmplY3Rpb25Ub2tlbignQ2FsbFNldERpc2FibGVkU3RhdGUnLCB7IHByb3ZpZGVkSW46ICdyb290JywgZmFjdG9yeTogKCkgPT4gc2V0RGlzYWJsZWRTdGF0ZURlZmF1bHQgfSk7XG4vKipcbiAqIFdoZXRoZXIgdG8gdXNlIHRoZSBmaXhlZCBzZXREaXNhYmxlZFN0YXRlIGJlaGF2aW9yIGJ5IGRlZmF1bHQuXG4gKi9cbmNvbnN0IHNldERpc2FibGVkU3RhdGVEZWZhdWx0ID0gJ2Fsd2F5cyc7XG5mdW5jdGlvbiBjb250cm9sUGF0aChuYW1lLCBwYXJlbnQpIHtcbiAgICByZXR1cm4gWy4uLnBhcmVudC5wYXRoLCBuYW1lXTtcbn1cbi8qKlxuICogTGlua3MgYSBGb3JtIGNvbnRyb2wgYW5kIGEgRm9ybSBkaXJlY3RpdmUgYnkgc2V0dGluZyB1cCBjYWxsYmFja3MgKHN1Y2ggYXMgYG9uQ2hhbmdlYCkgb24gYm90aFxuICogaW5zdGFuY2VzLiBUaGlzIGZ1bmN0aW9uIGlzIHR5cGljYWxseSBpbnZva2VkIHdoZW4gZm9ybSBkaXJlY3RpdmUgaXMgYmVpbmcgaW5pdGlhbGl6ZWQuXG4gKlxuICogQHBhcmFtIGNvbnRyb2wgRm9ybSBjb250cm9sIGluc3RhbmNlIHRoYXQgc2hvdWxkIGJlIGxpbmtlZC5cbiAqIEBwYXJhbSBkaXIgRGlyZWN0aXZlIHRoYXQgc2hvdWxkIGJlIGxpbmtlZCB3aXRoIGEgZ2l2ZW4gY29udHJvbC5cbiAqL1xuZnVuY3Rpb24gc2V0VXBDb250cm9sKGNvbnRyb2wsIGRpciwgY2FsbFNldERpc2FibGVkU3RhdGUgPSBzZXREaXNhYmxlZFN0YXRlRGVmYXVsdCkge1xuICAgIGlmICh0eXBlb2YgbmdEZXZNb2RlID09PSAndW5kZWZpbmVkJyB8fCBuZ0Rldk1vZGUpIHtcbiAgICAgICAgaWYgKCFjb250cm9sKVxuICAgICAgICAgICAgX3Rocm93RXJyb3IoZGlyLCAnQ2Fubm90IGZpbmQgY29udHJvbCB3aXRoJyk7XG4gICAgICAgIGlmICghZGlyLnZhbHVlQWNjZXNzb3IpXG4gICAgICAgICAgICBfdGhyb3dNaXNzaW5nVmFsdWVBY2Nlc3NvckVycm9yKGRpcik7XG4gICAgfVxuICAgIHNldFVwVmFsaWRhdG9ycyhjb250cm9sLCBkaXIpO1xuICAgIGRpci52YWx1ZUFjY2Vzc29yLndyaXRlVmFsdWUoY29udHJvbC52YWx1ZSk7XG4gICAgLy8gVGhlIGxlZ2FjeSBiZWhhdmlvciBvbmx5IGNhbGxzIHRoZSBDVkEncyBgc2V0RGlzYWJsZWRTdGF0ZWAgaWYgdGhlIGNvbnRyb2wgaXMgZGlzYWJsZWQuXG4gICAgLy8gSWYgdGhlIGBjYWxsU2V0RGlzYWJsZWRTdGF0ZWAgb3B0aW9uIGlzIHNldCB0byBgYWx3YXlzYCwgdGhlbiB0aGlzIGJ1ZyBpcyBmaXhlZCBhbmRcbiAgICAvLyB0aGUgbWV0aG9kIGlzIGFsd2F5cyBjYWxsZWQuXG4gICAgaWYgKGNvbnRyb2wuZGlzYWJsZWQgfHwgY2FsbFNldERpc2FibGVkU3RhdGUgPT09ICdhbHdheXMnKSB7XG4gICAgICAgIGRpci52YWx1ZUFjY2Vzc29yLnNldERpc2FibGVkU3RhdGU/Lihjb250cm9sLmRpc2FibGVkKTtcbiAgICB9XG4gICAgc2V0VXBWaWV3Q2hhbmdlUGlwZWxpbmUoY29udHJvbCwgZGlyKTtcbiAgICBzZXRVcE1vZGVsQ2hhbmdlUGlwZWxpbmUoY29udHJvbCwgZGlyKTtcbiAgICBzZXRVcEJsdXJQaXBlbGluZShjb250cm9sLCBkaXIpO1xuICAgIHNldFVwRGlzYWJsZWRDaGFuZ2VIYW5kbGVyKGNvbnRyb2wsIGRpcik7XG59XG4vKipcbiAqIFJldmVydHMgY29uZmlndXJhdGlvbiBwZXJmb3JtZWQgYnkgdGhlIGBzZXRVcENvbnRyb2xgIGNvbnRyb2wgZnVuY3Rpb24uXG4gKiBFZmZlY3RpdmVseSBkaXNjb25uZWN0cyBmb3JtIGNvbnRyb2wgd2l0aCBhIGdpdmVuIGZvcm0gZGlyZWN0aXZlLlxuICogVGhpcyBmdW5jdGlvbiBpcyB0eXBpY2FsbHkgaW52b2tlZCB3aGVuIGNvcnJlc3BvbmRpbmcgZm9ybSBkaXJlY3RpdmUgaXMgYmVpbmcgZGVzdHJveWVkLlxuICpcbiAqIEBwYXJhbSBjb250cm9sIEZvcm0gY29udHJvbCB3aGljaCBzaG91bGQgYmUgY2xlYW5lZCB1cC5cbiAqIEBwYXJhbSBkaXIgRGlyZWN0aXZlIHRoYXQgc2hvdWxkIGJlIGRpc2Nvbm5lY3RlZCBmcm9tIGEgZ2l2ZW4gY29udHJvbC5cbiAqIEBwYXJhbSB2YWxpZGF0ZUNvbnRyb2xQcmVzZW5jZU9uQ2hhbmdlIEZsYWcgdGhhdCBpbmRpY2F0ZXMgd2hldGhlciBvbkNoYW5nZSBoYW5kbGVyIHNob3VsZFxuICogICAgIGNvbnRhaW4gYXNzZXJ0cyB0byB2ZXJpZnkgdGhhdCBpdCdzIG5vdCBjYWxsZWQgb25jZSBkaXJlY3RpdmUgaXMgZGVzdHJveWVkLiBXZSBuZWVkIHRoaXMgZmxhZ1xuICogICAgIHRvIGF2b2lkIHBvdGVudGlhbGx5IGJyZWFraW5nIGNoYW5nZXMgY2F1c2VkIGJ5IGJldHRlciBjb250cm9sIGNsZWFudXAgaW50cm9kdWNlZCBpbiAjMzkyMzUuXG4gKi9cbmZ1bmN0aW9uIGNsZWFuVXBDb250cm9sKGNvbnRyb2wsIGRpciwgdmFsaWRhdGVDb250cm9sUHJlc2VuY2VPbkNoYW5nZSA9IHRydWUpIHtcbiAgICBjb25zdCBub29wID0gKCkgPT4ge1xuICAgICAgICBpZiAodmFsaWRhdGVDb250cm9sUHJlc2VuY2VPbkNoYW5nZSAmJiAodHlwZW9mIG5nRGV2TW9kZSA9PT0gJ3VuZGVmaW5lZCcgfHwgbmdEZXZNb2RlKSkge1xuICAgICAgICAgICAgX25vQ29udHJvbEVycm9yKGRpcik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8vIFRoZSBgdmFsdWVBY2Nlc3NvcmAgZmllbGQgaXMgdHlwaWNhbGx5IGRlZmluZWQgb24gRnJvbUNvbnRyb2wgYW5kIEZvcm1Db250cm9sTmFtZSBkaXJlY3RpdmVcbiAgICAvLyBpbnN0YW5jZXMgYW5kIHRoZXJlIGlzIGEgbG9naWMgaW4gYHNlbGVjdFZhbHVlQWNjZXNzb3JgIGZ1bmN0aW9uIHRoYXQgdGhyb3dzIGlmIGl0J3Mgbm90IHRoZVxuICAgIC8vIGNhc2UuIFdlIHN0aWxsIGNoZWNrIHRoZSBwcmVzZW5jZSBvZiBgdmFsdWVBY2Nlc3NvcmAgYmVmb3JlIGludm9raW5nIGl0cyBtZXRob2RzIHRvIG1ha2Ugc3VyZVxuICAgIC8vIHRoYXQgY2xlYW51cCB3b3JrcyBjb3JyZWN0bHkgaWYgYXBwIGNvZGUgb3IgdGVzdHMgYXJlIHNldHVwIHRvIGlnbm9yZSB0aGUgZXJyb3IgdGhyb3duIGZyb21cbiAgICAvLyBgc2VsZWN0VmFsdWVBY2Nlc3NvcmAuIFNlZSBodHRwczovL2dpdGh1Yi5jb20vYW5ndWxhci9hbmd1bGFyL2lzc3Vlcy80MDUyMS5cbiAgICBpZiAoZGlyLnZhbHVlQWNjZXNzb3IpIHtcbiAgICAgICAgZGlyLnZhbHVlQWNjZXNzb3IucmVnaXN0ZXJPbkNoYW5nZShub29wKTtcbiAgICAgICAgZGlyLnZhbHVlQWNjZXNzb3IucmVnaXN0ZXJPblRvdWNoZWQobm9vcCk7XG4gICAgfVxuICAgIGNsZWFuVXBWYWxpZGF0b3JzKGNvbnRyb2wsIGRpcik7XG4gICAgaWYgKGNvbnRyb2wpIHtcbiAgICAgICAgZGlyLl9pbnZva2VPbkRlc3Ryb3lDYWxsYmFja3MoKTtcbiAgICAgICAgY29udHJvbC5fcmVnaXN0ZXJPbkNvbGxlY3Rpb25DaGFuZ2UoKCkgPT4geyB9KTtcbiAgICB9XG59XG5mdW5jdGlvbiByZWdpc3Rlck9uVmFsaWRhdG9yQ2hhbmdlKHZhbGlkYXRvcnMsIG9uQ2hhbmdlKSB7XG4gICAgdmFsaWRhdG9ycy5mb3JFYWNoKCh2YWxpZGF0b3IpID0+IHtcbiAgICAgICAgaWYgKHZhbGlkYXRvci5yZWdpc3Rlck9uVmFsaWRhdG9yQ2hhbmdlKVxuICAgICAgICAgICAgdmFsaWRhdG9yLnJlZ2lzdGVyT25WYWxpZGF0b3JDaGFuZ2Uob25DaGFuZ2UpO1xuICAgIH0pO1xufVxuLyoqXG4gKiBTZXRzIHVwIGRpc2FibGVkIGNoYW5nZSBoYW5kbGVyIGZ1bmN0aW9uIG9uIGEgZ2l2ZW4gZm9ybSBjb250cm9sIGlmIENvbnRyb2xWYWx1ZUFjY2Vzc29yXG4gKiBhc3NvY2lhdGVkIHdpdGggYSBnaXZlbiBkaXJlY3RpdmUgaW5zdGFuY2Ugc3VwcG9ydHMgdGhlIGBzZXREaXNhYmxlZFN0YXRlYCBjYWxsLlxuICpcbiAqIEBwYXJhbSBjb250cm9sIEZvcm0gY29udHJvbCB3aGVyZSBkaXNhYmxlZCBjaGFuZ2UgaGFuZGxlciBzaG91bGQgYmUgc2V0dXAuXG4gKiBAcGFyYW0gZGlyIENvcnJlc3BvbmRpbmcgZGlyZWN0aXZlIGluc3RhbmNlIGFzc29jaWF0ZWQgd2l0aCB0aGlzIGNvbnRyb2wuXG4gKi9cbmZ1bmN0aW9uIHNldFVwRGlzYWJsZWRDaGFuZ2VIYW5kbGVyKGNvbnRyb2wsIGRpcikge1xuICAgIGlmIChkaXIudmFsdWVBY2Nlc3Nvci5zZXREaXNhYmxlZFN0YXRlKSB7XG4gICAgICAgIGNvbnN0IG9uRGlzYWJsZWRDaGFuZ2UgPSAoaXNEaXNhYmxlZCkgPT4ge1xuICAgICAgICAgICAgZGlyLnZhbHVlQWNjZXNzb3Iuc2V0RGlzYWJsZWRTdGF0ZShpc0Rpc2FibGVkKTtcbiAgICAgICAgfTtcbiAgICAgICAgY29udHJvbC5yZWdpc3Rlck9uRGlzYWJsZWRDaGFuZ2Uob25EaXNhYmxlZENoYW5nZSk7XG4gICAgICAgIC8vIFJlZ2lzdGVyIGEgY2FsbGJhY2sgZnVuY3Rpb24gdG8gY2xlYW51cCBkaXNhYmxlZCBjaGFuZ2UgaGFuZGxlclxuICAgICAgICAvLyBmcm9tIGEgY29udHJvbCBpbnN0YW5jZSB3aGVuIGEgZGlyZWN0aXZlIGlzIGRlc3Ryb3llZC5cbiAgICAgICAgZGlyLl9yZWdpc3Rlck9uRGVzdHJveSgoKSA9PiB7XG4gICAgICAgICAgICBjb250cm9sLl91bnJlZ2lzdGVyT25EaXNhYmxlZENoYW5nZShvbkRpc2FibGVkQ2hhbmdlKTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuLyoqXG4gKiBTZXRzIHVwIHN5bmMgYW5kIGFzeW5jIGRpcmVjdGl2ZSB2YWxpZGF0b3JzIG9uIHByb3ZpZGVkIGZvcm0gY29udHJvbC5cbiAqIFRoaXMgZnVuY3Rpb24gbWVyZ2VzIHZhbGlkYXRvcnMgZnJvbSB0aGUgZGlyZWN0aXZlIGludG8gdGhlIHZhbGlkYXRvcnMgb2YgdGhlIGNvbnRyb2wuXG4gKlxuICogQHBhcmFtIGNvbnRyb2wgRm9ybSBjb250cm9sIHdoZXJlIGRpcmVjdGl2ZSB2YWxpZGF0b3JzIHNob3VsZCBiZSBzZXR1cC5cbiAqIEBwYXJhbSBkaXIgRGlyZWN0aXZlIGluc3RhbmNlIHRoYXQgY29udGFpbnMgdmFsaWRhdG9ycyB0byBiZSBzZXR1cC5cbiAqL1xuZnVuY3Rpb24gc2V0VXBWYWxpZGF0b3JzKGNvbnRyb2wsIGRpcikge1xuICAgIGNvbnN0IHZhbGlkYXRvcnMgPSBnZXRDb250cm9sVmFsaWRhdG9ycyhjb250cm9sKTtcbiAgICBpZiAoZGlyLnZhbGlkYXRvciAhPT0gbnVsbCkge1xuICAgICAgICBjb250cm9sLnNldFZhbGlkYXRvcnMobWVyZ2VWYWxpZGF0b3JzKHZhbGlkYXRvcnMsIGRpci52YWxpZGF0b3IpKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIHZhbGlkYXRvcnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgLy8gSWYgc3luYyB2YWxpZGF0b3JzIGFyZSByZXByZXNlbnRlZCBieSBhIHNpbmdsZSB2YWxpZGF0b3IgZnVuY3Rpb24sIHdlIGZvcmNlIHRoZVxuICAgICAgICAvLyBgVmFsaWRhdG9ycy5jb21wb3NlYCBjYWxsIHRvIGhhcHBlbiBieSBleGVjdXRpbmcgdGhlIGBzZXRWYWxpZGF0b3JzYCBmdW5jdGlvbiB3aXRoXG4gICAgICAgIC8vIGFuIGFycmF5IHRoYXQgY29udGFpbnMgdGhhdCBmdW5jdGlvbi4gV2UgbmVlZCB0aGlzIHRvIGF2b2lkIHBvc3NpYmxlIGRpc2NyZXBhbmNpZXMgaW5cbiAgICAgICAgLy8gdmFsaWRhdG9ycyBiZWhhdmlvciwgc28gc3luYyB2YWxpZGF0b3JzIGFyZSBhbHdheXMgcHJvY2Vzc2VkIGJ5IHRoZSBgVmFsaWRhdG9ycy5jb21wb3NlYC5cbiAgICAgICAgLy8gTm90ZTogd2Ugc2hvdWxkIGNvbnNpZGVyIG1vdmluZyB0aGlzIGxvZ2ljIGluc2lkZSB0aGUgYHNldFZhbGlkYXRvcnNgIGZ1bmN0aW9uIGl0c2VsZiwgc28gd2VcbiAgICAgICAgLy8gaGF2ZSBjb25zaXN0ZW50IGJlaGF2aW9yIG9uIEFic3RyYWN0Q29udHJvbCBBUEkgbGV2ZWwuIFRoZSBzYW1lIGFwcGxpZXMgdG8gdGhlIGFzeW5jXG4gICAgICAgIC8vIHZhbGlkYXRvcnMgbG9naWMgYmVsb3cuXG4gICAgICAgIGNvbnRyb2wuc2V0VmFsaWRhdG9ycyhbdmFsaWRhdG9yc10pO1xuICAgIH1cbiAgICBjb25zdCBhc3luY1ZhbGlkYXRvcnMgPSBnZXRDb250cm9sQXN5bmNWYWxpZGF0b3JzKGNvbnRyb2wpO1xuICAgIGlmIChkaXIuYXN5bmNWYWxpZGF0b3IgIT09IG51bGwpIHtcbiAgICAgICAgY29udHJvbC5zZXRBc3luY1ZhbGlkYXRvcnMobWVyZ2VWYWxpZGF0b3JzKGFzeW5jVmFsaWRhdG9ycywgZGlyLmFzeW5jVmFsaWRhdG9yKSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiBhc3luY1ZhbGlkYXRvcnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgY29udHJvbC5zZXRBc3luY1ZhbGlkYXRvcnMoW2FzeW5jVmFsaWRhdG9yc10pO1xuICAgIH1cbiAgICAvLyBSZS1ydW4gdmFsaWRhdGlvbiB3aGVuIHZhbGlkYXRvciBiaW5kaW5nIGNoYW5nZXMsIGUuZy4gbWlubGVuZ3RoPTMgLT4gbWlubGVuZ3RoPTRcbiAgICBjb25zdCBvblZhbGlkYXRvckNoYW5nZSA9ICgpID0+IGNvbnRyb2wudXBkYXRlVmFsdWVBbmRWYWxpZGl0eSgpO1xuICAgIHJlZ2lzdGVyT25WYWxpZGF0b3JDaGFuZ2UoZGlyLl9yYXdWYWxpZGF0b3JzLCBvblZhbGlkYXRvckNoYW5nZSk7XG4gICAgcmVnaXN0ZXJPblZhbGlkYXRvckNoYW5nZShkaXIuX3Jhd0FzeW5jVmFsaWRhdG9ycywgb25WYWxpZGF0b3JDaGFuZ2UpO1xufVxuLyoqXG4gKiBDbGVhbnMgdXAgc3luYyBhbmQgYXN5bmMgZGlyZWN0aXZlIHZhbGlkYXRvcnMgb24gcHJvdmlkZWQgZm9ybSBjb250cm9sLlxuICogVGhpcyBmdW5jdGlvbiByZXZlcnRzIHRoZSBzZXR1cCBwZXJmb3JtZWQgYnkgdGhlIGBzZXRVcFZhbGlkYXRvcnNgIGZ1bmN0aW9uLCBpLmUuXG4gKiByZW1vdmVzIGRpcmVjdGl2ZS1zcGVjaWZpYyB2YWxpZGF0b3JzIGZyb20gYSBnaXZlbiBjb250cm9sIGluc3RhbmNlLlxuICpcbiAqIEBwYXJhbSBjb250cm9sIEZvcm0gY29udHJvbCBmcm9tIHdoZXJlIGRpcmVjdGl2ZSB2YWxpZGF0b3JzIHNob3VsZCBiZSByZW1vdmVkLlxuICogQHBhcmFtIGRpciBEaXJlY3RpdmUgaW5zdGFuY2UgdGhhdCBjb250YWlucyB2YWxpZGF0b3JzIHRvIGJlIHJlbW92ZWQuXG4gKiBAcmV0dXJucyB0cnVlIGlmIGEgY29udHJvbCB3YXMgdXBkYXRlZCBhcyBhIHJlc3VsdCBvZiB0aGlzIGFjdGlvbi5cbiAqL1xuZnVuY3Rpb24gY2xlYW5VcFZhbGlkYXRvcnMoY29udHJvbCwgZGlyKSB7XG4gICAgbGV0IGlzQ29udHJvbFVwZGF0ZWQgPSBmYWxzZTtcbiAgICBpZiAoY29udHJvbCAhPT0gbnVsbCkge1xuICAgICAgICBpZiAoZGlyLnZhbGlkYXRvciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgY29uc3QgdmFsaWRhdG9ycyA9IGdldENvbnRyb2xWYWxpZGF0b3JzKGNvbnRyb2wpO1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsaWRhdG9ycykgJiYgdmFsaWRhdG9ycy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgLy8gRmlsdGVyIG91dCBkaXJlY3RpdmUgdmFsaWRhdG9yIGZ1bmN0aW9uLlxuICAgICAgICAgICAgICAgIGNvbnN0IHVwZGF0ZWRWYWxpZGF0b3JzID0gdmFsaWRhdG9ycy5maWx0ZXIoKHZhbGlkYXRvcikgPT4gdmFsaWRhdG9yICE9PSBkaXIudmFsaWRhdG9yKTtcbiAgICAgICAgICAgICAgICBpZiAodXBkYXRlZFZhbGlkYXRvcnMubGVuZ3RoICE9PSB2YWxpZGF0b3JzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBpc0NvbnRyb2xVcGRhdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgY29udHJvbC5zZXRWYWxpZGF0b3JzKHVwZGF0ZWRWYWxpZGF0b3JzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRpci5hc3luY1ZhbGlkYXRvciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgY29uc3QgYXN5bmNWYWxpZGF0b3JzID0gZ2V0Q29udHJvbEFzeW5jVmFsaWRhdG9ycyhjb250cm9sKTtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGFzeW5jVmFsaWRhdG9ycykgJiYgYXN5bmNWYWxpZGF0b3JzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAvLyBGaWx0ZXIgb3V0IGRpcmVjdGl2ZSBhc3luYyB2YWxpZGF0b3IgZnVuY3Rpb24uXG4gICAgICAgICAgICAgICAgY29uc3QgdXBkYXRlZEFzeW5jVmFsaWRhdG9ycyA9IGFzeW5jVmFsaWRhdG9ycy5maWx0ZXIoKGFzeW5jVmFsaWRhdG9yKSA9PiBhc3luY1ZhbGlkYXRvciAhPT0gZGlyLmFzeW5jVmFsaWRhdG9yKTtcbiAgICAgICAgICAgICAgICBpZiAodXBkYXRlZEFzeW5jVmFsaWRhdG9ycy5sZW5ndGggIT09IGFzeW5jVmFsaWRhdG9ycy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgaXNDb250cm9sVXBkYXRlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRyb2wuc2V0QXN5bmNWYWxpZGF0b3JzKHVwZGF0ZWRBc3luY1ZhbGlkYXRvcnMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBDbGVhciBvblZhbGlkYXRvckNoYW5nZSBjYWxsYmFja3MgYnkgcHJvdmlkaW5nIGEgbm9vcCBmdW5jdGlvbi5cbiAgICBjb25zdCBub29wID0gKCkgPT4geyB9O1xuICAgIHJlZ2lzdGVyT25WYWxpZGF0b3JDaGFuZ2UoZGlyLl9yYXdWYWxpZGF0b3JzLCBub29wKTtcbiAgICByZWdpc3Rlck9uVmFsaWRhdG9yQ2hhbmdlKGRpci5fcmF3QXN5bmNWYWxpZGF0b3JzLCBub29wKTtcbiAgICByZXR1cm4gaXNDb250cm9sVXBkYXRlZDtcbn1cbmZ1bmN0aW9uIHNldFVwVmlld0NoYW5nZVBpcGVsaW5lKGNvbnRyb2wsIGRpcikge1xuICAgIGRpci52YWx1ZUFjY2Vzc29yLnJlZ2lzdGVyT25DaGFuZ2UoKG5ld1ZhbHVlKSA9PiB7XG4gICAgICAgIGNvbnRyb2wuX3BlbmRpbmdWYWx1ZSA9IG5ld1ZhbHVlO1xuICAgICAgICBjb250cm9sLl9wZW5kaW5nQ2hhbmdlID0gdHJ1ZTtcbiAgICAgICAgY29udHJvbC5fcGVuZGluZ0RpcnR5ID0gdHJ1ZTtcbiAgICAgICAgaWYgKGNvbnRyb2wudXBkYXRlT24gPT09ICdjaGFuZ2UnKVxuICAgICAgICAgICAgdXBkYXRlQ29udHJvbChjb250cm9sLCBkaXIpO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gc2V0VXBCbHVyUGlwZWxpbmUoY29udHJvbCwgZGlyKSB7XG4gICAgZGlyLnZhbHVlQWNjZXNzb3IucmVnaXN0ZXJPblRvdWNoZWQoKCkgPT4ge1xuICAgICAgICBjb250cm9sLl9wZW5kaW5nVG91Y2hlZCA9IHRydWU7XG4gICAgICAgIGlmIChjb250cm9sLnVwZGF0ZU9uID09PSAnYmx1cicgJiYgY29udHJvbC5fcGVuZGluZ0NoYW5nZSlcbiAgICAgICAgICAgIHVwZGF0ZUNvbnRyb2woY29udHJvbCwgZGlyKTtcbiAgICAgICAgaWYgKGNvbnRyb2wudXBkYXRlT24gIT09ICdzdWJtaXQnKVxuICAgICAgICAgICAgY29udHJvbC5tYXJrQXNUb3VjaGVkKCk7XG4gICAgfSk7XG59XG5mdW5jdGlvbiB1cGRhdGVDb250cm9sKGNvbnRyb2wsIGRpcikge1xuICAgIGlmIChjb250cm9sLl9wZW5kaW5nRGlydHkpXG4gICAgICAgIGNvbnRyb2wubWFya0FzRGlydHkoKTtcbiAgICBjb250cm9sLnNldFZhbHVlKGNvbnRyb2wuX3BlbmRpbmdWYWx1ZSwgeyBlbWl0TW9kZWxUb1ZpZXdDaGFuZ2U6IGZhbHNlIH0pO1xuICAgIGRpci52aWV3VG9Nb2RlbFVwZGF0ZShjb250cm9sLl9wZW5kaW5nVmFsdWUpO1xuICAgIGNvbnRyb2wuX3BlbmRpbmdDaGFuZ2UgPSBmYWxzZTtcbn1cbmZ1bmN0aW9uIHNldFVwTW9kZWxDaGFuZ2VQaXBlbGluZShjb250cm9sLCBkaXIpIHtcbiAgICBjb25zdCBvbkNoYW5nZSA9IChuZXdWYWx1ZSwgZW1pdE1vZGVsRXZlbnQpID0+IHtcbiAgICAgICAgLy8gY29udHJvbCAtPiB2aWV3XG4gICAgICAgIGRpci52YWx1ZUFjY2Vzc29yLndyaXRlVmFsdWUobmV3VmFsdWUpO1xuICAgICAgICAvLyBjb250cm9sIC0+IG5nTW9kZWxcbiAgICAgICAgaWYgKGVtaXRNb2RlbEV2ZW50KVxuICAgICAgICAgICAgZGlyLnZpZXdUb01vZGVsVXBkYXRlKG5ld1ZhbHVlKTtcbiAgICB9O1xuICAgIGNvbnRyb2wucmVnaXN0ZXJPbkNoYW5nZShvbkNoYW5nZSk7XG4gICAgLy8gUmVnaXN0ZXIgYSBjYWxsYmFjayBmdW5jdGlvbiB0byBjbGVhbnVwIG9uQ2hhbmdlIGhhbmRsZXJcbiAgICAvLyBmcm9tIGEgY29udHJvbCBpbnN0YW5jZSB3aGVuIGEgZGlyZWN0aXZlIGlzIGRlc3Ryb3llZC5cbiAgICBkaXIuX3JlZ2lzdGVyT25EZXN0cm95KCgpID0+IHtcbiAgICAgICAgY29udHJvbC5fdW5yZWdpc3Rlck9uQ2hhbmdlKG9uQ2hhbmdlKTtcbiAgICB9KTtcbn1cbi8qKlxuICogTGlua3MgYSBGb3JtR3JvdXAgb3IgRm9ybUFycmF5IGluc3RhbmNlIGFuZCBjb3JyZXNwb25kaW5nIEZvcm0gZGlyZWN0aXZlIGJ5IHNldHRpbmcgdXAgdmFsaWRhdG9yc1xuICogcHJlc2VudCBpbiB0aGUgdmlldy5cbiAqXG4gKiBAcGFyYW0gY29udHJvbCBGb3JtR3JvdXAgb3IgRm9ybUFycmF5IGluc3RhbmNlIHRoYXQgc2hvdWxkIGJlIGxpbmtlZC5cbiAqIEBwYXJhbSBkaXIgRGlyZWN0aXZlIHRoYXQgcHJvdmlkZXMgdmlldyB2YWxpZGF0b3JzLlxuICovXG5mdW5jdGlvbiBzZXRVcEZvcm1Db250YWluZXIoY29udHJvbCwgZGlyKSB7XG4gICAgaWYgKGNvbnRyb2wgPT0gbnVsbCAmJiAodHlwZW9mIG5nRGV2TW9kZSA9PT0gJ3VuZGVmaW5lZCcgfHwgbmdEZXZNb2RlKSlcbiAgICAgICAgX3Rocm93RXJyb3IoZGlyLCAnQ2Fubm90IGZpbmQgY29udHJvbCB3aXRoJyk7XG4gICAgc2V0VXBWYWxpZGF0b3JzKGNvbnRyb2wsIGRpcik7XG59XG4vKipcbiAqIFJldmVydHMgdGhlIHNldHVwIHBlcmZvcm1lZCBieSB0aGUgYHNldFVwRm9ybUNvbnRhaW5lcmAgZnVuY3Rpb24uXG4gKlxuICogQHBhcmFtIGNvbnRyb2wgRm9ybUdyb3VwIG9yIEZvcm1BcnJheSBpbnN0YW5jZSB0aGF0IHNob3VsZCBiZSBjbGVhbmVkIHVwLlxuICogQHBhcmFtIGRpciBEaXJlY3RpdmUgdGhhdCBwcm92aWRlZCB2aWV3IHZhbGlkYXRvcnMuXG4gKiBAcmV0dXJucyB0cnVlIGlmIGEgY29udHJvbCB3YXMgdXBkYXRlZCBhcyBhIHJlc3VsdCBvZiB0aGlzIGFjdGlvbi5cbiAqL1xuZnVuY3Rpb24gY2xlYW5VcEZvcm1Db250YWluZXIoY29udHJvbCwgZGlyKSB7XG4gICAgcmV0dXJuIGNsZWFuVXBWYWxpZGF0b3JzKGNvbnRyb2wsIGRpcik7XG59XG5mdW5jdGlvbiBfbm9Db250cm9sRXJyb3IoZGlyKSB7XG4gICAgcmV0dXJuIF90aHJvd0Vycm9yKGRpciwgJ1RoZXJlIGlzIG5vIEZvcm1Db250cm9sIGluc3RhbmNlIGF0dGFjaGVkIHRvIGZvcm0gY29udHJvbCBlbGVtZW50IHdpdGgnKTtcbn1cbmZ1bmN0aW9uIF90aHJvd0Vycm9yKGRpciwgbWVzc2FnZSkge1xuICAgIGNvbnN0IG1lc3NhZ2VFbmQgPSBfZGVzY3JpYmVDb250cm9sTG9jYXRpb24oZGlyKTtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYCR7bWVzc2FnZX0gJHttZXNzYWdlRW5kfWApO1xufVxuZnVuY3Rpb24gX2Rlc2NyaWJlQ29udHJvbExvY2F0aW9uKGRpcikge1xuICAgIGNvbnN0IHBhdGggPSBkaXIucGF0aDtcbiAgICBpZiAocGF0aCAmJiBwYXRoLmxlbmd0aCA+IDEpXG4gICAgICAgIHJldHVybiBgcGF0aDogJyR7cGF0aC5qb2luKCcgLT4gJyl9J2A7XG4gICAgaWYgKHBhdGg/LlswXSlcbiAgICAgICAgcmV0dXJuIGBuYW1lOiAnJHtwYXRofSdgO1xuICAgIHJldHVybiAndW5zcGVjaWZpZWQgbmFtZSBhdHRyaWJ1dGUnO1xufVxuZnVuY3Rpb24gX3Rocm93TWlzc2luZ1ZhbHVlQWNjZXNzb3JFcnJvcihkaXIpIHtcbiAgICBjb25zdCBsb2MgPSBfZGVzY3JpYmVDb250cm9sTG9jYXRpb24oZGlyKTtcbiAgICB0aHJvdyBuZXcgybVSdW50aW1lRXJyb3IoLTEyMDMgLyogUnVudGltZUVycm9yQ29kZS5OR19NSVNTSU5HX1ZBTFVFX0FDQ0VTU09SICovLCBgTm8gdmFsdWUgYWNjZXNzb3IgZm9yIGZvcm0gY29udHJvbCAke2xvY30uYCk7XG59XG5mdW5jdGlvbiBfdGhyb3dJbnZhbGlkVmFsdWVBY2Nlc3NvckVycm9yKGRpcikge1xuICAgIGNvbnN0IGxvYyA9IF9kZXNjcmliZUNvbnRyb2xMb2NhdGlvbihkaXIpO1xuICAgIHRocm93IG5ldyDJtVJ1bnRpbWVFcnJvcigxMjAwIC8qIFJ1bnRpbWVFcnJvckNvZGUuTkdfVkFMVUVfQUNDRVNTT1JfTk9UX1BST1ZJREVEICovLCBgVmFsdWUgYWNjZXNzb3Igd2FzIG5vdCBwcm92aWRlZCBhcyBhbiBhcnJheSBmb3IgZm9ybSBjb250cm9sIHdpdGggJHtsb2N9LiBgICtcbiAgICAgICAgYENoZWNrIHRoYXQgdGhlIFxcYE5HX1ZBTFVFX0FDQ0VTU09SXFxgIHRva2VuIGlzIGNvbmZpZ3VyZWQgYXMgYSBcXGBtdWx0aTogdHJ1ZVxcYCBwcm92aWRlci5gKTtcbn1cbmZ1bmN0aW9uIGlzUHJvcGVydHlVcGRhdGVkKGNoYW5nZXMsIHZpZXdNb2RlbCkge1xuICAgIGlmICghY2hhbmdlcy5oYXNPd25Qcm9wZXJ0eSgnbW9kZWwnKSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGNvbnN0IGNoYW5nZSA9IGNoYW5nZXNbJ21vZGVsJ107XG4gICAgaWYgKGNoYW5nZS5pc0ZpcnN0Q2hhbmdlKCkpXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIHJldHVybiAhT2JqZWN0LmlzKHZpZXdNb2RlbCwgY2hhbmdlLmN1cnJlbnRWYWx1ZSk7XG59XG5mdW5jdGlvbiBpc0J1aWx0SW5BY2Nlc3Nvcih2YWx1ZUFjY2Vzc29yKSB7XG4gICAgLy8gQ2hlY2sgaWYgYSBnaXZlbiB2YWx1ZSBhY2Nlc3NvciBpcyBhbiBpbnN0YW5jZSBvZiBhIGNsYXNzIHRoYXQgZGlyZWN0bHkgZXh0ZW5kc1xuICAgIC8vIGBCdWlsdEluQ29udHJvbFZhbHVlQWNjZXNzb3JgIG9uZS5cbiAgICByZXR1cm4gT2JqZWN0LmdldFByb3RvdHlwZU9mKHZhbHVlQWNjZXNzb3IuY29uc3RydWN0b3IpID09PSBCdWlsdEluQ29udHJvbFZhbHVlQWNjZXNzb3I7XG59XG5mdW5jdGlvbiBzeW5jUGVuZGluZ0NvbnRyb2xzKGZvcm0sIGRpcmVjdGl2ZXMpIHtcbiAgICBmb3JtLl9zeW5jUGVuZGluZ0NvbnRyb2xzKCk7XG4gICAgZGlyZWN0aXZlcy5mb3JFYWNoKChkaXIpID0+IHtcbiAgICAgICAgY29uc3QgY29udHJvbCA9IGRpci5jb250cm9sO1xuICAgICAgICBpZiAoY29udHJvbC51cGRhdGVPbiA9PT0gJ3N1Ym1pdCcgJiYgY29udHJvbC5fcGVuZGluZ0NoYW5nZSkge1xuICAgICAgICAgICAgZGlyLnZpZXdUb01vZGVsVXBkYXRlKGNvbnRyb2wuX3BlbmRpbmdWYWx1ZSk7XG4gICAgICAgICAgICBjb250cm9sLl9wZW5kaW5nQ2hhbmdlID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbi8vIFRPRE86IHZzYXZraW4gcmVtb3ZlIGl0IG9uY2UgaHR0cHM6Ly9naXRodWIuY29tL2FuZ3VsYXIvYW5ndWxhci9pc3N1ZXMvMzAxMSBpcyBpbXBsZW1lbnRlZFxuZnVuY3Rpb24gc2VsZWN0VmFsdWVBY2Nlc3NvcihkaXIsIHZhbHVlQWNjZXNzb3JzKSB7XG4gICAgaWYgKCF2YWx1ZUFjY2Vzc29ycylcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHZhbHVlQWNjZXNzb3JzKSAmJiAodHlwZW9mIG5nRGV2TW9kZSA9PT0gJ3VuZGVmaW5lZCcgfHwgbmdEZXZNb2RlKSlcbiAgICAgICAgX3Rocm93SW52YWxpZFZhbHVlQWNjZXNzb3JFcnJvcihkaXIpO1xuICAgIGxldCBkZWZhdWx0QWNjZXNzb3IgPSB1bmRlZmluZWQ7XG4gICAgbGV0IGJ1aWx0aW5BY2Nlc3NvciA9IHVuZGVmaW5lZDtcbiAgICBsZXQgY3VzdG9tQWNjZXNzb3IgPSB1bmRlZmluZWQ7XG4gICAgdmFsdWVBY2Nlc3NvcnMuZm9yRWFjaCgodikgPT4ge1xuICAgICAgICBpZiAodi5jb25zdHJ1Y3RvciA9PT0gRGVmYXVsdFZhbHVlQWNjZXNzb3IpIHtcbiAgICAgICAgICAgIGRlZmF1bHRBY2Nlc3NvciA9IHY7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNCdWlsdEluQWNjZXNzb3IodikpIHtcbiAgICAgICAgICAgIGlmIChidWlsdGluQWNjZXNzb3IgJiYgKHR5cGVvZiBuZ0Rldk1vZGUgPT09ICd1bmRlZmluZWQnIHx8IG5nRGV2TW9kZSkpXG4gICAgICAgICAgICAgICAgX3Rocm93RXJyb3IoZGlyLCAnTW9yZSB0aGFuIG9uZSBidWlsdC1pbiB2YWx1ZSBhY2Nlc3NvciBtYXRjaGVzIGZvcm0gY29udHJvbCB3aXRoJyk7XG4gICAgICAgICAgICBidWlsdGluQWNjZXNzb3IgPSB2O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKGN1c3RvbUFjY2Vzc29yICYmICh0eXBlb2YgbmdEZXZNb2RlID09PSAndW5kZWZpbmVkJyB8fCBuZ0Rldk1vZGUpKVxuICAgICAgICAgICAgICAgIF90aHJvd0Vycm9yKGRpciwgJ01vcmUgdGhhbiBvbmUgY3VzdG9tIHZhbHVlIGFjY2Vzc29yIG1hdGNoZXMgZm9ybSBjb250cm9sIHdpdGgnKTtcbiAgICAgICAgICAgIGN1c3RvbUFjY2Vzc29yID0gdjtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIGlmIChjdXN0b21BY2Nlc3NvcilcbiAgICAgICAgcmV0dXJuIGN1c3RvbUFjY2Vzc29yO1xuICAgIGlmIChidWlsdGluQWNjZXNzb3IpXG4gICAgICAgIHJldHVybiBidWlsdGluQWNjZXNzb3I7XG4gICAgaWYgKGRlZmF1bHRBY2Nlc3NvcilcbiAgICAgICAgcmV0dXJuIGRlZmF1bHRBY2Nlc3NvcjtcbiAgICBpZiAodHlwZW9mIG5nRGV2TW9kZSA9PT0gJ3VuZGVmaW5lZCcgfHwgbmdEZXZNb2RlKSB7XG4gICAgICAgIF90aHJvd0Vycm9yKGRpciwgJ05vIHZhbGlkIHZhbHVlIGFjY2Vzc29yIGZvciBmb3JtIGNvbnRyb2wgd2l0aCcpO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIHJlbW92ZUxpc3RJdGVtJDEobGlzdCwgZWwpIHtcbiAgICBjb25zdCBpbmRleCA9IGxpc3QuaW5kZXhPZihlbCk7XG4gICAgaWYgKGluZGV4ID4gLTEpXG4gICAgICAgIGxpc3Quc3BsaWNlKGluZGV4LCAxKTtcbn1cbi8vIFRPRE8oa2FyYSk6IHJlbW92ZSBhZnRlciBkZXByZWNhdGlvbiBwZXJpb2RcbmZ1bmN0aW9uIF9uZ01vZGVsV2FybmluZyhuYW1lLCB0eXBlLCBpbnN0YW5jZSwgd2FybmluZ0NvbmZpZykge1xuICAgIGlmICh3YXJuaW5nQ29uZmlnID09PSAnbmV2ZXInKVxuICAgICAgICByZXR1cm47XG4gICAgaWYgKCgod2FybmluZ0NvbmZpZyA9PT0gbnVsbCB8fCB3YXJuaW5nQ29uZmlnID09PSAnb25jZScpICYmICF0eXBlLl9uZ01vZGVsV2FybmluZ1NlbnRPbmNlKSB8fFxuICAgICAgICAod2FybmluZ0NvbmZpZyA9PT0gJ2Fsd2F5cycgJiYgIWluc3RhbmNlLl9uZ01vZGVsV2FybmluZ1NlbnQpKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihuZ01vZGVsV2FybmluZyhuYW1lKSk7XG4gICAgICAgIHR5cGUuX25nTW9kZWxXYXJuaW5nU2VudE9uY2UgPSB0cnVlO1xuICAgICAgICBpbnN0YW5jZS5fbmdNb2RlbFdhcm5pbmdTZW50ID0gdHJ1ZTtcbiAgICB9XG59XG5cbmNvbnN0IGZvcm1EaXJlY3RpdmVQcm92aWRlciQxID0ge1xuICAgIHByb3ZpZGU6IENvbnRyb2xDb250YWluZXIsXG4gICAgdXNlRXhpc3Rpbmc6IGZvcndhcmRSZWYoKCkgPT4gTmdGb3JtKVxufTtcbmNvbnN0IHJlc29sdmVkUHJvbWlzZSQxID0gKCgpID0+IFByb21pc2UucmVzb2x2ZSgpKSgpO1xuLyoqXG4gKiBAZGVzY3JpcHRpb25cbiAqIENyZWF0ZXMgYSB0b3AtbGV2ZWwgYEZvcm1Hcm91cGAgaW5zdGFuY2UgYW5kIGJpbmRzIGl0IHRvIGEgZm9ybVxuICogdG8gdHJhY2sgYWdncmVnYXRlIGZvcm0gdmFsdWUgYW5kIHZhbGlkYXRpb24gc3RhdHVzLlxuICpcbiAqIEFzIHNvb24gYXMgeW91IGltcG9ydCB0aGUgYEZvcm1zTW9kdWxlYCwgdGhpcyBkaXJlY3RpdmUgYmVjb21lcyBhY3RpdmUgYnkgZGVmYXVsdCBvblxuICogYWxsIGA8Zm9ybT5gIHRhZ3MuICBZb3UgZG9uJ3QgbmVlZCB0byBhZGQgYSBzcGVjaWFsIHNlbGVjdG9yLlxuICpcbiAqIFlvdSBvcHRpb25hbGx5IGV4cG9ydCB0aGUgZGlyZWN0aXZlIGludG8gYSBsb2NhbCB0ZW1wbGF0ZSB2YXJpYWJsZSB1c2luZyBgbmdGb3JtYCBhcyB0aGUga2V5XG4gKiAoZXg6IGAjbXlGb3JtPVwibmdGb3JtXCJgKS4gVGhpcyBpcyBvcHRpb25hbCwgYnV0IHVzZWZ1bC4gIE1hbnkgcHJvcGVydGllcyBmcm9tIHRoZSB1bmRlcmx5aW5nXG4gKiBgRm9ybUdyb3VwYCBpbnN0YW5jZSBhcmUgZHVwbGljYXRlZCBvbiB0aGUgZGlyZWN0aXZlIGl0c2VsZiwgc28gYSByZWZlcmVuY2UgdG8gaXRcbiAqIGdpdmVzIHlvdSBhY2Nlc3MgdG8gdGhlIGFnZ3JlZ2F0ZSB2YWx1ZSBhbmQgdmFsaWRpdHkgc3RhdHVzIG9mIHRoZSBmb3JtLCBhcyB3ZWxsIGFzXG4gKiB1c2VyIGludGVyYWN0aW9uIHByb3BlcnRpZXMgbGlrZSBgZGlydHlgIGFuZCBgdG91Y2hlZGAuXG4gKlxuICogVG8gcmVnaXN0ZXIgY2hpbGQgY29udHJvbHMgd2l0aCB0aGUgZm9ybSwgdXNlIGBOZ01vZGVsYCB3aXRoIGEgYG5hbWVgXG4gKiBhdHRyaWJ1dGUuIFlvdSBtYXkgdXNlIGBOZ01vZGVsR3JvdXBgIHRvIGNyZWF0ZSBzdWItZ3JvdXBzIHdpdGhpbiB0aGUgZm9ybS5cbiAqXG4gKiBJZiBuZWNlc3NhcnksIGxpc3RlbiB0byB0aGUgZGlyZWN0aXZlJ3MgYG5nU3VibWl0YCBldmVudCB0byBiZSBub3RpZmllZCB3aGVuIHRoZSB1c2VyIGhhc1xuICogdHJpZ2dlcmVkIGEgZm9ybSBzdWJtaXNzaW9uLiBUaGUgYG5nU3VibWl0YCBldmVudCBlbWl0cyB0aGUgb3JpZ2luYWwgZm9ybVxuICogc3VibWlzc2lvbiBldmVudC5cbiAqXG4gKiBJbiB0ZW1wbGF0ZSBkcml2ZW4gZm9ybXMsIGFsbCBgPGZvcm0+YCB0YWdzIGFyZSBhdXRvbWF0aWNhbGx5IHRhZ2dlZCBhcyBgTmdGb3JtYC5cbiAqIFRvIGltcG9ydCB0aGUgYEZvcm1zTW9kdWxlYCBidXQgc2tpcCBpdHMgdXNhZ2UgaW4gc29tZSBmb3JtcyxcbiAqIGZvciBleGFtcGxlLCB0byB1c2UgbmF0aXZlIEhUTUw1IHZhbGlkYXRpb24sIGFkZCB0aGUgYG5nTm9Gb3JtYCBhbmQgdGhlIGA8Zm9ybT5gXG4gKiB0YWdzIHdvbid0IGNyZWF0ZSBhbiBgTmdGb3JtYCBkaXJlY3RpdmUuIEluIHJlYWN0aXZlIGZvcm1zLCB1c2luZyBgbmdOb0Zvcm1gIGlzXG4gKiB1bm5lY2Vzc2FyeSBiZWNhdXNlIHRoZSBgPGZvcm0+YCB0YWdzIGFyZSBpbmVydC4gSW4gdGhhdCBjYXNlLCB5b3Ugd291bGRcbiAqIHJlZnJhaW4gZnJvbSB1c2luZyB0aGUgYGZvcm1Hcm91cGAgZGlyZWN0aXZlLlxuICpcbiAqIEB1c2FnZU5vdGVzXG4gKlxuICogIyMjIExpc3RlbmluZyBmb3IgZm9ybSBzdWJtaXNzaW9uXG4gKlxuICogVGhlIGZvbGxvd2luZyBleGFtcGxlIHNob3dzIGhvdyB0byBjYXB0dXJlIHRoZSBmb3JtIHZhbHVlcyBmcm9tIHRoZSBcIm5nU3VibWl0XCIgZXZlbnQuXG4gKlxuICoge0BleGFtcGxlIGZvcm1zL3RzL3NpbXBsZUZvcm0vc2ltcGxlX2Zvcm1fZXhhbXBsZS50cyByZWdpb249J0NvbXBvbmVudCd9XG4gKlxuICogIyMjIFNldHRpbmcgdGhlIHVwZGF0ZSBvcHRpb25zXG4gKlxuICogVGhlIGZvbGxvd2luZyBleGFtcGxlIHNob3dzIHlvdSBob3cgdG8gY2hhbmdlIHRoZSBcInVwZGF0ZU9uXCIgb3B0aW9uIGZyb20gaXRzIGRlZmF1bHQgdXNpbmdcbiAqIG5nRm9ybU9wdGlvbnMuXG4gKlxuICogYGBgaHRtbFxuICogPGZvcm0gW25nRm9ybU9wdGlvbnNdPVwie3VwZGF0ZU9uOiAnYmx1cid9XCI+XG4gKiAgICA8aW5wdXQgbmFtZT1cIm9uZVwiIG5nTW9kZWw+ICA8IS0tIHRoaXMgbmdNb2RlbCB3aWxsIHVwZGF0ZSBvbiBibHVyIC0tPlxuICogPC9mb3JtPlxuICogYGBgXG4gKlxuICogIyMjIE5hdGl2ZSBET00gdmFsaWRhdGlvbiBVSVxuICpcbiAqIEluIG9yZGVyIHRvIHByZXZlbnQgdGhlIG5hdGl2ZSBET00gZm9ybSB2YWxpZGF0aW9uIFVJIGZyb20gaW50ZXJmZXJpbmcgd2l0aCBBbmd1bGFyJ3MgZm9ybVxuICogdmFsaWRhdGlvbiwgQW5ndWxhciBhdXRvbWF0aWNhbGx5IGFkZHMgdGhlIGBub3ZhbGlkYXRlYCBhdHRyaWJ1dGUgb24gYW55IGA8Zm9ybT5gIHdoZW5ldmVyXG4gKiBgRm9ybU1vZHVsZWAgb3IgYFJlYWN0aXZlRm9ybU1vZHVsZWAgYXJlIGltcG9ydGVkIGludG8gdGhlIGFwcGxpY2F0aW9uLlxuICogSWYgeW91IHdhbnQgdG8gZXhwbGljaXRseSBlbmFibGUgbmF0aXZlIERPTSB2YWxpZGF0aW9uIFVJIHdpdGggQW5ndWxhciBmb3JtcywgeW91IGNhbiBhZGQgdGhlXG4gKiBgbmdOYXRpdmVWYWxpZGF0ZWAgYXR0cmlidXRlIHRvIHRoZSBgPGZvcm0+YCBlbGVtZW50OlxuICpcbiAqIGBgYGh0bWxcbiAqIDxmb3JtIG5nTmF0aXZlVmFsaWRhdGU+XG4gKiAgIC4uLlxuICogPC9mb3JtPlxuICogYGBgXG4gKlxuICogQG5nTW9kdWxlIEZvcm1zTW9kdWxlXG4gKiBAcHVibGljQXBpXG4gKi9cbmNsYXNzIE5nRm9ybSBleHRlbmRzIENvbnRyb2xDb250YWluZXIge1xuICAgIGNvbnN0cnVjdG9yKHZhbGlkYXRvcnMsIGFzeW5jVmFsaWRhdG9ycywgY2FsbFNldERpc2FibGVkU3RhdGUpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5jYWxsU2V0RGlzYWJsZWRTdGF0ZSA9IGNhbGxTZXREaXNhYmxlZFN0YXRlO1xuICAgICAgICAvKipcbiAgICAgICAgICogQGRlc2NyaXB0aW9uXG4gICAgICAgICAqIFJldHVybnMgd2hldGhlciB0aGUgZm9ybSBzdWJtaXNzaW9uIGhhcyBiZWVuIHRyaWdnZXJlZC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc3VibWl0dGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2RpcmVjdGl2ZXMgPSBuZXcgU2V0KCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgICAgICogRXZlbnQgZW1pdHRlciBmb3IgdGhlIFwibmdTdWJtaXRcIiBldmVudFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5uZ1N1Ym1pdCA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgdGhpcy5mb3JtID1cbiAgICAgICAgICAgIG5ldyBGb3JtR3JvdXAoe30sIGNvbXBvc2VWYWxpZGF0b3JzKHZhbGlkYXRvcnMpLCBjb21wb3NlQXN5bmNWYWxpZGF0b3JzKGFzeW5jVmFsaWRhdG9ycykpO1xuICAgIH1cbiAgICAvKiogQG5vZG9jICovXG4gICAgbmdBZnRlclZpZXdJbml0KCkge1xuICAgICAgICB0aGlzLl9zZXRVcGRhdGVTdHJhdGVneSgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKiBUaGUgZGlyZWN0aXZlIGluc3RhbmNlLlxuICAgICAqL1xuICAgIGdldCBmb3JtRGlyZWN0aXZlKCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICogVGhlIGludGVybmFsIGBGb3JtR3JvdXBgIGluc3RhbmNlLlxuICAgICAqL1xuICAgIGdldCBjb250cm9sKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5mb3JtO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKiBSZXR1cm5zIGFuIGFycmF5IHJlcHJlc2VudGluZyB0aGUgcGF0aCB0byB0aGlzIGdyb3VwLiBCZWNhdXNlIHRoaXMgZGlyZWN0aXZlXG4gICAgICogYWx3YXlzIGxpdmVzIGF0IHRoZSB0b3AgbGV2ZWwgb2YgYSBmb3JtLCBpdCBpcyBhbHdheXMgYW4gZW1wdHkgYXJyYXkuXG4gICAgICovXG4gICAgZ2V0IHBhdGgoKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICogUmV0dXJucyBhIG1hcCBvZiB0aGUgY29udHJvbHMgaW4gdGhpcyBncm91cC5cbiAgICAgKi9cbiAgICBnZXQgY29udHJvbHMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZvcm0uY29udHJvbHM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqIE1ldGhvZCB0aGF0IHNldHMgdXAgdGhlIGNvbnRyb2wgZGlyZWN0aXZlIGluIHRoaXMgZ3JvdXAsIHJlLWNhbGN1bGF0ZXMgaXRzIHZhbHVlXG4gICAgICogYW5kIHZhbGlkaXR5LCBhbmQgYWRkcyB0aGUgaW5zdGFuY2UgdG8gdGhlIGludGVybmFsIGxpc3Qgb2YgZGlyZWN0aXZlcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBkaXIgVGhlIGBOZ01vZGVsYCBkaXJlY3RpdmUgaW5zdGFuY2UuXG4gICAgICovXG4gICAgYWRkQ29udHJvbChkaXIpIHtcbiAgICAgICAgcmVzb2x2ZWRQcm9taXNlJDEudGhlbigoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBjb250YWluZXIgPSB0aGlzLl9maW5kQ29udGFpbmVyKGRpci5wYXRoKTtcbiAgICAgICAgICAgIGRpci5jb250cm9sID1cbiAgICAgICAgICAgICAgICBjb250YWluZXIucmVnaXN0ZXJDb250cm9sKGRpci5uYW1lLCBkaXIuY29udHJvbCk7XG4gICAgICAgICAgICBzZXRVcENvbnRyb2woZGlyLmNvbnRyb2wsIGRpciwgdGhpcy5jYWxsU2V0RGlzYWJsZWRTdGF0ZSk7XG4gICAgICAgICAgICBkaXIuY29udHJvbC51cGRhdGVWYWx1ZUFuZFZhbGlkaXR5KHsgZW1pdEV2ZW50OiBmYWxzZSB9KTtcbiAgICAgICAgICAgIHRoaXMuX2RpcmVjdGl2ZXMuYWRkKGRpcik7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKiBSZXRyaWV2ZXMgdGhlIGBGb3JtQ29udHJvbGAgaW5zdGFuY2UgZnJvbSB0aGUgcHJvdmlkZWQgYE5nTW9kZWxgIGRpcmVjdGl2ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBkaXIgVGhlIGBOZ01vZGVsYCBkaXJlY3RpdmUgaW5zdGFuY2UuXG4gICAgICovXG4gICAgZ2V0Q29udHJvbChkaXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZm9ybS5nZXQoZGlyLnBhdGgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKiBSZW1vdmVzIHRoZSBgTmdNb2RlbGAgaW5zdGFuY2UgZnJvbSB0aGUgaW50ZXJuYWwgbGlzdCBvZiBkaXJlY3RpdmVzXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZGlyIFRoZSBgTmdNb2RlbGAgZGlyZWN0aXZlIGluc3RhbmNlLlxuICAgICAqL1xuICAgIHJlbW92ZUNvbnRyb2woZGlyKSB7XG4gICAgICAgIHJlc29sdmVkUHJvbWlzZSQxLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgY29udGFpbmVyID0gdGhpcy5fZmluZENvbnRhaW5lcihkaXIucGF0aCk7XG4gICAgICAgICAgICBpZiAoY29udGFpbmVyKSB7XG4gICAgICAgICAgICAgICAgY29udGFpbmVyLnJlbW92ZUNvbnRyb2woZGlyLm5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fZGlyZWN0aXZlcy5kZWxldGUoZGlyKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqIEFkZHMgYSBuZXcgYE5nTW9kZWxHcm91cGAgZGlyZWN0aXZlIGluc3RhbmNlIHRvIHRoZSBmb3JtLlxuICAgICAqXG4gICAgICogQHBhcmFtIGRpciBUaGUgYE5nTW9kZWxHcm91cGAgZGlyZWN0aXZlIGluc3RhbmNlLlxuICAgICAqL1xuICAgIGFkZEZvcm1Hcm91cChkaXIpIHtcbiAgICAgICAgcmVzb2x2ZWRQcm9taXNlJDEudGhlbigoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBjb250YWluZXIgPSB0aGlzLl9maW5kQ29udGFpbmVyKGRpci5wYXRoKTtcbiAgICAgICAgICAgIGNvbnN0IGdyb3VwID0gbmV3IEZvcm1Hcm91cCh7fSk7XG4gICAgICAgICAgICBzZXRVcEZvcm1Db250YWluZXIoZ3JvdXAsIGRpcik7XG4gICAgICAgICAgICBjb250YWluZXIucmVnaXN0ZXJDb250cm9sKGRpci5uYW1lLCBncm91cCk7XG4gICAgICAgICAgICBncm91cC51cGRhdGVWYWx1ZUFuZFZhbGlkaXR5KHsgZW1pdEV2ZW50OiBmYWxzZSB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqIFJlbW92ZXMgdGhlIGBOZ01vZGVsR3JvdXBgIGRpcmVjdGl2ZSBpbnN0YW5jZSBmcm9tIHRoZSBmb3JtLlxuICAgICAqXG4gICAgICogQHBhcmFtIGRpciBUaGUgYE5nTW9kZWxHcm91cGAgZGlyZWN0aXZlIGluc3RhbmNlLlxuICAgICAqL1xuICAgIHJlbW92ZUZvcm1Hcm91cChkaXIpIHtcbiAgICAgICAgcmVzb2x2ZWRQcm9taXNlJDEudGhlbigoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBjb250YWluZXIgPSB0aGlzLl9maW5kQ29udGFpbmVyKGRpci5wYXRoKTtcbiAgICAgICAgICAgIGlmIChjb250YWluZXIpIHtcbiAgICAgICAgICAgICAgICBjb250YWluZXIucmVtb3ZlQ29udHJvbChkaXIubmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKiBSZXRyaWV2ZXMgdGhlIGBGb3JtR3JvdXBgIGZvciBhIHByb3ZpZGVkIGBOZ01vZGVsR3JvdXBgIGRpcmVjdGl2ZSBpbnN0YW5jZVxuICAgICAqXG4gICAgICogQHBhcmFtIGRpciBUaGUgYE5nTW9kZWxHcm91cGAgZGlyZWN0aXZlIGluc3RhbmNlLlxuICAgICAqL1xuICAgIGdldEZvcm1Hcm91cChkaXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZm9ybS5nZXQoZGlyLnBhdGgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBuZXcgdmFsdWUgZm9yIHRoZSBwcm92aWRlZCBgTmdDb250cm9sYCBkaXJlY3RpdmUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZGlyIFRoZSBgTmdDb250cm9sYCBkaXJlY3RpdmUgaW5zdGFuY2UuXG4gICAgICogQHBhcmFtIHZhbHVlIFRoZSBuZXcgdmFsdWUgZm9yIHRoZSBkaXJlY3RpdmUncyBjb250cm9sLlxuICAgICAqL1xuICAgIHVwZGF0ZU1vZGVsKGRpciwgdmFsdWUpIHtcbiAgICAgICAgcmVzb2x2ZWRQcm9taXNlJDEudGhlbigoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBjdHJsID0gdGhpcy5mb3JtLmdldChkaXIucGF0aCk7XG4gICAgICAgICAgICBjdHJsLnNldFZhbHVlKHZhbHVlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqIFNldHMgdGhlIHZhbHVlIGZvciB0aGlzIGBGb3JtR3JvdXBgLlxuICAgICAqXG4gICAgICogQHBhcmFtIHZhbHVlIFRoZSBuZXcgdmFsdWVcbiAgICAgKi9cbiAgICBzZXRWYWx1ZSh2YWx1ZSkge1xuICAgICAgICB0aGlzLmNvbnRyb2wuc2V0VmFsdWUodmFsdWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKiBNZXRob2QgY2FsbGVkIHdoZW4gdGhlIFwic3VibWl0XCIgZXZlbnQgaXMgdHJpZ2dlcmVkIG9uIHRoZSBmb3JtLlxuICAgICAqIFRyaWdnZXJzIHRoZSBgbmdTdWJtaXRgIGVtaXR0ZXIgdG8gZW1pdCB0aGUgXCJzdWJtaXRcIiBldmVudCBhcyBpdHMgcGF5bG9hZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSAkZXZlbnQgVGhlIFwic3VibWl0XCIgZXZlbnQgb2JqZWN0XG4gICAgICovXG4gICAgb25TdWJtaXQoJGV2ZW50KSB7XG4gICAgICAgIHRoaXMuc3VibWl0dGVkID0gdHJ1ZTtcbiAgICAgICAgc3luY1BlbmRpbmdDb250cm9scyh0aGlzLmZvcm0sIHRoaXMuX2RpcmVjdGl2ZXMpO1xuICAgICAgICB0aGlzLm5nU3VibWl0LmVtaXQoJGV2ZW50KTtcbiAgICAgICAgLy8gRm9ybXMgd2l0aCBgbWV0aG9kPVwiZGlhbG9nXCJgIGhhdmUgc29tZSBzcGVjaWFsIGJlaGF2aW9yXG4gICAgICAgIC8vIHRoYXQgd29uJ3QgcmVsb2FkIHRoZSBwYWdlIGFuZCB0aGF0IHNob3VsZG4ndCBiZSBwcmV2ZW50ZWQuXG4gICAgICAgIHJldHVybiAkZXZlbnQ/LnRhcmdldD8ubWV0aG9kID09PSAnZGlhbG9nJztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICogTWV0aG9kIGNhbGxlZCB3aGVuIHRoZSBcInJlc2V0XCIgZXZlbnQgaXMgdHJpZ2dlcmVkIG9uIHRoZSBmb3JtLlxuICAgICAqL1xuICAgIG9uUmVzZXQoKSB7XG4gICAgICAgIHRoaXMucmVzZXRGb3JtKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqIFJlc2V0cyB0aGUgZm9ybSB0byBhbiBpbml0aWFsIHZhbHVlIGFuZCByZXNldHMgaXRzIHN1Ym1pdHRlZCBzdGF0dXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdmFsdWUgVGhlIG5ldyB2YWx1ZSBmb3IgdGhlIGZvcm0uXG4gICAgICovXG4gICAgcmVzZXRGb3JtKHZhbHVlID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMuZm9ybS5yZXNldCh2YWx1ZSk7XG4gICAgICAgIHRoaXMuc3VibWl0dGVkID0gZmFsc2U7XG4gICAgfVxuICAgIF9zZXRVcGRhdGVTdHJhdGVneSgpIHtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucyAmJiB0aGlzLm9wdGlvbnMudXBkYXRlT24gIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5mb3JtLl91cGRhdGVPbiA9IHRoaXMub3B0aW9ucy51cGRhdGVPbjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfZmluZENvbnRhaW5lcihwYXRoKSB7XG4gICAgICAgIHBhdGgucG9wKCk7XG4gICAgICAgIHJldHVybiBwYXRoLmxlbmd0aCA/IHRoaXMuZm9ybS5nZXQocGF0aCkgOiB0aGlzLmZvcm07XG4gICAgfVxuICAgIHN0YXRpYyB7IHRoaXMuybVmYWMgPSBpMC7Jtcm1bmdEZWNsYXJlRmFjdG9yeSh7IG1pblZlcnNpb246IFwiMTIuMC4wXCIsIHZlcnNpb246IFwiMTcuMy4xMlwiLCBuZ0ltcG9ydDogaTAsIHR5cGU6IE5nRm9ybSwgZGVwczogW3sgdG9rZW46IE5HX1ZBTElEQVRPUlMsIG9wdGlvbmFsOiB0cnVlLCBzZWxmOiB0cnVlIH0sIHsgdG9rZW46IE5HX0FTWU5DX1ZBTElEQVRPUlMsIG9wdGlvbmFsOiB0cnVlLCBzZWxmOiB0cnVlIH0sIHsgdG9rZW46IENBTExfU0VUX0RJU0FCTEVEX1NUQVRFLCBvcHRpb25hbDogdHJ1ZSB9XSwgdGFyZ2V0OiBpMC7Jtcm1RmFjdG9yeVRhcmdldC5EaXJlY3RpdmUgfSk7IH1cbiAgICBzdGF0aWMgeyB0aGlzLsm1ZGlyID0gaTAuybXJtW5nRGVjbGFyZURpcmVjdGl2ZSh7IG1pblZlcnNpb246IFwiMTQuMC4wXCIsIHZlcnNpb246IFwiMTcuMy4xMlwiLCB0eXBlOiBOZ0Zvcm0sIHNlbGVjdG9yOiBcImZvcm06bm90KFtuZ05vRm9ybV0pOm5vdChbZm9ybUdyb3VwXSksbmctZm9ybSxbbmdGb3JtXVwiLCBpbnB1dHM6IHsgb3B0aW9uczogW1wibmdGb3JtT3B0aW9uc1wiLCBcIm9wdGlvbnNcIl0gfSwgb3V0cHV0czogeyBuZ1N1Ym1pdDogXCJuZ1N1Ym1pdFwiIH0sIGhvc3Q6IHsgbGlzdGVuZXJzOiB7IFwic3VibWl0XCI6IFwib25TdWJtaXQoJGV2ZW50KVwiLCBcInJlc2V0XCI6IFwib25SZXNldCgpXCIgfSB9LCBwcm92aWRlcnM6IFtmb3JtRGlyZWN0aXZlUHJvdmlkZXIkMV0sIGV4cG9ydEFzOiBbXCJuZ0Zvcm1cIl0sIHVzZXNJbmhlcml0YW5jZTogdHJ1ZSwgbmdJbXBvcnQ6IGkwIH0pOyB9XG59XG5pMC7Jtcm1bmdEZWNsYXJlQ2xhc3NNZXRhZGF0YSh7IG1pblZlcnNpb246IFwiMTIuMC4wXCIsIHZlcnNpb246IFwiMTcuMy4xMlwiLCBuZ0ltcG9ydDogaTAsIHR5cGU6IE5nRm9ybSwgZGVjb3JhdG9yczogW3tcbiAgICAgICAgICAgIHR5cGU6IERpcmVjdGl2ZSxcbiAgICAgICAgICAgIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnZm9ybTpub3QoW25nTm9Gb3JtXSk6bm90KFtmb3JtR3JvdXBdKSxuZy1mb3JtLFtuZ0Zvcm1dJyxcbiAgICAgICAgICAgICAgICAgICAgcHJvdmlkZXJzOiBbZm9ybURpcmVjdGl2ZVByb3ZpZGVyJDFdLFxuICAgICAgICAgICAgICAgICAgICBob3N0OiB7ICcoc3VibWl0KSc6ICdvblN1Ym1pdCgkZXZlbnQpJywgJyhyZXNldCknOiAnb25SZXNldCgpJyB9LFxuICAgICAgICAgICAgICAgICAgICBvdXRwdXRzOiBbJ25nU3VibWl0J10sXG4gICAgICAgICAgICAgICAgICAgIGV4cG9ydEFzOiAnbmdGb3JtJ1xuICAgICAgICAgICAgICAgIH1dXG4gICAgICAgIH1dLCBjdG9yUGFyYW1ldGVyczogKCkgPT4gW3sgdHlwZTogdW5kZWZpbmVkLCBkZWNvcmF0b3JzOiBbe1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBPcHRpb25hbFxuICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogU2VsZlxuICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogSW5qZWN0LFxuICAgICAgICAgICAgICAgICAgICBhcmdzOiBbTkdfVkFMSURBVE9SU11cbiAgICAgICAgICAgICAgICB9XSB9LCB7IHR5cGU6IHVuZGVmaW5lZCwgZGVjb3JhdG9yczogW3tcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogT3B0aW9uYWxcbiAgICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFNlbGZcbiAgICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IEluamVjdCxcbiAgICAgICAgICAgICAgICAgICAgYXJnczogW05HX0FTWU5DX1ZBTElEQVRPUlNdXG4gICAgICAgICAgICAgICAgfV0gfSwgeyB0eXBlOiB1bmRlZmluZWQsIGRlY29yYXRvcnM6IFt7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IE9wdGlvbmFsXG4gICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBJbmplY3QsXG4gICAgICAgICAgICAgICAgICAgIGFyZ3M6IFtDQUxMX1NFVF9ESVNBQkxFRF9TVEFURV1cbiAgICAgICAgICAgICAgICB9XSB9XSwgcHJvcERlY29yYXRvcnM6IHsgb3B0aW9uczogW3tcbiAgICAgICAgICAgICAgICB0eXBlOiBJbnB1dCxcbiAgICAgICAgICAgICAgICBhcmdzOiBbJ25nRm9ybU9wdGlvbnMnXVxuICAgICAgICAgICAgfV0gfSB9KTtcblxuZnVuY3Rpb24gcmVtb3ZlTGlzdEl0ZW0obGlzdCwgZWwpIHtcbiAgICBjb25zdCBpbmRleCA9IGxpc3QuaW5kZXhPZihlbCk7XG4gICAgaWYgKGluZGV4ID4gLTEpXG4gICAgICAgIGxpc3Quc3BsaWNlKGluZGV4LCAxKTtcbn1cblxuZnVuY3Rpb24gaXNGb3JtQ29udHJvbFN0YXRlKGZvcm1TdGF0ZSkge1xuICAgIHJldHVybiB0eXBlb2YgZm9ybVN0YXRlID09PSAnb2JqZWN0JyAmJiBmb3JtU3RhdGUgIT09IG51bGwgJiZcbiAgICAgICAgT2JqZWN0LmtleXMoZm9ybVN0YXRlKS5sZW5ndGggPT09IDIgJiYgJ3ZhbHVlJyBpbiBmb3JtU3RhdGUgJiYgJ2Rpc2FibGVkJyBpbiBmb3JtU3RhdGU7XG59XG5jb25zdCBGb3JtQ29udHJvbCA9IChjbGFzcyBGb3JtQ29udHJvbCBleHRlbmRzIEFic3RyYWN0Q29udHJvbCB7XG4gICAgY29uc3RydWN0b3IoXG4gICAgLy8gZm9ybVN0YXRlIGFuZCBkZWZhdWx0VmFsdWUgd2lsbCBvbmx5IGJlIG51bGwgaWYgVCBpcyBudWxsYWJsZVxuICAgIGZvcm1TdGF0ZSA9IG51bGwsIHZhbGlkYXRvck9yT3B0cywgYXN5bmNWYWxpZGF0b3IpIHtcbiAgICAgICAgc3VwZXIocGlja1ZhbGlkYXRvcnModmFsaWRhdG9yT3JPcHRzKSwgcGlja0FzeW5jVmFsaWRhdG9ycyhhc3luY1ZhbGlkYXRvciwgdmFsaWRhdG9yT3JPcHRzKSk7XG4gICAgICAgIC8qKiBAcHVibGljQXBpICovXG4gICAgICAgIHRoaXMuZGVmYXVsdFZhbHVlID0gbnVsbDtcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICB0aGlzLl9vbkNoYW5nZSA9IFtdO1xuICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgIHRoaXMuX3BlbmRpbmdDaGFuZ2UgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fYXBwbHlGb3JtU3RhdGUoZm9ybVN0YXRlKTtcbiAgICAgICAgdGhpcy5fc2V0VXBkYXRlU3RyYXRlZ3kodmFsaWRhdG9yT3JPcHRzKTtcbiAgICAgICAgdGhpcy5faW5pdE9ic2VydmFibGVzKCk7XG4gICAgICAgIHRoaXMudXBkYXRlVmFsdWVBbmRWYWxpZGl0eSh7XG4gICAgICAgICAgICBvbmx5U2VsZjogdHJ1ZSxcbiAgICAgICAgICAgIC8vIElmIGBhc3luY1ZhbGlkYXRvcmAgaXMgcHJlc2VudCwgaXQgd2lsbCB0cmlnZ2VyIGNvbnRyb2wgc3RhdHVzIGNoYW5nZSBmcm9tIGBQRU5ESU5HYCB0b1xuICAgICAgICAgICAgLy8gYFZBTElEYCBvciBgSU5WQUxJRGAuXG4gICAgICAgICAgICAvLyBUaGUgc3RhdHVzIHNob3VsZCBiZSBicm9hZGNhc3RlZCB2aWEgdGhlIGBzdGF0dXNDaGFuZ2VzYCBvYnNlcnZhYmxlLCBzbyB3ZSBzZXRcbiAgICAgICAgICAgIC8vIGBlbWl0RXZlbnRgIHRvIGB0cnVlYCB0byBhbGxvdyB0aGF0IGR1cmluZyB0aGUgY29udHJvbCBjcmVhdGlvbiBwcm9jZXNzLlxuICAgICAgICAgICAgZW1pdEV2ZW50OiAhIXRoaXMuYXN5bmNWYWxpZGF0b3JcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChpc09wdGlvbnNPYmoodmFsaWRhdG9yT3JPcHRzKSAmJlxuICAgICAgICAgICAgKHZhbGlkYXRvck9yT3B0cy5ub25OdWxsYWJsZSB8fCB2YWxpZGF0b3JPck9wdHMuaW5pdGlhbFZhbHVlSXNEZWZhdWx0KSkge1xuICAgICAgICAgICAgaWYgKGlzRm9ybUNvbnRyb2xTdGF0ZShmb3JtU3RhdGUpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kZWZhdWx0VmFsdWUgPSBmb3JtU3RhdGUudmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRlZmF1bHRWYWx1ZSA9IGZvcm1TdGF0ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBzZXRWYWx1ZSh2YWx1ZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIHRoaXMudmFsdWUgPSB0aGlzLl9wZW5kaW5nVmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgaWYgKHRoaXMuX29uQ2hhbmdlLmxlbmd0aCAmJiBvcHRpb25zLmVtaXRNb2RlbFRvVmlld0NoYW5nZSAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHRoaXMuX29uQ2hhbmdlLmZvckVhY2goKGNoYW5nZUZuKSA9PiBjaGFuZ2VGbih0aGlzLnZhbHVlLCBvcHRpb25zLmVtaXRWaWV3VG9Nb2RlbENoYW5nZSAhPT0gZmFsc2UpKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnVwZGF0ZVZhbHVlQW5kVmFsaWRpdHkob3B0aW9ucyk7XG4gICAgfVxuICAgIHBhdGNoVmFsdWUodmFsdWUsIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICB0aGlzLnNldFZhbHVlKHZhbHVlLCBvcHRpb25zKTtcbiAgICB9XG4gICAgcmVzZXQoZm9ybVN0YXRlID0gdGhpcy5kZWZhdWx0VmFsdWUsIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICB0aGlzLl9hcHBseUZvcm1TdGF0ZShmb3JtU3RhdGUpO1xuICAgICAgICB0aGlzLm1hcmtBc1ByaXN0aW5lKG9wdGlvbnMpO1xuICAgICAgICB0aGlzLm1hcmtBc1VudG91Y2hlZChvcHRpb25zKTtcbiAgICAgICAgdGhpcy5zZXRWYWx1ZSh0aGlzLnZhbHVlLCBvcHRpb25zKTtcbiAgICAgICAgdGhpcy5fcGVuZGluZ0NoYW5nZSA9IGZhbHNlO1xuICAgIH1cbiAgICAvKiogIEBpbnRlcm5hbCAqL1xuICAgIF91cGRhdGVWYWx1ZSgpIHsgfVxuICAgIC8qKiAgQGludGVybmFsICovXG4gICAgX2FueUNvbnRyb2xzKGNvbmRpdGlvbikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8qKiAgQGludGVybmFsICovXG4gICAgX2FsbENvbnRyb2xzRGlzYWJsZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRpc2FibGVkO1xuICAgIH1cbiAgICByZWdpc3Rlck9uQ2hhbmdlKGZuKSB7XG4gICAgICAgIHRoaXMuX29uQ2hhbmdlLnB1c2goZm4pO1xuICAgIH1cbiAgICAvKiogQGludGVybmFsICovXG4gICAgX3VucmVnaXN0ZXJPbkNoYW5nZShmbikge1xuICAgICAgICByZW1vdmVMaXN0SXRlbSh0aGlzLl9vbkNoYW5nZSwgZm4pO1xuICAgIH1cbiAgICByZWdpc3Rlck9uRGlzYWJsZWRDaGFuZ2UoZm4pIHtcbiAgICAgICAgdGhpcy5fb25EaXNhYmxlZENoYW5nZS5wdXNoKGZuKTtcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIF91bnJlZ2lzdGVyT25EaXNhYmxlZENoYW5nZShmbikge1xuICAgICAgICByZW1vdmVMaXN0SXRlbSh0aGlzLl9vbkRpc2FibGVkQ2hhbmdlLCBmbik7XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBfZm9yRWFjaENoaWxkKGNiKSB7IH1cbiAgICAvKiogQGludGVybmFsICovXG4gICAgX3N5bmNQZW5kaW5nQ29udHJvbHMoKSB7XG4gICAgICAgIGlmICh0aGlzLnVwZGF0ZU9uID09PSAnc3VibWl0Jykge1xuICAgICAgICAgICAgaWYgKHRoaXMuX3BlbmRpbmdEaXJ0eSlcbiAgICAgICAgICAgICAgICB0aGlzLm1hcmtBc0RpcnR5KCk7XG4gICAgICAgICAgICBpZiAodGhpcy5fcGVuZGluZ1RvdWNoZWQpXG4gICAgICAgICAgICAgICAgdGhpcy5tYXJrQXNUb3VjaGVkKCk7XG4gICAgICAgICAgICBpZiAodGhpcy5fcGVuZGluZ0NoYW5nZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0VmFsdWUodGhpcy5fcGVuZGluZ1ZhbHVlLCB7IG9ubHlTZWxmOiB0cnVlLCBlbWl0TW9kZWxUb1ZpZXdDaGFuZ2U6IGZhbHNlIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgX2FwcGx5Rm9ybVN0YXRlKGZvcm1TdGF0ZSkge1xuICAgICAgICBpZiAoaXNGb3JtQ29udHJvbFN0YXRlKGZvcm1TdGF0ZSkpIHtcbiAgICAgICAgICAgIHRoaXMudmFsdWUgPSB0aGlzLl9wZW5kaW5nVmFsdWUgPSBmb3JtU3RhdGUudmFsdWU7XG4gICAgICAgICAgICBmb3JtU3RhdGUuZGlzYWJsZWQgPyB0aGlzLmRpc2FibGUoeyBvbmx5U2VsZjogdHJ1ZSwgZW1pdEV2ZW50OiBmYWxzZSB9KSA6XG4gICAgICAgICAgICAgICAgdGhpcy5lbmFibGUoeyBvbmx5U2VsZjogdHJ1ZSwgZW1pdEV2ZW50OiBmYWxzZSB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMudmFsdWUgPSB0aGlzLl9wZW5kaW5nVmFsdWUgPSBmb3JtU3RhdGU7XG4gICAgICAgIH1cbiAgICB9XG59KTtcbmNvbnN0IFVudHlwZWRGb3JtQ29udHJvbCA9IEZvcm1Db250cm9sO1xuLyoqXG4gKiBAZGVzY3JpcHRpb25cbiAqIEFzc2VydHMgdGhhdCB0aGUgZ2l2ZW4gY29udHJvbCBpcyBhbiBpbnN0YW5jZSBvZiBgRm9ybUNvbnRyb2xgXG4gKlxuICogQHB1YmxpY0FwaVxuICovXG5jb25zdCBpc0Zvcm1Db250cm9sID0gKGNvbnRyb2wpID0+IGNvbnRyb2wgaW5zdGFuY2VvZiBGb3JtQ29udHJvbDtcblxuLyoqXG4gKiBAZGVzY3JpcHRpb25cbiAqIEEgYmFzZSBjbGFzcyBmb3IgY29kZSBzaGFyZWQgYmV0d2VlbiB0aGUgYE5nTW9kZWxHcm91cGAgYW5kIGBGb3JtR3JvdXBOYW1lYCBkaXJlY3RpdmVzLlxuICpcbiAqIEBwdWJsaWNBcGlcbiAqL1xuY2xhc3MgQWJzdHJhY3RGb3JtR3JvdXBEaXJlY3RpdmUgZXh0ZW5kcyBDb250cm9sQ29udGFpbmVyIHtcbiAgICAvKiogQG5vZG9jICovXG4gICAgbmdPbkluaXQoKSB7XG4gICAgICAgIHRoaXMuX2NoZWNrUGFyZW50VHlwZSgpO1xuICAgICAgICAvLyBSZWdpc3RlciB0aGUgZ3JvdXAgd2l0aCBpdHMgcGFyZW50IGdyb3VwLlxuICAgICAgICB0aGlzLmZvcm1EaXJlY3RpdmUuYWRkRm9ybUdyb3VwKHRoaXMpO1xuICAgIH1cbiAgICAvKiogQG5vZG9jICovXG4gICAgbmdPbkRlc3Ryb3koKSB7XG4gICAgICAgIGlmICh0aGlzLmZvcm1EaXJlY3RpdmUpIHtcbiAgICAgICAgICAgIC8vIFJlbW92ZSB0aGUgZ3JvdXAgZnJvbSBpdHMgcGFyZW50IGdyb3VwLlxuICAgICAgICAgICAgdGhpcy5mb3JtRGlyZWN0aXZlLnJlbW92ZUZvcm1Hcm91cCh0aGlzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKiBUaGUgYEZvcm1Hcm91cGAgYm91bmQgdG8gdGhpcyBkaXJlY3RpdmUuXG4gICAgICovXG4gICAgZ2V0IGNvbnRyb2woKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZvcm1EaXJlY3RpdmUuZ2V0Rm9ybUdyb3VwKHRoaXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKiBUaGUgcGF0aCB0byB0aGlzIGdyb3VwIGZyb20gdGhlIHRvcC1sZXZlbCBkaXJlY3RpdmUuXG4gICAgICovXG4gICAgZ2V0IHBhdGgoKSB7XG4gICAgICAgIHJldHVybiBjb250cm9sUGF0aCh0aGlzLm5hbWUgPT0gbnVsbCA/IHRoaXMubmFtZSA6IHRoaXMubmFtZS50b1N0cmluZygpLCB0aGlzLl9wYXJlbnQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKiBUaGUgdG9wLWxldmVsIGRpcmVjdGl2ZSBmb3IgdGhpcyBncm91cCBpZiBwcmVzZW50LCBvdGhlcndpc2UgbnVsbC5cbiAgICAgKi9cbiAgICBnZXQgZm9ybURpcmVjdGl2ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BhcmVudCA/IHRoaXMuX3BhcmVudC5mb3JtRGlyZWN0aXZlIDogbnVsbDtcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIF9jaGVja1BhcmVudFR5cGUoKSB7IH1cbiAgICBzdGF0aWMgeyB0aGlzLsm1ZmFjID0gaTAuybXJtW5nRGVjbGFyZUZhY3RvcnkoeyBtaW5WZXJzaW9uOiBcIjEyLjAuMFwiLCB2ZXJzaW9uOiBcIjE3LjMuMTJcIiwgbmdJbXBvcnQ6IGkwLCB0eXBlOiBBYnN0cmFjdEZvcm1Hcm91cERpcmVjdGl2ZSwgZGVwczogbnVsbCwgdGFyZ2V0OiBpMC7Jtcm1RmFjdG9yeVRhcmdldC5EaXJlY3RpdmUgfSk7IH1cbiAgICBzdGF0aWMgeyB0aGlzLsm1ZGlyID0gaTAuybXJtW5nRGVjbGFyZURpcmVjdGl2ZSh7IG1pblZlcnNpb246IFwiMTQuMC4wXCIsIHZlcnNpb246IFwiMTcuMy4xMlwiLCB0eXBlOiBBYnN0cmFjdEZvcm1Hcm91cERpcmVjdGl2ZSwgdXNlc0luaGVyaXRhbmNlOiB0cnVlLCBuZ0ltcG9ydDogaTAgfSk7IH1cbn1cbmkwLsm1ybVuZ0RlY2xhcmVDbGFzc01ldGFkYXRhKHsgbWluVmVyc2lvbjogXCIxMi4wLjBcIiwgdmVyc2lvbjogXCIxNy4zLjEyXCIsIG5nSW1wb3J0OiBpMCwgdHlwZTogQWJzdHJhY3RGb3JtR3JvdXBEaXJlY3RpdmUsIGRlY29yYXRvcnM6IFt7XG4gICAgICAgICAgICB0eXBlOiBEaXJlY3RpdmVcbiAgICAgICAgfV0gfSk7XG5cbmZ1bmN0aW9uIG1vZGVsUGFyZW50RXhjZXB0aW9uKCkge1xuICAgIHJldHVybiBuZXcgybVSdW50aW1lRXJyb3IoMTM1MCAvKiBSdW50aW1lRXJyb3JDb2RlLk5HTU9ERUxfSU5fRk9STV9HUk9VUCAqLywgYFxuICAgIG5nTW9kZWwgY2Fubm90IGJlIHVzZWQgdG8gcmVnaXN0ZXIgZm9ybSBjb250cm9scyB3aXRoIGEgcGFyZW50IGZvcm1Hcm91cCBkaXJlY3RpdmUuICBUcnkgdXNpbmdcbiAgICBmb3JtR3JvdXAncyBwYXJ0bmVyIGRpcmVjdGl2ZSBcImZvcm1Db250cm9sTmFtZVwiIGluc3RlYWQuICBFeGFtcGxlOlxuXG4gICAgJHtmb3JtQ29udHJvbE5hbWVFeGFtcGxlfVxuXG4gICAgT3IsIGlmIHlvdSdkIGxpa2UgdG8gYXZvaWQgcmVnaXN0ZXJpbmcgdGhpcyBmb3JtIGNvbnRyb2wsIGluZGljYXRlIHRoYXQgaXQncyBzdGFuZGFsb25lIGluIG5nTW9kZWxPcHRpb25zOlxuXG4gICAgRXhhbXBsZTpcblxuICAgICR7bmdNb2RlbFdpdGhGb3JtR3JvdXBFeGFtcGxlfWApO1xufVxuZnVuY3Rpb24gZm9ybUdyb3VwTmFtZUV4Y2VwdGlvbigpIHtcbiAgICByZXR1cm4gbmV3IMm1UnVudGltZUVycm9yKDEzNTEgLyogUnVudGltZUVycm9yQ29kZS5OR01PREVMX0lOX0ZPUk1fR1JPVVBfTkFNRSAqLywgYFxuICAgIG5nTW9kZWwgY2Fubm90IGJlIHVzZWQgdG8gcmVnaXN0ZXIgZm9ybSBjb250cm9scyB3aXRoIGEgcGFyZW50IGZvcm1Hcm91cE5hbWUgb3IgZm9ybUFycmF5TmFtZSBkaXJlY3RpdmUuXG5cbiAgICBPcHRpb24gMTogVXNlIGZvcm1Db250cm9sTmFtZSBpbnN0ZWFkIG9mIG5nTW9kZWwgKHJlYWN0aXZlIHN0cmF0ZWd5KTpcblxuICAgICR7Zm9ybUdyb3VwTmFtZUV4YW1wbGV9XG5cbiAgICBPcHRpb24gMjogIFVwZGF0ZSBuZ01vZGVsJ3MgcGFyZW50IGJlIG5nTW9kZWxHcm91cCAodGVtcGxhdGUtZHJpdmVuIHN0cmF0ZWd5KTpcblxuICAgICR7bmdNb2RlbEdyb3VwRXhhbXBsZX1gKTtcbn1cbmZ1bmN0aW9uIG1pc3NpbmdOYW1lRXhjZXB0aW9uKCkge1xuICAgIHJldHVybiBuZXcgybVSdW50aW1lRXJyb3IoMTM1MiAvKiBSdW50aW1lRXJyb3JDb2RlLk5HTU9ERUxfV0lUSE9VVF9OQU1FICovLCBgSWYgbmdNb2RlbCBpcyB1c2VkIHdpdGhpbiBhIGZvcm0gdGFnLCBlaXRoZXIgdGhlIG5hbWUgYXR0cmlidXRlIG11c3QgYmUgc2V0IG9yIHRoZSBmb3JtXG4gICAgY29udHJvbCBtdXN0IGJlIGRlZmluZWQgYXMgJ3N0YW5kYWxvbmUnIGluIG5nTW9kZWxPcHRpb25zLlxuXG4gICAgRXhhbXBsZSAxOiA8aW5wdXQgWyhuZ01vZGVsKV09XCJwZXJzb24uZmlyc3ROYW1lXCIgbmFtZT1cImZpcnN0XCI+XG4gICAgRXhhbXBsZSAyOiA8aW5wdXQgWyhuZ01vZGVsKV09XCJwZXJzb24uZmlyc3ROYW1lXCIgW25nTW9kZWxPcHRpb25zXT1cIntzdGFuZGFsb25lOiB0cnVlfVwiPmApO1xufVxuZnVuY3Rpb24gbW9kZWxHcm91cFBhcmVudEV4Y2VwdGlvbigpIHtcbiAgICByZXR1cm4gbmV3IMm1UnVudGltZUVycm9yKDEzNTMgLyogUnVudGltZUVycm9yQ29kZS5OR01PREVMR1JPVVBfSU5fRk9STV9HUk9VUCAqLywgYFxuICAgIG5nTW9kZWxHcm91cCBjYW5ub3QgYmUgdXNlZCB3aXRoIGEgcGFyZW50IGZvcm1Hcm91cCBkaXJlY3RpdmUuXG5cbiAgICBPcHRpb24gMTogVXNlIGZvcm1Hcm91cE5hbWUgaW5zdGVhZCBvZiBuZ01vZGVsR3JvdXAgKHJlYWN0aXZlIHN0cmF0ZWd5KTpcblxuICAgICR7Zm9ybUdyb3VwTmFtZUV4YW1wbGV9XG5cbiAgICBPcHRpb24gMjogIFVzZSBhIHJlZ3VsYXIgZm9ybSB0YWcgaW5zdGVhZCBvZiB0aGUgZm9ybUdyb3VwIGRpcmVjdGl2ZSAodGVtcGxhdGUtZHJpdmVuIHN0cmF0ZWd5KTpcblxuICAgICR7bmdNb2RlbEdyb3VwRXhhbXBsZX1gKTtcbn1cblxuY29uc3QgbW9kZWxHcm91cFByb3ZpZGVyID0ge1xuICAgIHByb3ZpZGU6IENvbnRyb2xDb250YWluZXIsXG4gICAgdXNlRXhpc3Rpbmc6IGZvcndhcmRSZWYoKCkgPT4gTmdNb2RlbEdyb3VwKVxufTtcbi8qKlxuICogQGRlc2NyaXB0aW9uXG4gKiBDcmVhdGVzIGFuZCBiaW5kcyBhIGBGb3JtR3JvdXBgIGluc3RhbmNlIHRvIGEgRE9NIGVsZW1lbnQuXG4gKlxuICogVGhpcyBkaXJlY3RpdmUgY2FuIG9ubHkgYmUgdXNlZCBhcyBhIGNoaWxkIG9mIGBOZ0Zvcm1gICh3aXRoaW4gYDxmb3JtPmAgdGFncykuXG4gKlxuICogVXNlIHRoaXMgZGlyZWN0aXZlIHRvIHZhbGlkYXRlIGEgc3ViLWdyb3VwIG9mIHlvdXIgZm9ybSBzZXBhcmF0ZWx5IGZyb20gdGhlXG4gKiByZXN0IG9mIHlvdXIgZm9ybSwgb3IgaWYgc29tZSB2YWx1ZXMgaW4geW91ciBkb21haW4gbW9kZWwgbWFrZSBtb3JlIHNlbnNlXG4gKiB0byBjb25zdW1lIHRvZ2V0aGVyIGluIGEgbmVzdGVkIG9iamVjdC5cbiAqXG4gKiBQcm92aWRlIGEgbmFtZSBmb3IgdGhlIHN1Yi1ncm91cCBhbmQgaXQgd2lsbCBiZWNvbWUgdGhlIGtleVxuICogZm9yIHRoZSBzdWItZ3JvdXAgaW4gdGhlIGZvcm0ncyBmdWxsIHZhbHVlLiBJZiB5b3UgbmVlZCBkaXJlY3QgYWNjZXNzLCBleHBvcnQgdGhlIGRpcmVjdGl2ZSBpbnRvXG4gKiBhIGxvY2FsIHRlbXBsYXRlIHZhcmlhYmxlIHVzaW5nIGBuZ01vZGVsR3JvdXBgIChleDogYCNteUdyb3VwPVwibmdNb2RlbEdyb3VwXCJgKS5cbiAqXG4gKiBAdXNhZ2VOb3Rlc1xuICpcbiAqICMjIyBDb25zdW1pbmcgY29udHJvbHMgaW4gYSBncm91cGluZ1xuICpcbiAqIFRoZSBmb2xsb3dpbmcgZXhhbXBsZSBzaG93cyB5b3UgaG93IHRvIGNvbWJpbmUgY29udHJvbHMgdG9nZXRoZXIgaW4gYSBzdWItZ3JvdXBcbiAqIG9mIHRoZSBmb3JtLlxuICpcbiAqIHtAZXhhbXBsZSBmb3Jtcy90cy9uZ01vZGVsR3JvdXAvbmdfbW9kZWxfZ3JvdXBfZXhhbXBsZS50cyByZWdpb249J0NvbXBvbmVudCd9XG4gKlxuICogQG5nTW9kdWxlIEZvcm1zTW9kdWxlXG4gKiBAcHVibGljQXBpXG4gKi9cbmNsYXNzIE5nTW9kZWxHcm91cCBleHRlbmRzIEFic3RyYWN0Rm9ybUdyb3VwRGlyZWN0aXZlIHtcbiAgICBjb25zdHJ1Y3RvcihwYXJlbnQsIHZhbGlkYXRvcnMsIGFzeW5jVmFsaWRhdG9ycykge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICAvKipcbiAgICAgICAgICogQGRlc2NyaXB0aW9uXG4gICAgICAgICAqIFRyYWNrcyB0aGUgbmFtZSBvZiB0aGUgYE5nTW9kZWxHcm91cGAgYm91bmQgdG8gdGhlIGRpcmVjdGl2ZS4gVGhlIG5hbWUgY29ycmVzcG9uZHNcbiAgICAgICAgICogdG8gYSBrZXkgaW4gdGhlIHBhcmVudCBgTmdGb3JtYC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubmFtZSA9ICcnO1xuICAgICAgICB0aGlzLl9wYXJlbnQgPSBwYXJlbnQ7XG4gICAgICAgIHRoaXMuX3NldFZhbGlkYXRvcnModmFsaWRhdG9ycyk7XG4gICAgICAgIHRoaXMuX3NldEFzeW5jVmFsaWRhdG9ycyhhc3luY1ZhbGlkYXRvcnMpO1xuICAgIH1cbiAgICAvKiogQGludGVybmFsICovXG4gICAgX2NoZWNrUGFyZW50VHlwZSgpIHtcbiAgICAgICAgaWYgKCEodGhpcy5fcGFyZW50IGluc3RhbmNlb2YgTmdNb2RlbEdyb3VwKSAmJiAhKHRoaXMuX3BhcmVudCBpbnN0YW5jZW9mIE5nRm9ybSkgJiZcbiAgICAgICAgICAgICh0eXBlb2YgbmdEZXZNb2RlID09PSAndW5kZWZpbmVkJyB8fCBuZ0Rldk1vZGUpKSB7XG4gICAgICAgICAgICB0aHJvdyBtb2RlbEdyb3VwUGFyZW50RXhjZXB0aW9uKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3RhdGljIHsgdGhpcy7JtWZhYyA9IGkwLsm1ybVuZ0RlY2xhcmVGYWN0b3J5KHsgbWluVmVyc2lvbjogXCIxMi4wLjBcIiwgdmVyc2lvbjogXCIxNy4zLjEyXCIsIG5nSW1wb3J0OiBpMCwgdHlwZTogTmdNb2RlbEdyb3VwLCBkZXBzOiBbeyB0b2tlbjogQ29udHJvbENvbnRhaW5lciwgaG9zdDogdHJ1ZSwgc2tpcFNlbGY6IHRydWUgfSwgeyB0b2tlbjogTkdfVkFMSURBVE9SUywgb3B0aW9uYWw6IHRydWUsIHNlbGY6IHRydWUgfSwgeyB0b2tlbjogTkdfQVNZTkNfVkFMSURBVE9SUywgb3B0aW9uYWw6IHRydWUsIHNlbGY6IHRydWUgfV0sIHRhcmdldDogaTAuybXJtUZhY3RvcnlUYXJnZXQuRGlyZWN0aXZlIH0pOyB9XG4gICAgc3RhdGljIHsgdGhpcy7JtWRpciA9IGkwLsm1ybVuZ0RlY2xhcmVEaXJlY3RpdmUoeyBtaW5WZXJzaW9uOiBcIjE0LjAuMFwiLCB2ZXJzaW9uOiBcIjE3LjMuMTJcIiwgdHlwZTogTmdNb2RlbEdyb3VwLCBzZWxlY3RvcjogXCJbbmdNb2RlbEdyb3VwXVwiLCBpbnB1dHM6IHsgbmFtZTogW1wibmdNb2RlbEdyb3VwXCIsIFwibmFtZVwiXSB9LCBwcm92aWRlcnM6IFttb2RlbEdyb3VwUHJvdmlkZXJdLCBleHBvcnRBczogW1wibmdNb2RlbEdyb3VwXCJdLCB1c2VzSW5oZXJpdGFuY2U6IHRydWUsIG5nSW1wb3J0OiBpMCB9KTsgfVxufVxuaTAuybXJtW5nRGVjbGFyZUNsYXNzTWV0YWRhdGEoeyBtaW5WZXJzaW9uOiBcIjEyLjAuMFwiLCB2ZXJzaW9uOiBcIjE3LjMuMTJcIiwgbmdJbXBvcnQ6IGkwLCB0eXBlOiBOZ01vZGVsR3JvdXAsIGRlY29yYXRvcnM6IFt7XG4gICAgICAgICAgICB0eXBlOiBEaXJlY3RpdmUsXG4gICAgICAgICAgICBhcmdzOiBbeyBzZWxlY3RvcjogJ1tuZ01vZGVsR3JvdXBdJywgcHJvdmlkZXJzOiBbbW9kZWxHcm91cFByb3ZpZGVyXSwgZXhwb3J0QXM6ICduZ01vZGVsR3JvdXAnIH1dXG4gICAgICAgIH1dLCBjdG9yUGFyYW1ldGVyczogKCkgPT4gW3sgdHlwZTogQ29udHJvbENvbnRhaW5lciwgZGVjb3JhdG9yczogW3tcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogSG9zdFxuICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogU2tpcFNlbGZcbiAgICAgICAgICAgICAgICB9XSB9LCB7IHR5cGU6IHVuZGVmaW5lZCwgZGVjb3JhdG9yczogW3tcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogT3B0aW9uYWxcbiAgICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFNlbGZcbiAgICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IEluamVjdCxcbiAgICAgICAgICAgICAgICAgICAgYXJnczogW05HX1ZBTElEQVRPUlNdXG4gICAgICAgICAgICAgICAgfV0gfSwgeyB0eXBlOiB1bmRlZmluZWQsIGRlY29yYXRvcnM6IFt7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IE9wdGlvbmFsXG4gICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBTZWxmXG4gICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBJbmplY3QsXG4gICAgICAgICAgICAgICAgICAgIGFyZ3M6IFtOR19BU1lOQ19WQUxJREFUT1JTXVxuICAgICAgICAgICAgICAgIH1dIH1dLCBwcm9wRGVjb3JhdG9yczogeyBuYW1lOiBbe1xuICAgICAgICAgICAgICAgIHR5cGU6IElucHV0LFxuICAgICAgICAgICAgICAgIGFyZ3M6IFsnbmdNb2RlbEdyb3VwJ11cbiAgICAgICAgICAgIH1dIH0gfSk7XG5cbmNvbnN0IGZvcm1Db250cm9sQmluZGluZyQxID0ge1xuICAgIHByb3ZpZGU6IE5nQ29udHJvbCxcbiAgICB1c2VFeGlzdGluZzogZm9yd2FyZFJlZigoKSA9PiBOZ01vZGVsKVxufTtcbi8qKlxuICogYG5nTW9kZWxgIGZvcmNlcyBhbiBhZGRpdGlvbmFsIGNoYW5nZSBkZXRlY3Rpb24gcnVuIHdoZW4gaXRzIGlucHV0cyBjaGFuZ2U6XG4gKiBFLmcuOlxuICogYGBgXG4gKiA8ZGl2Pnt7bXlNb2RlbC52YWxpZH19PC9kaXY+XG4gKiA8aW5wdXQgWyhuZ01vZGVsKV09XCJteVZhbHVlXCIgI215TW9kZWw9XCJuZ01vZGVsXCI+XG4gKiBgYGBcbiAqIEkuZS4gYG5nTW9kZWxgIGNhbiBleHBvcnQgaXRzZWxmIG9uIHRoZSBlbGVtZW50IGFuZCB0aGVuIGJlIHVzZWQgaW4gdGhlIHRlbXBsYXRlLlxuICogTm9ybWFsbHksIHRoaXMgd291bGQgcmVzdWx0IGluIGV4cHJlc3Npb25zIGJlZm9yZSB0aGUgYGlucHV0YCB0aGF0IHVzZSB0aGUgZXhwb3J0ZWQgZGlyZWN0aXZlXG4gKiB0byBoYXZlIGFuIG9sZCB2YWx1ZSBhcyB0aGV5IGhhdmUgYmVlblxuICogZGlydHkgY2hlY2tlZCBiZWZvcmUuIEFzIHRoaXMgaXMgYSB2ZXJ5IGNvbW1vbiBjYXNlIGZvciBgbmdNb2RlbGAsIHdlIGFkZGVkIHRoaXMgc2Vjb25kIGNoYW5nZVxuICogZGV0ZWN0aW9uIHJ1bi5cbiAqXG4gKiBOb3RlczpcbiAqIC0gdGhpcyBpcyBqdXN0IG9uZSBleHRyYSBydW4gbm8gbWF0dGVyIGhvdyBtYW55IGBuZ01vZGVsYHMgaGF2ZSBiZWVuIGNoYW5nZWQuXG4gKiAtIHRoaXMgaXMgYSBnZW5lcmFsIHByb2JsZW0gd2hlbiB1c2luZyBgZXhwb3J0QXNgIGZvciBkaXJlY3RpdmVzIVxuICovXG5jb25zdCByZXNvbHZlZFByb21pc2UgPSAoKCkgPT4gUHJvbWlzZS5yZXNvbHZlKCkpKCk7XG4vKipcbiAqIEBkZXNjcmlwdGlvblxuICogQ3JlYXRlcyBhIGBGb3JtQ29udHJvbGAgaW5zdGFuY2UgZnJvbSBhIFtkb21haW5cbiAqIG1vZGVsXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Eb21haW5fbW9kZWwpIGFuZCBiaW5kcyBpdCB0byBhIGZvcm0gY29udHJvbCBlbGVtZW50LlxuICpcbiAqIFRoZSBgRm9ybUNvbnRyb2xgIGluc3RhbmNlIHRyYWNrcyB0aGUgdmFsdWUsIHVzZXIgaW50ZXJhY3Rpb24sIGFuZFxuICogdmFsaWRhdGlvbiBzdGF0dXMgb2YgdGhlIGNvbnRyb2wgYW5kIGtlZXBzIHRoZSB2aWV3IHN5bmNlZCB3aXRoIHRoZSBtb2RlbC4gSWYgdXNlZFxuICogd2l0aGluIGEgcGFyZW50IGZvcm0sIHRoZSBkaXJlY3RpdmUgYWxzbyByZWdpc3RlcnMgaXRzZWxmIHdpdGggdGhlIGZvcm0gYXMgYSBjaGlsZFxuICogY29udHJvbC5cbiAqXG4gKiBUaGlzIGRpcmVjdGl2ZSBpcyB1c2VkIGJ5IGl0c2VsZiBvciBhcyBwYXJ0IG9mIGEgbGFyZ2VyIGZvcm0uIFVzZSB0aGVcbiAqIGBuZ01vZGVsYCBzZWxlY3RvciB0byBhY3RpdmF0ZSBpdC5cbiAqXG4gKiBJdCBhY2NlcHRzIGEgZG9tYWluIG1vZGVsIGFzIGFuIG9wdGlvbmFsIGBJbnB1dGAuIElmIHlvdSBoYXZlIGEgb25lLXdheSBiaW5kaW5nXG4gKiB0byBgbmdNb2RlbGAgd2l0aCBgW11gIHN5bnRheCwgY2hhbmdpbmcgdGhlIGRvbWFpbiBtb2RlbCdzIHZhbHVlIGluIHRoZSBjb21wb25lbnRcbiAqIGNsYXNzIHNldHMgdGhlIHZhbHVlIGluIHRoZSB2aWV3LiBJZiB5b3UgaGF2ZSBhIHR3by13YXkgYmluZGluZyB3aXRoIGBbKCldYCBzeW50YXhcbiAqIChhbHNvIGtub3duIGFzICdiYW5hbmEtaW4tYS1ib3ggc3ludGF4JyksIHRoZSB2YWx1ZSBpbiB0aGUgVUkgYWx3YXlzIHN5bmNzIGJhY2sgdG9cbiAqIHRoZSBkb21haW4gbW9kZWwgaW4geW91ciBjbGFzcy5cbiAqXG4gKiBUbyBpbnNwZWN0IHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBhc3NvY2lhdGVkIGBGb3JtQ29udHJvbGAgKGxpa2UgdGhlIHZhbGlkaXR5IHN0YXRlKSxcbiAqIGV4cG9ydCB0aGUgZGlyZWN0aXZlIGludG8gYSBsb2NhbCB0ZW1wbGF0ZSB2YXJpYWJsZSB1c2luZyBgbmdNb2RlbGAgYXMgdGhlIGtleSAoZXg6XG4gKiBgI215VmFyPVwibmdNb2RlbFwiYCkuIFlvdSBjYW4gdGhlbiBhY2Nlc3MgdGhlIGNvbnRyb2wgdXNpbmcgdGhlIGRpcmVjdGl2ZSdzIGBjb250cm9sYCBwcm9wZXJ0eS5cbiAqIEhvd2V2ZXIsIHRoZSBtb3N0IGNvbW1vbmx5IHVzZWQgcHJvcGVydGllcyAobGlrZSBgdmFsaWRgIGFuZCBgZGlydHlgKSBhbHNvIGV4aXN0IG9uIHRoZSBjb250cm9sXG4gKiBmb3IgZGlyZWN0IGFjY2Vzcy4gU2VlIGEgZnVsbCBsaXN0IG9mIHByb3BlcnRpZXMgZGlyZWN0bHkgYXZhaWxhYmxlIGluXG4gKiBgQWJzdHJhY3RDb250cm9sRGlyZWN0aXZlYC5cbiAqXG4gKiBAc2VlIHtAbGluayBSYWRpb0NvbnRyb2xWYWx1ZUFjY2Vzc29yfVxuICogQHNlZSB7QGxpbmsgU2VsZWN0Q29udHJvbFZhbHVlQWNjZXNzb3J9XG4gKlxuICogQHVzYWdlTm90ZXNcbiAqXG4gKiAjIyMgVXNpbmcgbmdNb2RlbCBvbiBhIHN0YW5kYWxvbmUgY29udHJvbFxuICpcbiAqIFRoZSBmb2xsb3dpbmcgZXhhbXBsZXMgc2hvdyBhIHNpbXBsZSBzdGFuZGFsb25lIGNvbnRyb2wgdXNpbmcgYG5nTW9kZWxgOlxuICpcbiAqIHtAZXhhbXBsZSBmb3Jtcy90cy9zaW1wbGVOZ01vZGVsL3NpbXBsZV9uZ19tb2RlbF9leGFtcGxlLnRzIHJlZ2lvbj0nQ29tcG9uZW50J31cbiAqXG4gKiBXaGVuIHVzaW5nIHRoZSBgbmdNb2RlbGAgd2l0aGluIGA8Zm9ybT5gIHRhZ3MsIHlvdSdsbCBhbHNvIG5lZWQgdG8gc3VwcGx5IGEgYG5hbWVgIGF0dHJpYnV0ZVxuICogc28gdGhhdCB0aGUgY29udHJvbCBjYW4gYmUgcmVnaXN0ZXJlZCB3aXRoIHRoZSBwYXJlbnQgZm9ybSB1bmRlciB0aGF0IG5hbWUuXG4gKlxuICogSW4gdGhlIGNvbnRleHQgb2YgYSBwYXJlbnQgZm9ybSwgaXQncyBvZnRlbiB1bm5lY2Vzc2FyeSB0byBpbmNsdWRlIG9uZS13YXkgb3IgdHdvLXdheSBiaW5kaW5nLFxuICogYXMgdGhlIHBhcmVudCBmb3JtIHN5bmNzIHRoZSB2YWx1ZSBmb3IgeW91LiBZb3UgYWNjZXNzIGl0cyBwcm9wZXJ0aWVzIGJ5IGV4cG9ydGluZyBpdCBpbnRvIGFcbiAqIGxvY2FsIHRlbXBsYXRlIHZhcmlhYmxlIHVzaW5nIGBuZ0Zvcm1gIHN1Y2ggYXMgKGAjZj1cIm5nRm9ybVwiYCkuIFVzZSB0aGUgdmFyaWFibGUgd2hlcmVcbiAqIG5lZWRlZCBvbiBmb3JtIHN1Ym1pc3Npb24uXG4gKlxuICogSWYgeW91IGRvIG5lZWQgdG8gcG9wdWxhdGUgaW5pdGlhbCB2YWx1ZXMgaW50byB5b3VyIGZvcm0sIHVzaW5nIGEgb25lLXdheSBiaW5kaW5nIGZvclxuICogYG5nTW9kZWxgIHRlbmRzIHRvIGJlIHN1ZmZpY2llbnQgYXMgbG9uZyBhcyB5b3UgdXNlIHRoZSBleHBvcnRlZCBmb3JtJ3MgdmFsdWUgcmF0aGVyXG4gKiB0aGFuIHRoZSBkb21haW4gbW9kZWwncyB2YWx1ZSBvbiBzdWJtaXQuXG4gKlxuICogIyMjIFVzaW5nIG5nTW9kZWwgd2l0aGluIGEgZm9ybVxuICpcbiAqIFRoZSBmb2xsb3dpbmcgZXhhbXBsZSBzaG93cyBjb250cm9scyB1c2luZyBgbmdNb2RlbGAgd2l0aGluIGEgZm9ybTpcbiAqXG4gKiB7QGV4YW1wbGUgZm9ybXMvdHMvc2ltcGxlRm9ybS9zaW1wbGVfZm9ybV9leGFtcGxlLnRzIHJlZ2lvbj0nQ29tcG9uZW50J31cbiAqXG4gKiAjIyMgVXNpbmcgYSBzdGFuZGFsb25lIG5nTW9kZWwgd2l0aGluIGEgZ3JvdXBcbiAqXG4gKiBUaGUgZm9sbG93aW5nIGV4YW1wbGUgc2hvd3MgeW91IGhvdyB0byB1c2UgYSBzdGFuZGFsb25lIG5nTW9kZWwgY29udHJvbFxuICogd2l0aGluIGEgZm9ybS4gVGhpcyBjb250cm9scyB0aGUgZGlzcGxheSBvZiB0aGUgZm9ybSwgYnV0IGRvZXNuJ3QgY29udGFpbiBmb3JtIGRhdGEuXG4gKlxuICogYGBgaHRtbFxuICogPGZvcm0+XG4gKiAgIDxpbnB1dCBuYW1lPVwibG9naW5cIiBuZ01vZGVsIHBsYWNlaG9sZGVyPVwiTG9naW5cIj5cbiAqICAgPGlucHV0IHR5cGU9XCJjaGVja2JveFwiIG5nTW9kZWwgW25nTW9kZWxPcHRpb25zXT1cIntzdGFuZGFsb25lOiB0cnVlfVwiPiBTaG93IG1vcmUgb3B0aW9ucz9cbiAqIDwvZm9ybT5cbiAqIDwhLS0gZm9ybSB2YWx1ZToge2xvZ2luOiAnJ30gLS0+XG4gKiBgYGBcbiAqXG4gKiAjIyMgU2V0dGluZyB0aGUgbmdNb2RlbCBgbmFtZWAgYXR0cmlidXRlIHRocm91Z2ggb3B0aW9uc1xuICpcbiAqIFRoZSBmb2xsb3dpbmcgZXhhbXBsZSBzaG93cyB5b3UgYW4gYWx0ZXJuYXRlIHdheSB0byBzZXQgdGhlIG5hbWUgYXR0cmlidXRlLiBIZXJlLFxuICogYW4gYXR0cmlidXRlIGlkZW50aWZpZWQgYXMgbmFtZSBpcyB1c2VkIHdpdGhpbiBhIGN1c3RvbSBmb3JtIGNvbnRyb2wgY29tcG9uZW50LiBUbyBzdGlsbCBiZSBhYmxlXG4gKiB0byBzcGVjaWZ5IHRoZSBOZ01vZGVsJ3MgbmFtZSwgeW91IG11c3Qgc3BlY2lmeSBpdCB1c2luZyB0aGUgYG5nTW9kZWxPcHRpb25zYCBpbnB1dCBpbnN0ZWFkLlxuICpcbiAqIGBgYGh0bWxcbiAqIDxmb3JtPlxuICogICA8bXktY3VzdG9tLWZvcm0tY29udHJvbCBuYW1lPVwiTmFuY3lcIiBuZ01vZGVsIFtuZ01vZGVsT3B0aW9uc109XCJ7bmFtZTogJ3VzZXInfVwiPlxuICogICA8L215LWN1c3RvbS1mb3JtLWNvbnRyb2w+XG4gKiA8L2Zvcm0+XG4gKiA8IS0tIGZvcm0gdmFsdWU6IHt1c2VyOiAnJ30gLS0+XG4gKiBgYGBcbiAqXG4gKiBAbmdNb2R1bGUgRm9ybXNNb2R1bGVcbiAqIEBwdWJsaWNBcGlcbiAqL1xuY2xhc3MgTmdNb2RlbCBleHRlbmRzIE5nQ29udHJvbCB7XG4gICAgY29uc3RydWN0b3IocGFyZW50LCB2YWxpZGF0b3JzLCBhc3luY1ZhbGlkYXRvcnMsIHZhbHVlQWNjZXNzb3JzLCBfY2hhbmdlRGV0ZWN0b3JSZWYsIGNhbGxTZXREaXNhYmxlZFN0YXRlKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuX2NoYW5nZURldGVjdG9yUmVmID0gX2NoYW5nZURldGVjdG9yUmVmO1xuICAgICAgICB0aGlzLmNhbGxTZXREaXNhYmxlZFN0YXRlID0gY2FsbFNldERpc2FibGVkU3RhdGU7XG4gICAgICAgIHRoaXMuY29udHJvbCA9IG5ldyBGb3JtQ29udHJvbCgpO1xuICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgIHRoaXMuX3JlZ2lzdGVyZWQgPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAgICAgKiBUcmFja3MgdGhlIG5hbWUgYm91bmQgdG8gdGhlIGRpcmVjdGl2ZS4gSWYgYSBwYXJlbnQgZm9ybSBleGlzdHMsIGl0XG4gICAgICAgICAqIHVzZXMgdGhpcyBuYW1lIGFzIGEga2V5IHRvIHJldHJpZXZlIHRoaXMgY29udHJvbCdzIHZhbHVlLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5uYW1lID0gJyc7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgICAgICogRXZlbnQgZW1pdHRlciBmb3IgcHJvZHVjaW5nIHRoZSBgbmdNb2RlbENoYW5nZWAgZXZlbnQgYWZ0ZXJcbiAgICAgICAgICogdGhlIHZpZXcgbW9kZWwgdXBkYXRlcy5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudXBkYXRlID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICB0aGlzLl9wYXJlbnQgPSBwYXJlbnQ7XG4gICAgICAgIHRoaXMuX3NldFZhbGlkYXRvcnModmFsaWRhdG9ycyk7XG4gICAgICAgIHRoaXMuX3NldEFzeW5jVmFsaWRhdG9ycyhhc3luY1ZhbGlkYXRvcnMpO1xuICAgICAgICB0aGlzLnZhbHVlQWNjZXNzb3IgPSBzZWxlY3RWYWx1ZUFjY2Vzc29yKHRoaXMsIHZhbHVlQWNjZXNzb3JzKTtcbiAgICB9XG4gICAgLyoqIEBub2RvYyAqL1xuICAgIG5nT25DaGFuZ2VzKGNoYW5nZXMpIHtcbiAgICAgICAgdGhpcy5fY2hlY2tGb3JFcnJvcnMoKTtcbiAgICAgICAgaWYgKCF0aGlzLl9yZWdpc3RlcmVkIHx8ICduYW1lJyBpbiBjaGFuZ2VzKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fcmVnaXN0ZXJlZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2NoZWNrTmFtZSgpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmZvcm1EaXJlY3RpdmUpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gV2UgY2FuJ3QgY2FsbCBgZm9ybURpcmVjdGl2ZS5yZW1vdmVDb250cm9sKHRoaXMpYCwgYmVjYXVzZSB0aGUgYG5hbWVgIGhhcyBhbHJlYWR5IGJlZW5cbiAgICAgICAgICAgICAgICAgICAgLy8gY2hhbmdlZC4gV2UgYWxzbyBjYW4ndCByZXNldCB0aGUgbmFtZSB0ZW1wb3JhcmlseSBzaW5jZSB0aGUgbG9naWMgaW4gYHJlbW92ZUNvbnRyb2xgXG4gICAgICAgICAgICAgICAgICAgIC8vIGlzIGluc2lkZSBhIHByb21pc2UgYW5kIGl0IHdvbid0IHJ1biBpbW1lZGlhdGVseS4gV2Ugd29yayBhcm91bmQgaXQgYnkgZ2l2aW5nIGl0IGFuXG4gICAgICAgICAgICAgICAgICAgIC8vIG9iamVjdCB3aXRoIHRoZSBzYW1lIHNoYXBlIGluc3RlYWQuXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG9sZE5hbWUgPSBjaGFuZ2VzWyduYW1lJ10ucHJldmlvdXNWYWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5mb3JtRGlyZWN0aXZlLnJlbW92ZUNvbnRyb2woeyBuYW1lOiBvbGROYW1lLCBwYXRoOiB0aGlzLl9nZXRQYXRoKG9sZE5hbWUpIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3NldFVwQ29udHJvbCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICgnaXNEaXNhYmxlZCcgaW4gY2hhbmdlcykge1xuICAgICAgICAgICAgdGhpcy5fdXBkYXRlRGlzYWJsZWQoY2hhbmdlcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzUHJvcGVydHlVcGRhdGVkKGNoYW5nZXMsIHRoaXMudmlld01vZGVsKSkge1xuICAgICAgICAgICAgdGhpcy5fdXBkYXRlVmFsdWUodGhpcy5tb2RlbCk7XG4gICAgICAgICAgICB0aGlzLnZpZXdNb2RlbCA9IHRoaXMubW9kZWw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqIEBub2RvYyAqL1xuICAgIG5nT25EZXN0cm95KCkge1xuICAgICAgICB0aGlzLmZvcm1EaXJlY3RpdmUgJiYgdGhpcy5mb3JtRGlyZWN0aXZlLnJlbW92ZUNvbnRyb2wodGhpcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqIFJldHVybnMgYW4gYXJyYXkgdGhhdCByZXByZXNlbnRzIHRoZSBwYXRoIGZyb20gdGhlIHRvcC1sZXZlbCBmb3JtIHRvIHRoaXMgY29udHJvbC5cbiAgICAgKiBFYWNoIGluZGV4IGlzIHRoZSBzdHJpbmcgbmFtZSBvZiB0aGUgY29udHJvbCBvbiB0aGF0IGxldmVsLlxuICAgICAqL1xuICAgIGdldCBwYXRoKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZ2V0UGF0aCh0aGlzLm5hbWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKiBUaGUgdG9wLWxldmVsIGRpcmVjdGl2ZSBmb3IgdGhpcyBjb250cm9sIGlmIHByZXNlbnQsIG90aGVyd2lzZSBudWxsLlxuICAgICAqL1xuICAgIGdldCBmb3JtRGlyZWN0aXZlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcGFyZW50ID8gdGhpcy5fcGFyZW50LmZvcm1EaXJlY3RpdmUgOiBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKiBTZXRzIHRoZSBuZXcgdmFsdWUgZm9yIHRoZSB2aWV3IG1vZGVsIGFuZCBlbWl0cyBhbiBgbmdNb2RlbENoYW5nZWAgZXZlbnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbmV3VmFsdWUgVGhlIG5ldyB2YWx1ZSBlbWl0dGVkIGJ5IGBuZ01vZGVsQ2hhbmdlYC5cbiAgICAgKi9cbiAgICB2aWV3VG9Nb2RlbFVwZGF0ZShuZXdWYWx1ZSkge1xuICAgICAgICB0aGlzLnZpZXdNb2RlbCA9IG5ld1ZhbHVlO1xuICAgICAgICB0aGlzLnVwZGF0ZS5lbWl0KG5ld1ZhbHVlKTtcbiAgICB9XG4gICAgX3NldFVwQ29udHJvbCgpIHtcbiAgICAgICAgdGhpcy5fc2V0VXBkYXRlU3RyYXRlZ3koKTtcbiAgICAgICAgdGhpcy5faXNTdGFuZGFsb25lKCkgPyB0aGlzLl9zZXRVcFN0YW5kYWxvbmUoKSA6IHRoaXMuZm9ybURpcmVjdGl2ZS5hZGRDb250cm9sKHRoaXMpO1xuICAgICAgICB0aGlzLl9yZWdpc3RlcmVkID0gdHJ1ZTtcbiAgICB9XG4gICAgX3NldFVwZGF0ZVN0cmF0ZWd5KCkge1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zICYmIHRoaXMub3B0aW9ucy51cGRhdGVPbiAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmNvbnRyb2wuX3VwZGF0ZU9uID0gdGhpcy5vcHRpb25zLnVwZGF0ZU9uO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9pc1N0YW5kYWxvbmUoKSB7XG4gICAgICAgIHJldHVybiAhdGhpcy5fcGFyZW50IHx8ICEhKHRoaXMub3B0aW9ucyAmJiB0aGlzLm9wdGlvbnMuc3RhbmRhbG9uZSk7XG4gICAgfVxuICAgIF9zZXRVcFN0YW5kYWxvbmUoKSB7XG4gICAgICAgIHNldFVwQ29udHJvbCh0aGlzLmNvbnRyb2wsIHRoaXMsIHRoaXMuY2FsbFNldERpc2FibGVkU3RhdGUpO1xuICAgICAgICB0aGlzLmNvbnRyb2wudXBkYXRlVmFsdWVBbmRWYWxpZGl0eSh7IGVtaXRFdmVudDogZmFsc2UgfSk7XG4gICAgfVxuICAgIF9jaGVja0ZvckVycm9ycygpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9pc1N0YW5kYWxvbmUoKSkge1xuICAgICAgICAgICAgdGhpcy5fY2hlY2tQYXJlbnRUeXBlKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fY2hlY2tOYW1lKCk7XG4gICAgfVxuICAgIF9jaGVja1BhcmVudFR5cGUoKSB7XG4gICAgICAgIGlmICh0eXBlb2YgbmdEZXZNb2RlID09PSAndW5kZWZpbmVkJyB8fCBuZ0Rldk1vZGUpIHtcbiAgICAgICAgICAgIGlmICghKHRoaXMuX3BhcmVudCBpbnN0YW5jZW9mIE5nTW9kZWxHcm91cCkgJiZcbiAgICAgICAgICAgICAgICB0aGlzLl9wYXJlbnQgaW5zdGFuY2VvZiBBYnN0cmFjdEZvcm1Hcm91cERpcmVjdGl2ZSkge1xuICAgICAgICAgICAgICAgIHRocm93IGZvcm1Hcm91cE5hbWVFeGNlcHRpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCEodGhpcy5fcGFyZW50IGluc3RhbmNlb2YgTmdNb2RlbEdyb3VwKSAmJiAhKHRoaXMuX3BhcmVudCBpbnN0YW5jZW9mIE5nRm9ybSkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBtb2RlbFBhcmVudEV4Y2VwdGlvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIF9jaGVja05hbWUoKSB7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMgJiYgdGhpcy5vcHRpb25zLm5hbWUpXG4gICAgICAgICAgICB0aGlzLm5hbWUgPSB0aGlzLm9wdGlvbnMubmFtZTtcbiAgICAgICAgaWYgKCF0aGlzLl9pc1N0YW5kYWxvbmUoKSAmJiAhdGhpcy5uYW1lICYmICh0eXBlb2YgbmdEZXZNb2RlID09PSAndW5kZWZpbmVkJyB8fCBuZ0Rldk1vZGUpKSB7XG4gICAgICAgICAgICB0aHJvdyBtaXNzaW5nTmFtZUV4Y2VwdGlvbigpO1xuICAgICAgICB9XG4gICAgfVxuICAgIF91cGRhdGVWYWx1ZSh2YWx1ZSkge1xuICAgICAgICByZXNvbHZlZFByb21pc2UudGhlbigoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmNvbnRyb2wuc2V0VmFsdWUodmFsdWUsIHsgZW1pdFZpZXdUb01vZGVsQ2hhbmdlOiBmYWxzZSB9KTtcbiAgICAgICAgICAgIHRoaXMuX2NoYW5nZURldGVjdG9yUmVmPy5tYXJrRm9yQ2hlY2soKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIF91cGRhdGVEaXNhYmxlZChjaGFuZ2VzKSB7XG4gICAgICAgIGNvbnN0IGRpc2FibGVkVmFsdWUgPSBjaGFuZ2VzWydpc0Rpc2FibGVkJ10uY3VycmVudFZhbHVlO1xuICAgICAgICAvLyBjaGVja2luZyBmb3IgMCB0byBhdm9pZCBicmVha2luZyBjaGFuZ2VcbiAgICAgICAgY29uc3QgaXNEaXNhYmxlZCA9IGRpc2FibGVkVmFsdWUgIT09IDAgJiYgYm9vbGVhbkF0dHJpYnV0ZShkaXNhYmxlZFZhbHVlKTtcbiAgICAgICAgcmVzb2x2ZWRQcm9taXNlLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgaWYgKGlzRGlzYWJsZWQgJiYgIXRoaXMuY29udHJvbC5kaXNhYmxlZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuY29udHJvbC5kaXNhYmxlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICghaXNEaXNhYmxlZCAmJiB0aGlzLmNvbnRyb2wuZGlzYWJsZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRyb2wuZW5hYmxlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9jaGFuZ2VEZXRlY3RvclJlZj8ubWFya0ZvckNoZWNrKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBfZ2V0UGF0aChjb250cm9sTmFtZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcGFyZW50ID8gY29udHJvbFBhdGgoY29udHJvbE5hbWUsIHRoaXMuX3BhcmVudCkgOiBbY29udHJvbE5hbWVdO1xuICAgIH1cbiAgICBzdGF0aWMgeyB0aGlzLsm1ZmFjID0gaTAuybXJtW5nRGVjbGFyZUZhY3RvcnkoeyBtaW5WZXJzaW9uOiBcIjEyLjAuMFwiLCB2ZXJzaW9uOiBcIjE3LjMuMTJcIiwgbmdJbXBvcnQ6IGkwLCB0eXBlOiBOZ01vZGVsLCBkZXBzOiBbeyB0b2tlbjogQ29udHJvbENvbnRhaW5lciwgaG9zdDogdHJ1ZSwgb3B0aW9uYWw6IHRydWUgfSwgeyB0b2tlbjogTkdfVkFMSURBVE9SUywgb3B0aW9uYWw6IHRydWUsIHNlbGY6IHRydWUgfSwgeyB0b2tlbjogTkdfQVNZTkNfVkFMSURBVE9SUywgb3B0aW9uYWw6IHRydWUsIHNlbGY6IHRydWUgfSwgeyB0b2tlbjogTkdfVkFMVUVfQUNDRVNTT1IsIG9wdGlvbmFsOiB0cnVlLCBzZWxmOiB0cnVlIH0sIHsgdG9rZW46IENoYW5nZURldGVjdG9yUmVmLCBvcHRpb25hbDogdHJ1ZSB9LCB7IHRva2VuOiBDQUxMX1NFVF9ESVNBQkxFRF9TVEFURSwgb3B0aW9uYWw6IHRydWUgfV0sIHRhcmdldDogaTAuybXJtUZhY3RvcnlUYXJnZXQuRGlyZWN0aXZlIH0pOyB9XG4gICAgc3RhdGljIHsgdGhpcy7JtWRpciA9IGkwLsm1ybVuZ0RlY2xhcmVEaXJlY3RpdmUoeyBtaW5WZXJzaW9uOiBcIjE0LjAuMFwiLCB2ZXJzaW9uOiBcIjE3LjMuMTJcIiwgdHlwZTogTmdNb2RlbCwgc2VsZWN0b3I6IFwiW25nTW9kZWxdOm5vdChbZm9ybUNvbnRyb2xOYW1lXSk6bm90KFtmb3JtQ29udHJvbF0pXCIsIGlucHV0czogeyBuYW1lOiBcIm5hbWVcIiwgaXNEaXNhYmxlZDogW1wiZGlzYWJsZWRcIiwgXCJpc0Rpc2FibGVkXCJdLCBtb2RlbDogW1wibmdNb2RlbFwiLCBcIm1vZGVsXCJdLCBvcHRpb25zOiBbXCJuZ01vZGVsT3B0aW9uc1wiLCBcIm9wdGlvbnNcIl0gfSwgb3V0cHV0czogeyB1cGRhdGU6IFwibmdNb2RlbENoYW5nZVwiIH0sIHByb3ZpZGVyczogW2Zvcm1Db250cm9sQmluZGluZyQxXSwgZXhwb3J0QXM6IFtcIm5nTW9kZWxcIl0sIHVzZXNJbmhlcml0YW5jZTogdHJ1ZSwgdXNlc09uQ2hhbmdlczogdHJ1ZSwgbmdJbXBvcnQ6IGkwIH0pOyB9XG59XG5pMC7Jtcm1bmdEZWNsYXJlQ2xhc3NNZXRhZGF0YSh7IG1pblZlcnNpb246IFwiMTIuMC4wXCIsIHZlcnNpb246IFwiMTcuMy4xMlwiLCBuZ0ltcG9ydDogaTAsIHR5cGU6IE5nTW9kZWwsIGRlY29yYXRvcnM6IFt7XG4gICAgICAgICAgICB0eXBlOiBEaXJlY3RpdmUsXG4gICAgICAgICAgICBhcmdzOiBbe1xuICAgICAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ1tuZ01vZGVsXTpub3QoW2Zvcm1Db250cm9sTmFtZV0pOm5vdChbZm9ybUNvbnRyb2xdKScsXG4gICAgICAgICAgICAgICAgICAgIHByb3ZpZGVyczogW2Zvcm1Db250cm9sQmluZGluZyQxXSxcbiAgICAgICAgICAgICAgICAgICAgZXhwb3J0QXM6ICduZ01vZGVsJ1xuICAgICAgICAgICAgICAgIH1dXG4gICAgICAgIH1dLCBjdG9yUGFyYW1ldGVyczogKCkgPT4gW3sgdHlwZTogQ29udHJvbENvbnRhaW5lciwgZGVjb3JhdG9yczogW3tcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogT3B0aW9uYWxcbiAgICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IEhvc3RcbiAgICAgICAgICAgICAgICB9XSB9LCB7IHR5cGU6IHVuZGVmaW5lZCwgZGVjb3JhdG9yczogW3tcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogT3B0aW9uYWxcbiAgICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFNlbGZcbiAgICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IEluamVjdCxcbiAgICAgICAgICAgICAgICAgICAgYXJnczogW05HX1ZBTElEQVRPUlNdXG4gICAgICAgICAgICAgICAgfV0gfSwgeyB0eXBlOiB1bmRlZmluZWQsIGRlY29yYXRvcnM6IFt7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IE9wdGlvbmFsXG4gICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBTZWxmXG4gICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBJbmplY3QsXG4gICAgICAgICAgICAgICAgICAgIGFyZ3M6IFtOR19BU1lOQ19WQUxJREFUT1JTXVxuICAgICAgICAgICAgICAgIH1dIH0sIHsgdHlwZTogdW5kZWZpbmVkLCBkZWNvcmF0b3JzOiBbe1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBPcHRpb25hbFxuICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogU2VsZlxuICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogSW5qZWN0LFxuICAgICAgICAgICAgICAgICAgICBhcmdzOiBbTkdfVkFMVUVfQUNDRVNTT1JdXG4gICAgICAgICAgICAgICAgfV0gfSwgeyB0eXBlOiBpMC5DaGFuZ2VEZXRlY3RvclJlZiwgZGVjb3JhdG9yczogW3tcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogT3B0aW9uYWxcbiAgICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IEluamVjdCxcbiAgICAgICAgICAgICAgICAgICAgYXJnczogW0NoYW5nZURldGVjdG9yUmVmXVxuICAgICAgICAgICAgICAgIH1dIH0sIHsgdHlwZTogdW5kZWZpbmVkLCBkZWNvcmF0b3JzOiBbe1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBPcHRpb25hbFxuICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogSW5qZWN0LFxuICAgICAgICAgICAgICAgICAgICBhcmdzOiBbQ0FMTF9TRVRfRElTQUJMRURfU1RBVEVdXG4gICAgICAgICAgICAgICAgfV0gfV0sIHByb3BEZWNvcmF0b3JzOiB7IG5hbWU6IFt7XG4gICAgICAgICAgICAgICAgdHlwZTogSW5wdXRcbiAgICAgICAgICAgIH1dLCBpc0Rpc2FibGVkOiBbe1xuICAgICAgICAgICAgICAgIHR5cGU6IElucHV0LFxuICAgICAgICAgICAgICAgIGFyZ3M6IFsnZGlzYWJsZWQnXVxuICAgICAgICAgICAgfV0sIG1vZGVsOiBbe1xuICAgICAgICAgICAgICAgIHR5cGU6IElucHV0LFxuICAgICAgICAgICAgICAgIGFyZ3M6IFsnbmdNb2RlbCddXG4gICAgICAgICAgICB9XSwgb3B0aW9uczogW3tcbiAgICAgICAgICAgICAgICB0eXBlOiBJbnB1dCxcbiAgICAgICAgICAgICAgICBhcmdzOiBbJ25nTW9kZWxPcHRpb25zJ11cbiAgICAgICAgICAgIH1dLCB1cGRhdGU6IFt7XG4gICAgICAgICAgICAgICAgdHlwZTogT3V0cHV0LFxuICAgICAgICAgICAgICAgIGFyZ3M6IFsnbmdNb2RlbENoYW5nZSddXG4gICAgICAgICAgICB9XSB9IH0pO1xuXG4vKipcbiAqIEBkZXNjcmlwdGlvblxuICpcbiAqIEFkZHMgYG5vdmFsaWRhdGVgIGF0dHJpYnV0ZSB0byBhbGwgZm9ybXMgYnkgZGVmYXVsdC5cbiAqXG4gKiBgbm92YWxpZGF0ZWAgaXMgdXNlZCB0byBkaXNhYmxlIGJyb3dzZXIncyBuYXRpdmUgZm9ybSB2YWxpZGF0aW9uLlxuICpcbiAqIElmIHlvdSB3YW50IHRvIHVzZSBuYXRpdmUgdmFsaWRhdGlvbiB3aXRoIEFuZ3VsYXIgZm9ybXMsIGp1c3QgYWRkIGBuZ05hdGl2ZVZhbGlkYXRlYCBhdHRyaWJ1dGU6XG4gKlxuICogYGBgXG4gKiA8Zm9ybSBuZ05hdGl2ZVZhbGlkYXRlPjwvZm9ybT5cbiAqIGBgYFxuICpcbiAqIEBwdWJsaWNBcGlcbiAqIEBuZ01vZHVsZSBSZWFjdGl2ZUZvcm1zTW9kdWxlXG4gKiBAbmdNb2R1bGUgRm9ybXNNb2R1bGVcbiAqL1xuY2xhc3MgybVOZ05vVmFsaWRhdGUge1xuICAgIHN0YXRpYyB7IHRoaXMuybVmYWMgPSBpMC7Jtcm1bmdEZWNsYXJlRmFjdG9yeSh7IG1pblZlcnNpb246IFwiMTIuMC4wXCIsIHZlcnNpb246IFwiMTcuMy4xMlwiLCBuZ0ltcG9ydDogaTAsIHR5cGU6IMm1TmdOb1ZhbGlkYXRlLCBkZXBzOiBbXSwgdGFyZ2V0OiBpMC7Jtcm1RmFjdG9yeVRhcmdldC5EaXJlY3RpdmUgfSk7IH1cbiAgICBzdGF0aWMgeyB0aGlzLsm1ZGlyID0gaTAuybXJtW5nRGVjbGFyZURpcmVjdGl2ZSh7IG1pblZlcnNpb246IFwiMTQuMC4wXCIsIHZlcnNpb246IFwiMTcuMy4xMlwiLCB0eXBlOiDJtU5nTm9WYWxpZGF0ZSwgc2VsZWN0b3I6IFwiZm9ybTpub3QoW25nTm9Gb3JtXSk6bm90KFtuZ05hdGl2ZVZhbGlkYXRlXSlcIiwgaG9zdDogeyBhdHRyaWJ1dGVzOiB7IFwibm92YWxpZGF0ZVwiOiBcIlwiIH0gfSwgbmdJbXBvcnQ6IGkwIH0pOyB9XG59XG5pMC7Jtcm1bmdEZWNsYXJlQ2xhc3NNZXRhZGF0YSh7IG1pblZlcnNpb246IFwiMTIuMC4wXCIsIHZlcnNpb246IFwiMTcuMy4xMlwiLCBuZ0ltcG9ydDogaTAsIHR5cGU6IMm1TmdOb1ZhbGlkYXRlLCBkZWNvcmF0b3JzOiBbe1xuICAgICAgICAgICAgdHlwZTogRGlyZWN0aXZlLFxuICAgICAgICAgICAgYXJnczogW3tcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdmb3JtOm5vdChbbmdOb0Zvcm1dKTpub3QoW25nTmF0aXZlVmFsaWRhdGVdKScsXG4gICAgICAgICAgICAgICAgICAgIGhvc3Q6IHsgJ25vdmFsaWRhdGUnOiAnJyB9LFxuICAgICAgICAgICAgICAgIH1dXG4gICAgICAgIH1dIH0pO1xuXG5jb25zdCBOVU1CRVJfVkFMVUVfQUNDRVNTT1IgPSB7XG4gICAgcHJvdmlkZTogTkdfVkFMVUVfQUNDRVNTT1IsXG4gICAgdXNlRXhpc3Rpbmc6IGZvcndhcmRSZWYoKCkgPT4gTnVtYmVyVmFsdWVBY2Nlc3NvciksXG4gICAgbXVsdGk6IHRydWVcbn07XG4vKipcbiAqIEBkZXNjcmlwdGlvblxuICogVGhlIGBDb250cm9sVmFsdWVBY2Nlc3NvcmAgZm9yIHdyaXRpbmcgYSBudW1iZXIgdmFsdWUgYW5kIGxpc3RlbmluZyB0byBudW1iZXIgaW5wdXQgY2hhbmdlcy5cbiAqIFRoZSB2YWx1ZSBhY2Nlc3NvciBpcyB1c2VkIGJ5IHRoZSBgRm9ybUNvbnRyb2xEaXJlY3RpdmVgLCBgRm9ybUNvbnRyb2xOYW1lYCwgYW5kIGBOZ01vZGVsYFxuICogZGlyZWN0aXZlcy5cbiAqXG4gKiBAdXNhZ2VOb3Rlc1xuICpcbiAqICMjIyBVc2luZyBhIG51bWJlciBpbnB1dCB3aXRoIGEgcmVhY3RpdmUgZm9ybS5cbiAqXG4gKiBUaGUgZm9sbG93aW5nIGV4YW1wbGUgc2hvd3MgaG93IHRvIHVzZSBhIG51bWJlciBpbnB1dCB3aXRoIGEgcmVhY3RpdmUgZm9ybS5cbiAqXG4gKiBgYGB0c1xuICogY29uc3QgdG90YWxDb3VudENvbnRyb2wgPSBuZXcgRm9ybUNvbnRyb2woKTtcbiAqIGBgYFxuICpcbiAqIGBgYFxuICogPGlucHV0IHR5cGU9XCJudW1iZXJcIiBbZm9ybUNvbnRyb2xdPVwidG90YWxDb3VudENvbnRyb2xcIj5cbiAqIGBgYFxuICpcbiAqIEBuZ01vZHVsZSBSZWFjdGl2ZUZvcm1zTW9kdWxlXG4gKiBAbmdNb2R1bGUgRm9ybXNNb2R1bGVcbiAqIEBwdWJsaWNBcGlcbiAqL1xuY2xhc3MgTnVtYmVyVmFsdWVBY2Nlc3NvciBleHRlbmRzIEJ1aWx0SW5Db250cm9sVmFsdWVBY2Nlc3NvciB7XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgXCJ2YWx1ZVwiIHByb3BlcnR5IG9uIHRoZSBpbnB1dCBlbGVtZW50LlxuICAgICAqIEBub2RvY1xuICAgICAqL1xuICAgIHdyaXRlVmFsdWUodmFsdWUpIHtcbiAgICAgICAgLy8gVGhlIHZhbHVlIG5lZWRzIHRvIGJlIG5vcm1hbGl6ZWQgZm9yIElFOSwgb3RoZXJ3aXNlIGl0IGlzIHNldCB0byAnbnVsbCcgd2hlbiBudWxsXG4gICAgICAgIGNvbnN0IG5vcm1hbGl6ZWRWYWx1ZSA9IHZhbHVlID09IG51bGwgPyAnJyA6IHZhbHVlO1xuICAgICAgICB0aGlzLnNldFByb3BlcnR5KCd2YWx1ZScsIG5vcm1hbGl6ZWRWYWx1ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlZ2lzdGVycyBhIGZ1bmN0aW9uIGNhbGxlZCB3aGVuIHRoZSBjb250cm9sIHZhbHVlIGNoYW5nZXMuXG4gICAgICogQG5vZG9jXG4gICAgICovXG4gICAgcmVnaXN0ZXJPbkNoYW5nZShmbikge1xuICAgICAgICB0aGlzLm9uQ2hhbmdlID0gKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICBmbih2YWx1ZSA9PSAnJyA/IG51bGwgOiBwYXJzZUZsb2F0KHZhbHVlKSk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIHN0YXRpYyB7IHRoaXMuybVmYWMgPSBpMC7Jtcm1bmdEZWNsYXJlRmFjdG9yeSh7IG1pblZlcnNpb246IFwiMTIuMC4wXCIsIHZlcnNpb246IFwiMTcuMy4xMlwiLCBuZ0ltcG9ydDogaTAsIHR5cGU6IE51bWJlclZhbHVlQWNjZXNzb3IsIGRlcHM6IG51bGwsIHRhcmdldDogaTAuybXJtUZhY3RvcnlUYXJnZXQuRGlyZWN0aXZlIH0pOyB9XG4gICAgc3RhdGljIHsgdGhpcy7JtWRpciA9IGkwLsm1ybVuZ0RlY2xhcmVEaXJlY3RpdmUoeyBtaW5WZXJzaW9uOiBcIjE0LjAuMFwiLCB2ZXJzaW9uOiBcIjE3LjMuMTJcIiwgdHlwZTogTnVtYmVyVmFsdWVBY2Nlc3Nvciwgc2VsZWN0b3I6IFwiaW5wdXRbdHlwZT1udW1iZXJdW2Zvcm1Db250cm9sTmFtZV0saW5wdXRbdHlwZT1udW1iZXJdW2Zvcm1Db250cm9sXSxpbnB1dFt0eXBlPW51bWJlcl1bbmdNb2RlbF1cIiwgaG9zdDogeyBsaXN0ZW5lcnM6IHsgXCJpbnB1dFwiOiBcIm9uQ2hhbmdlKCRldmVudC50YXJnZXQudmFsdWUpXCIsIFwiYmx1clwiOiBcIm9uVG91Y2hlZCgpXCIgfSB9LCBwcm92aWRlcnM6IFtOVU1CRVJfVkFMVUVfQUNDRVNTT1JdLCB1c2VzSW5oZXJpdGFuY2U6IHRydWUsIG5nSW1wb3J0OiBpMCB9KTsgfVxufVxuaTAuybXJtW5nRGVjbGFyZUNsYXNzTWV0YWRhdGEoeyBtaW5WZXJzaW9uOiBcIjEyLjAuMFwiLCB2ZXJzaW9uOiBcIjE3LjMuMTJcIiwgbmdJbXBvcnQ6IGkwLCB0eXBlOiBOdW1iZXJWYWx1ZUFjY2Vzc29yLCBkZWNvcmF0b3JzOiBbe1xuICAgICAgICAgICAgdHlwZTogRGlyZWN0aXZlLFxuICAgICAgICAgICAgYXJnczogW3tcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdpbnB1dFt0eXBlPW51bWJlcl1bZm9ybUNvbnRyb2xOYW1lXSxpbnB1dFt0eXBlPW51bWJlcl1bZm9ybUNvbnRyb2xdLGlucHV0W3R5cGU9bnVtYmVyXVtuZ01vZGVsXScsXG4gICAgICAgICAgICAgICAgICAgIGhvc3Q6IHsgJyhpbnB1dCknOiAnb25DaGFuZ2UoJGV2ZW50LnRhcmdldC52YWx1ZSknLCAnKGJsdXIpJzogJ29uVG91Y2hlZCgpJyB9LFxuICAgICAgICAgICAgICAgICAgICBwcm92aWRlcnM6IFtOVU1CRVJfVkFMVUVfQUNDRVNTT1JdXG4gICAgICAgICAgICAgICAgfV1cbiAgICAgICAgfV0gfSk7XG5cbmNvbnN0IFJBRElPX1ZBTFVFX0FDQ0VTU09SID0ge1xuICAgIHByb3ZpZGU6IE5HX1ZBTFVFX0FDQ0VTU09SLFxuICAgIHVzZUV4aXN0aW5nOiBmb3J3YXJkUmVmKCgpID0+IFJhZGlvQ29udHJvbFZhbHVlQWNjZXNzb3IpLFxuICAgIG11bHRpOiB0cnVlXG59O1xuZnVuY3Rpb24gdGhyb3dOYW1lRXJyb3IoKSB7XG4gICAgdGhyb3cgbmV3IMm1UnVudGltZUVycm9yKDEyMDIgLyogUnVudGltZUVycm9yQ29kZS5OQU1FX0FORF9GT1JNX0NPTlRST0xfTkFNRV9NVVNUX01BVENIICovLCBgXG4gICAgICBJZiB5b3UgZGVmaW5lIGJvdGggYSBuYW1lIGFuZCBhIGZvcm1Db250cm9sTmFtZSBhdHRyaWJ1dGUgb24geW91ciByYWRpbyBidXR0b24sIHRoZWlyIHZhbHVlc1xuICAgICAgbXVzdCBtYXRjaC4gRXg6IDxpbnB1dCB0eXBlPVwicmFkaW9cIiBmb3JtQ29udHJvbE5hbWU9XCJmb29kXCIgbmFtZT1cImZvb2RcIj5cbiAgICBgKTtcbn1cbi8qKlxuICogQGRlc2NyaXB0aW9uXG4gKiBDbGFzcyB1c2VkIGJ5IEFuZ3VsYXIgdG8gdHJhY2sgcmFkaW8gYnV0dG9ucy4gRm9yIGludGVybmFsIHVzZSBvbmx5LlxuICovXG5jbGFzcyBSYWRpb0NvbnRyb2xSZWdpc3RyeSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuX2FjY2Vzc29ycyA9IFtdO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKiBBZGRzIGEgY29udHJvbCB0byB0aGUgaW50ZXJuYWwgcmVnaXN0cnkuIEZvciBpbnRlcm5hbCB1c2Ugb25seS5cbiAgICAgKi9cbiAgICBhZGQoY29udHJvbCwgYWNjZXNzb3IpIHtcbiAgICAgICAgdGhpcy5fYWNjZXNzb3JzLnB1c2goW2NvbnRyb2wsIGFjY2Vzc29yXSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqIFJlbW92ZXMgYSBjb250cm9sIGZyb20gdGhlIGludGVybmFsIHJlZ2lzdHJ5LiBGb3IgaW50ZXJuYWwgdXNlIG9ubHkuXG4gICAgICovXG4gICAgcmVtb3ZlKGFjY2Vzc29yKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSB0aGlzLl9hY2Nlc3NvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9hY2Nlc3NvcnNbaV1bMV0gPT09IGFjY2Vzc29yKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fYWNjZXNzb3JzLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICogU2VsZWN0cyBhIHJhZGlvIGJ1dHRvbi4gRm9yIGludGVybmFsIHVzZSBvbmx5LlxuICAgICAqL1xuICAgIHNlbGVjdChhY2Nlc3Nvcikge1xuICAgICAgICB0aGlzLl9hY2Nlc3NvcnMuZm9yRWFjaCgoYykgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2lzU2FtZUdyb3VwKGMsIGFjY2Vzc29yKSAmJiBjWzFdICE9PSBhY2Nlc3Nvcikge1xuICAgICAgICAgICAgICAgIGNbMV0uZmlyZVVuY2hlY2soYWNjZXNzb3IudmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgX2lzU2FtZUdyb3VwKGNvbnRyb2xQYWlyLCBhY2Nlc3Nvcikge1xuICAgICAgICBpZiAoIWNvbnRyb2xQYWlyWzBdLmNvbnRyb2wpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHJldHVybiBjb250cm9sUGFpclswXS5fcGFyZW50ID09PSBhY2Nlc3Nvci5fY29udHJvbC5fcGFyZW50ICYmXG4gICAgICAgICAgICBjb250cm9sUGFpclsxXS5uYW1lID09PSBhY2Nlc3Nvci5uYW1lO1xuICAgIH1cbiAgICBzdGF0aWMgeyB0aGlzLsm1ZmFjID0gaTAuybXJtW5nRGVjbGFyZUZhY3RvcnkoeyBtaW5WZXJzaW9uOiBcIjEyLjAuMFwiLCB2ZXJzaW9uOiBcIjE3LjMuMTJcIiwgbmdJbXBvcnQ6IGkwLCB0eXBlOiBSYWRpb0NvbnRyb2xSZWdpc3RyeSwgZGVwczogW10sIHRhcmdldDogaTAuybXJtUZhY3RvcnlUYXJnZXQuSW5qZWN0YWJsZSB9KTsgfVxuICAgIHN0YXRpYyB7IHRoaXMuybVwcm92ID0gaTAuybXJtW5nRGVjbGFyZUluamVjdGFibGUoeyBtaW5WZXJzaW9uOiBcIjEyLjAuMFwiLCB2ZXJzaW9uOiBcIjE3LjMuMTJcIiwgbmdJbXBvcnQ6IGkwLCB0eXBlOiBSYWRpb0NvbnRyb2xSZWdpc3RyeSwgcHJvdmlkZWRJbjogJ3Jvb3QnIH0pOyB9XG59XG5pMC7Jtcm1bmdEZWNsYXJlQ2xhc3NNZXRhZGF0YSh7IG1pblZlcnNpb246IFwiMTIuMC4wXCIsIHZlcnNpb246IFwiMTcuMy4xMlwiLCBuZ0ltcG9ydDogaTAsIHR5cGU6IFJhZGlvQ29udHJvbFJlZ2lzdHJ5LCBkZWNvcmF0b3JzOiBbe1xuICAgICAgICAgICAgdHlwZTogSW5qZWN0YWJsZSxcbiAgICAgICAgICAgIGFyZ3M6IFt7IHByb3ZpZGVkSW46ICdyb290JyB9XVxuICAgICAgICB9XSB9KTtcbi8qKlxuICogQGRlc2NyaXB0aW9uXG4gKiBUaGUgYENvbnRyb2xWYWx1ZUFjY2Vzc29yYCBmb3Igd3JpdGluZyByYWRpbyBjb250cm9sIHZhbHVlcyBhbmQgbGlzdGVuaW5nIHRvIHJhZGlvIGNvbnRyb2xcbiAqIGNoYW5nZXMuIFRoZSB2YWx1ZSBhY2Nlc3NvciBpcyB1c2VkIGJ5IHRoZSBgRm9ybUNvbnRyb2xEaXJlY3RpdmVgLCBgRm9ybUNvbnRyb2xOYW1lYCwgYW5kXG4gKiBgTmdNb2RlbGAgZGlyZWN0aXZlcy5cbiAqXG4gKiBAdXNhZ2VOb3Rlc1xuICpcbiAqICMjIyBVc2luZyByYWRpbyBidXR0b25zIHdpdGggcmVhY3RpdmUgZm9ybSBkaXJlY3RpdmVzXG4gKlxuICogVGhlIGZvbGxvdyBleGFtcGxlIHNob3dzIGhvdyB0byB1c2UgcmFkaW8gYnV0dG9ucyBpbiBhIHJlYWN0aXZlIGZvcm0uIFdoZW4gdXNpbmcgcmFkaW8gYnV0dG9ucyBpblxuICogYSByZWFjdGl2ZSBmb3JtLCByYWRpbyBidXR0b25zIGluIHRoZSBzYW1lIGdyb3VwIHNob3VsZCBoYXZlIHRoZSBzYW1lIGBmb3JtQ29udHJvbE5hbWVgLlxuICogUHJvdmlkaW5nIGEgYG5hbWVgIGF0dHJpYnV0ZSBpcyBvcHRpb25hbC5cbiAqXG4gKiB7QGV4YW1wbGUgZm9ybXMvdHMvcmVhY3RpdmVSYWRpb0J1dHRvbnMvcmVhY3RpdmVfcmFkaW9fYnV0dG9uX2V4YW1wbGUudHMgcmVnaW9uPSdSZWFjdGl2ZSd9XG4gKlxuICogQG5nTW9kdWxlIFJlYWN0aXZlRm9ybXNNb2R1bGVcbiAqIEBuZ01vZHVsZSBGb3Jtc01vZHVsZVxuICogQHB1YmxpY0FwaVxuICovXG5jbGFzcyBSYWRpb0NvbnRyb2xWYWx1ZUFjY2Vzc29yIGV4dGVuZHMgQnVpbHRJbkNvbnRyb2xWYWx1ZUFjY2Vzc29yIHtcbiAgICBjb25zdHJ1Y3RvcihyZW5kZXJlciwgZWxlbWVudFJlZiwgX3JlZ2lzdHJ5LCBfaW5qZWN0b3IpIHtcbiAgICAgICAgc3VwZXIocmVuZGVyZXIsIGVsZW1lbnRSZWYpO1xuICAgICAgICB0aGlzLl9yZWdpc3RyeSA9IF9yZWdpc3RyeTtcbiAgICAgICAgdGhpcy5faW5qZWN0b3IgPSBfaW5qZWN0b3I7XG4gICAgICAgIHRoaXMuc2V0RGlzYWJsZWRTdGF0ZUZpcmVkID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgcmVnaXN0ZXJlZCBjYWxsYmFjayBmdW5jdGlvbiBjYWxsZWQgd2hlbiBhIGNoYW5nZSBldmVudCBvY2N1cnMgb24gdGhlIGlucHV0IGVsZW1lbnQuXG4gICAgICAgICAqIE5vdGU6IHdlIGRlY2xhcmUgYG9uQ2hhbmdlYCBoZXJlIChhbHNvIHVzZWQgYXMgaG9zdCBsaXN0ZW5lcikgYXMgYSBmdW5jdGlvbiB3aXRoIG5vIGFyZ3VtZW50c1xuICAgICAgICAgKiB0byBvdmVycmlkZSB0aGUgYG9uQ2hhbmdlYCBmdW5jdGlvbiAod2hpY2ggZXhwZWN0cyAxIGFyZ3VtZW50KSBpbiB0aGUgcGFyZW50XG4gICAgICAgICAqIGBCYXNlQ29udHJvbFZhbHVlQWNjZXNzb3JgIGNsYXNzLlxuICAgICAgICAgKiBAbm9kb2NcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMub25DaGFuZ2UgPSAoKSA9PiB7IH07XG4gICAgICAgIHRoaXMuY2FsbFNldERpc2FibGVkU3RhdGUgPSBpbmplY3QoQ0FMTF9TRVRfRElTQUJMRURfU1RBVEUsIHsgb3B0aW9uYWw6IHRydWUgfSkgPz8gc2V0RGlzYWJsZWRTdGF0ZURlZmF1bHQ7XG4gICAgfVxuICAgIC8qKiBAbm9kb2MgKi9cbiAgICBuZ09uSW5pdCgpIHtcbiAgICAgICAgdGhpcy5fY29udHJvbCA9IHRoaXMuX2luamVjdG9yLmdldChOZ0NvbnRyb2wpO1xuICAgICAgICB0aGlzLl9jaGVja05hbWUoKTtcbiAgICAgICAgdGhpcy5fcmVnaXN0cnkuYWRkKHRoaXMuX2NvbnRyb2wsIHRoaXMpO1xuICAgIH1cbiAgICAvKiogQG5vZG9jICovXG4gICAgbmdPbkRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuX3JlZ2lzdHJ5LnJlbW92ZSh0aGlzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgXCJjaGVja2VkXCIgcHJvcGVydHkgdmFsdWUgb24gdGhlIHJhZGlvIGlucHV0IGVsZW1lbnQuXG4gICAgICogQG5vZG9jXG4gICAgICovXG4gICAgd3JpdGVWYWx1ZSh2YWx1ZSkge1xuICAgICAgICB0aGlzLl9zdGF0ZSA9IHZhbHVlID09PSB0aGlzLnZhbHVlO1xuICAgICAgICB0aGlzLnNldFByb3BlcnR5KCdjaGVja2VkJywgdGhpcy5fc3RhdGUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWdpc3RlcnMgYSBmdW5jdGlvbiBjYWxsZWQgd2hlbiB0aGUgY29udHJvbCB2YWx1ZSBjaGFuZ2VzLlxuICAgICAqIEBub2RvY1xuICAgICAqL1xuICAgIHJlZ2lzdGVyT25DaGFuZ2UoZm4pIHtcbiAgICAgICAgdGhpcy5fZm4gPSBmbjtcbiAgICAgICAgdGhpcy5vbkNoYW5nZSA9ICgpID0+IHtcbiAgICAgICAgICAgIGZuKHRoaXMudmFsdWUpO1xuICAgICAgICAgICAgdGhpcy5fcmVnaXN0cnkuc2VsZWN0KHRoaXMpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICAvKiogQG5vZG9jICovXG4gICAgc2V0RGlzYWJsZWRTdGF0ZShpc0Rpc2FibGVkKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBgc2V0RGlzYWJsZWRTdGF0ZWAgaXMgc3VwcG9zZWQgdG8gYmUgY2FsbGVkIHdoZW5ldmVyIHRoZSBkaXNhYmxlZCBzdGF0ZSBvZiBhIGNvbnRyb2wgY2hhbmdlcyxcbiAgICAgICAgICogaW5jbHVkaW5nIHVwb24gY29udHJvbCBjcmVhdGlvbi4gSG93ZXZlciwgYSBsb25nc3RhbmRpbmcgYnVnIGNhdXNlZCB0aGUgbWV0aG9kIHRvIG5vdCBmaXJlXG4gICAgICAgICAqIHdoZW4gYW4gKmVuYWJsZWQqIGNvbnRyb2wgd2FzIGF0dGFjaGVkLiBUaGlzIGJ1ZyB3YXMgZml4ZWQgaW4gdjE1IGluICM0NzU3Ni5cbiAgICAgICAgICpcbiAgICAgICAgICogVGhpcyBoYWQgYSBzaWRlIGVmZmVjdDogcHJldmlvdXNseSwgaXQgd2FzIHBvc3NpYmxlIHRvIGluc3RhbnRpYXRlIGEgcmVhY3RpdmUgZm9ybSBjb250cm9sXG4gICAgICAgICAqIHdpdGggYFthdHRyLmRpc2FibGVkXT10cnVlYCwgZXZlbiB0aG91Z2ggdGhlIGNvcnJlc3BvbmRpbmcgY29udHJvbCB3YXMgZW5hYmxlZCBpbiB0aGVcbiAgICAgICAgICogbW9kZWwuIFRoaXMgcmVzdWx0ZWQgaW4gYSBtaXNtYXRjaCBiZXR3ZWVuIHRoZSBtb2RlbCBhbmQgdGhlIERPTS4gTm93LCBiZWNhdXNlXG4gICAgICAgICAqIGBzZXREaXNhYmxlZFN0YXRlYCBpcyBhbHdheXMgY2FsbGVkLCB0aGUgdmFsdWUgaW4gdGhlIERPTSB3aWxsIGJlIGltbWVkaWF0ZWx5IG92ZXJ3cml0dGVuXG4gICAgICAgICAqIHdpdGggdGhlIFwiY29ycmVjdFwiIGVuYWJsZWQgdmFsdWUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEhvd2V2ZXIsIHRoZSBmaXggYWxzbyBjcmVhdGVkIGFuIGV4Y2VwdGlvbmFsIGNhc2U6IHJhZGlvIGJ1dHRvbnMuIEJlY2F1c2UgUmVhY3RpdmUgRm9ybXNcbiAgICAgICAgICogbW9kZWxzIHRoZSBlbnRpcmUgZ3JvdXAgb2YgcmFkaW8gYnV0dG9ucyBhcyBhIHNpbmdsZSBgRm9ybUNvbnRyb2xgLCB0aGVyZSBpcyBubyB3YXkgdG9cbiAgICAgICAgICogY29udHJvbCB0aGUgZGlzYWJsZWQgc3RhdGUgZm9yIGluZGl2aWR1YWwgcmFkaW9zLCBzbyB0aGV5IGNhbiBubyBsb25nZXIgYmUgY29uZmlndXJlZCBhc1xuICAgICAgICAgKiBkaXNhYmxlZC4gVGh1cywgd2Uga2VlcCB0aGUgb2xkIGJlaGF2aW9yIGZvciByYWRpbyBidXR0b25zLCBzbyB0aGF0IGBbYXR0ci5kaXNhYmxlZF1gXG4gICAgICAgICAqIGNvbnRpbnVlcyB0byB3b3JrLiBTcGVjaWZpY2FsbHksIHdlIGRyb3AgdGhlIGZpcnN0IGNhbGwgdG8gYHNldERpc2FibGVkU3RhdGVgIGlmIGBkaXNhYmxlZGBcbiAgICAgICAgICogaXMgYGZhbHNlYCwgYW5kIHdlIGFyZSBub3QgaW4gbGVnYWN5IG1vZGUuXG4gICAgICAgICAqL1xuICAgICAgICBpZiAodGhpcy5zZXREaXNhYmxlZFN0YXRlRmlyZWQgfHwgaXNEaXNhYmxlZCB8fFxuICAgICAgICAgICAgdGhpcy5jYWxsU2V0RGlzYWJsZWRTdGF0ZSA9PT0gJ3doZW5EaXNhYmxlZEZvckxlZ2FjeUNvZGUnKSB7XG4gICAgICAgICAgICB0aGlzLnNldFByb3BlcnR5KCdkaXNhYmxlZCcsIGlzRGlzYWJsZWQpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2V0RGlzYWJsZWRTdGF0ZUZpcmVkID0gdHJ1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgXCJ2YWx1ZVwiIG9uIHRoZSByYWRpbyBpbnB1dCBlbGVtZW50IGFuZCB1bmNoZWNrcyBpdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB2YWx1ZVxuICAgICAqL1xuICAgIGZpcmVVbmNoZWNrKHZhbHVlKSB7XG4gICAgICAgIHRoaXMud3JpdGVWYWx1ZSh2YWx1ZSk7XG4gICAgfVxuICAgIF9jaGVja05hbWUoKSB7XG4gICAgICAgIGlmICh0aGlzLm5hbWUgJiYgdGhpcy5mb3JtQ29udHJvbE5hbWUgJiYgdGhpcy5uYW1lICE9PSB0aGlzLmZvcm1Db250cm9sTmFtZSAmJlxuICAgICAgICAgICAgKHR5cGVvZiBuZ0Rldk1vZGUgPT09ICd1bmRlZmluZWQnIHx8IG5nRGV2TW9kZSkpIHtcbiAgICAgICAgICAgIHRocm93TmFtZUVycm9yKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLm5hbWUgJiYgdGhpcy5mb3JtQ29udHJvbE5hbWUpXG4gICAgICAgICAgICB0aGlzLm5hbWUgPSB0aGlzLmZvcm1Db250cm9sTmFtZTtcbiAgICB9XG4gICAgc3RhdGljIHsgdGhpcy7JtWZhYyA9IGkwLsm1ybVuZ0RlY2xhcmVGYWN0b3J5KHsgbWluVmVyc2lvbjogXCIxMi4wLjBcIiwgdmVyc2lvbjogXCIxNy4zLjEyXCIsIG5nSW1wb3J0OiBpMCwgdHlwZTogUmFkaW9Db250cm9sVmFsdWVBY2Nlc3NvciwgZGVwczogW3sgdG9rZW46IGkwLlJlbmRlcmVyMiB9LCB7IHRva2VuOiBpMC5FbGVtZW50UmVmIH0sIHsgdG9rZW46IFJhZGlvQ29udHJvbFJlZ2lzdHJ5IH0sIHsgdG9rZW46IGkwLkluamVjdG9yIH1dLCB0YXJnZXQ6IGkwLsm1ybVGYWN0b3J5VGFyZ2V0LkRpcmVjdGl2ZSB9KTsgfVxuICAgIHN0YXRpYyB7IHRoaXMuybVkaXIgPSBpMC7Jtcm1bmdEZWNsYXJlRGlyZWN0aXZlKHsgbWluVmVyc2lvbjogXCIxNC4wLjBcIiwgdmVyc2lvbjogXCIxNy4zLjEyXCIsIHR5cGU6IFJhZGlvQ29udHJvbFZhbHVlQWNjZXNzb3IsIHNlbGVjdG9yOiBcImlucHV0W3R5cGU9cmFkaW9dW2Zvcm1Db250cm9sTmFtZV0saW5wdXRbdHlwZT1yYWRpb11bZm9ybUNvbnRyb2xdLGlucHV0W3R5cGU9cmFkaW9dW25nTW9kZWxdXCIsIGlucHV0czogeyBuYW1lOiBcIm5hbWVcIiwgZm9ybUNvbnRyb2xOYW1lOiBcImZvcm1Db250cm9sTmFtZVwiLCB2YWx1ZTogXCJ2YWx1ZVwiIH0sIGhvc3Q6IHsgbGlzdGVuZXJzOiB7IFwiY2hhbmdlXCI6IFwib25DaGFuZ2UoKVwiLCBcImJsdXJcIjogXCJvblRvdWNoZWQoKVwiIH0gfSwgcHJvdmlkZXJzOiBbUkFESU9fVkFMVUVfQUNDRVNTT1JdLCB1c2VzSW5oZXJpdGFuY2U6IHRydWUsIG5nSW1wb3J0OiBpMCB9KTsgfVxufVxuaTAuybXJtW5nRGVjbGFyZUNsYXNzTWV0YWRhdGEoeyBtaW5WZXJzaW9uOiBcIjEyLjAuMFwiLCB2ZXJzaW9uOiBcIjE3LjMuMTJcIiwgbmdJbXBvcnQ6IGkwLCB0eXBlOiBSYWRpb0NvbnRyb2xWYWx1ZUFjY2Vzc29yLCBkZWNvcmF0b3JzOiBbe1xuICAgICAgICAgICAgdHlwZTogRGlyZWN0aXZlLFxuICAgICAgICAgICAgYXJnczogW3tcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdpbnB1dFt0eXBlPXJhZGlvXVtmb3JtQ29udHJvbE5hbWVdLGlucHV0W3R5cGU9cmFkaW9dW2Zvcm1Db250cm9sXSxpbnB1dFt0eXBlPXJhZGlvXVtuZ01vZGVsXScsXG4gICAgICAgICAgICAgICAgICAgIGhvc3Q6IHsgJyhjaGFuZ2UpJzogJ29uQ2hhbmdlKCknLCAnKGJsdXIpJzogJ29uVG91Y2hlZCgpJyB9LFxuICAgICAgICAgICAgICAgICAgICBwcm92aWRlcnM6IFtSQURJT19WQUxVRV9BQ0NFU1NPUl1cbiAgICAgICAgICAgICAgICB9XVxuICAgICAgICB9XSwgY3RvclBhcmFtZXRlcnM6ICgpID0+IFt7IHR5cGU6IGkwLlJlbmRlcmVyMiB9LCB7IHR5cGU6IGkwLkVsZW1lbnRSZWYgfSwgeyB0eXBlOiBSYWRpb0NvbnRyb2xSZWdpc3RyeSB9LCB7IHR5cGU6IGkwLkluamVjdG9yIH1dLCBwcm9wRGVjb3JhdG9yczogeyBuYW1lOiBbe1xuICAgICAgICAgICAgICAgIHR5cGU6IElucHV0XG4gICAgICAgICAgICB9XSwgZm9ybUNvbnRyb2xOYW1lOiBbe1xuICAgICAgICAgICAgICAgIHR5cGU6IElucHV0XG4gICAgICAgICAgICB9XSwgdmFsdWU6IFt7XG4gICAgICAgICAgICAgICAgdHlwZTogSW5wdXRcbiAgICAgICAgICAgIH1dIH0gfSk7XG5cbmNvbnN0IFJBTkdFX1ZBTFVFX0FDQ0VTU09SID0ge1xuICAgIHByb3ZpZGU6IE5HX1ZBTFVFX0FDQ0VTU09SLFxuICAgIHVzZUV4aXN0aW5nOiBmb3J3YXJkUmVmKCgpID0+IFJhbmdlVmFsdWVBY2Nlc3NvciksXG4gICAgbXVsdGk6IHRydWVcbn07XG4vKipcbiAqIEBkZXNjcmlwdGlvblxuICogVGhlIGBDb250cm9sVmFsdWVBY2Nlc3NvcmAgZm9yIHdyaXRpbmcgYSByYW5nZSB2YWx1ZSBhbmQgbGlzdGVuaW5nIHRvIHJhbmdlIGlucHV0IGNoYW5nZXMuXG4gKiBUaGUgdmFsdWUgYWNjZXNzb3IgaXMgdXNlZCBieSB0aGUgYEZvcm1Db250cm9sRGlyZWN0aXZlYCwgYEZvcm1Db250cm9sTmFtZWAsIGFuZCAgYE5nTW9kZWxgXG4gKiBkaXJlY3RpdmVzLlxuICpcbiAqIEB1c2FnZU5vdGVzXG4gKlxuICogIyMjIFVzaW5nIGEgcmFuZ2UgaW5wdXQgd2l0aCBhIHJlYWN0aXZlIGZvcm1cbiAqXG4gKiBUaGUgZm9sbG93aW5nIGV4YW1wbGUgc2hvd3MgaG93IHRvIHVzZSBhIHJhbmdlIGlucHV0IHdpdGggYSByZWFjdGl2ZSBmb3JtLlxuICpcbiAqIGBgYHRzXG4gKiBjb25zdCBhZ2VDb250cm9sID0gbmV3IEZvcm1Db250cm9sKCk7XG4gKiBgYGBcbiAqXG4gKiBgYGBcbiAqIDxpbnB1dCB0eXBlPVwicmFuZ2VcIiBbZm9ybUNvbnRyb2xdPVwiYWdlQ29udHJvbFwiPlxuICogYGBgXG4gKlxuICogQG5nTW9kdWxlIFJlYWN0aXZlRm9ybXNNb2R1bGVcbiAqIEBuZ01vZHVsZSBGb3Jtc01vZHVsZVxuICogQHB1YmxpY0FwaVxuICovXG5jbGFzcyBSYW5nZVZhbHVlQWNjZXNzb3IgZXh0ZW5kcyBCdWlsdEluQ29udHJvbFZhbHVlQWNjZXNzb3Ige1xuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIFwidmFsdWVcIiBwcm9wZXJ0eSBvbiB0aGUgaW5wdXQgZWxlbWVudC5cbiAgICAgKiBAbm9kb2NcbiAgICAgKi9cbiAgICB3cml0ZVZhbHVlKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuc2V0UHJvcGVydHkoJ3ZhbHVlJywgcGFyc2VGbG9hdCh2YWx1ZSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWdpc3RlcnMgYSBmdW5jdGlvbiBjYWxsZWQgd2hlbiB0aGUgY29udHJvbCB2YWx1ZSBjaGFuZ2VzLlxuICAgICAqIEBub2RvY1xuICAgICAqL1xuICAgIHJlZ2lzdGVyT25DaGFuZ2UoZm4pIHtcbiAgICAgICAgdGhpcy5vbkNoYW5nZSA9ICh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgZm4odmFsdWUgPT0gJycgPyBudWxsIDogcGFyc2VGbG9hdCh2YWx1ZSkpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBzdGF0aWMgeyB0aGlzLsm1ZmFjID0gaTAuybXJtW5nRGVjbGFyZUZhY3RvcnkoeyBtaW5WZXJzaW9uOiBcIjEyLjAuMFwiLCB2ZXJzaW9uOiBcIjE3LjMuMTJcIiwgbmdJbXBvcnQ6IGkwLCB0eXBlOiBSYW5nZVZhbHVlQWNjZXNzb3IsIGRlcHM6IG51bGwsIHRhcmdldDogaTAuybXJtUZhY3RvcnlUYXJnZXQuRGlyZWN0aXZlIH0pOyB9XG4gICAgc3RhdGljIHsgdGhpcy7JtWRpciA9IGkwLsm1ybVuZ0RlY2xhcmVEaXJlY3RpdmUoeyBtaW5WZXJzaW9uOiBcIjE0LjAuMFwiLCB2ZXJzaW9uOiBcIjE3LjMuMTJcIiwgdHlwZTogUmFuZ2VWYWx1ZUFjY2Vzc29yLCBzZWxlY3RvcjogXCJpbnB1dFt0eXBlPXJhbmdlXVtmb3JtQ29udHJvbE5hbWVdLGlucHV0W3R5cGU9cmFuZ2VdW2Zvcm1Db250cm9sXSxpbnB1dFt0eXBlPXJhbmdlXVtuZ01vZGVsXVwiLCBob3N0OiB7IGxpc3RlbmVyczogeyBcImNoYW5nZVwiOiBcIm9uQ2hhbmdlKCRldmVudC50YXJnZXQudmFsdWUpXCIsIFwiaW5wdXRcIjogXCJvbkNoYW5nZSgkZXZlbnQudGFyZ2V0LnZhbHVlKVwiLCBcImJsdXJcIjogXCJvblRvdWNoZWQoKVwiIH0gfSwgcHJvdmlkZXJzOiBbUkFOR0VfVkFMVUVfQUNDRVNTT1JdLCB1c2VzSW5oZXJpdGFuY2U6IHRydWUsIG5nSW1wb3J0OiBpMCB9KTsgfVxufVxuaTAuybXJtW5nRGVjbGFyZUNsYXNzTWV0YWRhdGEoeyBtaW5WZXJzaW9uOiBcIjEyLjAuMFwiLCB2ZXJzaW9uOiBcIjE3LjMuMTJcIiwgbmdJbXBvcnQ6IGkwLCB0eXBlOiBSYW5nZVZhbHVlQWNjZXNzb3IsIGRlY29yYXRvcnM6IFt7XG4gICAgICAgICAgICB0eXBlOiBEaXJlY3RpdmUsXG4gICAgICAgICAgICBhcmdzOiBbe1xuICAgICAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ2lucHV0W3R5cGU9cmFuZ2VdW2Zvcm1Db250cm9sTmFtZV0saW5wdXRbdHlwZT1yYW5nZV1bZm9ybUNvbnRyb2xdLGlucHV0W3R5cGU9cmFuZ2VdW25nTW9kZWxdJyxcbiAgICAgICAgICAgICAgICAgICAgaG9zdDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgJyhjaGFuZ2UpJzogJ29uQ2hhbmdlKCRldmVudC50YXJnZXQudmFsdWUpJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICcoaW5wdXQpJzogJ29uQ2hhbmdlKCRldmVudC50YXJnZXQudmFsdWUpJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICcoYmx1ciknOiAnb25Ub3VjaGVkKCknXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHByb3ZpZGVyczogW1JBTkdFX1ZBTFVFX0FDQ0VTU09SXVxuICAgICAgICAgICAgICAgIH1dXG4gICAgICAgIH1dIH0pO1xuXG4vKipcbiAqIFRva2VuIHRvIHByb3ZpZGUgdG8gdHVybiBvZmYgdGhlIG5nTW9kZWwgd2FybmluZyBvbiBmb3JtQ29udHJvbCBhbmQgZm9ybUNvbnRyb2xOYW1lLlxuICovXG5jb25zdCBOR19NT0RFTF9XSVRIX0ZPUk1fQ09OVFJPTF9XQVJOSU5HID0gbmV3IEluamVjdGlvblRva2VuKG5nRGV2TW9kZSA/ICdOZ01vZGVsV2l0aEZvcm1Db250cm9sV2FybmluZycgOiAnJyk7XG5jb25zdCBmb3JtQ29udHJvbEJpbmRpbmcgPSB7XG4gICAgcHJvdmlkZTogTmdDb250cm9sLFxuICAgIHVzZUV4aXN0aW5nOiBmb3J3YXJkUmVmKCgpID0+IEZvcm1Db250cm9sRGlyZWN0aXZlKVxufTtcbi8qKlxuICogQGRlc2NyaXB0aW9uXG4gKiBTeW5jaHJvbml6ZXMgYSBzdGFuZGFsb25lIGBGb3JtQ29udHJvbGAgaW5zdGFuY2UgdG8gYSBmb3JtIGNvbnRyb2wgZWxlbWVudC5cbiAqXG4gKiBOb3RlIHRoYXQgc3VwcG9ydCBmb3IgdXNpbmcgdGhlIGBuZ01vZGVsYCBpbnB1dCBwcm9wZXJ0eSBhbmQgYG5nTW9kZWxDaGFuZ2VgIGV2ZW50IHdpdGggcmVhY3RpdmVcbiAqIGZvcm0gZGlyZWN0aXZlcyB3YXMgZGVwcmVjYXRlZCBpbiBBbmd1bGFyIHY2IGFuZCBpcyBzY2hlZHVsZWQgZm9yIHJlbW92YWwgaW5cbiAqIGEgZnV0dXJlIHZlcnNpb24gb2YgQW5ndWxhci5cbiAqIEZvciBkZXRhaWxzLCBzZWUgW0RlcHJlY2F0ZWQgZmVhdHVyZXNdKGd1aWRlL2RlcHJlY2F0aW9ucyNuZ21vZGVsLXdpdGgtcmVhY3RpdmUtZm9ybXMpLlxuICpcbiAqIEBzZWUgW1JlYWN0aXZlIEZvcm1zIEd1aWRlXShndWlkZS9yZWFjdGl2ZS1mb3JtcylcbiAqIEBzZWUge0BsaW5rIEZvcm1Db250cm9sfVxuICogQHNlZSB7QGxpbmsgQWJzdHJhY3RDb250cm9sfVxuICpcbiAqIEB1c2FnZU5vdGVzXG4gKlxuICogVGhlIGZvbGxvd2luZyBleGFtcGxlIHNob3dzIGhvdyB0byByZWdpc3RlciBhIHN0YW5kYWxvbmUgY29udHJvbCBhbmQgc2V0IGl0cyB2YWx1ZS5cbiAqXG4gKiB7QGV4YW1wbGUgZm9ybXMvdHMvc2ltcGxlRm9ybUNvbnRyb2wvc2ltcGxlX2Zvcm1fY29udHJvbF9leGFtcGxlLnRzIHJlZ2lvbj0nQ29tcG9uZW50J31cbiAqXG4gKiBAbmdNb2R1bGUgUmVhY3RpdmVGb3Jtc01vZHVsZVxuICogQHB1YmxpY0FwaVxuICovXG5jbGFzcyBGb3JtQ29udHJvbERpcmVjdGl2ZSBleHRlbmRzIE5nQ29udHJvbCB7XG4gICAgLyoqXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICogVHJpZ2dlcnMgYSB3YXJuaW5nIGluIGRldiBtb2RlIHRoYXQgdGhpcyBpbnB1dCBzaG91bGQgbm90IGJlIHVzZWQgd2l0aCByZWFjdGl2ZSBmb3Jtcy5cbiAgICAgKi9cbiAgICBzZXQgaXNEaXNhYmxlZChpc0Rpc2FibGVkKSB7XG4gICAgICAgIGlmICh0eXBlb2YgbmdEZXZNb2RlID09PSAndW5kZWZpbmVkJyB8fCBuZ0Rldk1vZGUpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihkaXNhYmxlZEF0dHJXYXJuaW5nKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKiBTdGF0aWMgcHJvcGVydHkgdXNlZCB0byB0cmFjayB3aGV0aGVyIGFueSBuZ01vZGVsIHdhcm5pbmdzIGhhdmUgYmVlbiBzZW50IGFjcm9zc1xuICAgICAqIGFsbCBpbnN0YW5jZXMgb2YgRm9ybUNvbnRyb2xEaXJlY3RpdmUuIFVzZWQgdG8gc3VwcG9ydCB3YXJuaW5nIGNvbmZpZyBvZiBcIm9uY2VcIi5cbiAgICAgKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHN0YXRpYyB7IHRoaXMuX25nTW9kZWxXYXJuaW5nU2VudE9uY2UgPSBmYWxzZTsgfVxuICAgIGNvbnN0cnVjdG9yKHZhbGlkYXRvcnMsIGFzeW5jVmFsaWRhdG9ycywgdmFsdWVBY2Nlc3NvcnMsIF9uZ01vZGVsV2FybmluZ0NvbmZpZywgY2FsbFNldERpc2FibGVkU3RhdGUpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5fbmdNb2RlbFdhcm5pbmdDb25maWcgPSBfbmdNb2RlbFdhcm5pbmdDb25maWc7XG4gICAgICAgIHRoaXMuY2FsbFNldERpc2FibGVkU3RhdGUgPSBjYWxsU2V0RGlzYWJsZWRTdGF0ZTtcbiAgICAgICAgLyoqIEBkZXByZWNhdGVkIGFzIG9mIHY2ICovXG4gICAgICAgIHRoaXMudXBkYXRlID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICAvKipcbiAgICAgICAgICogQGRlc2NyaXB0aW9uXG4gICAgICAgICAqIEluc3RhbmNlIHByb3BlcnR5IHVzZWQgdG8gdHJhY2sgd2hldGhlciBhbiBuZ01vZGVsIHdhcm5pbmcgaGFzIGJlZW4gc2VudCBvdXQgZm9yIHRoaXNcbiAgICAgICAgICogcGFydGljdWxhciBgRm9ybUNvbnRyb2xEaXJlY3RpdmVgIGluc3RhbmNlLiBVc2VkIHRvIHN1cHBvcnQgd2FybmluZyBjb25maWcgb2YgXCJhbHdheXNcIi5cbiAgICAgICAgICpcbiAgICAgICAgICogQGludGVybmFsXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9uZ01vZGVsV2FybmluZ1NlbnQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fc2V0VmFsaWRhdG9ycyh2YWxpZGF0b3JzKTtcbiAgICAgICAgdGhpcy5fc2V0QXN5bmNWYWxpZGF0b3JzKGFzeW5jVmFsaWRhdG9ycyk7XG4gICAgICAgIHRoaXMudmFsdWVBY2Nlc3NvciA9IHNlbGVjdFZhbHVlQWNjZXNzb3IodGhpcywgdmFsdWVBY2Nlc3NvcnMpO1xuICAgIH1cbiAgICAvKiogQG5vZG9jICovXG4gICAgbmdPbkNoYW5nZXMoY2hhbmdlcykge1xuICAgICAgICBpZiAodGhpcy5faXNDb250cm9sQ2hhbmdlZChjaGFuZ2VzKSkge1xuICAgICAgICAgICAgY29uc3QgcHJldmlvdXNGb3JtID0gY2hhbmdlc1snZm9ybSddLnByZXZpb3VzVmFsdWU7XG4gICAgICAgICAgICBpZiAocHJldmlvdXNGb3JtKSB7XG4gICAgICAgICAgICAgICAgY2xlYW5VcENvbnRyb2wocHJldmlvdXNGb3JtLCB0aGlzLCAvKiB2YWxpZGF0ZUNvbnRyb2xQcmVzZW5jZU9uQ2hhbmdlICovIGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNldFVwQ29udHJvbCh0aGlzLmZvcm0sIHRoaXMsIHRoaXMuY2FsbFNldERpc2FibGVkU3RhdGUpO1xuICAgICAgICAgICAgdGhpcy5mb3JtLnVwZGF0ZVZhbHVlQW5kVmFsaWRpdHkoeyBlbWl0RXZlbnQ6IGZhbHNlIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc1Byb3BlcnR5VXBkYXRlZChjaGFuZ2VzLCB0aGlzLnZpZXdNb2RlbCkpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbmdEZXZNb2RlID09PSAndW5kZWZpbmVkJyB8fCBuZ0Rldk1vZGUpIHtcbiAgICAgICAgICAgICAgICBfbmdNb2RlbFdhcm5pbmcoJ2Zvcm1Db250cm9sJywgRm9ybUNvbnRyb2xEaXJlY3RpdmUsIHRoaXMsIHRoaXMuX25nTW9kZWxXYXJuaW5nQ29uZmlnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZm9ybS5zZXRWYWx1ZSh0aGlzLm1vZGVsKTtcbiAgICAgICAgICAgIHRoaXMudmlld01vZGVsID0gdGhpcy5tb2RlbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKiogQG5vZG9jICovXG4gICAgbmdPbkRlc3Ryb3koKSB7XG4gICAgICAgIGlmICh0aGlzLmZvcm0pIHtcbiAgICAgICAgICAgIGNsZWFuVXBDb250cm9sKHRoaXMuZm9ybSwgdGhpcywgLyogdmFsaWRhdGVDb250cm9sUHJlc2VuY2VPbkNoYW5nZSAqLyBmYWxzZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICogUmV0dXJucyBhbiBhcnJheSB0aGF0IHJlcHJlc2VudHMgdGhlIHBhdGggZnJvbSB0aGUgdG9wLWxldmVsIGZvcm0gdG8gdGhpcyBjb250cm9sLlxuICAgICAqIEVhY2ggaW5kZXggaXMgdGhlIHN0cmluZyBuYW1lIG9mIHRoZSBjb250cm9sIG9uIHRoYXQgbGV2ZWwuXG4gICAgICovXG4gICAgZ2V0IHBhdGgoKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICogVGhlIGBGb3JtQ29udHJvbGAgYm91bmQgdG8gdGhpcyBkaXJlY3RpdmUuXG4gICAgICovXG4gICAgZ2V0IGNvbnRyb2woKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZvcm07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqIFNldHMgdGhlIG5ldyB2YWx1ZSBmb3IgdGhlIHZpZXcgbW9kZWwgYW5kIGVtaXRzIGFuIGBuZ01vZGVsQ2hhbmdlYCBldmVudC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBuZXdWYWx1ZSBUaGUgbmV3IHZhbHVlIGZvciB0aGUgdmlldyBtb2RlbC5cbiAgICAgKi9cbiAgICB2aWV3VG9Nb2RlbFVwZGF0ZShuZXdWYWx1ZSkge1xuICAgICAgICB0aGlzLnZpZXdNb2RlbCA9IG5ld1ZhbHVlO1xuICAgICAgICB0aGlzLnVwZGF0ZS5lbWl0KG5ld1ZhbHVlKTtcbiAgICB9XG4gICAgX2lzQ29udHJvbENoYW5nZWQoY2hhbmdlcykge1xuICAgICAgICByZXR1cm4gY2hhbmdlcy5oYXNPd25Qcm9wZXJ0eSgnZm9ybScpO1xuICAgIH1cbiAgICBzdGF0aWMgeyB0aGlzLsm1ZmFjID0gaTAuybXJtW5nRGVjbGFyZUZhY3RvcnkoeyBtaW5WZXJzaW9uOiBcIjEyLjAuMFwiLCB2ZXJzaW9uOiBcIjE3LjMuMTJcIiwgbmdJbXBvcnQ6IGkwLCB0eXBlOiBGb3JtQ29udHJvbERpcmVjdGl2ZSwgZGVwczogW3sgdG9rZW46IE5HX1ZBTElEQVRPUlMsIG9wdGlvbmFsOiB0cnVlLCBzZWxmOiB0cnVlIH0sIHsgdG9rZW46IE5HX0FTWU5DX1ZBTElEQVRPUlMsIG9wdGlvbmFsOiB0cnVlLCBzZWxmOiB0cnVlIH0sIHsgdG9rZW46IE5HX1ZBTFVFX0FDQ0VTU09SLCBvcHRpb25hbDogdHJ1ZSwgc2VsZjogdHJ1ZSB9LCB7IHRva2VuOiBOR19NT0RFTF9XSVRIX0ZPUk1fQ09OVFJPTF9XQVJOSU5HLCBvcHRpb25hbDogdHJ1ZSB9LCB7IHRva2VuOiBDQUxMX1NFVF9ESVNBQkxFRF9TVEFURSwgb3B0aW9uYWw6IHRydWUgfV0sIHRhcmdldDogaTAuybXJtUZhY3RvcnlUYXJnZXQuRGlyZWN0aXZlIH0pOyB9XG4gICAgc3RhdGljIHsgdGhpcy7JtWRpciA9IGkwLsm1ybVuZ0RlY2xhcmVEaXJlY3RpdmUoeyBtaW5WZXJzaW9uOiBcIjE0LjAuMFwiLCB2ZXJzaW9uOiBcIjE3LjMuMTJcIiwgdHlwZTogRm9ybUNvbnRyb2xEaXJlY3RpdmUsIHNlbGVjdG9yOiBcIltmb3JtQ29udHJvbF1cIiwgaW5wdXRzOiB7IGZvcm06IFtcImZvcm1Db250cm9sXCIsIFwiZm9ybVwiXSwgaXNEaXNhYmxlZDogW1wiZGlzYWJsZWRcIiwgXCJpc0Rpc2FibGVkXCJdLCBtb2RlbDogW1wibmdNb2RlbFwiLCBcIm1vZGVsXCJdIH0sIG91dHB1dHM6IHsgdXBkYXRlOiBcIm5nTW9kZWxDaGFuZ2VcIiB9LCBwcm92aWRlcnM6IFtmb3JtQ29udHJvbEJpbmRpbmddLCBleHBvcnRBczogW1wibmdGb3JtXCJdLCB1c2VzSW5oZXJpdGFuY2U6IHRydWUsIHVzZXNPbkNoYW5nZXM6IHRydWUsIG5nSW1wb3J0OiBpMCB9KTsgfVxufVxuaTAuybXJtW5nRGVjbGFyZUNsYXNzTWV0YWRhdGEoeyBtaW5WZXJzaW9uOiBcIjEyLjAuMFwiLCB2ZXJzaW9uOiBcIjE3LjMuMTJcIiwgbmdJbXBvcnQ6IGkwLCB0eXBlOiBGb3JtQ29udHJvbERpcmVjdGl2ZSwgZGVjb3JhdG9yczogW3tcbiAgICAgICAgICAgIHR5cGU6IERpcmVjdGl2ZSxcbiAgICAgICAgICAgIGFyZ3M6IFt7IHNlbGVjdG9yOiAnW2Zvcm1Db250cm9sXScsIHByb3ZpZGVyczogW2Zvcm1Db250cm9sQmluZGluZ10sIGV4cG9ydEFzOiAnbmdGb3JtJyB9XVxuICAgICAgICB9XSwgY3RvclBhcmFtZXRlcnM6ICgpID0+IFt7IHR5cGU6IHVuZGVmaW5lZCwgZGVjb3JhdG9yczogW3tcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogT3B0aW9uYWxcbiAgICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFNlbGZcbiAgICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IEluamVjdCxcbiAgICAgICAgICAgICAgICAgICAgYXJnczogW05HX1ZBTElEQVRPUlNdXG4gICAgICAgICAgICAgICAgfV0gfSwgeyB0eXBlOiB1bmRlZmluZWQsIGRlY29yYXRvcnM6IFt7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IE9wdGlvbmFsXG4gICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBTZWxmXG4gICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBJbmplY3QsXG4gICAgICAgICAgICAgICAgICAgIGFyZ3M6IFtOR19BU1lOQ19WQUxJREFUT1JTXVxuICAgICAgICAgICAgICAgIH1dIH0sIHsgdHlwZTogdW5kZWZpbmVkLCBkZWNvcmF0b3JzOiBbe1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBPcHRpb25hbFxuICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogU2VsZlxuICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogSW5qZWN0LFxuICAgICAgICAgICAgICAgICAgICBhcmdzOiBbTkdfVkFMVUVfQUNDRVNTT1JdXG4gICAgICAgICAgICAgICAgfV0gfSwgeyB0eXBlOiB1bmRlZmluZWQsIGRlY29yYXRvcnM6IFt7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IE9wdGlvbmFsXG4gICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBJbmplY3QsXG4gICAgICAgICAgICAgICAgICAgIGFyZ3M6IFtOR19NT0RFTF9XSVRIX0ZPUk1fQ09OVFJPTF9XQVJOSU5HXVxuICAgICAgICAgICAgICAgIH1dIH0sIHsgdHlwZTogdW5kZWZpbmVkLCBkZWNvcmF0b3JzOiBbe1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBPcHRpb25hbFxuICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogSW5qZWN0LFxuICAgICAgICAgICAgICAgICAgICBhcmdzOiBbQ0FMTF9TRVRfRElTQUJMRURfU1RBVEVdXG4gICAgICAgICAgICAgICAgfV0gfV0sIHByb3BEZWNvcmF0b3JzOiB7IGZvcm06IFt7XG4gICAgICAgICAgICAgICAgdHlwZTogSW5wdXQsXG4gICAgICAgICAgICAgICAgYXJnczogWydmb3JtQ29udHJvbCddXG4gICAgICAgICAgICB9XSwgaXNEaXNhYmxlZDogW3tcbiAgICAgICAgICAgICAgICB0eXBlOiBJbnB1dCxcbiAgICAgICAgICAgICAgICBhcmdzOiBbJ2Rpc2FibGVkJ11cbiAgICAgICAgICAgIH1dLCBtb2RlbDogW3tcbiAgICAgICAgICAgICAgICB0eXBlOiBJbnB1dCxcbiAgICAgICAgICAgICAgICBhcmdzOiBbJ25nTW9kZWwnXVxuICAgICAgICAgICAgfV0sIHVwZGF0ZTogW3tcbiAgICAgICAgICAgICAgICB0eXBlOiBPdXRwdXQsXG4gICAgICAgICAgICAgICAgYXJnczogWyduZ01vZGVsQ2hhbmdlJ11cbiAgICAgICAgICAgIH1dIH0gfSk7XG5cbmNvbnN0IGZvcm1EaXJlY3RpdmVQcm92aWRlciA9IHtcbiAgICBwcm92aWRlOiBDb250cm9sQ29udGFpbmVyLFxuICAgIHVzZUV4aXN0aW5nOiBmb3J3YXJkUmVmKCgpID0+IEZvcm1Hcm91cERpcmVjdGl2ZSlcbn07XG4vKipcbiAqIEBkZXNjcmlwdGlvblxuICpcbiAqIEJpbmRzIGFuIGV4aXN0aW5nIGBGb3JtR3JvdXBgIG9yIGBGb3JtUmVjb3JkYCB0byBhIERPTSBlbGVtZW50LlxuICpcbiAqIFRoaXMgZGlyZWN0aXZlIGFjY2VwdHMgYW4gZXhpc3RpbmcgYEZvcm1Hcm91cGAgaW5zdGFuY2UuIEl0IHdpbGwgdGhlbiB1c2UgdGhpc1xuICogYEZvcm1Hcm91cGAgaW5zdGFuY2UgdG8gbWF0Y2ggYW55IGNoaWxkIGBGb3JtQ29udHJvbGAsIGBGb3JtR3JvdXBgL2BGb3JtUmVjb3JkYCxcbiAqIGFuZCBgRm9ybUFycmF5YCBpbnN0YW5jZXMgdG8gY2hpbGQgYEZvcm1Db250cm9sTmFtZWAsIGBGb3JtR3JvdXBOYW1lYCxcbiAqIGFuZCBgRm9ybUFycmF5TmFtZWAgZGlyZWN0aXZlcy5cbiAqXG4gKiBAc2VlIFtSZWFjdGl2ZSBGb3JtcyBHdWlkZV0oZ3VpZGUvcmVhY3RpdmUtZm9ybXMpXG4gKiBAc2VlIHtAbGluayBBYnN0cmFjdENvbnRyb2x9XG4gKlxuICogQHVzYWdlTm90ZXNcbiAqICMjIyBSZWdpc3RlciBGb3JtIEdyb3VwXG4gKlxuICogVGhlIGZvbGxvd2luZyBleGFtcGxlIHJlZ2lzdGVycyBhIGBGb3JtR3JvdXBgIHdpdGggZmlyc3QgbmFtZSBhbmQgbGFzdCBuYW1lIGNvbnRyb2xzLFxuICogYW5kIGxpc3RlbnMgZm9yIHRoZSAqbmdTdWJtaXQqIGV2ZW50IHdoZW4gdGhlIGJ1dHRvbiBpcyBjbGlja2VkLlxuICpcbiAqIHtAZXhhbXBsZSBmb3Jtcy90cy9zaW1wbGVGb3JtR3JvdXAvc2ltcGxlX2Zvcm1fZ3JvdXBfZXhhbXBsZS50cyByZWdpb249J0NvbXBvbmVudCd9XG4gKlxuICogQG5nTW9kdWxlIFJlYWN0aXZlRm9ybXNNb2R1bGVcbiAqIEBwdWJsaWNBcGlcbiAqL1xuY2xhc3MgRm9ybUdyb3VwRGlyZWN0aXZlIGV4dGVuZHMgQ29udHJvbENvbnRhaW5lciB7XG4gICAgY29uc3RydWN0b3IodmFsaWRhdG9ycywgYXN5bmNWYWxpZGF0b3JzLCBjYWxsU2V0RGlzYWJsZWRTdGF0ZSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmNhbGxTZXREaXNhYmxlZFN0YXRlID0gY2FsbFNldERpc2FibGVkU3RhdGU7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgICAgICogUmVwb3J0cyB3aGV0aGVyIHRoZSBmb3JtIHN1Ym1pc3Npb24gaGFzIGJlZW4gdHJpZ2dlcmVkLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zdWJtaXR0ZWQgPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENhbGxiYWNrIHRoYXQgc2hvdWxkIGJlIGludm9rZWQgd2hlbiBjb250cm9scyBpbiBGb3JtR3JvdXAgb3IgRm9ybUFycmF5IGNvbGxlY3Rpb24gY2hhbmdlXG4gICAgICAgICAqIChhZGRlZCBvciByZW1vdmVkKS4gVGhpcyBjYWxsYmFjayB0cmlnZ2VycyBjb3JyZXNwb25kaW5nIERPTSB1cGRhdGVzLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fb25Db2xsZWN0aW9uQ2hhbmdlID0gKCkgPT4gdGhpcy5fdXBkYXRlRG9tVmFsdWUoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAgICAgKiBUcmFja3MgdGhlIGxpc3Qgb2YgYWRkZWQgYEZvcm1Db250cm9sTmFtZWAgaW5zdGFuY2VzXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmRpcmVjdGl2ZXMgPSBbXTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAgICAgKiBUcmFja3MgdGhlIGBGb3JtR3JvdXBgIGJvdW5kIHRvIHRoaXMgZGlyZWN0aXZlLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5mb3JtID0gbnVsbDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAgICAgKiBFbWl0cyBhbiBldmVudCB3aGVuIHRoZSBmb3JtIHN1Ym1pc3Npb24gaGFzIGJlZW4gdHJpZ2dlcmVkLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5uZ1N1Ym1pdCA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgdGhpcy5fc2V0VmFsaWRhdG9ycyh2YWxpZGF0b3JzKTtcbiAgICAgICAgdGhpcy5fc2V0QXN5bmNWYWxpZGF0b3JzKGFzeW5jVmFsaWRhdG9ycyk7XG4gICAgfVxuICAgIC8qKiBAbm9kb2MgKi9cbiAgICBuZ09uQ2hhbmdlcyhjaGFuZ2VzKSB7XG4gICAgICAgIHRoaXMuX2NoZWNrRm9ybVByZXNlbnQoKTtcbiAgICAgICAgaWYgKGNoYW5nZXMuaGFzT3duUHJvcGVydHkoJ2Zvcm0nKSkge1xuICAgICAgICAgICAgdGhpcy5fdXBkYXRlVmFsaWRhdG9ycygpO1xuICAgICAgICAgICAgdGhpcy5fdXBkYXRlRG9tVmFsdWUoKTtcbiAgICAgICAgICAgIHRoaXMuX3VwZGF0ZVJlZ2lzdHJhdGlvbnMoKTtcbiAgICAgICAgICAgIHRoaXMuX29sZEZvcm0gPSB0aGlzLmZvcm07XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqIEBub2RvYyAqL1xuICAgIG5nT25EZXN0cm95KCkge1xuICAgICAgICBpZiAodGhpcy5mb3JtKSB7XG4gICAgICAgICAgICBjbGVhblVwVmFsaWRhdG9ycyh0aGlzLmZvcm0sIHRoaXMpO1xuICAgICAgICAgICAgLy8gQ3VycmVudGx5IHRoZSBgb25Db2xsZWN0aW9uQ2hhbmdlYCBjYWxsYmFjayBpcyByZXdyaXR0ZW4gZWFjaCB0aW1lIHRoZVxuICAgICAgICAgICAgLy8gYF9yZWdpc3Rlck9uQ29sbGVjdGlvbkNoYW5nZWAgZnVuY3Rpb24gaXMgaW52b2tlZC4gVGhlIGltcGxpY2F0aW9uIGlzIHRoYXQgY2xlYW51cCBzaG91bGRcbiAgICAgICAgICAgIC8vIGhhcHBlbiAqb25seSogd2hlbiB0aGUgYG9uQ29sbGVjdGlvbkNoYW5nZWAgY2FsbGJhY2sgd2FzIHNldCBieSB0aGlzIGRpcmVjdGl2ZSBpbnN0YW5jZS5cbiAgICAgICAgICAgIC8vIE90aGVyd2lzZSBpdCBtaWdodCBjYXVzZSBvdmVycmlkaW5nIGEgY2FsbGJhY2sgb2Ygc29tZSBvdGhlciBkaXJlY3RpdmUgaW5zdGFuY2VzLiBXZSBzaG91bGRcbiAgICAgICAgICAgIC8vIGNvbnNpZGVyIHVwZGF0aW5nIHRoaXMgbG9naWMgbGF0ZXIgdG8gbWFrZSBpdCBzaW1pbGFyIHRvIGhvdyBgb25DaGFuZ2VgIGNhbGxiYWNrcyBhcmVcbiAgICAgICAgICAgIC8vIGhhbmRsZWQsIHNlZSBodHRwczovL2dpdGh1Yi5jb20vYW5ndWxhci9hbmd1bGFyL2lzc3Vlcy8zOTczMiBmb3IgYWRkaXRpb25hbCBpbmZvLlxuICAgICAgICAgICAgaWYgKHRoaXMuZm9ybS5fb25Db2xsZWN0aW9uQ2hhbmdlID09PSB0aGlzLl9vbkNvbGxlY3Rpb25DaGFuZ2UpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmZvcm0uX3JlZ2lzdGVyT25Db2xsZWN0aW9uQ2hhbmdlKCgpID0+IHsgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICogUmV0dXJucyB0aGlzIGRpcmVjdGl2ZSdzIGluc3RhbmNlLlxuICAgICAqL1xuICAgIGdldCBmb3JtRGlyZWN0aXZlKCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICogUmV0dXJucyB0aGUgYEZvcm1Hcm91cGAgYm91bmQgdG8gdGhpcyBkaXJlY3RpdmUuXG4gICAgICovXG4gICAgZ2V0IGNvbnRyb2woKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZvcm07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqIFJldHVybnMgYW4gYXJyYXkgcmVwcmVzZW50aW5nIHRoZSBwYXRoIHRvIHRoaXMgZ3JvdXAuIEJlY2F1c2UgdGhpcyBkaXJlY3RpdmVcbiAgICAgKiBhbHdheXMgbGl2ZXMgYXQgdGhlIHRvcCBsZXZlbCBvZiBhIGZvcm0sIGl0IGFsd2F5cyBhbiBlbXB0eSBhcnJheS5cbiAgICAgKi9cbiAgICBnZXQgcGF0aCgpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKiBNZXRob2QgdGhhdCBzZXRzIHVwIHRoZSBjb250cm9sIGRpcmVjdGl2ZSBpbiB0aGlzIGdyb3VwLCByZS1jYWxjdWxhdGVzIGl0cyB2YWx1ZVxuICAgICAqIGFuZCB2YWxpZGl0eSwgYW5kIGFkZHMgdGhlIGluc3RhbmNlIHRvIHRoZSBpbnRlcm5hbCBsaXN0IG9mIGRpcmVjdGl2ZXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZGlyIFRoZSBgRm9ybUNvbnRyb2xOYW1lYCBkaXJlY3RpdmUgaW5zdGFuY2UuXG4gICAgICovXG4gICAgYWRkQ29udHJvbChkaXIpIHtcbiAgICAgICAgY29uc3QgY3RybCA9IHRoaXMuZm9ybS5nZXQoZGlyLnBhdGgpO1xuICAgICAgICBzZXRVcENvbnRyb2woY3RybCwgZGlyLCB0aGlzLmNhbGxTZXREaXNhYmxlZFN0YXRlKTtcbiAgICAgICAgY3RybC51cGRhdGVWYWx1ZUFuZFZhbGlkaXR5KHsgZW1pdEV2ZW50OiBmYWxzZSB9KTtcbiAgICAgICAgdGhpcy5kaXJlY3RpdmVzLnB1c2goZGlyKTtcbiAgICAgICAgcmV0dXJuIGN0cmw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqIFJldHJpZXZlcyB0aGUgYEZvcm1Db250cm9sYCBpbnN0YW5jZSBmcm9tIHRoZSBwcm92aWRlZCBgRm9ybUNvbnRyb2xOYW1lYCBkaXJlY3RpdmVcbiAgICAgKlxuICAgICAqIEBwYXJhbSBkaXIgVGhlIGBGb3JtQ29udHJvbE5hbWVgIGRpcmVjdGl2ZSBpbnN0YW5jZS5cbiAgICAgKi9cbiAgICBnZXRDb250cm9sKGRpcikge1xuICAgICAgICByZXR1cm4gdGhpcy5mb3JtLmdldChkaXIucGF0aCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqIFJlbW92ZXMgdGhlIGBGb3JtQ29udHJvbE5hbWVgIGluc3RhbmNlIGZyb20gdGhlIGludGVybmFsIGxpc3Qgb2YgZGlyZWN0aXZlc1xuICAgICAqXG4gICAgICogQHBhcmFtIGRpciBUaGUgYEZvcm1Db250cm9sTmFtZWAgZGlyZWN0aXZlIGluc3RhbmNlLlxuICAgICAqL1xuICAgIHJlbW92ZUNvbnRyb2woZGlyKSB7XG4gICAgICAgIGNsZWFuVXBDb250cm9sKGRpci5jb250cm9sIHx8IG51bGwsIGRpciwgLyogdmFsaWRhdGVDb250cm9sUHJlc2VuY2VPbkNoYW5nZSAqLyBmYWxzZSk7XG4gICAgICAgIHJlbW92ZUxpc3RJdGVtJDEodGhpcy5kaXJlY3RpdmVzLCBkaXIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGRzIGEgbmV3IGBGb3JtR3JvdXBOYW1lYCBkaXJlY3RpdmUgaW5zdGFuY2UgdG8gdGhlIGZvcm0uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZGlyIFRoZSBgRm9ybUdyb3VwTmFtZWAgZGlyZWN0aXZlIGluc3RhbmNlLlxuICAgICAqL1xuICAgIGFkZEZvcm1Hcm91cChkaXIpIHtcbiAgICAgICAgdGhpcy5fc2V0VXBGb3JtQ29udGFpbmVyKGRpcik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBlcmZvcm1zIHRoZSBuZWNlc3NhcnkgY2xlYW51cCB3aGVuIGEgYEZvcm1Hcm91cE5hbWVgIGRpcmVjdGl2ZSBpbnN0YW5jZSBpcyByZW1vdmVkIGZyb20gdGhlXG4gICAgICogdmlldy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBkaXIgVGhlIGBGb3JtR3JvdXBOYW1lYCBkaXJlY3RpdmUgaW5zdGFuY2UuXG4gICAgICovXG4gICAgcmVtb3ZlRm9ybUdyb3VwKGRpcikge1xuICAgICAgICB0aGlzLl9jbGVhblVwRm9ybUNvbnRhaW5lcihkaXIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKiBSZXRyaWV2ZXMgdGhlIGBGb3JtR3JvdXBgIGZvciBhIHByb3ZpZGVkIGBGb3JtR3JvdXBOYW1lYCBkaXJlY3RpdmUgaW5zdGFuY2VcbiAgICAgKlxuICAgICAqIEBwYXJhbSBkaXIgVGhlIGBGb3JtR3JvdXBOYW1lYCBkaXJlY3RpdmUgaW5zdGFuY2UuXG4gICAgICovXG4gICAgZ2V0Rm9ybUdyb3VwKGRpcikge1xuICAgICAgICByZXR1cm4gdGhpcy5mb3JtLmdldChkaXIucGF0aCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBlcmZvcm1zIHRoZSBuZWNlc3Nhcnkgc2V0dXAgd2hlbiBhIGBGb3JtQXJyYXlOYW1lYCBkaXJlY3RpdmUgaW5zdGFuY2UgaXMgYWRkZWQgdG8gdGhlIHZpZXcuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZGlyIFRoZSBgRm9ybUFycmF5TmFtZWAgZGlyZWN0aXZlIGluc3RhbmNlLlxuICAgICAqL1xuICAgIGFkZEZvcm1BcnJheShkaXIpIHtcbiAgICAgICAgdGhpcy5fc2V0VXBGb3JtQ29udGFpbmVyKGRpcik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBlcmZvcm1zIHRoZSBuZWNlc3NhcnkgY2xlYW51cCB3aGVuIGEgYEZvcm1BcnJheU5hbWVgIGRpcmVjdGl2ZSBpbnN0YW5jZSBpcyByZW1vdmVkIGZyb20gdGhlXG4gICAgICogdmlldy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBkaXIgVGhlIGBGb3JtQXJyYXlOYW1lYCBkaXJlY3RpdmUgaW5zdGFuY2UuXG4gICAgICovXG4gICAgcmVtb3ZlRm9ybUFycmF5KGRpcikge1xuICAgICAgICB0aGlzLl9jbGVhblVwRm9ybUNvbnRhaW5lcihkaXIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKiBSZXRyaWV2ZXMgdGhlIGBGb3JtQXJyYXlgIGZvciBhIHByb3ZpZGVkIGBGb3JtQXJyYXlOYW1lYCBkaXJlY3RpdmUgaW5zdGFuY2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZGlyIFRoZSBgRm9ybUFycmF5TmFtZWAgZGlyZWN0aXZlIGluc3RhbmNlLlxuICAgICAqL1xuICAgIGdldEZvcm1BcnJheShkaXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZm9ybS5nZXQoZGlyLnBhdGgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBuZXcgdmFsdWUgZm9yIHRoZSBwcm92aWRlZCBgRm9ybUNvbnRyb2xOYW1lYCBkaXJlY3RpdmUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZGlyIFRoZSBgRm9ybUNvbnRyb2xOYW1lYCBkaXJlY3RpdmUgaW5zdGFuY2UuXG4gICAgICogQHBhcmFtIHZhbHVlIFRoZSBuZXcgdmFsdWUgZm9yIHRoZSBkaXJlY3RpdmUncyBjb250cm9sLlxuICAgICAqL1xuICAgIHVwZGF0ZU1vZGVsKGRpciwgdmFsdWUpIHtcbiAgICAgICAgY29uc3QgY3RybCA9IHRoaXMuZm9ybS5nZXQoZGlyLnBhdGgpO1xuICAgICAgICBjdHJsLnNldFZhbHVlKHZhbHVlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICogTWV0aG9kIGNhbGxlZCB3aXRoIHRoZSBcInN1Ym1pdFwiIGV2ZW50IGlzIHRyaWdnZXJlZCBvbiB0aGUgZm9ybS5cbiAgICAgKiBUcmlnZ2VycyB0aGUgYG5nU3VibWl0YCBlbWl0dGVyIHRvIGVtaXQgdGhlIFwic3VibWl0XCIgZXZlbnQgYXMgaXRzIHBheWxvYWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gJGV2ZW50IFRoZSBcInN1Ym1pdFwiIGV2ZW50IG9iamVjdFxuICAgICAqL1xuICAgIG9uU3VibWl0KCRldmVudCkge1xuICAgICAgICB0aGlzLnN1Ym1pdHRlZCA9IHRydWU7XG4gICAgICAgIHN5bmNQZW5kaW5nQ29udHJvbHModGhpcy5mb3JtLCB0aGlzLmRpcmVjdGl2ZXMpO1xuICAgICAgICB0aGlzLm5nU3VibWl0LmVtaXQoJGV2ZW50KTtcbiAgICAgICAgLy8gRm9ybXMgd2l0aCBgbWV0aG9kPVwiZGlhbG9nXCJgIGhhdmUgc29tZSBzcGVjaWFsIGJlaGF2aW9yIHRoYXQgd29uJ3QgcmVsb2FkIHRoZSBwYWdlIGFuZCB0aGF0XG4gICAgICAgIC8vIHNob3VsZG4ndCBiZSBwcmV2ZW50ZWQuIE5vdGUgdGhhdCB3ZSBuZWVkIHRvIG51bGwgY2hlY2sgdGhlIGBldmVudGAgYW5kIHRoZSBgdGFyZ2V0YCwgYmVjYXVzZVxuICAgICAgICAvLyBzb21lIGludGVybmFsIGFwcHMgY2FsbCB0aGlzIG1ldGhvZCBkaXJlY3RseSB3aXRoIHRoZSB3cm9uZyBhcmd1bWVudHMuXG4gICAgICAgIHJldHVybiAkZXZlbnQ/LnRhcmdldD8ubWV0aG9kID09PSAnZGlhbG9nJztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICogTWV0aG9kIGNhbGxlZCB3aGVuIHRoZSBcInJlc2V0XCIgZXZlbnQgaXMgdHJpZ2dlcmVkIG9uIHRoZSBmb3JtLlxuICAgICAqL1xuICAgIG9uUmVzZXQoKSB7XG4gICAgICAgIHRoaXMucmVzZXRGb3JtKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqIFJlc2V0cyB0aGUgZm9ybSB0byBhbiBpbml0aWFsIHZhbHVlIGFuZCByZXNldHMgaXRzIHN1Ym1pdHRlZCBzdGF0dXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdmFsdWUgVGhlIG5ldyB2YWx1ZSBmb3IgdGhlIGZvcm0uXG4gICAgICovXG4gICAgcmVzZXRGb3JtKHZhbHVlID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMuZm9ybS5yZXNldCh2YWx1ZSk7XG4gICAgICAgIHRoaXMuc3VibWl0dGVkID0gZmFsc2U7XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBfdXBkYXRlRG9tVmFsdWUoKSB7XG4gICAgICAgIHRoaXMuZGlyZWN0aXZlcy5mb3JFYWNoKGRpciA9PiB7XG4gICAgICAgICAgICBjb25zdCBvbGRDdHJsID0gZGlyLmNvbnRyb2w7XG4gICAgICAgICAgICBjb25zdCBuZXdDdHJsID0gdGhpcy5mb3JtLmdldChkaXIucGF0aCk7XG4gICAgICAgICAgICBpZiAob2xkQ3RybCAhPT0gbmV3Q3RybCkge1xuICAgICAgICAgICAgICAgIC8vIE5vdGU6IHRoZSB2YWx1ZSBvZiB0aGUgYGRpci5jb250cm9sYCBtYXkgbm90IGJlIGRlZmluZWQsIGZvciBleGFtcGxlIHdoZW4gaXQncyBhIGZpcnN0XG4gICAgICAgICAgICAgICAgLy8gYEZvcm1Db250cm9sYCB0aGF0IGlzIGFkZGVkIHRvIGEgYEZvcm1Hcm91cGAgaW5zdGFuY2UgKHZpYSBgYWRkQ29udHJvbGAgY2FsbCkuXG4gICAgICAgICAgICAgICAgY2xlYW5VcENvbnRyb2wob2xkQ3RybCB8fCBudWxsLCBkaXIpO1xuICAgICAgICAgICAgICAgIC8vIENoZWNrIHdoZXRoZXIgbmV3IGNvbnRyb2wgYXQgdGhlIHNhbWUgbG9jYXRpb24gaW5zaWRlIHRoZSBjb3JyZXNwb25kaW5nIGBGb3JtR3JvdXBgIGlzIGFuXG4gICAgICAgICAgICAgICAgLy8gaW5zdGFuY2Ugb2YgYEZvcm1Db250cm9sYCBhbmQgcGVyZm9ybSBjb250cm9sIHNldHVwIG9ubHkgaWYgdGhhdCdzIHRoZSBjYXNlLlxuICAgICAgICAgICAgICAgIC8vIE5vdGU6IHdlIGRvbid0IG5lZWQgdG8gY2xlYXIgdGhlIGxpc3Qgb2YgZGlyZWN0aXZlcyAoYHRoaXMuZGlyZWN0aXZlc2ApIGhlcmUsIGl0IHdvdWxkIGJlXG4gICAgICAgICAgICAgICAgLy8gdGFrZW4gY2FyZSBvZiBpbiB0aGUgYHJlbW92ZUNvbnRyb2xgIG1ldGhvZCBpbnZva2VkIHdoZW4gY29ycmVzcG9uZGluZyBgZm9ybUNvbnRyb2xOYW1lYFxuICAgICAgICAgICAgICAgIC8vIGRpcmVjdGl2ZSBpbnN0YW5jZSBpcyBiZWluZyByZW1vdmVkIChpbnZva2VkIGZyb20gYEZvcm1Db250cm9sTmFtZS5uZ09uRGVzdHJveWApLlxuICAgICAgICAgICAgICAgIGlmIChpc0Zvcm1Db250cm9sKG5ld0N0cmwpKSB7XG4gICAgICAgICAgICAgICAgICAgIHNldFVwQ29udHJvbChuZXdDdHJsLCBkaXIsIHRoaXMuY2FsbFNldERpc2FibGVkU3RhdGUpO1xuICAgICAgICAgICAgICAgICAgICBkaXIuY29udHJvbCA9IG5ld0N0cmw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5mb3JtLl91cGRhdGVUcmVlVmFsaWRpdHkoeyBlbWl0RXZlbnQ6IGZhbHNlIH0pO1xuICAgIH1cbiAgICBfc2V0VXBGb3JtQ29udGFpbmVyKGRpcikge1xuICAgICAgICBjb25zdCBjdHJsID0gdGhpcy5mb3JtLmdldChkaXIucGF0aCk7XG4gICAgICAgIHNldFVwRm9ybUNvbnRhaW5lcihjdHJsLCBkaXIpO1xuICAgICAgICAvLyBOT1RFOiB0aGlzIG9wZXJhdGlvbiBsb29rcyB1bm5lY2Vzc2FyeSBpbiBjYXNlIG5vIG5ldyB2YWxpZGF0b3JzIHdlcmUgYWRkZWQgaW5cbiAgICAgICAgLy8gYHNldFVwRm9ybUNvbnRhaW5lcmAgY2FsbC4gQ29uc2lkZXIgdXBkYXRpbmcgdGhpcyBjb2RlIHRvIG1hdGNoIHRoZSBsb2dpYyBpblxuICAgICAgICAvLyBgX2NsZWFuVXBGb3JtQ29udGFpbmVyYCBmdW5jdGlvbi5cbiAgICAgICAgY3RybC51cGRhdGVWYWx1ZUFuZFZhbGlkaXR5KHsgZW1pdEV2ZW50OiBmYWxzZSB9KTtcbiAgICB9XG4gICAgX2NsZWFuVXBGb3JtQ29udGFpbmVyKGRpcikge1xuICAgICAgICBpZiAodGhpcy5mb3JtKSB7XG4gICAgICAgICAgICBjb25zdCBjdHJsID0gdGhpcy5mb3JtLmdldChkaXIucGF0aCk7XG4gICAgICAgICAgICBpZiAoY3RybCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGlzQ29udHJvbFVwZGF0ZWQgPSBjbGVhblVwRm9ybUNvbnRhaW5lcihjdHJsLCBkaXIpO1xuICAgICAgICAgICAgICAgIGlmIChpc0NvbnRyb2xVcGRhdGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFJ1biB2YWxpZGl0eSBjaGVjayBvbmx5IGluIGNhc2UgYSBjb250cm9sIHdhcyB1cGRhdGVkIChpLmUuIHZpZXcgdmFsaWRhdG9ycyB3ZXJlXG4gICAgICAgICAgICAgICAgICAgIC8vIHJlbW92ZWQpIGFzIHJlbW92aW5nIHZpZXcgdmFsaWRhdG9ycyBtaWdodCBjYXVzZSB2YWxpZGl0eSB0byBjaGFuZ2UuXG4gICAgICAgICAgICAgICAgICAgIGN0cmwudXBkYXRlVmFsdWVBbmRWYWxpZGl0eSh7IGVtaXRFdmVudDogZmFsc2UgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIF91cGRhdGVSZWdpc3RyYXRpb25zKCkge1xuICAgICAgICB0aGlzLmZvcm0uX3JlZ2lzdGVyT25Db2xsZWN0aW9uQ2hhbmdlKHRoaXMuX29uQ29sbGVjdGlvbkNoYW5nZSk7XG4gICAgICAgIGlmICh0aGlzLl9vbGRGb3JtKSB7XG4gICAgICAgICAgICB0aGlzLl9vbGRGb3JtLl9yZWdpc3Rlck9uQ29sbGVjdGlvbkNoYW5nZSgoKSA9PiB7IH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIF91cGRhdGVWYWxpZGF0b3JzKCkge1xuICAgICAgICBzZXRVcFZhbGlkYXRvcnModGhpcy5mb3JtLCB0aGlzKTtcbiAgICAgICAgaWYgKHRoaXMuX29sZEZvcm0pIHtcbiAgICAgICAgICAgIGNsZWFuVXBWYWxpZGF0b3JzKHRoaXMuX29sZEZvcm0sIHRoaXMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9jaGVja0Zvcm1QcmVzZW50KCkge1xuICAgICAgICBpZiAoIXRoaXMuZm9ybSAmJiAodHlwZW9mIG5nRGV2TW9kZSA9PT0gJ3VuZGVmaW5lZCcgfHwgbmdEZXZNb2RlKSkge1xuICAgICAgICAgICAgdGhyb3cgbWlzc2luZ0Zvcm1FeGNlcHRpb24oKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzdGF0aWMgeyB0aGlzLsm1ZmFjID0gaTAuybXJtW5nRGVjbGFyZUZhY3RvcnkoeyBtaW5WZXJzaW9uOiBcIjEyLjAuMFwiLCB2ZXJzaW9uOiBcIjE3LjMuMTJcIiwgbmdJbXBvcnQ6IGkwLCB0eXBlOiBGb3JtR3JvdXBEaXJlY3RpdmUsIGRlcHM6IFt7IHRva2VuOiBOR19WQUxJREFUT1JTLCBvcHRpb25hbDogdHJ1ZSwgc2VsZjogdHJ1ZSB9LCB7IHRva2VuOiBOR19BU1lOQ19WQUxJREFUT1JTLCBvcHRpb25hbDogdHJ1ZSwgc2VsZjogdHJ1ZSB9LCB7IHRva2VuOiBDQUxMX1NFVF9ESVNBQkxFRF9TVEFURSwgb3B0aW9uYWw6IHRydWUgfV0sIHRhcmdldDogaTAuybXJtUZhY3RvcnlUYXJnZXQuRGlyZWN0aXZlIH0pOyB9XG4gICAgc3RhdGljIHsgdGhpcy7JtWRpciA9IGkwLsm1ybVuZ0RlY2xhcmVEaXJlY3RpdmUoeyBtaW5WZXJzaW9uOiBcIjE0LjAuMFwiLCB2ZXJzaW9uOiBcIjE3LjMuMTJcIiwgdHlwZTogRm9ybUdyb3VwRGlyZWN0aXZlLCBzZWxlY3RvcjogXCJbZm9ybUdyb3VwXVwiLCBpbnB1dHM6IHsgZm9ybTogW1wiZm9ybUdyb3VwXCIsIFwiZm9ybVwiXSB9LCBvdXRwdXRzOiB7IG5nU3VibWl0OiBcIm5nU3VibWl0XCIgfSwgaG9zdDogeyBsaXN0ZW5lcnM6IHsgXCJzdWJtaXRcIjogXCJvblN1Ym1pdCgkZXZlbnQpXCIsIFwicmVzZXRcIjogXCJvblJlc2V0KClcIiB9IH0sIHByb3ZpZGVyczogW2Zvcm1EaXJlY3RpdmVQcm92aWRlcl0sIGV4cG9ydEFzOiBbXCJuZ0Zvcm1cIl0sIHVzZXNJbmhlcml0YW5jZTogdHJ1ZSwgdXNlc09uQ2hhbmdlczogdHJ1ZSwgbmdJbXBvcnQ6IGkwIH0pOyB9XG59XG5pMC7Jtcm1bmdEZWNsYXJlQ2xhc3NNZXRhZGF0YSh7IG1pblZlcnNpb246IFwiMTIuMC4wXCIsIHZlcnNpb246IFwiMTcuMy4xMlwiLCBuZ0ltcG9ydDogaTAsIHR5cGU6IEZvcm1Hcm91cERpcmVjdGl2ZSwgZGVjb3JhdG9yczogW3tcbiAgICAgICAgICAgIHR5cGU6IERpcmVjdGl2ZSxcbiAgICAgICAgICAgIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnW2Zvcm1Hcm91cF0nLFxuICAgICAgICAgICAgICAgICAgICBwcm92aWRlcnM6IFtmb3JtRGlyZWN0aXZlUHJvdmlkZXJdLFxuICAgICAgICAgICAgICAgICAgICBob3N0OiB7ICcoc3VibWl0KSc6ICdvblN1Ym1pdCgkZXZlbnQpJywgJyhyZXNldCknOiAnb25SZXNldCgpJyB9LFxuICAgICAgICAgICAgICAgICAgICBleHBvcnRBczogJ25nRm9ybSdcbiAgICAgICAgICAgICAgICB9XVxuICAgICAgICB9XSwgY3RvclBhcmFtZXRlcnM6ICgpID0+IFt7IHR5cGU6IHVuZGVmaW5lZCwgZGVjb3JhdG9yczogW3tcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogT3B0aW9uYWxcbiAgICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFNlbGZcbiAgICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IEluamVjdCxcbiAgICAgICAgICAgICAgICAgICAgYXJnczogW05HX1ZBTElEQVRPUlNdXG4gICAgICAgICAgICAgICAgfV0gfSwgeyB0eXBlOiB1bmRlZmluZWQsIGRlY29yYXRvcnM6IFt7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IE9wdGlvbmFsXG4gICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBTZWxmXG4gICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBJbmplY3QsXG4gICAgICAgICAgICAgICAgICAgIGFyZ3M6IFtOR19BU1lOQ19WQUxJREFUT1JTXVxuICAgICAgICAgICAgICAgIH1dIH0sIHsgdHlwZTogdW5kZWZpbmVkLCBkZWNvcmF0b3JzOiBbe1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBPcHRpb25hbFxuICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogSW5qZWN0LFxuICAgICAgICAgICAgICAgICAgICBhcmdzOiBbQ0FMTF9TRVRfRElTQUJMRURfU1RBVEVdXG4gICAgICAgICAgICAgICAgfV0gfV0sIHByb3BEZWNvcmF0b3JzOiB7IGZvcm06IFt7XG4gICAgICAgICAgICAgICAgdHlwZTogSW5wdXQsXG4gICAgICAgICAgICAgICAgYXJnczogWydmb3JtR3JvdXAnXVxuICAgICAgICAgICAgfV0sIG5nU3VibWl0OiBbe1xuICAgICAgICAgICAgICAgIHR5cGU6IE91dHB1dFxuICAgICAgICAgICAgfV0gfSB9KTtcblxuY29uc3QgZm9ybUdyb3VwTmFtZVByb3ZpZGVyID0ge1xuICAgIHByb3ZpZGU6IENvbnRyb2xDb250YWluZXIsXG4gICAgdXNlRXhpc3Rpbmc6IGZvcndhcmRSZWYoKCkgPT4gRm9ybUdyb3VwTmFtZSlcbn07XG4vKipcbiAqIEBkZXNjcmlwdGlvblxuICpcbiAqIFN5bmNzIGEgbmVzdGVkIGBGb3JtR3JvdXBgIG9yIGBGb3JtUmVjb3JkYCB0byBhIERPTSBlbGVtZW50LlxuICpcbiAqIFRoaXMgZGlyZWN0aXZlIGNhbiBvbmx5IGJlIHVzZWQgd2l0aCBhIHBhcmVudCBgRm9ybUdyb3VwRGlyZWN0aXZlYC5cbiAqXG4gKiBJdCBhY2NlcHRzIHRoZSBzdHJpbmcgbmFtZSBvZiB0aGUgbmVzdGVkIGBGb3JtR3JvdXBgIG9yIGBGb3JtUmVjb3JkYCB0byBsaW5rLCBhbmRcbiAqIGxvb2tzIGZvciBhIGBGb3JtR3JvdXBgIG9yIGBGb3JtUmVjb3JkYCByZWdpc3RlcmVkIHdpdGggdGhhdCBuYW1lIGluIHRoZSBwYXJlbnRcbiAqIGBGb3JtR3JvdXBgIGluc3RhbmNlIHlvdSBwYXNzZWQgaW50byBgRm9ybUdyb3VwRGlyZWN0aXZlYC5cbiAqXG4gKiBVc2UgbmVzdGVkIGZvcm0gZ3JvdXBzIHRvIHZhbGlkYXRlIGEgc3ViLWdyb3VwIG9mIGFcbiAqIGZvcm0gc2VwYXJhdGVseSBmcm9tIHRoZSByZXN0IG9yIHRvIGdyb3VwIHRoZSB2YWx1ZXMgb2YgY2VydGFpblxuICogY29udHJvbHMgaW50byB0aGVpciBvd24gbmVzdGVkIG9iamVjdC5cbiAqXG4gKiBAc2VlIFtSZWFjdGl2ZSBGb3JtcyBHdWlkZV0oZ3VpZGUvcmVhY3RpdmUtZm9ybXMpXG4gKlxuICogQHVzYWdlTm90ZXNcbiAqXG4gKiAjIyMgQWNjZXNzIHRoZSBncm91cCBieSBuYW1lXG4gKlxuICogVGhlIGZvbGxvd2luZyBleGFtcGxlIHVzZXMgdGhlIGBBYnN0cmFjdENvbnRyb2wuZ2V0YCBtZXRob2QgdG8gYWNjZXNzIHRoZVxuICogYXNzb2NpYXRlZCBgRm9ybUdyb3VwYFxuICpcbiAqIGBgYHRzXG4gKiAgIHRoaXMuZm9ybS5nZXQoJ25hbWUnKTtcbiAqIGBgYFxuICpcbiAqICMjIyBBY2Nlc3MgaW5kaXZpZHVhbCBjb250cm9scyBpbiB0aGUgZ3JvdXBcbiAqXG4gKiBUaGUgZm9sbG93aW5nIGV4YW1wbGUgdXNlcyB0aGUgYEFic3RyYWN0Q29udHJvbC5nZXRgIG1ldGhvZCB0byBhY2Nlc3NcbiAqIGluZGl2aWR1YWwgY29udHJvbHMgd2l0aGluIHRoZSBncm91cCB1c2luZyBkb3Qgc3ludGF4LlxuICpcbiAqIGBgYHRzXG4gKiAgIHRoaXMuZm9ybS5nZXQoJ25hbWUuZmlyc3QnKTtcbiAqIGBgYFxuICpcbiAqICMjIyBSZWdpc3RlciBhIG5lc3RlZCBgRm9ybUdyb3VwYC5cbiAqXG4gKiBUaGUgZm9sbG93aW5nIGV4YW1wbGUgcmVnaXN0ZXJzIGEgbmVzdGVkICpuYW1lKiBgRm9ybUdyb3VwYCB3aXRoaW4gYW4gZXhpc3RpbmcgYEZvcm1Hcm91cGAsXG4gKiBhbmQgcHJvdmlkZXMgbWV0aG9kcyB0byByZXRyaWV2ZSB0aGUgbmVzdGVkIGBGb3JtR3JvdXBgIGFuZCBpbmRpdmlkdWFsIGNvbnRyb2xzLlxuICpcbiAqIHtAZXhhbXBsZSBmb3Jtcy90cy9uZXN0ZWRGb3JtR3JvdXAvbmVzdGVkX2Zvcm1fZ3JvdXBfZXhhbXBsZS50cyByZWdpb249J0NvbXBvbmVudCd9XG4gKlxuICogQG5nTW9kdWxlIFJlYWN0aXZlRm9ybXNNb2R1bGVcbiAqIEBwdWJsaWNBcGlcbiAqL1xuY2xhc3MgRm9ybUdyb3VwTmFtZSBleHRlbmRzIEFic3RyYWN0Rm9ybUdyb3VwRGlyZWN0aXZlIHtcbiAgICBjb25zdHJ1Y3RvcihwYXJlbnQsIHZhbGlkYXRvcnMsIGFzeW5jVmFsaWRhdG9ycykge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICAvKipcbiAgICAgICAgICogQGRlc2NyaXB0aW9uXG4gICAgICAgICAqIFRyYWNrcyB0aGUgbmFtZSBvZiB0aGUgYEZvcm1Hcm91cGAgYm91bmQgdG8gdGhlIGRpcmVjdGl2ZS4gVGhlIG5hbWUgY29ycmVzcG9uZHNcbiAgICAgICAgICogdG8gYSBrZXkgaW4gdGhlIHBhcmVudCBgRm9ybUdyb3VwYCBvciBgRm9ybUFycmF5YC5cbiAgICAgICAgICogQWNjZXB0cyBhIG5hbWUgYXMgYSBzdHJpbmcgb3IgYSBudW1iZXIuXG4gICAgICAgICAqIFRoZSBuYW1lIGluIHRoZSBmb3JtIG9mIGEgc3RyaW5nIGlzIHVzZWZ1bCBmb3IgaW5kaXZpZHVhbCBmb3JtcyxcbiAgICAgICAgICogd2hpbGUgdGhlIG51bWVyaWNhbCBmb3JtIGFsbG93cyBmb3IgZm9ybSBncm91cHMgdG8gYmUgYm91bmRcbiAgICAgICAgICogdG8gaW5kaWNlcyB3aGVuIGl0ZXJhdGluZyBvdmVyIGdyb3VwcyBpbiBhIGBGb3JtQXJyYXlgLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5uYW1lID0gbnVsbDtcbiAgICAgICAgdGhpcy5fcGFyZW50ID0gcGFyZW50O1xuICAgICAgICB0aGlzLl9zZXRWYWxpZGF0b3JzKHZhbGlkYXRvcnMpO1xuICAgICAgICB0aGlzLl9zZXRBc3luY1ZhbGlkYXRvcnMoYXN5bmNWYWxpZGF0b3JzKTtcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIF9jaGVja1BhcmVudFR5cGUoKSB7XG4gICAgICAgIGlmIChfaGFzSW52YWxpZFBhcmVudCh0aGlzLl9wYXJlbnQpICYmICh0eXBlb2YgbmdEZXZNb2RlID09PSAndW5kZWZpbmVkJyB8fCBuZ0Rldk1vZGUpKSB7XG4gICAgICAgICAgICB0aHJvdyBncm91cFBhcmVudEV4Y2VwdGlvbigpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHN0YXRpYyB7IHRoaXMuybVmYWMgPSBpMC7Jtcm1bmdEZWNsYXJlRmFjdG9yeSh7IG1pblZlcnNpb246IFwiMTIuMC4wXCIsIHZlcnNpb246IFwiMTcuMy4xMlwiLCBuZ0ltcG9ydDogaTAsIHR5cGU6IEZvcm1Hcm91cE5hbWUsIGRlcHM6IFt7IHRva2VuOiBDb250cm9sQ29udGFpbmVyLCBob3N0OiB0cnVlLCBvcHRpb25hbDogdHJ1ZSwgc2tpcFNlbGY6IHRydWUgfSwgeyB0b2tlbjogTkdfVkFMSURBVE9SUywgb3B0aW9uYWw6IHRydWUsIHNlbGY6IHRydWUgfSwgeyB0b2tlbjogTkdfQVNZTkNfVkFMSURBVE9SUywgb3B0aW9uYWw6IHRydWUsIHNlbGY6IHRydWUgfV0sIHRhcmdldDogaTAuybXJtUZhY3RvcnlUYXJnZXQuRGlyZWN0aXZlIH0pOyB9XG4gICAgc3RhdGljIHsgdGhpcy7JtWRpciA9IGkwLsm1ybVuZ0RlY2xhcmVEaXJlY3RpdmUoeyBtaW5WZXJzaW9uOiBcIjE0LjAuMFwiLCB2ZXJzaW9uOiBcIjE3LjMuMTJcIiwgdHlwZTogRm9ybUdyb3VwTmFtZSwgc2VsZWN0b3I6IFwiW2Zvcm1Hcm91cE5hbWVdXCIsIGlucHV0czogeyBuYW1lOiBbXCJmb3JtR3JvdXBOYW1lXCIsIFwibmFtZVwiXSB9LCBwcm92aWRlcnM6IFtmb3JtR3JvdXBOYW1lUHJvdmlkZXJdLCB1c2VzSW5oZXJpdGFuY2U6IHRydWUsIG5nSW1wb3J0OiBpMCB9KTsgfVxufVxuaTAuybXJtW5nRGVjbGFyZUNsYXNzTWV0YWRhdGEoeyBtaW5WZXJzaW9uOiBcIjEyLjAuMFwiLCB2ZXJzaW9uOiBcIjE3LjMuMTJcIiwgbmdJbXBvcnQ6IGkwLCB0eXBlOiBGb3JtR3JvdXBOYW1lLCBkZWNvcmF0b3JzOiBbe1xuICAgICAgICAgICAgdHlwZTogRGlyZWN0aXZlLFxuICAgICAgICAgICAgYXJnczogW3sgc2VsZWN0b3I6ICdbZm9ybUdyb3VwTmFtZV0nLCBwcm92aWRlcnM6IFtmb3JtR3JvdXBOYW1lUHJvdmlkZXJdIH1dXG4gICAgICAgIH1dLCBjdG9yUGFyYW1ldGVyczogKCkgPT4gW3sgdHlwZTogQ29udHJvbENvbnRhaW5lciwgZGVjb3JhdG9yczogW3tcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogT3B0aW9uYWxcbiAgICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IEhvc3RcbiAgICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFNraXBTZWxmXG4gICAgICAgICAgICAgICAgfV0gfSwgeyB0eXBlOiB1bmRlZmluZWQsIGRlY29yYXRvcnM6IFt7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IE9wdGlvbmFsXG4gICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBTZWxmXG4gICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBJbmplY3QsXG4gICAgICAgICAgICAgICAgICAgIGFyZ3M6IFtOR19WQUxJREFUT1JTXVxuICAgICAgICAgICAgICAgIH1dIH0sIHsgdHlwZTogdW5kZWZpbmVkLCBkZWNvcmF0b3JzOiBbe1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBPcHRpb25hbFxuICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogU2VsZlxuICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogSW5qZWN0LFxuICAgICAgICAgICAgICAgICAgICBhcmdzOiBbTkdfQVNZTkNfVkFMSURBVE9SU11cbiAgICAgICAgICAgICAgICB9XSB9XSwgcHJvcERlY29yYXRvcnM6IHsgbmFtZTogW3tcbiAgICAgICAgICAgICAgICB0eXBlOiBJbnB1dCxcbiAgICAgICAgICAgICAgICBhcmdzOiBbJ2Zvcm1Hcm91cE5hbWUnXVxuICAgICAgICAgICAgfV0gfSB9KTtcbmNvbnN0IGZvcm1BcnJheU5hbWVQcm92aWRlciA9IHtcbiAgICBwcm92aWRlOiBDb250cm9sQ29udGFpbmVyLFxuICAgIHVzZUV4aXN0aW5nOiBmb3J3YXJkUmVmKCgpID0+IEZvcm1BcnJheU5hbWUpXG59O1xuLyoqXG4gKiBAZGVzY3JpcHRpb25cbiAqXG4gKiBTeW5jcyBhIG5lc3RlZCBgRm9ybUFycmF5YCB0byBhIERPTSBlbGVtZW50LlxuICpcbiAqIFRoaXMgZGlyZWN0aXZlIGlzIGRlc2lnbmVkIHRvIGJlIHVzZWQgd2l0aCBhIHBhcmVudCBgRm9ybUdyb3VwRGlyZWN0aXZlYCAoc2VsZWN0b3I6XG4gKiBgW2Zvcm1Hcm91cF1gKS5cbiAqXG4gKiBJdCBhY2NlcHRzIHRoZSBzdHJpbmcgbmFtZSBvZiB0aGUgbmVzdGVkIGBGb3JtQXJyYXlgIHlvdSB3YW50IHRvIGxpbmssIGFuZFxuICogd2lsbCBsb29rIGZvciBhIGBGb3JtQXJyYXlgIHJlZ2lzdGVyZWQgd2l0aCB0aGF0IG5hbWUgaW4gdGhlIHBhcmVudFxuICogYEZvcm1Hcm91cGAgaW5zdGFuY2UgeW91IHBhc3NlZCBpbnRvIGBGb3JtR3JvdXBEaXJlY3RpdmVgLlxuICpcbiAqIEBzZWUgW1JlYWN0aXZlIEZvcm1zIEd1aWRlXShndWlkZS9yZWFjdGl2ZS1mb3JtcylcbiAqIEBzZWUge0BsaW5rIEFic3RyYWN0Q29udHJvbH1cbiAqXG4gKiBAdXNhZ2VOb3Rlc1xuICpcbiAqICMjIyBFeGFtcGxlXG4gKlxuICoge0BleGFtcGxlIGZvcm1zL3RzL25lc3RlZEZvcm1BcnJheS9uZXN0ZWRfZm9ybV9hcnJheV9leGFtcGxlLnRzIHJlZ2lvbj0nQ29tcG9uZW50J31cbiAqXG4gKiBAbmdNb2R1bGUgUmVhY3RpdmVGb3Jtc01vZHVsZVxuICogQHB1YmxpY0FwaVxuICovXG5jbGFzcyBGb3JtQXJyYXlOYW1lIGV4dGVuZHMgQ29udHJvbENvbnRhaW5lciB7XG4gICAgY29uc3RydWN0b3IocGFyZW50LCB2YWxpZGF0b3JzLCBhc3luY1ZhbGlkYXRvcnMpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAgICAgKiBUcmFja3MgdGhlIG5hbWUgb2YgdGhlIGBGb3JtQXJyYXlgIGJvdW5kIHRvIHRoZSBkaXJlY3RpdmUuIFRoZSBuYW1lIGNvcnJlc3BvbmRzXG4gICAgICAgICAqIHRvIGEga2V5IGluIHRoZSBwYXJlbnQgYEZvcm1Hcm91cGAgb3IgYEZvcm1BcnJheWAuXG4gICAgICAgICAqIEFjY2VwdHMgYSBuYW1lIGFzIGEgc3RyaW5nIG9yIGEgbnVtYmVyLlxuICAgICAgICAgKiBUaGUgbmFtZSBpbiB0aGUgZm9ybSBvZiBhIHN0cmluZyBpcyB1c2VmdWwgZm9yIGluZGl2aWR1YWwgZm9ybXMsXG4gICAgICAgICAqIHdoaWxlIHRoZSBudW1lcmljYWwgZm9ybSBhbGxvd3MgZm9yIGZvcm0gYXJyYXlzIHRvIGJlIGJvdW5kXG4gICAgICAgICAqIHRvIGluZGljZXMgd2hlbiBpdGVyYXRpbmcgb3ZlciBhcnJheXMgaW4gYSBgRm9ybUFycmF5YC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubmFtZSA9IG51bGw7XG4gICAgICAgIHRoaXMuX3BhcmVudCA9IHBhcmVudDtcbiAgICAgICAgdGhpcy5fc2V0VmFsaWRhdG9ycyh2YWxpZGF0b3JzKTtcbiAgICAgICAgdGhpcy5fc2V0QXN5bmNWYWxpZGF0b3JzKGFzeW5jVmFsaWRhdG9ycyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEEgbGlmZWN5Y2xlIG1ldGhvZCBjYWxsZWQgd2hlbiB0aGUgZGlyZWN0aXZlJ3MgaW5wdXRzIGFyZSBpbml0aWFsaXplZC4gRm9yIGludGVybmFsIHVzZSBvbmx5LlxuICAgICAqIEB0aHJvd3MgSWYgdGhlIGRpcmVjdGl2ZSBkb2VzIG5vdCBoYXZlIGEgdmFsaWQgcGFyZW50LlxuICAgICAqIEBub2RvY1xuICAgICAqL1xuICAgIG5nT25Jbml0KCkge1xuICAgICAgICB0aGlzLl9jaGVja1BhcmVudFR5cGUoKTtcbiAgICAgICAgdGhpcy5mb3JtRGlyZWN0aXZlLmFkZEZvcm1BcnJheSh0aGlzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQSBsaWZlY3ljbGUgbWV0aG9kIGNhbGxlZCBiZWZvcmUgdGhlIGRpcmVjdGl2ZSdzIGluc3RhbmNlIGlzIGRlc3Ryb3llZC4gRm9yIGludGVybmFsIHVzZSBvbmx5LlxuICAgICAqIEBub2RvY1xuICAgICAqL1xuICAgIG5nT25EZXN0cm95KCkge1xuICAgICAgICBpZiAodGhpcy5mb3JtRGlyZWN0aXZlKSB7XG4gICAgICAgICAgICB0aGlzLmZvcm1EaXJlY3RpdmUucmVtb3ZlRm9ybUFycmF5KHRoaXMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqIFRoZSBgRm9ybUFycmF5YCBib3VuZCB0byB0aGlzIGRpcmVjdGl2ZS5cbiAgICAgKi9cbiAgICBnZXQgY29udHJvbCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZm9ybURpcmVjdGl2ZS5nZXRGb3JtQXJyYXkodGhpcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqIFRoZSB0b3AtbGV2ZWwgZGlyZWN0aXZlIGZvciB0aGlzIGdyb3VwIGlmIHByZXNlbnQsIG90aGVyd2lzZSBudWxsLlxuICAgICAqL1xuICAgIGdldCBmb3JtRGlyZWN0aXZlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcGFyZW50ID8gdGhpcy5fcGFyZW50LmZvcm1EaXJlY3RpdmUgOiBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKiBSZXR1cm5zIGFuIGFycmF5IHRoYXQgcmVwcmVzZW50cyB0aGUgcGF0aCBmcm9tIHRoZSB0b3AtbGV2ZWwgZm9ybSB0byB0aGlzIGNvbnRyb2wuXG4gICAgICogRWFjaCBpbmRleCBpcyB0aGUgc3RyaW5nIG5hbWUgb2YgdGhlIGNvbnRyb2wgb24gdGhhdCBsZXZlbC5cbiAgICAgKi9cbiAgICBnZXQgcGF0aCgpIHtcbiAgICAgICAgcmV0dXJuIGNvbnRyb2xQYXRoKHRoaXMubmFtZSA9PSBudWxsID8gdGhpcy5uYW1lIDogdGhpcy5uYW1lLnRvU3RyaW5nKCksIHRoaXMuX3BhcmVudCk7XG4gICAgfVxuICAgIF9jaGVja1BhcmVudFR5cGUoKSB7XG4gICAgICAgIGlmIChfaGFzSW52YWxpZFBhcmVudCh0aGlzLl9wYXJlbnQpICYmICh0eXBlb2YgbmdEZXZNb2RlID09PSAndW5kZWZpbmVkJyB8fCBuZ0Rldk1vZGUpKSB7XG4gICAgICAgICAgICB0aHJvdyBhcnJheVBhcmVudEV4Y2VwdGlvbigpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHN0YXRpYyB7IHRoaXMuybVmYWMgPSBpMC7Jtcm1bmdEZWNsYXJlRmFjdG9yeSh7IG1pblZlcnNpb246IFwiMTIuMC4wXCIsIHZlcnNpb246IFwiMTcuMy4xMlwiLCBuZ0ltcG9ydDogaTAsIHR5cGU6IEZvcm1BcnJheU5hbWUsIGRlcHM6IFt7IHRva2VuOiBDb250cm9sQ29udGFpbmVyLCBob3N0OiB0cnVlLCBvcHRpb25hbDogdHJ1ZSwgc2tpcFNlbGY6IHRydWUgfSwgeyB0b2tlbjogTkdfVkFMSURBVE9SUywgb3B0aW9uYWw6IHRydWUsIHNlbGY6IHRydWUgfSwgeyB0b2tlbjogTkdfQVNZTkNfVkFMSURBVE9SUywgb3B0aW9uYWw6IHRydWUsIHNlbGY6IHRydWUgfV0sIHRhcmdldDogaTAuybXJtUZhY3RvcnlUYXJnZXQuRGlyZWN0aXZlIH0pOyB9XG4gICAgc3RhdGljIHsgdGhpcy7JtWRpciA9IGkwLsm1ybVuZ0RlY2xhcmVEaXJlY3RpdmUoeyBtaW5WZXJzaW9uOiBcIjE0LjAuMFwiLCB2ZXJzaW9uOiBcIjE3LjMuMTJcIiwgdHlwZTogRm9ybUFycmF5TmFtZSwgc2VsZWN0b3I6IFwiW2Zvcm1BcnJheU5hbWVdXCIsIGlucHV0czogeyBuYW1lOiBbXCJmb3JtQXJyYXlOYW1lXCIsIFwibmFtZVwiXSB9LCBwcm92aWRlcnM6IFtmb3JtQXJyYXlOYW1lUHJvdmlkZXJdLCB1c2VzSW5oZXJpdGFuY2U6IHRydWUsIG5nSW1wb3J0OiBpMCB9KTsgfVxufVxuaTAuybXJtW5nRGVjbGFyZUNsYXNzTWV0YWRhdGEoeyBtaW5WZXJzaW9uOiBcIjEyLjAuMFwiLCB2ZXJzaW9uOiBcIjE3LjMuMTJcIiwgbmdJbXBvcnQ6IGkwLCB0eXBlOiBGb3JtQXJyYXlOYW1lLCBkZWNvcmF0b3JzOiBbe1xuICAgICAgICAgICAgdHlwZTogRGlyZWN0aXZlLFxuICAgICAgICAgICAgYXJnczogW3sgc2VsZWN0b3I6ICdbZm9ybUFycmF5TmFtZV0nLCBwcm92aWRlcnM6IFtmb3JtQXJyYXlOYW1lUHJvdmlkZXJdIH1dXG4gICAgICAgIH1dLCBjdG9yUGFyYW1ldGVyczogKCkgPT4gW3sgdHlwZTogQ29udHJvbENvbnRhaW5lciwgZGVjb3JhdG9yczogW3tcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogT3B0aW9uYWxcbiAgICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IEhvc3RcbiAgICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFNraXBTZWxmXG4gICAgICAgICAgICAgICAgfV0gfSwgeyB0eXBlOiB1bmRlZmluZWQsIGRlY29yYXRvcnM6IFt7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IE9wdGlvbmFsXG4gICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBTZWxmXG4gICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBJbmplY3QsXG4gICAgICAgICAgICAgICAgICAgIGFyZ3M6IFtOR19WQUxJREFUT1JTXVxuICAgICAgICAgICAgICAgIH1dIH0sIHsgdHlwZTogdW5kZWZpbmVkLCBkZWNvcmF0b3JzOiBbe1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBPcHRpb25hbFxuICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogU2VsZlxuICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogSW5qZWN0LFxuICAgICAgICAgICAgICAgICAgICBhcmdzOiBbTkdfQVNZTkNfVkFMSURBVE9SU11cbiAgICAgICAgICAgICAgICB9XSB9XSwgcHJvcERlY29yYXRvcnM6IHsgbmFtZTogW3tcbiAgICAgICAgICAgICAgICB0eXBlOiBJbnB1dCxcbiAgICAgICAgICAgICAgICBhcmdzOiBbJ2Zvcm1BcnJheU5hbWUnXVxuICAgICAgICAgICAgfV0gfSB9KTtcbmZ1bmN0aW9uIF9oYXNJbnZhbGlkUGFyZW50KHBhcmVudCkge1xuICAgIHJldHVybiAhKHBhcmVudCBpbnN0YW5jZW9mIEZvcm1Hcm91cE5hbWUpICYmICEocGFyZW50IGluc3RhbmNlb2YgRm9ybUdyb3VwRGlyZWN0aXZlKSAmJlxuICAgICAgICAhKHBhcmVudCBpbnN0YW5jZW9mIEZvcm1BcnJheU5hbWUpO1xufVxuXG5jb25zdCBjb250cm9sTmFtZUJpbmRpbmcgPSB7XG4gICAgcHJvdmlkZTogTmdDb250cm9sLFxuICAgIHVzZUV4aXN0aW5nOiBmb3J3YXJkUmVmKCgpID0+IEZvcm1Db250cm9sTmFtZSlcbn07XG4vKipcbiAqIEBkZXNjcmlwdGlvblxuICogU3luY3MgYSBgRm9ybUNvbnRyb2xgIGluIGFuIGV4aXN0aW5nIGBGb3JtR3JvdXBgIHRvIGEgZm9ybSBjb250cm9sXG4gKiBlbGVtZW50IGJ5IG5hbWUuXG4gKlxuICogQHNlZSBbUmVhY3RpdmUgRm9ybXMgR3VpZGVdKGd1aWRlL3JlYWN0aXZlLWZvcm1zKVxuICogQHNlZSB7QGxpbmsgRm9ybUNvbnRyb2x9XG4gKiBAc2VlIHtAbGluayBBYnN0cmFjdENvbnRyb2x9XG4gKlxuICogQHVzYWdlTm90ZXNcbiAqXG4gKiAjIyMgUmVnaXN0ZXIgYEZvcm1Db250cm9sYCB3aXRoaW4gYSBncm91cFxuICpcbiAqIFRoZSBmb2xsb3dpbmcgZXhhbXBsZSBzaG93cyBob3cgdG8gcmVnaXN0ZXIgbXVsdGlwbGUgZm9ybSBjb250cm9scyB3aXRoaW4gYSBmb3JtIGdyb3VwXG4gKiBhbmQgc2V0IHRoZWlyIHZhbHVlLlxuICpcbiAqIHtAZXhhbXBsZSBmb3Jtcy90cy9zaW1wbGVGb3JtR3JvdXAvc2ltcGxlX2Zvcm1fZ3JvdXBfZXhhbXBsZS50cyByZWdpb249J0NvbXBvbmVudCd9XG4gKlxuICogVG8gc2VlIGBmb3JtQ29udHJvbE5hbWVgIGV4YW1wbGVzIHdpdGggZGlmZmVyZW50IGZvcm0gY29udHJvbCB0eXBlcywgc2VlOlxuICpcbiAqICogUmFkaW8gYnV0dG9uczogYFJhZGlvQ29udHJvbFZhbHVlQWNjZXNzb3JgXG4gKiAqIFNlbGVjdHM6IGBTZWxlY3RDb250cm9sVmFsdWVBY2Nlc3NvcmBcbiAqXG4gKiAjIyMgVXNlIHdpdGggbmdNb2RlbCBpcyBkZXByZWNhdGVkXG4gKlxuICogU3VwcG9ydCBmb3IgdXNpbmcgdGhlIGBuZ01vZGVsYCBpbnB1dCBwcm9wZXJ0eSBhbmQgYG5nTW9kZWxDaGFuZ2VgIGV2ZW50IHdpdGggcmVhY3RpdmVcbiAqIGZvcm0gZGlyZWN0aXZlcyBoYXMgYmVlbiBkZXByZWNhdGVkIGluIEFuZ3VsYXIgdjYgYW5kIGlzIHNjaGVkdWxlZCBmb3IgcmVtb3ZhbCBpblxuICogYSBmdXR1cmUgdmVyc2lvbiBvZiBBbmd1bGFyLlxuICpcbiAqIEZvciBkZXRhaWxzLCBzZWUgW0RlcHJlY2F0ZWQgZmVhdHVyZXNdKGd1aWRlL2RlcHJlY2F0aW9ucyNuZ21vZGVsLXdpdGgtcmVhY3RpdmUtZm9ybXMpLlxuICpcbiAqIEBuZ01vZHVsZSBSZWFjdGl2ZUZvcm1zTW9kdWxlXG4gKiBAcHVibGljQXBpXG4gKi9cbmNsYXNzIEZvcm1Db250cm9sTmFtZSBleHRlbmRzIE5nQ29udHJvbCB7XG4gICAgLyoqXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICogVHJpZ2dlcnMgYSB3YXJuaW5nIGluIGRldiBtb2RlIHRoYXQgdGhpcyBpbnB1dCBzaG91bGQgbm90IGJlIHVzZWQgd2l0aCByZWFjdGl2ZSBmb3Jtcy5cbiAgICAgKi9cbiAgICBzZXQgaXNEaXNhYmxlZChpc0Rpc2FibGVkKSB7XG4gICAgICAgIGlmICh0eXBlb2YgbmdEZXZNb2RlID09PSAndW5kZWZpbmVkJyB8fCBuZ0Rldk1vZGUpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihkaXNhYmxlZEF0dHJXYXJuaW5nKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKiBTdGF0aWMgcHJvcGVydHkgdXNlZCB0byB0cmFjayB3aGV0aGVyIGFueSBuZ01vZGVsIHdhcm5pbmdzIGhhdmUgYmVlbiBzZW50IGFjcm9zc1xuICAgICAqIGFsbCBpbnN0YW5jZXMgb2YgRm9ybUNvbnRyb2xOYW1lLiBVc2VkIHRvIHN1cHBvcnQgd2FybmluZyBjb25maWcgb2YgXCJvbmNlXCIuXG4gICAgICpcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBzdGF0aWMgeyB0aGlzLl9uZ01vZGVsV2FybmluZ1NlbnRPbmNlID0gZmFsc2U7IH1cbiAgICBjb25zdHJ1Y3RvcihwYXJlbnQsIHZhbGlkYXRvcnMsIGFzeW5jVmFsaWRhdG9ycywgdmFsdWVBY2Nlc3NvcnMsIF9uZ01vZGVsV2FybmluZ0NvbmZpZykge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLl9uZ01vZGVsV2FybmluZ0NvbmZpZyA9IF9uZ01vZGVsV2FybmluZ0NvbmZpZztcbiAgICAgICAgdGhpcy5fYWRkZWQgPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAgICAgKiBUcmFja3MgdGhlIG5hbWUgb2YgdGhlIGBGb3JtQ29udHJvbGAgYm91bmQgdG8gdGhlIGRpcmVjdGl2ZS4gVGhlIG5hbWUgY29ycmVzcG9uZHNcbiAgICAgICAgICogdG8gYSBrZXkgaW4gdGhlIHBhcmVudCBgRm9ybUdyb3VwYCBvciBgRm9ybUFycmF5YC5cbiAgICAgICAgICogQWNjZXB0cyBhIG5hbWUgYXMgYSBzdHJpbmcgb3IgYSBudW1iZXIuXG4gICAgICAgICAqIFRoZSBuYW1lIGluIHRoZSBmb3JtIG9mIGEgc3RyaW5nIGlzIHVzZWZ1bCBmb3IgaW5kaXZpZHVhbCBmb3JtcyxcbiAgICAgICAgICogd2hpbGUgdGhlIG51bWVyaWNhbCBmb3JtIGFsbG93cyBmb3IgZm9ybSBjb250cm9scyB0byBiZSBib3VuZFxuICAgICAgICAgKiB0byBpbmRpY2VzIHdoZW4gaXRlcmF0aW5nIG92ZXIgY29udHJvbHMgaW4gYSBgRm9ybUFycmF5YC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubmFtZSA9IG51bGw7XG4gICAgICAgIC8qKiBAZGVwcmVjYXRlZCBhcyBvZiB2NiAqL1xuICAgICAgICB0aGlzLnVwZGF0ZSA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAgICAgKiBJbnN0YW5jZSBwcm9wZXJ0eSB1c2VkIHRvIHRyYWNrIHdoZXRoZXIgYW4gbmdNb2RlbCB3YXJuaW5nIGhhcyBiZWVuIHNlbnQgb3V0IGZvciB0aGlzXG4gICAgICAgICAqIHBhcnRpY3VsYXIgRm9ybUNvbnRyb2xOYW1lIGluc3RhbmNlLiBVc2VkIHRvIHN1cHBvcnQgd2FybmluZyBjb25maWcgb2YgXCJhbHdheXNcIi5cbiAgICAgICAgICpcbiAgICAgICAgICogQGludGVybmFsXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9uZ01vZGVsV2FybmluZ1NlbnQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fcGFyZW50ID0gcGFyZW50O1xuICAgICAgICB0aGlzLl9zZXRWYWxpZGF0b3JzKHZhbGlkYXRvcnMpO1xuICAgICAgICB0aGlzLl9zZXRBc3luY1ZhbGlkYXRvcnMoYXN5bmNWYWxpZGF0b3JzKTtcbiAgICAgICAgdGhpcy52YWx1ZUFjY2Vzc29yID0gc2VsZWN0VmFsdWVBY2Nlc3Nvcih0aGlzLCB2YWx1ZUFjY2Vzc29ycyk7XG4gICAgfVxuICAgIC8qKiBAbm9kb2MgKi9cbiAgICBuZ09uQ2hhbmdlcyhjaGFuZ2VzKSB7XG4gICAgICAgIGlmICghdGhpcy5fYWRkZWQpXG4gICAgICAgICAgICB0aGlzLl9zZXRVcENvbnRyb2woKTtcbiAgICAgICAgaWYgKGlzUHJvcGVydHlVcGRhdGVkKGNoYW5nZXMsIHRoaXMudmlld01vZGVsKSkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBuZ0Rldk1vZGUgPT09ICd1bmRlZmluZWQnIHx8IG5nRGV2TW9kZSkge1xuICAgICAgICAgICAgICAgIF9uZ01vZGVsV2FybmluZygnZm9ybUNvbnRyb2xOYW1lJywgRm9ybUNvbnRyb2xOYW1lLCB0aGlzLCB0aGlzLl9uZ01vZGVsV2FybmluZ0NvbmZpZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnZpZXdNb2RlbCA9IHRoaXMubW9kZWw7XG4gICAgICAgICAgICB0aGlzLmZvcm1EaXJlY3RpdmUudXBkYXRlTW9kZWwodGhpcywgdGhpcy5tb2RlbCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqIEBub2RvYyAqL1xuICAgIG5nT25EZXN0cm95KCkge1xuICAgICAgICBpZiAodGhpcy5mb3JtRGlyZWN0aXZlKSB7XG4gICAgICAgICAgICB0aGlzLmZvcm1EaXJlY3RpdmUucmVtb3ZlQ29udHJvbCh0aGlzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKiBTZXRzIHRoZSBuZXcgdmFsdWUgZm9yIHRoZSB2aWV3IG1vZGVsIGFuZCBlbWl0cyBhbiBgbmdNb2RlbENoYW5nZWAgZXZlbnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbmV3VmFsdWUgVGhlIG5ldyB2YWx1ZSBmb3IgdGhlIHZpZXcgbW9kZWwuXG4gICAgICovXG4gICAgdmlld1RvTW9kZWxVcGRhdGUobmV3VmFsdWUpIHtcbiAgICAgICAgdGhpcy52aWV3TW9kZWwgPSBuZXdWYWx1ZTtcbiAgICAgICAgdGhpcy51cGRhdGUuZW1pdChuZXdWYWx1ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqIFJldHVybnMgYW4gYXJyYXkgdGhhdCByZXByZXNlbnRzIHRoZSBwYXRoIGZyb20gdGhlIHRvcC1sZXZlbCBmb3JtIHRvIHRoaXMgY29udHJvbC5cbiAgICAgKiBFYWNoIGluZGV4IGlzIHRoZSBzdHJpbmcgbmFtZSBvZiB0aGUgY29udHJvbCBvbiB0aGF0IGxldmVsLlxuICAgICAqL1xuICAgIGdldCBwYXRoKCkge1xuICAgICAgICByZXR1cm4gY29udHJvbFBhdGgodGhpcy5uYW1lID09IG51bGwgPyB0aGlzLm5hbWUgOiB0aGlzLm5hbWUudG9TdHJpbmcoKSwgdGhpcy5fcGFyZW50KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICogVGhlIHRvcC1sZXZlbCBkaXJlY3RpdmUgZm9yIHRoaXMgZ3JvdXAgaWYgcHJlc2VudCwgb3RoZXJ3aXNlIG51bGwuXG4gICAgICovXG4gICAgZ2V0IGZvcm1EaXJlY3RpdmUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wYXJlbnQgPyB0aGlzLl9wYXJlbnQuZm9ybURpcmVjdGl2ZSA6IG51bGw7XG4gICAgfVxuICAgIF9jaGVja1BhcmVudFR5cGUoKSB7XG4gICAgICAgIGlmICh0eXBlb2YgbmdEZXZNb2RlID09PSAndW5kZWZpbmVkJyB8fCBuZ0Rldk1vZGUpIHtcbiAgICAgICAgICAgIGlmICghKHRoaXMuX3BhcmVudCBpbnN0YW5jZW9mIEZvcm1Hcm91cE5hbWUpICYmXG4gICAgICAgICAgICAgICAgdGhpcy5fcGFyZW50IGluc3RhbmNlb2YgQWJzdHJhY3RGb3JtR3JvdXBEaXJlY3RpdmUpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZ01vZGVsR3JvdXBFeGNlcHRpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCEodGhpcy5fcGFyZW50IGluc3RhbmNlb2YgRm9ybUdyb3VwTmFtZSkgJiZcbiAgICAgICAgICAgICAgICAhKHRoaXMuX3BhcmVudCBpbnN0YW5jZW9mIEZvcm1Hcm91cERpcmVjdGl2ZSkgJiZcbiAgICAgICAgICAgICAgICAhKHRoaXMuX3BhcmVudCBpbnN0YW5jZW9mIEZvcm1BcnJheU5hbWUpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgY29udHJvbFBhcmVudEV4Y2VwdGlvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIF9zZXRVcENvbnRyb2woKSB7XG4gICAgICAgIHRoaXMuX2NoZWNrUGFyZW50VHlwZSgpO1xuICAgICAgICB0aGlzLmNvbnRyb2wgPSB0aGlzLmZvcm1EaXJlY3RpdmUuYWRkQ29udHJvbCh0aGlzKTtcbiAgICAgICAgdGhpcy5fYWRkZWQgPSB0cnVlO1xuICAgIH1cbiAgICBzdGF0aWMgeyB0aGlzLsm1ZmFjID0gaTAuybXJtW5nRGVjbGFyZUZhY3RvcnkoeyBtaW5WZXJzaW9uOiBcIjEyLjAuMFwiLCB2ZXJzaW9uOiBcIjE3LjMuMTJcIiwgbmdJbXBvcnQ6IGkwLCB0eXBlOiBGb3JtQ29udHJvbE5hbWUsIGRlcHM6IFt7IHRva2VuOiBDb250cm9sQ29udGFpbmVyLCBob3N0OiB0cnVlLCBvcHRpb25hbDogdHJ1ZSwgc2tpcFNlbGY6IHRydWUgfSwgeyB0b2tlbjogTkdfVkFMSURBVE9SUywgb3B0aW9uYWw6IHRydWUsIHNlbGY6IHRydWUgfSwgeyB0b2tlbjogTkdfQVNZTkNfVkFMSURBVE9SUywgb3B0aW9uYWw6IHRydWUsIHNlbGY6IHRydWUgfSwgeyB0b2tlbjogTkdfVkFMVUVfQUNDRVNTT1IsIG9wdGlvbmFsOiB0cnVlLCBzZWxmOiB0cnVlIH0sIHsgdG9rZW46IE5HX01PREVMX1dJVEhfRk9STV9DT05UUk9MX1dBUk5JTkcsIG9wdGlvbmFsOiB0cnVlIH1dLCB0YXJnZXQ6IGkwLsm1ybVGYWN0b3J5VGFyZ2V0LkRpcmVjdGl2ZSB9KTsgfVxuICAgIHN0YXRpYyB7IHRoaXMuybVkaXIgPSBpMC7Jtcm1bmdEZWNsYXJlRGlyZWN0aXZlKHsgbWluVmVyc2lvbjogXCIxNC4wLjBcIiwgdmVyc2lvbjogXCIxNy4zLjEyXCIsIHR5cGU6IEZvcm1Db250cm9sTmFtZSwgc2VsZWN0b3I6IFwiW2Zvcm1Db250cm9sTmFtZV1cIiwgaW5wdXRzOiB7IG5hbWU6IFtcImZvcm1Db250cm9sTmFtZVwiLCBcIm5hbWVcIl0sIGlzRGlzYWJsZWQ6IFtcImRpc2FibGVkXCIsIFwiaXNEaXNhYmxlZFwiXSwgbW9kZWw6IFtcIm5nTW9kZWxcIiwgXCJtb2RlbFwiXSB9LCBvdXRwdXRzOiB7IHVwZGF0ZTogXCJuZ01vZGVsQ2hhbmdlXCIgfSwgcHJvdmlkZXJzOiBbY29udHJvbE5hbWVCaW5kaW5nXSwgdXNlc0luaGVyaXRhbmNlOiB0cnVlLCB1c2VzT25DaGFuZ2VzOiB0cnVlLCBuZ0ltcG9ydDogaTAgfSk7IH1cbn1cbmkwLsm1ybVuZ0RlY2xhcmVDbGFzc01ldGFkYXRhKHsgbWluVmVyc2lvbjogXCIxMi4wLjBcIiwgdmVyc2lvbjogXCIxNy4zLjEyXCIsIG5nSW1wb3J0OiBpMCwgdHlwZTogRm9ybUNvbnRyb2xOYW1lLCBkZWNvcmF0b3JzOiBbe1xuICAgICAgICAgICAgdHlwZTogRGlyZWN0aXZlLFxuICAgICAgICAgICAgYXJnczogW3sgc2VsZWN0b3I6ICdbZm9ybUNvbnRyb2xOYW1lXScsIHByb3ZpZGVyczogW2NvbnRyb2xOYW1lQmluZGluZ10gfV1cbiAgICAgICAgfV0sIGN0b3JQYXJhbWV0ZXJzOiAoKSA9PiBbeyB0eXBlOiBDb250cm9sQ29udGFpbmVyLCBkZWNvcmF0b3JzOiBbe1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBPcHRpb25hbFxuICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogSG9zdFxuICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogU2tpcFNlbGZcbiAgICAgICAgICAgICAgICB9XSB9LCB7IHR5cGU6IHVuZGVmaW5lZCwgZGVjb3JhdG9yczogW3tcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogT3B0aW9uYWxcbiAgICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFNlbGZcbiAgICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IEluamVjdCxcbiAgICAgICAgICAgICAgICAgICAgYXJnczogW05HX1ZBTElEQVRPUlNdXG4gICAgICAgICAgICAgICAgfV0gfSwgeyB0eXBlOiB1bmRlZmluZWQsIGRlY29yYXRvcnM6IFt7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IE9wdGlvbmFsXG4gICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBTZWxmXG4gICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBJbmplY3QsXG4gICAgICAgICAgICAgICAgICAgIGFyZ3M6IFtOR19BU1lOQ19WQUxJREFUT1JTXVxuICAgICAgICAgICAgICAgIH1dIH0sIHsgdHlwZTogdW5kZWZpbmVkLCBkZWNvcmF0b3JzOiBbe1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBPcHRpb25hbFxuICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogU2VsZlxuICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogSW5qZWN0LFxuICAgICAgICAgICAgICAgICAgICBhcmdzOiBbTkdfVkFMVUVfQUNDRVNTT1JdXG4gICAgICAgICAgICAgICAgfV0gfSwgeyB0eXBlOiB1bmRlZmluZWQsIGRlY29yYXRvcnM6IFt7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IE9wdGlvbmFsXG4gICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBJbmplY3QsXG4gICAgICAgICAgICAgICAgICAgIGFyZ3M6IFtOR19NT0RFTF9XSVRIX0ZPUk1fQ09OVFJPTF9XQVJOSU5HXVxuICAgICAgICAgICAgICAgIH1dIH1dLCBwcm9wRGVjb3JhdG9yczogeyBuYW1lOiBbe1xuICAgICAgICAgICAgICAgIHR5cGU6IElucHV0LFxuICAgICAgICAgICAgICAgIGFyZ3M6IFsnZm9ybUNvbnRyb2xOYW1lJ11cbiAgICAgICAgICAgIH1dLCBpc0Rpc2FibGVkOiBbe1xuICAgICAgICAgICAgICAgIHR5cGU6IElucHV0LFxuICAgICAgICAgICAgICAgIGFyZ3M6IFsnZGlzYWJsZWQnXVxuICAgICAgICAgICAgfV0sIG1vZGVsOiBbe1xuICAgICAgICAgICAgICAgIHR5cGU6IElucHV0LFxuICAgICAgICAgICAgICAgIGFyZ3M6IFsnbmdNb2RlbCddXG4gICAgICAgICAgICB9XSwgdXBkYXRlOiBbe1xuICAgICAgICAgICAgICAgIHR5cGU6IE91dHB1dCxcbiAgICAgICAgICAgICAgICBhcmdzOiBbJ25nTW9kZWxDaGFuZ2UnXVxuICAgICAgICAgICAgfV0gfSB9KTtcblxuY29uc3QgU0VMRUNUX1ZBTFVFX0FDQ0VTU09SID0ge1xuICAgIHByb3ZpZGU6IE5HX1ZBTFVFX0FDQ0VTU09SLFxuICAgIHVzZUV4aXN0aW5nOiBmb3J3YXJkUmVmKCgpID0+IFNlbGVjdENvbnRyb2xWYWx1ZUFjY2Vzc29yKSxcbiAgICBtdWx0aTogdHJ1ZVxufTtcbmZ1bmN0aW9uIF9idWlsZFZhbHVlU3RyaW5nJDEoaWQsIHZhbHVlKSB7XG4gICAgaWYgKGlkID09IG51bGwpXG4gICAgICAgIHJldHVybiBgJHt2YWx1ZX1gO1xuICAgIGlmICh2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnKVxuICAgICAgICB2YWx1ZSA9ICdPYmplY3QnO1xuICAgIHJldHVybiBgJHtpZH06ICR7dmFsdWV9YC5zbGljZSgwLCA1MCk7XG59XG5mdW5jdGlvbiBfZXh0cmFjdElkJDEodmFsdWVTdHJpbmcpIHtcbiAgICByZXR1cm4gdmFsdWVTdHJpbmcuc3BsaXQoJzonKVswXTtcbn1cbi8qKlxuICogQGRlc2NyaXB0aW9uXG4gKiBUaGUgYENvbnRyb2xWYWx1ZUFjY2Vzc29yYCBmb3Igd3JpdGluZyBzZWxlY3QgY29udHJvbCB2YWx1ZXMgYW5kIGxpc3RlbmluZyB0byBzZWxlY3QgY29udHJvbFxuICogY2hhbmdlcy4gVGhlIHZhbHVlIGFjY2Vzc29yIGlzIHVzZWQgYnkgdGhlIGBGb3JtQ29udHJvbERpcmVjdGl2ZWAsIGBGb3JtQ29udHJvbE5hbWVgLCBhbmRcbiAqIGBOZ01vZGVsYCBkaXJlY3RpdmVzLlxuICpcbiAqIEB1c2FnZU5vdGVzXG4gKlxuICogIyMjIFVzaW5nIHNlbGVjdCBjb250cm9scyBpbiBhIHJlYWN0aXZlIGZvcm1cbiAqXG4gKiBUaGUgZm9sbG93aW5nIGV4YW1wbGVzIHNob3cgaG93IHRvIHVzZSBhIHNlbGVjdCBjb250cm9sIGluIGEgcmVhY3RpdmUgZm9ybS5cbiAqXG4gKiB7QGV4YW1wbGUgZm9ybXMvdHMvcmVhY3RpdmVTZWxlY3RDb250cm9sL3JlYWN0aXZlX3NlbGVjdF9jb250cm9sX2V4YW1wbGUudHMgcmVnaW9uPSdDb21wb25lbnQnfVxuICpcbiAqICMjIyBVc2luZyBzZWxlY3QgY29udHJvbHMgaW4gYSB0ZW1wbGF0ZS1kcml2ZW4gZm9ybVxuICpcbiAqIFRvIHVzZSBhIHNlbGVjdCBpbiBhIHRlbXBsYXRlLWRyaXZlbiBmb3JtLCBzaW1wbHkgYWRkIGFuIGBuZ01vZGVsYCBhbmQgYSBgbmFtZWBcbiAqIGF0dHJpYnV0ZSB0byB0aGUgbWFpbiBgPHNlbGVjdD5gIHRhZy5cbiAqXG4gKiB7QGV4YW1wbGUgZm9ybXMvdHMvc2VsZWN0Q29udHJvbC9zZWxlY3RfY29udHJvbF9leGFtcGxlLnRzIHJlZ2lvbj0nQ29tcG9uZW50J31cbiAqXG4gKiAjIyMgQ3VzdG9taXppbmcgb3B0aW9uIHNlbGVjdGlvblxuICpcbiAqIEFuZ3VsYXIgdXNlcyBvYmplY3QgaWRlbnRpdHkgdG8gc2VsZWN0IG9wdGlvbi4gSXQncyBwb3NzaWJsZSBmb3IgdGhlIGlkZW50aXRpZXMgb2YgaXRlbXNcbiAqIHRvIGNoYW5nZSB3aGlsZSB0aGUgZGF0YSBkb2VzIG5vdC4gVGhpcyBjYW4gaGFwcGVuLCBmb3IgZXhhbXBsZSwgaWYgdGhlIGl0ZW1zIGFyZSBwcm9kdWNlZFxuICogZnJvbSBhbiBSUEMgdG8gdGhlIHNlcnZlciwgYW5kIHRoYXQgUlBDIGlzIHJlLXJ1bi4gRXZlbiBpZiB0aGUgZGF0YSBoYXNuJ3QgY2hhbmdlZCwgdGhlXG4gKiBzZWNvbmQgcmVzcG9uc2Ugd2lsbCBwcm9kdWNlIG9iamVjdHMgd2l0aCBkaWZmZXJlbnQgaWRlbnRpdGllcy5cbiAqXG4gKiBUbyBjdXN0b21pemUgdGhlIGRlZmF1bHQgb3B0aW9uIGNvbXBhcmlzb24gYWxnb3JpdGhtLCBgPHNlbGVjdD5gIHN1cHBvcnRzIGBjb21wYXJlV2l0aGAgaW5wdXQuXG4gKiBgY29tcGFyZVdpdGhgIHRha2VzIGEgKipmdW5jdGlvbioqIHdoaWNoIGhhcyB0d28gYXJndW1lbnRzOiBgb3B0aW9uMWAgYW5kIGBvcHRpb24yYC5cbiAqIElmIGBjb21wYXJlV2l0aGAgaXMgZ2l2ZW4sIEFuZ3VsYXIgc2VsZWN0cyBvcHRpb24gYnkgdGhlIHJldHVybiB2YWx1ZSBvZiB0aGUgZnVuY3Rpb24uXG4gKlxuICogYGBgdHNcbiAqIGNvbnN0IHNlbGVjdGVkQ291bnRyaWVzQ29udHJvbCA9IG5ldyBGb3JtQ29udHJvbCgpO1xuICogYGBgXG4gKlxuICogYGBgXG4gKiA8c2VsZWN0IFtjb21wYXJlV2l0aF09XCJjb21wYXJlRm5cIiAgW2Zvcm1Db250cm9sXT1cInNlbGVjdGVkQ291bnRyaWVzQ29udHJvbFwiPlxuICogICAgIDxvcHRpb24gKm5nRm9yPVwibGV0IGNvdW50cnkgb2YgY291bnRyaWVzXCIgW25nVmFsdWVdPVwiY291bnRyeVwiPlxuICogICAgICAgICB7e2NvdW50cnkubmFtZX19XG4gKiAgICAgPC9vcHRpb24+XG4gKiA8L3NlbGVjdD5cbiAqXG4gKiBjb21wYXJlRm4oYzE6IENvdW50cnksIGMyOiBDb3VudHJ5KTogYm9vbGVhbiB7XG4gKiAgICAgcmV0dXJuIGMxICYmIGMyID8gYzEuaWQgPT09IGMyLmlkIDogYzEgPT09IGMyO1xuICogfVxuICogYGBgXG4gKlxuICogKipOb3RlOioqIFdlIGxpc3RlbiB0byB0aGUgJ2NoYW5nZScgZXZlbnQgYmVjYXVzZSAnaW5wdXQnIGV2ZW50cyBhcmVuJ3QgZmlyZWRcbiAqIGZvciBzZWxlY3RzIGluIElFLCBzZWU6XG4gKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvSFRNTEVsZW1lbnQvaW5wdXRfZXZlbnQjYnJvd3Nlcl9jb21wYXRpYmlsaXR5XG4gKlxuICogQG5nTW9kdWxlIFJlYWN0aXZlRm9ybXNNb2R1bGVcbiAqIEBuZ01vZHVsZSBGb3Jtc01vZHVsZVxuICogQHB1YmxpY0FwaVxuICovXG5jbGFzcyBTZWxlY3RDb250cm9sVmFsdWVBY2Nlc3NvciBleHRlbmRzIEJ1aWx0SW5Db250cm9sVmFsdWVBY2Nlc3NvciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgdGhpcy5fb3B0aW9uTWFwID0gbmV3IE1hcCgpO1xuICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgIHRoaXMuX2lkQ291bnRlciA9IDA7XG4gICAgICAgIHRoaXMuX2NvbXBhcmVXaXRoID0gT2JqZWN0LmlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKiBUcmFja3MgdGhlIG9wdGlvbiBjb21wYXJpc29uIGFsZ29yaXRobSBmb3IgdHJhY2tpbmcgaWRlbnRpdGllcyB3aGVuXG4gICAgICogY2hlY2tpbmcgZm9yIGNoYW5nZXMuXG4gICAgICovXG4gICAgc2V0IGNvbXBhcmVXaXRoKGZuKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicgJiYgKHR5cGVvZiBuZ0Rldk1vZGUgPT09ICd1bmRlZmluZWQnIHx8IG5nRGV2TW9kZSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyDJtVJ1bnRpbWVFcnJvcigxMjAxIC8qIFJ1bnRpbWVFcnJvckNvZGUuQ09NUEFSRVdJVEhfTk9UX0FfRk4gKi8sIGBjb21wYXJlV2l0aCBtdXN0IGJlIGEgZnVuY3Rpb24sIGJ1dCByZWNlaXZlZCAke0pTT04uc3RyaW5naWZ5KGZuKX1gKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9jb21wYXJlV2l0aCA9IGZuO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBcInZhbHVlXCIgcHJvcGVydHkgb24gdGhlIHNlbGVjdCBlbGVtZW50LlxuICAgICAqIEBub2RvY1xuICAgICAqL1xuICAgIHdyaXRlVmFsdWUodmFsdWUpIHtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICBjb25zdCBpZCA9IHRoaXMuX2dldE9wdGlvbklkKHZhbHVlKTtcbiAgICAgICAgY29uc3QgdmFsdWVTdHJpbmcgPSBfYnVpbGRWYWx1ZVN0cmluZyQxKGlkLCB2YWx1ZSk7XG4gICAgICAgIHRoaXMuc2V0UHJvcGVydHkoJ3ZhbHVlJywgdmFsdWVTdHJpbmcpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWdpc3RlcnMgYSBmdW5jdGlvbiBjYWxsZWQgd2hlbiB0aGUgY29udHJvbCB2YWx1ZSBjaGFuZ2VzLlxuICAgICAqIEBub2RvY1xuICAgICAqL1xuICAgIHJlZ2lzdGVyT25DaGFuZ2UoZm4pIHtcbiAgICAgICAgdGhpcy5vbkNoYW5nZSA9ICh2YWx1ZVN0cmluZykgPT4ge1xuICAgICAgICAgICAgdGhpcy52YWx1ZSA9IHRoaXMuX2dldE9wdGlvblZhbHVlKHZhbHVlU3RyaW5nKTtcbiAgICAgICAgICAgIGZuKHRoaXMudmFsdWUpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICAvKiogQGludGVybmFsICovXG4gICAgX3JlZ2lzdGVyT3B0aW9uKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMuX2lkQ291bnRlcisrKS50b1N0cmluZygpO1xuICAgIH1cbiAgICAvKiogQGludGVybmFsICovXG4gICAgX2dldE9wdGlvbklkKHZhbHVlKSB7XG4gICAgICAgIGZvciAoY29uc3QgaWQgb2YgdGhpcy5fb3B0aW9uTWFwLmtleXMoKSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2NvbXBhcmVXaXRoKHRoaXMuX29wdGlvbk1hcC5nZXQoaWQpLCB2YWx1ZSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGlkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICAvKiogQGludGVybmFsICovXG4gICAgX2dldE9wdGlvblZhbHVlKHZhbHVlU3RyaW5nKSB7XG4gICAgICAgIGNvbnN0IGlkID0gX2V4dHJhY3RJZCQxKHZhbHVlU3RyaW5nKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX29wdGlvbk1hcC5oYXMoaWQpID8gdGhpcy5fb3B0aW9uTWFwLmdldChpZCkgOiB2YWx1ZVN0cmluZztcbiAgICB9XG4gICAgc3RhdGljIHsgdGhpcy7JtWZhYyA9IGkwLsm1ybVuZ0RlY2xhcmVGYWN0b3J5KHsgbWluVmVyc2lvbjogXCIxMi4wLjBcIiwgdmVyc2lvbjogXCIxNy4zLjEyXCIsIG5nSW1wb3J0OiBpMCwgdHlwZTogU2VsZWN0Q29udHJvbFZhbHVlQWNjZXNzb3IsIGRlcHM6IG51bGwsIHRhcmdldDogaTAuybXJtUZhY3RvcnlUYXJnZXQuRGlyZWN0aXZlIH0pOyB9XG4gICAgc3RhdGljIHsgdGhpcy7JtWRpciA9IGkwLsm1ybVuZ0RlY2xhcmVEaXJlY3RpdmUoeyBtaW5WZXJzaW9uOiBcIjE0LjAuMFwiLCB2ZXJzaW9uOiBcIjE3LjMuMTJcIiwgdHlwZTogU2VsZWN0Q29udHJvbFZhbHVlQWNjZXNzb3IsIHNlbGVjdG9yOiBcInNlbGVjdDpub3QoW211bHRpcGxlXSlbZm9ybUNvbnRyb2xOYW1lXSxzZWxlY3Q6bm90KFttdWx0aXBsZV0pW2Zvcm1Db250cm9sXSxzZWxlY3Q6bm90KFttdWx0aXBsZV0pW25nTW9kZWxdXCIsIGlucHV0czogeyBjb21wYXJlV2l0aDogXCJjb21wYXJlV2l0aFwiIH0sIGhvc3Q6IHsgbGlzdGVuZXJzOiB7IFwiY2hhbmdlXCI6IFwib25DaGFuZ2UoJGV2ZW50LnRhcmdldC52YWx1ZSlcIiwgXCJibHVyXCI6IFwib25Ub3VjaGVkKClcIiB9IH0sIHByb3ZpZGVyczogW1NFTEVDVF9WQUxVRV9BQ0NFU1NPUl0sIHVzZXNJbmhlcml0YW5jZTogdHJ1ZSwgbmdJbXBvcnQ6IGkwIH0pOyB9XG59XG5pMC7Jtcm1bmdEZWNsYXJlQ2xhc3NNZXRhZGF0YSh7IG1pblZlcnNpb246IFwiMTIuMC4wXCIsIHZlcnNpb246IFwiMTcuMy4xMlwiLCBuZ0ltcG9ydDogaTAsIHR5cGU6IFNlbGVjdENvbnRyb2xWYWx1ZUFjY2Vzc29yLCBkZWNvcmF0b3JzOiBbe1xuICAgICAgICAgICAgdHlwZTogRGlyZWN0aXZlLFxuICAgICAgICAgICAgYXJnczogW3tcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdzZWxlY3Q6bm90KFttdWx0aXBsZV0pW2Zvcm1Db250cm9sTmFtZV0sc2VsZWN0Om5vdChbbXVsdGlwbGVdKVtmb3JtQ29udHJvbF0sc2VsZWN0Om5vdChbbXVsdGlwbGVdKVtuZ01vZGVsXScsXG4gICAgICAgICAgICAgICAgICAgIGhvc3Q6IHsgJyhjaGFuZ2UpJzogJ29uQ2hhbmdlKCRldmVudC50YXJnZXQudmFsdWUpJywgJyhibHVyKSc6ICdvblRvdWNoZWQoKScgfSxcbiAgICAgICAgICAgICAgICAgICAgcHJvdmlkZXJzOiBbU0VMRUNUX1ZBTFVFX0FDQ0VTU09SXVxuICAgICAgICAgICAgICAgIH1dXG4gICAgICAgIH1dLCBwcm9wRGVjb3JhdG9yczogeyBjb21wYXJlV2l0aDogW3tcbiAgICAgICAgICAgICAgICB0eXBlOiBJbnB1dFxuICAgICAgICAgICAgfV0gfSB9KTtcbi8qKlxuICogQGRlc2NyaXB0aW9uXG4gKiBNYXJrcyBgPG9wdGlvbj5gIGFzIGR5bmFtaWMsIHNvIEFuZ3VsYXIgY2FuIGJlIG5vdGlmaWVkIHdoZW4gb3B0aW9ucyBjaGFuZ2UuXG4gKlxuICogQHNlZSB7QGxpbmsgU2VsZWN0Q29udHJvbFZhbHVlQWNjZXNzb3J9XG4gKlxuICogQG5nTW9kdWxlIFJlYWN0aXZlRm9ybXNNb2R1bGVcbiAqIEBuZ01vZHVsZSBGb3Jtc01vZHVsZVxuICogQHB1YmxpY0FwaVxuICovXG5jbGFzcyBOZ1NlbGVjdE9wdGlvbiB7XG4gICAgY29uc3RydWN0b3IoX2VsZW1lbnQsIF9yZW5kZXJlciwgX3NlbGVjdCkge1xuICAgICAgICB0aGlzLl9lbGVtZW50ID0gX2VsZW1lbnQ7XG4gICAgICAgIHRoaXMuX3JlbmRlcmVyID0gX3JlbmRlcmVyO1xuICAgICAgICB0aGlzLl9zZWxlY3QgPSBfc2VsZWN0O1xuICAgICAgICBpZiAodGhpcy5fc2VsZWN0KVxuICAgICAgICAgICAgdGhpcy5pZCA9IHRoaXMuX3NlbGVjdC5fcmVnaXN0ZXJPcHRpb24oKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICogVHJhY2tzIHRoZSB2YWx1ZSBib3VuZCB0byB0aGUgb3B0aW9uIGVsZW1lbnQuIFVubGlrZSB0aGUgdmFsdWUgYmluZGluZyxcbiAgICAgKiBuZ1ZhbHVlIHN1cHBvcnRzIGJpbmRpbmcgdG8gb2JqZWN0cy5cbiAgICAgKi9cbiAgICBzZXQgbmdWYWx1ZSh2YWx1ZSkge1xuICAgICAgICBpZiAodGhpcy5fc2VsZWN0ID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRoaXMuX3NlbGVjdC5fb3B0aW9uTWFwLnNldCh0aGlzLmlkLCB2YWx1ZSk7XG4gICAgICAgIHRoaXMuX3NldEVsZW1lbnRWYWx1ZShfYnVpbGRWYWx1ZVN0cmluZyQxKHRoaXMuaWQsIHZhbHVlKSk7XG4gICAgICAgIHRoaXMuX3NlbGVjdC53cml0ZVZhbHVlKHRoaXMuX3NlbGVjdC52YWx1ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqIFRyYWNrcyBzaW1wbGUgc3RyaW5nIHZhbHVlcyBib3VuZCB0byB0aGUgb3B0aW9uIGVsZW1lbnQuXG4gICAgICogRm9yIG9iamVjdHMsIHVzZSB0aGUgYG5nVmFsdWVgIGlucHV0IGJpbmRpbmcuXG4gICAgICovXG4gICAgc2V0IHZhbHVlKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuX3NldEVsZW1lbnRWYWx1ZSh2YWx1ZSk7XG4gICAgICAgIGlmICh0aGlzLl9zZWxlY3QpXG4gICAgICAgICAgICB0aGlzLl9zZWxlY3Qud3JpdGVWYWx1ZSh0aGlzLl9zZWxlY3QudmFsdWUpO1xuICAgIH1cbiAgICAvKiogQGludGVybmFsICovXG4gICAgX3NldEVsZW1lbnRWYWx1ZSh2YWx1ZSkge1xuICAgICAgICB0aGlzLl9yZW5kZXJlci5zZXRQcm9wZXJ0eSh0aGlzLl9lbGVtZW50Lm5hdGl2ZUVsZW1lbnQsICd2YWx1ZScsIHZhbHVlKTtcbiAgICB9XG4gICAgLyoqIEBub2RvYyAqL1xuICAgIG5nT25EZXN0cm95KCkge1xuICAgICAgICBpZiAodGhpcy5fc2VsZWN0KSB7XG4gICAgICAgICAgICB0aGlzLl9zZWxlY3QuX29wdGlvbk1hcC5kZWxldGUodGhpcy5pZCk7XG4gICAgICAgICAgICB0aGlzLl9zZWxlY3Qud3JpdGVWYWx1ZSh0aGlzLl9zZWxlY3QudmFsdWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHN0YXRpYyB7IHRoaXMuybVmYWMgPSBpMC7Jtcm1bmdEZWNsYXJlRmFjdG9yeSh7IG1pblZlcnNpb246IFwiMTIuMC4wXCIsIHZlcnNpb246IFwiMTcuMy4xMlwiLCBuZ0ltcG9ydDogaTAsIHR5cGU6IE5nU2VsZWN0T3B0aW9uLCBkZXBzOiBbeyB0b2tlbjogaTAuRWxlbWVudFJlZiB9LCB7IHRva2VuOiBpMC5SZW5kZXJlcjIgfSwgeyB0b2tlbjogU2VsZWN0Q29udHJvbFZhbHVlQWNjZXNzb3IsIGhvc3Q6IHRydWUsIG9wdGlvbmFsOiB0cnVlIH1dLCB0YXJnZXQ6IGkwLsm1ybVGYWN0b3J5VGFyZ2V0LkRpcmVjdGl2ZSB9KTsgfVxuICAgIHN0YXRpYyB7IHRoaXMuybVkaXIgPSBpMC7Jtcm1bmdEZWNsYXJlRGlyZWN0aXZlKHsgbWluVmVyc2lvbjogXCIxNC4wLjBcIiwgdmVyc2lvbjogXCIxNy4zLjEyXCIsIHR5cGU6IE5nU2VsZWN0T3B0aW9uLCBzZWxlY3RvcjogXCJvcHRpb25cIiwgaW5wdXRzOiB7IG5nVmFsdWU6IFwibmdWYWx1ZVwiLCB2YWx1ZTogXCJ2YWx1ZVwiIH0sIG5nSW1wb3J0OiBpMCB9KTsgfVxufVxuaTAuybXJtW5nRGVjbGFyZUNsYXNzTWV0YWRhdGEoeyBtaW5WZXJzaW9uOiBcIjEyLjAuMFwiLCB2ZXJzaW9uOiBcIjE3LjMuMTJcIiwgbmdJbXBvcnQ6IGkwLCB0eXBlOiBOZ1NlbGVjdE9wdGlvbiwgZGVjb3JhdG9yczogW3tcbiAgICAgICAgICAgIHR5cGU6IERpcmVjdGl2ZSxcbiAgICAgICAgICAgIGFyZ3M6IFt7IHNlbGVjdG9yOiAnb3B0aW9uJyB9XVxuICAgICAgICB9XSwgY3RvclBhcmFtZXRlcnM6ICgpID0+IFt7IHR5cGU6IGkwLkVsZW1lbnRSZWYgfSwgeyB0eXBlOiBpMC5SZW5kZXJlcjIgfSwgeyB0eXBlOiBTZWxlY3RDb250cm9sVmFsdWVBY2Nlc3NvciwgZGVjb3JhdG9yczogW3tcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogT3B0aW9uYWxcbiAgICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IEhvc3RcbiAgICAgICAgICAgICAgICB9XSB9XSwgcHJvcERlY29yYXRvcnM6IHsgbmdWYWx1ZTogW3tcbiAgICAgICAgICAgICAgICB0eXBlOiBJbnB1dCxcbiAgICAgICAgICAgICAgICBhcmdzOiBbJ25nVmFsdWUnXVxuICAgICAgICAgICAgfV0sIHZhbHVlOiBbe1xuICAgICAgICAgICAgICAgIHR5cGU6IElucHV0LFxuICAgICAgICAgICAgICAgIGFyZ3M6IFsndmFsdWUnXVxuICAgICAgICAgICAgfV0gfSB9KTtcblxuY29uc3QgU0VMRUNUX01VTFRJUExFX1ZBTFVFX0FDQ0VTU09SID0ge1xuICAgIHByb3ZpZGU6IE5HX1ZBTFVFX0FDQ0VTU09SLFxuICAgIHVzZUV4aXN0aW5nOiBmb3J3YXJkUmVmKCgpID0+IFNlbGVjdE11bHRpcGxlQ29udHJvbFZhbHVlQWNjZXNzb3IpLFxuICAgIG11bHRpOiB0cnVlXG59O1xuZnVuY3Rpb24gX2J1aWxkVmFsdWVTdHJpbmcoaWQsIHZhbHVlKSB7XG4gICAgaWYgKGlkID09IG51bGwpXG4gICAgICAgIHJldHVybiBgJHt2YWx1ZX1gO1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKVxuICAgICAgICB2YWx1ZSA9IGAnJHt2YWx1ZX0nYDtcbiAgICBpZiAodmFsdWUgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JylcbiAgICAgICAgdmFsdWUgPSAnT2JqZWN0JztcbiAgICByZXR1cm4gYCR7aWR9OiAke3ZhbHVlfWAuc2xpY2UoMCwgNTApO1xufVxuZnVuY3Rpb24gX2V4dHJhY3RJZCh2YWx1ZVN0cmluZykge1xuICAgIHJldHVybiB2YWx1ZVN0cmluZy5zcGxpdCgnOicpWzBdO1xufVxuLyoqIE1vY2sgaW50ZXJmYWNlIGZvciBIVE1MQ29sbGVjdGlvbiAqL1xuY2xhc3MgSFRNTENvbGxlY3Rpb24ge1xufVxuLyoqXG4gKiBAZGVzY3JpcHRpb25cbiAqIFRoZSBgQ29udHJvbFZhbHVlQWNjZXNzb3JgIGZvciB3cml0aW5nIG11bHRpLXNlbGVjdCBjb250cm9sIHZhbHVlcyBhbmQgbGlzdGVuaW5nIHRvIG11bHRpLXNlbGVjdFxuICogY29udHJvbCBjaGFuZ2VzLiBUaGUgdmFsdWUgYWNjZXNzb3IgaXMgdXNlZCBieSB0aGUgYEZvcm1Db250cm9sRGlyZWN0aXZlYCwgYEZvcm1Db250cm9sTmFtZWAsIGFuZFxuICogYE5nTW9kZWxgIGRpcmVjdGl2ZXMuXG4gKlxuICogQHNlZSB7QGxpbmsgU2VsZWN0Q29udHJvbFZhbHVlQWNjZXNzb3J9XG4gKlxuICogQHVzYWdlTm90ZXNcbiAqXG4gKiAjIyMgVXNpbmcgYSBtdWx0aS1zZWxlY3QgY29udHJvbFxuICpcbiAqIFRoZSBmb2xsb3cgZXhhbXBsZSBzaG93cyB5b3UgaG93IHRvIHVzZSBhIG11bHRpLXNlbGVjdCBjb250cm9sIHdpdGggYSByZWFjdGl2ZSBmb3JtLlxuICpcbiAqIGBgYHRzXG4gKiBjb25zdCBjb3VudHJ5Q29udHJvbCA9IG5ldyBGb3JtQ29udHJvbCgpO1xuICogYGBgXG4gKlxuICogYGBgXG4gKiA8c2VsZWN0IG11bHRpcGxlIG5hbWU9XCJjb3VudHJpZXNcIiBbZm9ybUNvbnRyb2xdPVwiY291bnRyeUNvbnRyb2xcIj5cbiAqICAgPG9wdGlvbiAqbmdGb3I9XCJsZXQgY291bnRyeSBvZiBjb3VudHJpZXNcIiBbbmdWYWx1ZV09XCJjb3VudHJ5XCI+XG4gKiAgICAge3sgY291bnRyeS5uYW1lIH19XG4gKiAgIDwvb3B0aW9uPlxuICogPC9zZWxlY3Q+XG4gKiBgYGBcbiAqXG4gKiAjIyMgQ3VzdG9taXppbmcgb3B0aW9uIHNlbGVjdGlvblxuICpcbiAqIFRvIGN1c3RvbWl6ZSB0aGUgZGVmYXVsdCBvcHRpb24gY29tcGFyaXNvbiBhbGdvcml0aG0sIGA8c2VsZWN0PmAgc3VwcG9ydHMgYGNvbXBhcmVXaXRoYCBpbnB1dC5cbiAqIFNlZSB0aGUgYFNlbGVjdENvbnRyb2xWYWx1ZUFjY2Vzc29yYCBmb3IgdXNhZ2UuXG4gKlxuICogQG5nTW9kdWxlIFJlYWN0aXZlRm9ybXNNb2R1bGVcbiAqIEBuZ01vZHVsZSBGb3Jtc01vZHVsZVxuICogQHB1YmxpY0FwaVxuICovXG5jbGFzcyBTZWxlY3RNdWx0aXBsZUNvbnRyb2xWYWx1ZUFjY2Vzc29yIGV4dGVuZHMgQnVpbHRJbkNvbnRyb2xWYWx1ZUFjY2Vzc29yIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICB0aGlzLl9vcHRpb25NYXAgPSBuZXcgTWFwKCk7XG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgdGhpcy5faWRDb3VudGVyID0gMDtcbiAgICAgICAgdGhpcy5fY29tcGFyZVdpdGggPSBPYmplY3QuaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqIFRyYWNrcyB0aGUgb3B0aW9uIGNvbXBhcmlzb24gYWxnb3JpdGhtIGZvciB0cmFja2luZyBpZGVudGl0aWVzIHdoZW5cbiAgICAgKiBjaGVja2luZyBmb3IgY2hhbmdlcy5cbiAgICAgKi9cbiAgICBzZXQgY29tcGFyZVdpdGgoZm4pIHtcbiAgICAgICAgaWYgKHR5cGVvZiBmbiAhPT0gJ2Z1bmN0aW9uJyAmJiAodHlwZW9mIG5nRGV2TW9kZSA9PT0gJ3VuZGVmaW5lZCcgfHwgbmdEZXZNb2RlKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IMm1UnVudGltZUVycm9yKDEyMDEgLyogUnVudGltZUVycm9yQ29kZS5DT01QQVJFV0lUSF9OT1RfQV9GTiAqLywgYGNvbXBhcmVXaXRoIG11c3QgYmUgYSBmdW5jdGlvbiwgYnV0IHJlY2VpdmVkICR7SlNPTi5zdHJpbmdpZnkoZm4pfWApO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2NvbXBhcmVXaXRoID0gZm47XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIFwidmFsdWVcIiBwcm9wZXJ0eSBvbiBvbmUgb3Igb2YgbW9yZSBvZiB0aGUgc2VsZWN0J3Mgb3B0aW9ucy5cbiAgICAgKiBAbm9kb2NcbiAgICAgKi9cbiAgICB3cml0ZVZhbHVlKHZhbHVlKSB7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgbGV0IG9wdGlvblNlbGVjdGVkU3RhdGVTZXR0ZXI7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgLy8gY29udmVydCB2YWx1ZXMgdG8gaWRzXG4gICAgICAgICAgICBjb25zdCBpZHMgPSB2YWx1ZS5tYXAoKHYpID0+IHRoaXMuX2dldE9wdGlvbklkKHYpKTtcbiAgICAgICAgICAgIG9wdGlvblNlbGVjdGVkU3RhdGVTZXR0ZXIgPSAob3B0LCBvKSA9PiB7XG4gICAgICAgICAgICAgICAgb3B0Ll9zZXRTZWxlY3RlZChpZHMuaW5kZXhPZihvLnRvU3RyaW5nKCkpID4gLTEpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG9wdGlvblNlbGVjdGVkU3RhdGVTZXR0ZXIgPSAob3B0LCBvKSA9PiB7XG4gICAgICAgICAgICAgICAgb3B0Ll9zZXRTZWxlY3RlZChmYWxzZSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX29wdGlvbk1hcC5mb3JFYWNoKG9wdGlvblNlbGVjdGVkU3RhdGVTZXR0ZXIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWdpc3RlcnMgYSBmdW5jdGlvbiBjYWxsZWQgd2hlbiB0aGUgY29udHJvbCB2YWx1ZSBjaGFuZ2VzXG4gICAgICogYW5kIHdyaXRlcyBhbiBhcnJheSBvZiB0aGUgc2VsZWN0ZWQgb3B0aW9ucy5cbiAgICAgKiBAbm9kb2NcbiAgICAgKi9cbiAgICByZWdpc3Rlck9uQ2hhbmdlKGZuKSB7XG4gICAgICAgIHRoaXMub25DaGFuZ2UgPSAoZWxlbWVudCkgPT4ge1xuICAgICAgICAgICAgY29uc3Qgc2VsZWN0ZWQgPSBbXTtcbiAgICAgICAgICAgIGNvbnN0IHNlbGVjdGVkT3B0aW9ucyA9IGVsZW1lbnQuc2VsZWN0ZWRPcHRpb25zO1xuICAgICAgICAgICAgaWYgKHNlbGVjdGVkT3B0aW9ucyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHNlbGVjdGVkT3B0aW9ucztcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG9wdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgb3B0ID0gb3B0aW9uc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdmFsID0gdGhpcy5fZ2V0T3B0aW9uVmFsdWUob3B0LnZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0ZWQucHVzaCh2YWwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIERlZ3JhZGUgdG8gdXNlIGBvcHRpb25zYCB3aGVuIGBzZWxlY3RlZE9wdGlvbnNgIHByb3BlcnR5IGlzIG5vdCBhdmFpbGFibGUuXG4gICAgICAgICAgICAvLyBOb3RlOiB0aGUgYHNlbGVjdGVkT3B0aW9uc2AgaXMgYXZhaWxhYmxlIGluIGFsbCBzdXBwb3J0ZWQgYnJvd3NlcnMsIGJ1dCB0aGUgRG9taW5vIGxpYlxuICAgICAgICAgICAgLy8gZG9lc24ndCBoYXZlIGl0IGN1cnJlbnRseSwgc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9mZ25hc3MvZG9taW5vL2lzc3Vlcy8xNzcuXG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCBvcHRpb25zID0gZWxlbWVudC5vcHRpb25zO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb3B0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBvcHQgPSBvcHRpb25zW2ldO1xuICAgICAgICAgICAgICAgICAgICBpZiAob3B0LnNlbGVjdGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB2YWwgPSB0aGlzLl9nZXRPcHRpb25WYWx1ZShvcHQudmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0ZWQucHVzaCh2YWwpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy52YWx1ZSA9IHNlbGVjdGVkO1xuICAgICAgICAgICAgZm4oc2VsZWN0ZWQpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICAvKiogQGludGVybmFsICovXG4gICAgX3JlZ2lzdGVyT3B0aW9uKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGlkID0gKHRoaXMuX2lkQ291bnRlcisrKS50b1N0cmluZygpO1xuICAgICAgICB0aGlzLl9vcHRpb25NYXAuc2V0KGlkLCB2YWx1ZSk7XG4gICAgICAgIHJldHVybiBpZDtcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIF9nZXRPcHRpb25JZCh2YWx1ZSkge1xuICAgICAgICBmb3IgKGNvbnN0IGlkIG9mIHRoaXMuX29wdGlvbk1hcC5rZXlzKCkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9jb21wYXJlV2l0aCh0aGlzLl9vcHRpb25NYXAuZ2V0KGlkKS5fdmFsdWUsIHZhbHVlKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gaWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBfZ2V0T3B0aW9uVmFsdWUodmFsdWVTdHJpbmcpIHtcbiAgICAgICAgY29uc3QgaWQgPSBfZXh0cmFjdElkKHZhbHVlU3RyaW5nKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX29wdGlvbk1hcC5oYXMoaWQpID8gdGhpcy5fb3B0aW9uTWFwLmdldChpZCkuX3ZhbHVlIDogdmFsdWVTdHJpbmc7XG4gICAgfVxuICAgIHN0YXRpYyB7IHRoaXMuybVmYWMgPSBpMC7Jtcm1bmdEZWNsYXJlRmFjdG9yeSh7IG1pblZlcnNpb246IFwiMTIuMC4wXCIsIHZlcnNpb246IFwiMTcuMy4xMlwiLCBuZ0ltcG9ydDogaTAsIHR5cGU6IFNlbGVjdE11bHRpcGxlQ29udHJvbFZhbHVlQWNjZXNzb3IsIGRlcHM6IG51bGwsIHRhcmdldDogaTAuybXJtUZhY3RvcnlUYXJnZXQuRGlyZWN0aXZlIH0pOyB9XG4gICAgc3RhdGljIHsgdGhpcy7JtWRpciA9IGkwLsm1ybVuZ0RlY2xhcmVEaXJlY3RpdmUoeyBtaW5WZXJzaW9uOiBcIjE0LjAuMFwiLCB2ZXJzaW9uOiBcIjE3LjMuMTJcIiwgdHlwZTogU2VsZWN0TXVsdGlwbGVDb250cm9sVmFsdWVBY2Nlc3Nvciwgc2VsZWN0b3I6IFwic2VsZWN0W211bHRpcGxlXVtmb3JtQ29udHJvbE5hbWVdLHNlbGVjdFttdWx0aXBsZV1bZm9ybUNvbnRyb2xdLHNlbGVjdFttdWx0aXBsZV1bbmdNb2RlbF1cIiwgaW5wdXRzOiB7IGNvbXBhcmVXaXRoOiBcImNvbXBhcmVXaXRoXCIgfSwgaG9zdDogeyBsaXN0ZW5lcnM6IHsgXCJjaGFuZ2VcIjogXCJvbkNoYW5nZSgkZXZlbnQudGFyZ2V0KVwiLCBcImJsdXJcIjogXCJvblRvdWNoZWQoKVwiIH0gfSwgcHJvdmlkZXJzOiBbU0VMRUNUX01VTFRJUExFX1ZBTFVFX0FDQ0VTU09SXSwgdXNlc0luaGVyaXRhbmNlOiB0cnVlLCBuZ0ltcG9ydDogaTAgfSk7IH1cbn1cbmkwLsm1ybVuZ0RlY2xhcmVDbGFzc01ldGFkYXRhKHsgbWluVmVyc2lvbjogXCIxMi4wLjBcIiwgdmVyc2lvbjogXCIxNy4zLjEyXCIsIG5nSW1wb3J0OiBpMCwgdHlwZTogU2VsZWN0TXVsdGlwbGVDb250cm9sVmFsdWVBY2Nlc3NvciwgZGVjb3JhdG9yczogW3tcbiAgICAgICAgICAgIHR5cGU6IERpcmVjdGl2ZSxcbiAgICAgICAgICAgIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnc2VsZWN0W211bHRpcGxlXVtmb3JtQ29udHJvbE5hbWVdLHNlbGVjdFttdWx0aXBsZV1bZm9ybUNvbnRyb2xdLHNlbGVjdFttdWx0aXBsZV1bbmdNb2RlbF0nLFxuICAgICAgICAgICAgICAgICAgICBob3N0OiB7ICcoY2hhbmdlKSc6ICdvbkNoYW5nZSgkZXZlbnQudGFyZ2V0KScsICcoYmx1ciknOiAnb25Ub3VjaGVkKCknIH0sXG4gICAgICAgICAgICAgICAgICAgIHByb3ZpZGVyczogW1NFTEVDVF9NVUxUSVBMRV9WQUxVRV9BQ0NFU1NPUl1cbiAgICAgICAgICAgICAgICB9XVxuICAgICAgICB9XSwgcHJvcERlY29yYXRvcnM6IHsgY29tcGFyZVdpdGg6IFt7XG4gICAgICAgICAgICAgICAgdHlwZTogSW5wdXRcbiAgICAgICAgICAgIH1dIH0gfSk7XG4vKipcbiAqIEBkZXNjcmlwdGlvblxuICogTWFya3MgYDxvcHRpb24+YCBhcyBkeW5hbWljLCBzbyBBbmd1bGFyIGNhbiBiZSBub3RpZmllZCB3aGVuIG9wdGlvbnMgY2hhbmdlLlxuICpcbiAqIEBzZWUge0BsaW5rIFNlbGVjdE11bHRpcGxlQ29udHJvbFZhbHVlQWNjZXNzb3J9XG4gKlxuICogQG5nTW9kdWxlIFJlYWN0aXZlRm9ybXNNb2R1bGVcbiAqIEBuZ01vZHVsZSBGb3Jtc01vZHVsZVxuICogQHB1YmxpY0FwaVxuICovXG5jbGFzcyDJtU5nU2VsZWN0TXVsdGlwbGVPcHRpb24ge1xuICAgIGNvbnN0cnVjdG9yKF9lbGVtZW50LCBfcmVuZGVyZXIsIF9zZWxlY3QpIHtcbiAgICAgICAgdGhpcy5fZWxlbWVudCA9IF9lbGVtZW50O1xuICAgICAgICB0aGlzLl9yZW5kZXJlciA9IF9yZW5kZXJlcjtcbiAgICAgICAgdGhpcy5fc2VsZWN0ID0gX3NlbGVjdDtcbiAgICAgICAgaWYgKHRoaXMuX3NlbGVjdCkge1xuICAgICAgICAgICAgdGhpcy5pZCA9IHRoaXMuX3NlbGVjdC5fcmVnaXN0ZXJPcHRpb24odGhpcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICogVHJhY2tzIHRoZSB2YWx1ZSBib3VuZCB0byB0aGUgb3B0aW9uIGVsZW1lbnQuIFVubGlrZSB0aGUgdmFsdWUgYmluZGluZyxcbiAgICAgKiBuZ1ZhbHVlIHN1cHBvcnRzIGJpbmRpbmcgdG8gb2JqZWN0cy5cbiAgICAgKi9cbiAgICBzZXQgbmdWYWx1ZSh2YWx1ZSkge1xuICAgICAgICBpZiAodGhpcy5fc2VsZWN0ID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRoaXMuX3ZhbHVlID0gdmFsdWU7XG4gICAgICAgIHRoaXMuX3NldEVsZW1lbnRWYWx1ZShfYnVpbGRWYWx1ZVN0cmluZyh0aGlzLmlkLCB2YWx1ZSkpO1xuICAgICAgICB0aGlzLl9zZWxlY3Qud3JpdGVWYWx1ZSh0aGlzLl9zZWxlY3QudmFsdWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKiBUcmFja3Mgc2ltcGxlIHN0cmluZyB2YWx1ZXMgYm91bmQgdG8gdGhlIG9wdGlvbiBlbGVtZW50LlxuICAgICAqIEZvciBvYmplY3RzLCB1c2UgdGhlIGBuZ1ZhbHVlYCBpbnB1dCBiaW5kaW5nLlxuICAgICAqL1xuICAgIHNldCB2YWx1ZSh2YWx1ZSkge1xuICAgICAgICBpZiAodGhpcy5fc2VsZWN0KSB7XG4gICAgICAgICAgICB0aGlzLl92YWx1ZSA9IHZhbHVlO1xuICAgICAgICAgICAgdGhpcy5fc2V0RWxlbWVudFZhbHVlKF9idWlsZFZhbHVlU3RyaW5nKHRoaXMuaWQsIHZhbHVlKSk7XG4gICAgICAgICAgICB0aGlzLl9zZWxlY3Qud3JpdGVWYWx1ZSh0aGlzLl9zZWxlY3QudmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fc2V0RWxlbWVudFZhbHVlKHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKiogQGludGVybmFsICovXG4gICAgX3NldEVsZW1lbnRWYWx1ZSh2YWx1ZSkge1xuICAgICAgICB0aGlzLl9yZW5kZXJlci5zZXRQcm9wZXJ0eSh0aGlzLl9lbGVtZW50Lm5hdGl2ZUVsZW1lbnQsICd2YWx1ZScsIHZhbHVlKTtcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIF9zZXRTZWxlY3RlZChzZWxlY3RlZCkge1xuICAgICAgICB0aGlzLl9yZW5kZXJlci5zZXRQcm9wZXJ0eSh0aGlzLl9lbGVtZW50Lm5hdGl2ZUVsZW1lbnQsICdzZWxlY3RlZCcsIHNlbGVjdGVkKTtcbiAgICB9XG4gICAgLyoqIEBub2RvYyAqL1xuICAgIG5nT25EZXN0cm95KCkge1xuICAgICAgICBpZiAodGhpcy5fc2VsZWN0KSB7XG4gICAgICAgICAgICB0aGlzLl9zZWxlY3QuX29wdGlvbk1hcC5kZWxldGUodGhpcy5pZCk7XG4gICAgICAgICAgICB0aGlzLl9zZWxlY3Qud3JpdGVWYWx1ZSh0aGlzLl9zZWxlY3QudmFsdWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHN0YXRpYyB7IHRoaXMuybVmYWMgPSBpMC7Jtcm1bmdEZWNsYXJlRmFjdG9yeSh7IG1pblZlcnNpb246IFwiMTIuMC4wXCIsIHZlcnNpb246IFwiMTcuMy4xMlwiLCBuZ0ltcG9ydDogaTAsIHR5cGU6IMm1TmdTZWxlY3RNdWx0aXBsZU9wdGlvbiwgZGVwczogW3sgdG9rZW46IGkwLkVsZW1lbnRSZWYgfSwgeyB0b2tlbjogaTAuUmVuZGVyZXIyIH0sIHsgdG9rZW46IFNlbGVjdE11bHRpcGxlQ29udHJvbFZhbHVlQWNjZXNzb3IsIGhvc3Q6IHRydWUsIG9wdGlvbmFsOiB0cnVlIH1dLCB0YXJnZXQ6IGkwLsm1ybVGYWN0b3J5VGFyZ2V0LkRpcmVjdGl2ZSB9KTsgfVxuICAgIHN0YXRpYyB7IHRoaXMuybVkaXIgPSBpMC7Jtcm1bmdEZWNsYXJlRGlyZWN0aXZlKHsgbWluVmVyc2lvbjogXCIxNC4wLjBcIiwgdmVyc2lvbjogXCIxNy4zLjEyXCIsIHR5cGU6IMm1TmdTZWxlY3RNdWx0aXBsZU9wdGlvbiwgc2VsZWN0b3I6IFwib3B0aW9uXCIsIGlucHV0czogeyBuZ1ZhbHVlOiBcIm5nVmFsdWVcIiwgdmFsdWU6IFwidmFsdWVcIiB9LCBuZ0ltcG9ydDogaTAgfSk7IH1cbn1cbmkwLsm1ybVuZ0RlY2xhcmVDbGFzc01ldGFkYXRhKHsgbWluVmVyc2lvbjogXCIxMi4wLjBcIiwgdmVyc2lvbjogXCIxNy4zLjEyXCIsIG5nSW1wb3J0OiBpMCwgdHlwZTogybVOZ1NlbGVjdE11bHRpcGxlT3B0aW9uLCBkZWNvcmF0b3JzOiBbe1xuICAgICAgICAgICAgdHlwZTogRGlyZWN0aXZlLFxuICAgICAgICAgICAgYXJnczogW3sgc2VsZWN0b3I6ICdvcHRpb24nIH1dXG4gICAgICAgIH1dLCBjdG9yUGFyYW1ldGVyczogKCkgPT4gW3sgdHlwZTogaTAuRWxlbWVudFJlZiB9LCB7IHR5cGU6IGkwLlJlbmRlcmVyMiB9LCB7IHR5cGU6IFNlbGVjdE11bHRpcGxlQ29udHJvbFZhbHVlQWNjZXNzb3IsIGRlY29yYXRvcnM6IFt7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IE9wdGlvbmFsXG4gICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBIb3N0XG4gICAgICAgICAgICAgICAgfV0gfV0sIHByb3BEZWNvcmF0b3JzOiB7IG5nVmFsdWU6IFt7XG4gICAgICAgICAgICAgICAgdHlwZTogSW5wdXQsXG4gICAgICAgICAgICAgICAgYXJnczogWyduZ1ZhbHVlJ11cbiAgICAgICAgICAgIH1dLCB2YWx1ZTogW3tcbiAgICAgICAgICAgICAgICB0eXBlOiBJbnB1dCxcbiAgICAgICAgICAgICAgICBhcmdzOiBbJ3ZhbHVlJ11cbiAgICAgICAgICAgIH1dIH0gfSk7XG5cbi8qKlxuICogTWV0aG9kIHRoYXQgdXBkYXRlcyBzdHJpbmcgdG8gaW50ZWdlciBpZiBub3QgYWxyZWFkeSBhIG51bWJlclxuICpcbiAqIEBwYXJhbSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29udmVydCB0byBpbnRlZ2VyLlxuICogQHJldHVybnMgdmFsdWUgb2YgcGFyYW1ldGVyIGNvbnZlcnRlZCB0byBudW1iZXIgb3IgaW50ZWdlci5cbiAqL1xuZnVuY3Rpb24gdG9JbnRlZ2VyKHZhbHVlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgPyB2YWx1ZSA6IHBhcnNlSW50KHZhbHVlLCAxMCk7XG59XG4vKipcbiAqIE1ldGhvZCB0aGF0IGVuc3VyZXMgdGhhdCBwcm92aWRlZCB2YWx1ZSBpcyBhIGZsb2F0IChhbmQgY29udmVydHMgaXQgdG8gZmxvYXQgaWYgbmVlZGVkKS5cbiAqXG4gKiBAcGFyYW0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQgdG8gZmxvYXQuXG4gKiBAcmV0dXJucyB2YWx1ZSBvZiBwYXJhbWV0ZXIgY29udmVydGVkIHRvIG51bWJlciBvciBmbG9hdC5cbiAqL1xuZnVuY3Rpb24gdG9GbG9hdCh2YWx1ZSkge1xuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInID8gdmFsdWUgOiBwYXJzZUZsb2F0KHZhbHVlKTtcbn1cbi8qKlxuICogQSBiYXNlIGNsYXNzIGZvciBWYWxpZGF0b3ItYmFzZWQgRGlyZWN0aXZlcy4gVGhlIGNsYXNzIGNvbnRhaW5zIGNvbW1vbiBsb2dpYyBzaGFyZWQgYWNyb3NzIHN1Y2hcbiAqIERpcmVjdGl2ZXMuXG4gKlxuICogRm9yIGludGVybmFsIHVzZSBvbmx5LCB0aGlzIGNsYXNzIGlzIG5vdCBpbnRlbmRlZCBmb3IgdXNlIG91dHNpZGUgb2YgdGhlIEZvcm1zIHBhY2thZ2UuXG4gKi9cbmNsYXNzIEFic3RyYWN0VmFsaWRhdG9yRGlyZWN0aXZlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5fdmFsaWRhdG9yID0gbnVsbFZhbGlkYXRvcjtcbiAgICB9XG4gICAgLyoqIEBub2RvYyAqL1xuICAgIG5nT25DaGFuZ2VzKGNoYW5nZXMpIHtcbiAgICAgICAgaWYgKHRoaXMuaW5wdXROYW1lIGluIGNoYW5nZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IGlucHV0ID0gdGhpcy5ub3JtYWxpemVJbnB1dChjaGFuZ2VzW3RoaXMuaW5wdXROYW1lXS5jdXJyZW50VmFsdWUpO1xuICAgICAgICAgICAgdGhpcy5fZW5hYmxlZCA9IHRoaXMuZW5hYmxlZChpbnB1dCk7XG4gICAgICAgICAgICB0aGlzLl92YWxpZGF0b3IgPSB0aGlzLl9lbmFibGVkID8gdGhpcy5jcmVhdGVWYWxpZGF0b3IoaW5wdXQpIDogbnVsbFZhbGlkYXRvcjtcbiAgICAgICAgICAgIGlmICh0aGlzLl9vbkNoYW5nZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX29uQ2hhbmdlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqIEBub2RvYyAqL1xuICAgIHZhbGlkYXRlKGNvbnRyb2wpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ZhbGlkYXRvcihjb250cm9sKTtcbiAgICB9XG4gICAgLyoqIEBub2RvYyAqL1xuICAgIHJlZ2lzdGVyT25WYWxpZGF0b3JDaGFuZ2UoZm4pIHtcbiAgICAgICAgdGhpcy5fb25DaGFuZ2UgPSBmbjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICogRGV0ZXJtaW5lcyB3aGV0aGVyIHRoaXMgdmFsaWRhdG9yIHNob3VsZCBiZSBhY3RpdmUgb3Igbm90IGJhc2VkIG9uIGFuIGlucHV0LlxuICAgICAqIEJhc2UgY2xhc3MgaW1wbGVtZW50YXRpb24gY2hlY2tzIHdoZXRoZXIgYW4gaW5wdXQgaXMgZGVmaW5lZCAoaWYgdGhlIHZhbHVlIGlzIGRpZmZlcmVudCBmcm9tXG4gICAgICogYG51bGxgIGFuZCBgdW5kZWZpbmVkYCkuIFZhbGlkYXRvciBjbGFzc2VzIHRoYXQgZXh0ZW5kIHRoaXMgYmFzZSBjbGFzcyBjYW4gb3ZlcnJpZGUgdGhpc1xuICAgICAqIGZ1bmN0aW9uIHdpdGggdGhlIGxvZ2ljIHNwZWNpZmljIHRvIGEgcGFydGljdWxhciB2YWxpZGF0b3IgZGlyZWN0aXZlLlxuICAgICAqL1xuICAgIGVuYWJsZWQoaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIGlucHV0ICE9IG51bGwgLyogYm90aCBgbnVsbGAgYW5kIGB1bmRlZmluZWRgICovO1xuICAgIH1cbiAgICBzdGF0aWMgeyB0aGlzLsm1ZmFjID0gaTAuybXJtW5nRGVjbGFyZUZhY3RvcnkoeyBtaW5WZXJzaW9uOiBcIjEyLjAuMFwiLCB2ZXJzaW9uOiBcIjE3LjMuMTJcIiwgbmdJbXBvcnQ6IGkwLCB0eXBlOiBBYnN0cmFjdFZhbGlkYXRvckRpcmVjdGl2ZSwgZGVwczogW10sIHRhcmdldDogaTAuybXJtUZhY3RvcnlUYXJnZXQuRGlyZWN0aXZlIH0pOyB9XG4gICAgc3RhdGljIHsgdGhpcy7JtWRpciA9IGkwLsm1ybVuZ0RlY2xhcmVEaXJlY3RpdmUoeyBtaW5WZXJzaW9uOiBcIjE0LjAuMFwiLCB2ZXJzaW9uOiBcIjE3LjMuMTJcIiwgdHlwZTogQWJzdHJhY3RWYWxpZGF0b3JEaXJlY3RpdmUsIHVzZXNPbkNoYW5nZXM6IHRydWUsIG5nSW1wb3J0OiBpMCB9KTsgfVxufVxuaTAuybXJtW5nRGVjbGFyZUNsYXNzTWV0YWRhdGEoeyBtaW5WZXJzaW9uOiBcIjEyLjAuMFwiLCB2ZXJzaW9uOiBcIjE3LjMuMTJcIiwgbmdJbXBvcnQ6IGkwLCB0eXBlOiBBYnN0cmFjdFZhbGlkYXRvckRpcmVjdGl2ZSwgZGVjb3JhdG9yczogW3tcbiAgICAgICAgICAgIHR5cGU6IERpcmVjdGl2ZVxuICAgICAgICB9XSB9KTtcbi8qKlxuICogQGRlc2NyaXB0aW9uXG4gKiBQcm92aWRlciB3aGljaCBhZGRzIGBNYXhWYWxpZGF0b3JgIHRvIHRoZSBgTkdfVkFMSURBVE9SU2AgbXVsdGktcHJvdmlkZXIgbGlzdC5cbiAqL1xuY29uc3QgTUFYX1ZBTElEQVRPUiA9IHtcbiAgICBwcm92aWRlOiBOR19WQUxJREFUT1JTLFxuICAgIHVzZUV4aXN0aW5nOiBmb3J3YXJkUmVmKCgpID0+IE1heFZhbGlkYXRvciksXG4gICAgbXVsdGk6IHRydWVcbn07XG4vKipcbiAqIEEgZGlyZWN0aXZlIHdoaWNoIGluc3RhbGxzIHRoZSB7QGxpbmsgTWF4VmFsaWRhdG9yfSBmb3IgYW55IGBmb3JtQ29udHJvbE5hbWVgLFxuICogYGZvcm1Db250cm9sYCwgb3IgY29udHJvbCB3aXRoIGBuZ01vZGVsYCB0aGF0IGFsc28gaGFzIGEgYG1heGAgYXR0cmlidXRlLlxuICpcbiAqIEBzZWUgW0Zvcm0gVmFsaWRhdGlvbl0oZ3VpZGUvZm9ybS12YWxpZGF0aW9uKVxuICpcbiAqIEB1c2FnZU5vdGVzXG4gKlxuICogIyMjIEFkZGluZyBhIG1heCB2YWxpZGF0b3JcbiAqXG4gKiBUaGUgZm9sbG93aW5nIGV4YW1wbGUgc2hvd3MgaG93IHRvIGFkZCBhIG1heCB2YWxpZGF0b3IgdG8gYW4gaW5wdXQgYXR0YWNoZWQgdG8gYW5cbiAqIG5nTW9kZWwgYmluZGluZy5cbiAqXG4gKiBgYGBodG1sXG4gKiA8aW5wdXQgdHlwZT1cIm51bWJlclwiIG5nTW9kZWwgbWF4PVwiNFwiPlxuICogYGBgXG4gKlxuICogQG5nTW9kdWxlIFJlYWN0aXZlRm9ybXNNb2R1bGVcbiAqIEBuZ01vZHVsZSBGb3Jtc01vZHVsZVxuICogQHB1YmxpY0FwaVxuICovXG5jbGFzcyBNYXhWYWxpZGF0b3IgZXh0ZW5kcyBBYnN0cmFjdFZhbGlkYXRvckRpcmVjdGl2ZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgdGhpcy5pbnB1dE5hbWUgPSAnbWF4JztcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICB0aGlzLm5vcm1hbGl6ZUlucHV0ID0gKGlucHV0KSA9PiB0b0Zsb2F0KGlucHV0KTtcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICB0aGlzLmNyZWF0ZVZhbGlkYXRvciA9IChtYXgpID0+IG1heFZhbGlkYXRvcihtYXgpO1xuICAgIH1cbiAgICBzdGF0aWMgeyB0aGlzLsm1ZmFjID0gaTAuybXJtW5nRGVjbGFyZUZhY3RvcnkoeyBtaW5WZXJzaW9uOiBcIjEyLjAuMFwiLCB2ZXJzaW9uOiBcIjE3LjMuMTJcIiwgbmdJbXBvcnQ6IGkwLCB0eXBlOiBNYXhWYWxpZGF0b3IsIGRlcHM6IG51bGwsIHRhcmdldDogaTAuybXJtUZhY3RvcnlUYXJnZXQuRGlyZWN0aXZlIH0pOyB9XG4gICAgc3RhdGljIHsgdGhpcy7JtWRpciA9IGkwLsm1ybVuZ0RlY2xhcmVEaXJlY3RpdmUoeyBtaW5WZXJzaW9uOiBcIjE0LjAuMFwiLCB2ZXJzaW9uOiBcIjE3LjMuMTJcIiwgdHlwZTogTWF4VmFsaWRhdG9yLCBzZWxlY3RvcjogXCJpbnB1dFt0eXBlPW51bWJlcl1bbWF4XVtmb3JtQ29udHJvbE5hbWVdLGlucHV0W3R5cGU9bnVtYmVyXVttYXhdW2Zvcm1Db250cm9sXSxpbnB1dFt0eXBlPW51bWJlcl1bbWF4XVtuZ01vZGVsXVwiLCBpbnB1dHM6IHsgbWF4OiBcIm1heFwiIH0sIGhvc3Q6IHsgcHJvcGVydGllczogeyBcImF0dHIubWF4XCI6IFwiX2VuYWJsZWQgPyBtYXggOiBudWxsXCIgfSB9LCBwcm92aWRlcnM6IFtNQVhfVkFMSURBVE9SXSwgdXNlc0luaGVyaXRhbmNlOiB0cnVlLCBuZ0ltcG9ydDogaTAgfSk7IH1cbn1cbmkwLsm1ybVuZ0RlY2xhcmVDbGFzc01ldGFkYXRhKHsgbWluVmVyc2lvbjogXCIxMi4wLjBcIiwgdmVyc2lvbjogXCIxNy4zLjEyXCIsIG5nSW1wb3J0OiBpMCwgdHlwZTogTWF4VmFsaWRhdG9yLCBkZWNvcmF0b3JzOiBbe1xuICAgICAgICAgICAgdHlwZTogRGlyZWN0aXZlLFxuICAgICAgICAgICAgYXJnczogW3tcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0b3I6ICdpbnB1dFt0eXBlPW51bWJlcl1bbWF4XVtmb3JtQ29udHJvbE5hbWVdLGlucHV0W3R5cGU9bnVtYmVyXVttYXhdW2Zvcm1Db250cm9sXSxpbnB1dFt0eXBlPW51bWJlcl1bbWF4XVtuZ01vZGVsXScsXG4gICAgICAgICAgICAgICAgICAgIHByb3ZpZGVyczogW01BWF9WQUxJREFUT1JdLFxuICAgICAgICAgICAgICAgICAgICBob3N0OiB7ICdbYXR0ci5tYXhdJzogJ19lbmFibGVkID8gbWF4IDogbnVsbCcgfVxuICAgICAgICAgICAgICAgIH1dXG4gICAgICAgIH1dLCBwcm9wRGVjb3JhdG9yczogeyBtYXg6IFt7XG4gICAgICAgICAgICAgICAgdHlwZTogSW5wdXRcbiAgICAgICAgICAgIH1dIH0gfSk7XG4vKipcbiAqIEBkZXNjcmlwdGlvblxuICogUHJvdmlkZXIgd2hpY2ggYWRkcyBgTWluVmFsaWRhdG9yYCB0byB0aGUgYE5HX1ZBTElEQVRPUlNgIG11bHRpLXByb3ZpZGVyIGxpc3QuXG4gKi9cbmNvbnN0IE1JTl9WQUxJREFUT1IgPSB7XG4gICAgcHJvdmlkZTogTkdfVkFMSURBVE9SUyxcbiAgICB1c2VFeGlzdGluZzogZm9yd2FyZFJlZigoKSA9PiBNaW5WYWxpZGF0b3IpLFxuICAgIG11bHRpOiB0cnVlXG59O1xuLyoqXG4gKiBBIGRpcmVjdGl2ZSB3aGljaCBpbnN0YWxscyB0aGUge0BsaW5rIE1pblZhbGlkYXRvcn0gZm9yIGFueSBgZm9ybUNvbnRyb2xOYW1lYCxcbiAqIGBmb3JtQ29udHJvbGAsIG9yIGNvbnRyb2wgd2l0aCBgbmdNb2RlbGAgdGhhdCBhbHNvIGhhcyBhIGBtaW5gIGF0dHJpYnV0ZS5cbiAqXG4gKiBAc2VlIFtGb3JtIFZhbGlkYXRpb25dKGd1aWRlL2Zvcm0tdmFsaWRhdGlvbilcbiAqXG4gKiBAdXNhZ2VOb3Rlc1xuICpcbiAqICMjIyBBZGRpbmcgYSBtaW4gdmFsaWRhdG9yXG4gKlxuICogVGhlIGZvbGxvd2luZyBleGFtcGxlIHNob3dzIGhvdyB0byBhZGQgYSBtaW4gdmFsaWRhdG9yIHRvIGFuIGlucHV0IGF0dGFjaGVkIHRvIGFuXG4gKiBuZ01vZGVsIGJpbmRpbmcuXG4gKlxuICogYGBgaHRtbFxuICogPGlucHV0IHR5cGU9XCJudW1iZXJcIiBuZ01vZGVsIG1pbj1cIjRcIj5cbiAqIGBgYFxuICpcbiAqIEBuZ01vZHVsZSBSZWFjdGl2ZUZvcm1zTW9kdWxlXG4gKiBAbmdNb2R1bGUgRm9ybXNNb2R1bGVcbiAqIEBwdWJsaWNBcGlcbiAqL1xuY2xhc3MgTWluVmFsaWRhdG9yIGV4dGVuZHMgQWJzdHJhY3RWYWxpZGF0b3JEaXJlY3RpdmUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgIHRoaXMuaW5wdXROYW1lID0gJ21pbic7XG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgdGhpcy5ub3JtYWxpemVJbnB1dCA9IChpbnB1dCkgPT4gdG9GbG9hdChpbnB1dCk7XG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgdGhpcy5jcmVhdGVWYWxpZGF0b3IgPSAobWluKSA9PiBtaW5WYWxpZGF0b3IobWluKTtcbiAgICB9XG4gICAgc3RhdGljIHsgdGhpcy7JtWZhYyA9IGkwLsm1ybVuZ0RlY2xhcmVGYWN0b3J5KHsgbWluVmVyc2lvbjogXCIxMi4wLjBcIiwgdmVyc2lvbjogXCIxNy4zLjEyXCIsIG5nSW1wb3J0OiBpMCwgdHlwZTogTWluVmFsaWRhdG9yLCBkZXBzOiBudWxsLCB0YXJnZXQ6IGkwLsm1ybVGYWN0b3J5VGFyZ2V0LkRpcmVjdGl2ZSB9KTsgfVxuICAgIHN0YXRpYyB7IHRoaXMuybVkaXIgPSBpMC7Jtcm1bmdEZWNsYXJlRGlyZWN0aXZlKHsgbWluVmVyc2lvbjogXCIxNC4wLjBcIiwgdmVyc2lvbjogXCIxNy4zLjEyXCIsIHR5cGU6IE1pblZhbGlkYXRvciwgc2VsZWN0b3I6IFwiaW5wdXRbdHlwZT1udW1iZXJdW21pbl1bZm9ybUNvbnRyb2xOYW1lXSxpbnB1dFt0eXBlPW51bWJlcl1bbWluXVtmb3JtQ29udHJvbF0saW5wdXRbdHlwZT1udW1iZXJdW21pbl1bbmdNb2RlbF1cIiwgaW5wdXRzOiB7IG1pbjogXCJtaW5cIiB9LCBob3N0OiB7IHByb3BlcnRpZXM6IHsgXCJhdHRyLm1pblwiOiBcIl9lbmFibGVkID8gbWluIDogbnVsbFwiIH0gfSwgcHJvdmlkZXJzOiBbTUlOX1ZBTElEQVRPUl0sIHVzZXNJbmhlcml0YW5jZTogdHJ1ZSwgbmdJbXBvcnQ6IGkwIH0pOyB9XG59XG5pMC7Jtcm1bmdEZWNsYXJlQ2xhc3NNZXRhZGF0YSh7IG1pblZlcnNpb246IFwiMTIuMC4wXCIsIHZlcnNpb246IFwiMTcuMy4xMlwiLCBuZ0ltcG9ydDogaTAsIHR5cGU6IE1pblZhbGlkYXRvciwgZGVjb3JhdG9yczogW3tcbiAgICAgICAgICAgIHR5cGU6IERpcmVjdGl2ZSxcbiAgICAgICAgICAgIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnaW5wdXRbdHlwZT1udW1iZXJdW21pbl1bZm9ybUNvbnRyb2xOYW1lXSxpbnB1dFt0eXBlPW51bWJlcl1bbWluXVtmb3JtQ29udHJvbF0saW5wdXRbdHlwZT1udW1iZXJdW21pbl1bbmdNb2RlbF0nLFxuICAgICAgICAgICAgICAgICAgICBwcm92aWRlcnM6IFtNSU5fVkFMSURBVE9SXSxcbiAgICAgICAgICAgICAgICAgICAgaG9zdDogeyAnW2F0dHIubWluXSc6ICdfZW5hYmxlZCA/IG1pbiA6IG51bGwnIH1cbiAgICAgICAgICAgICAgICB9XVxuICAgICAgICB9XSwgcHJvcERlY29yYXRvcnM6IHsgbWluOiBbe1xuICAgICAgICAgICAgICAgIHR5cGU6IElucHV0XG4gICAgICAgICAgICB9XSB9IH0pO1xuLyoqXG4gKiBAZGVzY3JpcHRpb25cbiAqIFByb3ZpZGVyIHdoaWNoIGFkZHMgYFJlcXVpcmVkVmFsaWRhdG9yYCB0byB0aGUgYE5HX1ZBTElEQVRPUlNgIG11bHRpLXByb3ZpZGVyIGxpc3QuXG4gKi9cbmNvbnN0IFJFUVVJUkVEX1ZBTElEQVRPUiA9IHtcbiAgICBwcm92aWRlOiBOR19WQUxJREFUT1JTLFxuICAgIHVzZUV4aXN0aW5nOiBmb3J3YXJkUmVmKCgpID0+IFJlcXVpcmVkVmFsaWRhdG9yKSxcbiAgICBtdWx0aTogdHJ1ZVxufTtcbi8qKlxuICogQGRlc2NyaXB0aW9uXG4gKiBQcm92aWRlciB3aGljaCBhZGRzIGBDaGVja2JveFJlcXVpcmVkVmFsaWRhdG9yYCB0byB0aGUgYE5HX1ZBTElEQVRPUlNgIG11bHRpLXByb3ZpZGVyIGxpc3QuXG4gKi9cbmNvbnN0IENIRUNLQk9YX1JFUVVJUkVEX1ZBTElEQVRPUiA9IHtcbiAgICBwcm92aWRlOiBOR19WQUxJREFUT1JTLFxuICAgIHVzZUV4aXN0aW5nOiBmb3J3YXJkUmVmKCgpID0+IENoZWNrYm94UmVxdWlyZWRWYWxpZGF0b3IpLFxuICAgIG11bHRpOiB0cnVlXG59O1xuLyoqXG4gKiBAZGVzY3JpcHRpb25cbiAqIEEgZGlyZWN0aXZlIHRoYXQgYWRkcyB0aGUgYHJlcXVpcmVkYCB2YWxpZGF0b3IgdG8gYW55IGNvbnRyb2xzIG1hcmtlZCB3aXRoIHRoZVxuICogYHJlcXVpcmVkYCBhdHRyaWJ1dGUuIFRoZSBkaXJlY3RpdmUgaXMgcHJvdmlkZWQgd2l0aCB0aGUgYE5HX1ZBTElEQVRPUlNgIG11bHRpLXByb3ZpZGVyIGxpc3QuXG4gKlxuICogQHNlZSBbRm9ybSBWYWxpZGF0aW9uXShndWlkZS9mb3JtLXZhbGlkYXRpb24pXG4gKlxuICogQHVzYWdlTm90ZXNcbiAqXG4gKiAjIyMgQWRkaW5nIGEgcmVxdWlyZWQgdmFsaWRhdG9yIHVzaW5nIHRlbXBsYXRlLWRyaXZlbiBmb3Jtc1xuICpcbiAqIGBgYFxuICogPGlucHV0IG5hbWU9XCJmdWxsTmFtZVwiIG5nTW9kZWwgcmVxdWlyZWQ+XG4gKiBgYGBcbiAqXG4gKiBAbmdNb2R1bGUgRm9ybXNNb2R1bGVcbiAqIEBuZ01vZHVsZSBSZWFjdGl2ZUZvcm1zTW9kdWxlXG4gKiBAcHVibGljQXBpXG4gKi9cbmNsYXNzIFJlcXVpcmVkVmFsaWRhdG9yIGV4dGVuZHMgQWJzdHJhY3RWYWxpZGF0b3JEaXJlY3RpdmUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgIHRoaXMuaW5wdXROYW1lID0gJ3JlcXVpcmVkJztcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICB0aGlzLm5vcm1hbGl6ZUlucHV0ID0gYm9vbGVhbkF0dHJpYnV0ZTtcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICB0aGlzLmNyZWF0ZVZhbGlkYXRvciA9IChpbnB1dCkgPT4gcmVxdWlyZWRWYWxpZGF0b3I7XG4gICAgfVxuICAgIC8qKiBAbm9kb2MgKi9cbiAgICBlbmFibGVkKGlucHV0KSB7XG4gICAgICAgIHJldHVybiBpbnB1dDtcbiAgICB9XG4gICAgc3RhdGljIHsgdGhpcy7JtWZhYyA9IGkwLsm1ybVuZ0RlY2xhcmVGYWN0b3J5KHsgbWluVmVyc2lvbjogXCIxMi4wLjBcIiwgdmVyc2lvbjogXCIxNy4zLjEyXCIsIG5nSW1wb3J0OiBpMCwgdHlwZTogUmVxdWlyZWRWYWxpZGF0b3IsIGRlcHM6IG51bGwsIHRhcmdldDogaTAuybXJtUZhY3RvcnlUYXJnZXQuRGlyZWN0aXZlIH0pOyB9XG4gICAgc3RhdGljIHsgdGhpcy7JtWRpciA9IGkwLsm1ybVuZ0RlY2xhcmVEaXJlY3RpdmUoeyBtaW5WZXJzaW9uOiBcIjE0LjAuMFwiLCB2ZXJzaW9uOiBcIjE3LjMuMTJcIiwgdHlwZTogUmVxdWlyZWRWYWxpZGF0b3IsIHNlbGVjdG9yOiBcIjpub3QoW3R5cGU9Y2hlY2tib3hdKVtyZXF1aXJlZF1bZm9ybUNvbnRyb2xOYW1lXSw6bm90KFt0eXBlPWNoZWNrYm94XSlbcmVxdWlyZWRdW2Zvcm1Db250cm9sXSw6bm90KFt0eXBlPWNoZWNrYm94XSlbcmVxdWlyZWRdW25nTW9kZWxdXCIsIGlucHV0czogeyByZXF1aXJlZDogXCJyZXF1aXJlZFwiIH0sIGhvc3Q6IHsgcHJvcGVydGllczogeyBcImF0dHIucmVxdWlyZWRcIjogXCJfZW5hYmxlZCA/IFxcXCJcXFwiIDogbnVsbFwiIH0gfSwgcHJvdmlkZXJzOiBbUkVRVUlSRURfVkFMSURBVE9SXSwgdXNlc0luaGVyaXRhbmNlOiB0cnVlLCBuZ0ltcG9ydDogaTAgfSk7IH1cbn1cbmkwLsm1ybVuZ0RlY2xhcmVDbGFzc01ldGFkYXRhKHsgbWluVmVyc2lvbjogXCIxMi4wLjBcIiwgdmVyc2lvbjogXCIxNy4zLjEyXCIsIG5nSW1wb3J0OiBpMCwgdHlwZTogUmVxdWlyZWRWYWxpZGF0b3IsIGRlY29yYXRvcnM6IFt7XG4gICAgICAgICAgICB0eXBlOiBEaXJlY3RpdmUsXG4gICAgICAgICAgICBhcmdzOiBbe1xuICAgICAgICAgICAgICAgICAgICBzZWxlY3RvcjogJzpub3QoW3R5cGU9Y2hlY2tib3hdKVtyZXF1aXJlZF1bZm9ybUNvbnRyb2xOYW1lXSw6bm90KFt0eXBlPWNoZWNrYm94XSlbcmVxdWlyZWRdW2Zvcm1Db250cm9sXSw6bm90KFt0eXBlPWNoZWNrYm94XSlbcmVxdWlyZWRdW25nTW9kZWxdJyxcbiAgICAgICAgICAgICAgICAgICAgcHJvdmlkZXJzOiBbUkVRVUlSRURfVkFMSURBVE9SXSxcbiAgICAgICAgICAgICAgICAgICAgaG9zdDogeyAnW2F0dHIucmVxdWlyZWRdJzogJ19lbmFibGVkID8gXCJcIiA6IG51bGwnIH1cbiAgICAgICAgICAgICAgICB9XVxuICAgICAgICB9XSwgcHJvcERlY29yYXRvcnM6IHsgcmVxdWlyZWQ6IFt7XG4gICAgICAgICAgICAgICAgdHlwZTogSW5wdXRcbiAgICAgICAgICAgIH1dIH0gfSk7XG4vKipcbiAqIEEgRGlyZWN0aXZlIHRoYXQgYWRkcyB0aGUgYHJlcXVpcmVkYCB2YWxpZGF0b3IgdG8gY2hlY2tib3ggY29udHJvbHMgbWFya2VkIHdpdGggdGhlXG4gKiBgcmVxdWlyZWRgIGF0dHJpYnV0ZS4gVGhlIGRpcmVjdGl2ZSBpcyBwcm92aWRlZCB3aXRoIHRoZSBgTkdfVkFMSURBVE9SU2AgbXVsdGktcHJvdmlkZXIgbGlzdC5cbiAqXG4gKiBAc2VlIFtGb3JtIFZhbGlkYXRpb25dKGd1aWRlL2Zvcm0tdmFsaWRhdGlvbilcbiAqXG4gKiBAdXNhZ2VOb3Rlc1xuICpcbiAqICMjIyBBZGRpbmcgYSByZXF1aXJlZCBjaGVja2JveCB2YWxpZGF0b3IgdXNpbmcgdGVtcGxhdGUtZHJpdmVuIGZvcm1zXG4gKlxuICogVGhlIGZvbGxvd2luZyBleGFtcGxlIHNob3dzIGhvdyB0byBhZGQgYSBjaGVja2JveCByZXF1aXJlZCB2YWxpZGF0b3IgdG8gYW4gaW5wdXQgYXR0YWNoZWQgdG8gYW5cbiAqIG5nTW9kZWwgYmluZGluZy5cbiAqXG4gKiBgYGBcbiAqIDxpbnB1dCB0eXBlPVwiY2hlY2tib3hcIiBuYW1lPVwiYWN0aXZlXCIgbmdNb2RlbCByZXF1aXJlZD5cbiAqIGBgYFxuICpcbiAqIEBwdWJsaWNBcGlcbiAqIEBuZ01vZHVsZSBGb3Jtc01vZHVsZVxuICogQG5nTW9kdWxlIFJlYWN0aXZlRm9ybXNNb2R1bGVcbiAqL1xuY2xhc3MgQ2hlY2tib3hSZXF1aXJlZFZhbGlkYXRvciBleHRlbmRzIFJlcXVpcmVkVmFsaWRhdG9yIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICB0aGlzLmNyZWF0ZVZhbGlkYXRvciA9IChpbnB1dCkgPT4gcmVxdWlyZWRUcnVlVmFsaWRhdG9yO1xuICAgIH1cbiAgICBzdGF0aWMgeyB0aGlzLsm1ZmFjID0gaTAuybXJtW5nRGVjbGFyZUZhY3RvcnkoeyBtaW5WZXJzaW9uOiBcIjEyLjAuMFwiLCB2ZXJzaW9uOiBcIjE3LjMuMTJcIiwgbmdJbXBvcnQ6IGkwLCB0eXBlOiBDaGVja2JveFJlcXVpcmVkVmFsaWRhdG9yLCBkZXBzOiBudWxsLCB0YXJnZXQ6IGkwLsm1ybVGYWN0b3J5VGFyZ2V0LkRpcmVjdGl2ZSB9KTsgfVxuICAgIHN0YXRpYyB7IHRoaXMuybVkaXIgPSBpMC7Jtcm1bmdEZWNsYXJlRGlyZWN0aXZlKHsgbWluVmVyc2lvbjogXCIxNC4wLjBcIiwgdmVyc2lvbjogXCIxNy4zLjEyXCIsIHR5cGU6IENoZWNrYm94UmVxdWlyZWRWYWxpZGF0b3IsIHNlbGVjdG9yOiBcImlucHV0W3R5cGU9Y2hlY2tib3hdW3JlcXVpcmVkXVtmb3JtQ29udHJvbE5hbWVdLGlucHV0W3R5cGU9Y2hlY2tib3hdW3JlcXVpcmVkXVtmb3JtQ29udHJvbF0saW5wdXRbdHlwZT1jaGVja2JveF1bcmVxdWlyZWRdW25nTW9kZWxdXCIsIGhvc3Q6IHsgcHJvcGVydGllczogeyBcImF0dHIucmVxdWlyZWRcIjogXCJfZW5hYmxlZCA/IFxcXCJcXFwiIDogbnVsbFwiIH0gfSwgcHJvdmlkZXJzOiBbQ0hFQ0tCT1hfUkVRVUlSRURfVkFMSURBVE9SXSwgdXNlc0luaGVyaXRhbmNlOiB0cnVlLCBuZ0ltcG9ydDogaTAgfSk7IH1cbn1cbmkwLsm1ybVuZ0RlY2xhcmVDbGFzc01ldGFkYXRhKHsgbWluVmVyc2lvbjogXCIxMi4wLjBcIiwgdmVyc2lvbjogXCIxNy4zLjEyXCIsIG5nSW1wb3J0OiBpMCwgdHlwZTogQ2hlY2tib3hSZXF1aXJlZFZhbGlkYXRvciwgZGVjb3JhdG9yczogW3tcbiAgICAgICAgICAgIHR5cGU6IERpcmVjdGl2ZSxcbiAgICAgICAgICAgIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnaW5wdXRbdHlwZT1jaGVja2JveF1bcmVxdWlyZWRdW2Zvcm1Db250cm9sTmFtZV0saW5wdXRbdHlwZT1jaGVja2JveF1bcmVxdWlyZWRdW2Zvcm1Db250cm9sXSxpbnB1dFt0eXBlPWNoZWNrYm94XVtyZXF1aXJlZF1bbmdNb2RlbF0nLFxuICAgICAgICAgICAgICAgICAgICBwcm92aWRlcnM6IFtDSEVDS0JPWF9SRVFVSVJFRF9WQUxJREFUT1JdLFxuICAgICAgICAgICAgICAgICAgICBob3N0OiB7ICdbYXR0ci5yZXF1aXJlZF0nOiAnX2VuYWJsZWQgPyBcIlwiIDogbnVsbCcgfVxuICAgICAgICAgICAgICAgIH1dXG4gICAgICAgIH1dIH0pO1xuLyoqXG4gKiBAZGVzY3JpcHRpb25cbiAqIFByb3ZpZGVyIHdoaWNoIGFkZHMgYEVtYWlsVmFsaWRhdG9yYCB0byB0aGUgYE5HX1ZBTElEQVRPUlNgIG11bHRpLXByb3ZpZGVyIGxpc3QuXG4gKi9cbmNvbnN0IEVNQUlMX1ZBTElEQVRPUiA9IHtcbiAgICBwcm92aWRlOiBOR19WQUxJREFUT1JTLFxuICAgIHVzZUV4aXN0aW5nOiBmb3J3YXJkUmVmKCgpID0+IEVtYWlsVmFsaWRhdG9yKSxcbiAgICBtdWx0aTogdHJ1ZVxufTtcbi8qKlxuICogQSBkaXJlY3RpdmUgdGhhdCBhZGRzIHRoZSBgZW1haWxgIHZhbGlkYXRvciB0byBjb250cm9scyBtYXJrZWQgd2l0aCB0aGVcbiAqIGBlbWFpbGAgYXR0cmlidXRlLiBUaGUgZGlyZWN0aXZlIGlzIHByb3ZpZGVkIHdpdGggdGhlIGBOR19WQUxJREFUT1JTYCBtdWx0aS1wcm92aWRlciBsaXN0LlxuICpcbiAqIFRoZSBlbWFpbCB2YWxpZGF0aW9uIGlzIGJhc2VkIG9uIHRoZSBXSEFUV0cgSFRNTCBzcGVjaWZpY2F0aW9uIHdpdGggc29tZSBlbmhhbmNlbWVudHMgdG9cbiAqIGluY29ycG9yYXRlIG1vcmUgUkZDIHJ1bGVzLiBNb3JlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBvbiB0aGUgW1ZhbGlkYXRvcnMuZW1haWxcbiAqIHBhZ2VdKGFwaS9mb3Jtcy9WYWxpZGF0b3JzI2VtYWlsKS5cbiAqXG4gKiBAc2VlIFtGb3JtIFZhbGlkYXRpb25dKGd1aWRlL2Zvcm0tdmFsaWRhdGlvbilcbiAqXG4gKiBAdXNhZ2VOb3Rlc1xuICpcbiAqICMjIyBBZGRpbmcgYW4gZW1haWwgdmFsaWRhdG9yXG4gKlxuICogVGhlIGZvbGxvd2luZyBleGFtcGxlIHNob3dzIGhvdyB0byBhZGQgYW4gZW1haWwgdmFsaWRhdG9yIHRvIGFuIGlucHV0IGF0dGFjaGVkIHRvIGFuIG5nTW9kZWxcbiAqIGJpbmRpbmcuXG4gKlxuICogYGBgXG4gKiA8aW5wdXQgdHlwZT1cImVtYWlsXCIgbmFtZT1cImVtYWlsXCIgbmdNb2RlbCBlbWFpbD5cbiAqIDxpbnB1dCB0eXBlPVwiZW1haWxcIiBuYW1lPVwiZW1haWxcIiBuZ01vZGVsIGVtYWlsPVwidHJ1ZVwiPlxuICogPGlucHV0IHR5cGU9XCJlbWFpbFwiIG5hbWU9XCJlbWFpbFwiIG5nTW9kZWwgW2VtYWlsXT1cInRydWVcIj5cbiAqIGBgYFxuICpcbiAqIEBwdWJsaWNBcGlcbiAqIEBuZ01vZHVsZSBGb3Jtc01vZHVsZVxuICogQG5nTW9kdWxlIFJlYWN0aXZlRm9ybXNNb2R1bGVcbiAqL1xuY2xhc3MgRW1haWxWYWxpZGF0b3IgZXh0ZW5kcyBBYnN0cmFjdFZhbGlkYXRvckRpcmVjdGl2ZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgdGhpcy5pbnB1dE5hbWUgPSAnZW1haWwnO1xuICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgIHRoaXMubm9ybWFsaXplSW5wdXQgPSBib29sZWFuQXR0cmlidXRlO1xuICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgIHRoaXMuY3JlYXRlVmFsaWRhdG9yID0gKGlucHV0KSA9PiBlbWFpbFZhbGlkYXRvcjtcbiAgICB9XG4gICAgLyoqIEBub2RvYyAqL1xuICAgIGVuYWJsZWQoaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIGlucHV0O1xuICAgIH1cbiAgICBzdGF0aWMgeyB0aGlzLsm1ZmFjID0gaTAuybXJtW5nRGVjbGFyZUZhY3RvcnkoeyBtaW5WZXJzaW9uOiBcIjEyLjAuMFwiLCB2ZXJzaW9uOiBcIjE3LjMuMTJcIiwgbmdJbXBvcnQ6IGkwLCB0eXBlOiBFbWFpbFZhbGlkYXRvciwgZGVwczogbnVsbCwgdGFyZ2V0OiBpMC7Jtcm1RmFjdG9yeVRhcmdldC5EaXJlY3RpdmUgfSk7IH1cbiAgICBzdGF0aWMgeyB0aGlzLsm1ZGlyID0gaTAuybXJtW5nRGVjbGFyZURpcmVjdGl2ZSh7IG1pblZlcnNpb246IFwiMTQuMC4wXCIsIHZlcnNpb246IFwiMTcuMy4xMlwiLCB0eXBlOiBFbWFpbFZhbGlkYXRvciwgc2VsZWN0b3I6IFwiW2VtYWlsXVtmb3JtQ29udHJvbE5hbWVdLFtlbWFpbF1bZm9ybUNvbnRyb2xdLFtlbWFpbF1bbmdNb2RlbF1cIiwgaW5wdXRzOiB7IGVtYWlsOiBcImVtYWlsXCIgfSwgcHJvdmlkZXJzOiBbRU1BSUxfVkFMSURBVE9SXSwgdXNlc0luaGVyaXRhbmNlOiB0cnVlLCBuZ0ltcG9ydDogaTAgfSk7IH1cbn1cbmkwLsm1ybVuZ0RlY2xhcmVDbGFzc01ldGFkYXRhKHsgbWluVmVyc2lvbjogXCIxMi4wLjBcIiwgdmVyc2lvbjogXCIxNy4zLjEyXCIsIG5nSW1wb3J0OiBpMCwgdHlwZTogRW1haWxWYWxpZGF0b3IsIGRlY29yYXRvcnM6IFt7XG4gICAgICAgICAgICB0eXBlOiBEaXJlY3RpdmUsXG4gICAgICAgICAgICBhcmdzOiBbe1xuICAgICAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ1tlbWFpbF1bZm9ybUNvbnRyb2xOYW1lXSxbZW1haWxdW2Zvcm1Db250cm9sXSxbZW1haWxdW25nTW9kZWxdJyxcbiAgICAgICAgICAgICAgICAgICAgcHJvdmlkZXJzOiBbRU1BSUxfVkFMSURBVE9SXVxuICAgICAgICAgICAgICAgIH1dXG4gICAgICAgIH1dLCBwcm9wRGVjb3JhdG9yczogeyBlbWFpbDogW3tcbiAgICAgICAgICAgICAgICB0eXBlOiBJbnB1dFxuICAgICAgICAgICAgfV0gfSB9KTtcbi8qKlxuICogQGRlc2NyaXB0aW9uXG4gKiBQcm92aWRlciB3aGljaCBhZGRzIGBNaW5MZW5ndGhWYWxpZGF0b3JgIHRvIHRoZSBgTkdfVkFMSURBVE9SU2AgbXVsdGktcHJvdmlkZXIgbGlzdC5cbiAqL1xuY29uc3QgTUlOX0xFTkdUSF9WQUxJREFUT1IgPSB7XG4gICAgcHJvdmlkZTogTkdfVkFMSURBVE9SUyxcbiAgICB1c2VFeGlzdGluZzogZm9yd2FyZFJlZigoKSA9PiBNaW5MZW5ndGhWYWxpZGF0b3IpLFxuICAgIG11bHRpOiB0cnVlXG59O1xuLyoqXG4gKiBBIGRpcmVjdGl2ZSB0aGF0IGFkZHMgbWluaW11bSBsZW5ndGggdmFsaWRhdGlvbiB0byBjb250cm9scyBtYXJrZWQgd2l0aCB0aGVcbiAqIGBtaW5sZW5ndGhgIGF0dHJpYnV0ZS4gVGhlIGRpcmVjdGl2ZSBpcyBwcm92aWRlZCB3aXRoIHRoZSBgTkdfVkFMSURBVE9SU2AgbXVsdGktcHJvdmlkZXIgbGlzdC5cbiAqXG4gKiBAc2VlIFtGb3JtIFZhbGlkYXRpb25dKGd1aWRlL2Zvcm0tdmFsaWRhdGlvbilcbiAqXG4gKiBAdXNhZ2VOb3Rlc1xuICpcbiAqICMjIyBBZGRpbmcgYSBtaW5pbXVtIGxlbmd0aCB2YWxpZGF0b3JcbiAqXG4gKiBUaGUgZm9sbG93aW5nIGV4YW1wbGUgc2hvd3MgaG93IHRvIGFkZCBhIG1pbmltdW0gbGVuZ3RoIHZhbGlkYXRvciB0byBhbiBpbnB1dCBhdHRhY2hlZCB0byBhblxuICogbmdNb2RlbCBiaW5kaW5nLlxuICpcbiAqIGBgYGh0bWxcbiAqIDxpbnB1dCBuYW1lPVwiZmlyc3ROYW1lXCIgbmdNb2RlbCBtaW5sZW5ndGg9XCI0XCI+XG4gKiBgYGBcbiAqXG4gKiBAbmdNb2R1bGUgUmVhY3RpdmVGb3Jtc01vZHVsZVxuICogQG5nTW9kdWxlIEZvcm1zTW9kdWxlXG4gKiBAcHVibGljQXBpXG4gKi9cbmNsYXNzIE1pbkxlbmd0aFZhbGlkYXRvciBleHRlbmRzIEFic3RyYWN0VmFsaWRhdG9yRGlyZWN0aXZlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICB0aGlzLmlucHV0TmFtZSA9ICdtaW5sZW5ndGgnO1xuICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgIHRoaXMubm9ybWFsaXplSW5wdXQgPSAoaW5wdXQpID0+IHRvSW50ZWdlcihpbnB1dCk7XG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgdGhpcy5jcmVhdGVWYWxpZGF0b3IgPSAobWlubGVuZ3RoKSA9PiBtaW5MZW5ndGhWYWxpZGF0b3IobWlubGVuZ3RoKTtcbiAgICB9XG4gICAgc3RhdGljIHsgdGhpcy7JtWZhYyA9IGkwLsm1ybVuZ0RlY2xhcmVGYWN0b3J5KHsgbWluVmVyc2lvbjogXCIxMi4wLjBcIiwgdmVyc2lvbjogXCIxNy4zLjEyXCIsIG5nSW1wb3J0OiBpMCwgdHlwZTogTWluTGVuZ3RoVmFsaWRhdG9yLCBkZXBzOiBudWxsLCB0YXJnZXQ6IGkwLsm1ybVGYWN0b3J5VGFyZ2V0LkRpcmVjdGl2ZSB9KTsgfVxuICAgIHN0YXRpYyB7IHRoaXMuybVkaXIgPSBpMC7Jtcm1bmdEZWNsYXJlRGlyZWN0aXZlKHsgbWluVmVyc2lvbjogXCIxNC4wLjBcIiwgdmVyc2lvbjogXCIxNy4zLjEyXCIsIHR5cGU6IE1pbkxlbmd0aFZhbGlkYXRvciwgc2VsZWN0b3I6IFwiW21pbmxlbmd0aF1bZm9ybUNvbnRyb2xOYW1lXSxbbWlubGVuZ3RoXVtmb3JtQ29udHJvbF0sW21pbmxlbmd0aF1bbmdNb2RlbF1cIiwgaW5wdXRzOiB7IG1pbmxlbmd0aDogXCJtaW5sZW5ndGhcIiB9LCBob3N0OiB7IHByb3BlcnRpZXM6IHsgXCJhdHRyLm1pbmxlbmd0aFwiOiBcIl9lbmFibGVkID8gbWlubGVuZ3RoIDogbnVsbFwiIH0gfSwgcHJvdmlkZXJzOiBbTUlOX0xFTkdUSF9WQUxJREFUT1JdLCB1c2VzSW5oZXJpdGFuY2U6IHRydWUsIG5nSW1wb3J0OiBpMCB9KTsgfVxufVxuaTAuybXJtW5nRGVjbGFyZUNsYXNzTWV0YWRhdGEoeyBtaW5WZXJzaW9uOiBcIjEyLjAuMFwiLCB2ZXJzaW9uOiBcIjE3LjMuMTJcIiwgbmdJbXBvcnQ6IGkwLCB0eXBlOiBNaW5MZW5ndGhWYWxpZGF0b3IsIGRlY29yYXRvcnM6IFt7XG4gICAgICAgICAgICB0eXBlOiBEaXJlY3RpdmUsXG4gICAgICAgICAgICBhcmdzOiBbe1xuICAgICAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ1ttaW5sZW5ndGhdW2Zvcm1Db250cm9sTmFtZV0sW21pbmxlbmd0aF1bZm9ybUNvbnRyb2xdLFttaW5sZW5ndGhdW25nTW9kZWxdJyxcbiAgICAgICAgICAgICAgICAgICAgcHJvdmlkZXJzOiBbTUlOX0xFTkdUSF9WQUxJREFUT1JdLFxuICAgICAgICAgICAgICAgICAgICBob3N0OiB7ICdbYXR0ci5taW5sZW5ndGhdJzogJ19lbmFibGVkID8gbWlubGVuZ3RoIDogbnVsbCcgfVxuICAgICAgICAgICAgICAgIH1dXG4gICAgICAgIH1dLCBwcm9wRGVjb3JhdG9yczogeyBtaW5sZW5ndGg6IFt7XG4gICAgICAgICAgICAgICAgdHlwZTogSW5wdXRcbiAgICAgICAgICAgIH1dIH0gfSk7XG4vKipcbiAqIEBkZXNjcmlwdGlvblxuICogUHJvdmlkZXIgd2hpY2ggYWRkcyBgTWF4TGVuZ3RoVmFsaWRhdG9yYCB0byB0aGUgYE5HX1ZBTElEQVRPUlNgIG11bHRpLXByb3ZpZGVyIGxpc3QuXG4gKi9cbmNvbnN0IE1BWF9MRU5HVEhfVkFMSURBVE9SID0ge1xuICAgIHByb3ZpZGU6IE5HX1ZBTElEQVRPUlMsXG4gICAgdXNlRXhpc3Rpbmc6IGZvcndhcmRSZWYoKCkgPT4gTWF4TGVuZ3RoVmFsaWRhdG9yKSxcbiAgICBtdWx0aTogdHJ1ZVxufTtcbi8qKlxuICogQSBkaXJlY3RpdmUgdGhhdCBhZGRzIG1heGltdW0gbGVuZ3RoIHZhbGlkYXRpb24gdG8gY29udHJvbHMgbWFya2VkIHdpdGggdGhlXG4gKiBgbWF4bGVuZ3RoYCBhdHRyaWJ1dGUuIFRoZSBkaXJlY3RpdmUgaXMgcHJvdmlkZWQgd2l0aCB0aGUgYE5HX1ZBTElEQVRPUlNgIG11bHRpLXByb3ZpZGVyIGxpc3QuXG4gKlxuICogQHNlZSBbRm9ybSBWYWxpZGF0aW9uXShndWlkZS9mb3JtLXZhbGlkYXRpb24pXG4gKlxuICogQHVzYWdlTm90ZXNcbiAqXG4gKiAjIyMgQWRkaW5nIGEgbWF4aW11bSBsZW5ndGggdmFsaWRhdG9yXG4gKlxuICogVGhlIGZvbGxvd2luZyBleGFtcGxlIHNob3dzIGhvdyB0byBhZGQgYSBtYXhpbXVtIGxlbmd0aCB2YWxpZGF0b3IgdG8gYW4gaW5wdXQgYXR0YWNoZWQgdG8gYW5cbiAqIG5nTW9kZWwgYmluZGluZy5cbiAqXG4gKiBgYGBodG1sXG4gKiA8aW5wdXQgbmFtZT1cImZpcnN0TmFtZVwiIG5nTW9kZWwgbWF4bGVuZ3RoPVwiMjVcIj5cbiAqIGBgYFxuICpcbiAqIEBuZ01vZHVsZSBSZWFjdGl2ZUZvcm1zTW9kdWxlXG4gKiBAbmdNb2R1bGUgRm9ybXNNb2R1bGVcbiAqIEBwdWJsaWNBcGlcbiAqL1xuY2xhc3MgTWF4TGVuZ3RoVmFsaWRhdG9yIGV4dGVuZHMgQWJzdHJhY3RWYWxpZGF0b3JEaXJlY3RpdmUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgIHRoaXMuaW5wdXROYW1lID0gJ21heGxlbmd0aCc7XG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgdGhpcy5ub3JtYWxpemVJbnB1dCA9IChpbnB1dCkgPT4gdG9JbnRlZ2VyKGlucHV0KTtcbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICB0aGlzLmNyZWF0ZVZhbGlkYXRvciA9IChtYXhsZW5ndGgpID0+IG1heExlbmd0aFZhbGlkYXRvcihtYXhsZW5ndGgpO1xuICAgIH1cbiAgICBzdGF0aWMgeyB0aGlzLsm1ZmFjID0gaTAuybXJtW5nRGVjbGFyZUZhY3RvcnkoeyBtaW5WZXJzaW9uOiBcIjEyLjAuMFwiLCB2ZXJzaW9uOiBcIjE3LjMuMTJcIiwgbmdJbXBvcnQ6IGkwLCB0eXBlOiBNYXhMZW5ndGhWYWxpZGF0b3IsIGRlcHM6IG51bGwsIHRhcmdldDogaTAuybXJtUZhY3RvcnlUYXJnZXQuRGlyZWN0aXZlIH0pOyB9XG4gICAgc3RhdGljIHsgdGhpcy7JtWRpciA9IGkwLsm1ybVuZ0RlY2xhcmVEaXJlY3RpdmUoeyBtaW5WZXJzaW9uOiBcIjE0LjAuMFwiLCB2ZXJzaW9uOiBcIjE3LjMuMTJcIiwgdHlwZTogTWF4TGVuZ3RoVmFsaWRhdG9yLCBzZWxlY3RvcjogXCJbbWF4bGVuZ3RoXVtmb3JtQ29udHJvbE5hbWVdLFttYXhsZW5ndGhdW2Zvcm1Db250cm9sXSxbbWF4bGVuZ3RoXVtuZ01vZGVsXVwiLCBpbnB1dHM6IHsgbWF4bGVuZ3RoOiBcIm1heGxlbmd0aFwiIH0sIGhvc3Q6IHsgcHJvcGVydGllczogeyBcImF0dHIubWF4bGVuZ3RoXCI6IFwiX2VuYWJsZWQgPyBtYXhsZW5ndGggOiBudWxsXCIgfSB9LCBwcm92aWRlcnM6IFtNQVhfTEVOR1RIX1ZBTElEQVRPUl0sIHVzZXNJbmhlcml0YW5jZTogdHJ1ZSwgbmdJbXBvcnQ6IGkwIH0pOyB9XG59XG5pMC7Jtcm1bmdEZWNsYXJlQ2xhc3NNZXRhZGF0YSh7IG1pblZlcnNpb246IFwiMTIuMC4wXCIsIHZlcnNpb246IFwiMTcuMy4xMlwiLCBuZ0ltcG9ydDogaTAsIHR5cGU6IE1heExlbmd0aFZhbGlkYXRvciwgZGVjb3JhdG9yczogW3tcbiAgICAgICAgICAgIHR5cGU6IERpcmVjdGl2ZSxcbiAgICAgICAgICAgIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdG9yOiAnW21heGxlbmd0aF1bZm9ybUNvbnRyb2xOYW1lXSxbbWF4bGVuZ3RoXVtmb3JtQ29udHJvbF0sW21heGxlbmd0aF1bbmdNb2RlbF0nLFxuICAgICAgICAgICAgICAgICAgICBwcm92aWRlcnM6IFtNQVhfTEVOR1RIX1ZBTElEQVRPUl0sXG4gICAgICAgICAgICAgICAgICAgIGhvc3Q6IHsgJ1thdHRyLm1heGxlbmd0aF0nOiAnX2VuYWJsZWQgPyBtYXhsZW5ndGggOiBudWxsJyB9XG4gICAgICAgICAgICAgICAgfV1cbiAgICAgICAgfV0sIHByb3BEZWNvcmF0b3JzOiB7IG1heGxlbmd0aDogW3tcbiAgICAgICAgICAgICAgICB0eXBlOiBJbnB1dFxuICAgICAgICAgICAgfV0gfSB9KTtcbi8qKlxuICogQGRlc2NyaXB0aW9uXG4gKiBQcm92aWRlciB3aGljaCBhZGRzIGBQYXR0ZXJuVmFsaWRhdG9yYCB0byB0aGUgYE5HX1ZBTElEQVRPUlNgIG11bHRpLXByb3ZpZGVyIGxpc3QuXG4gKi9cbmNvbnN0IFBBVFRFUk5fVkFMSURBVE9SID0ge1xuICAgIHByb3ZpZGU6IE5HX1ZBTElEQVRPUlMsXG4gICAgdXNlRXhpc3Rpbmc6IGZvcndhcmRSZWYoKCkgPT4gUGF0dGVyblZhbGlkYXRvciksXG4gICAgbXVsdGk6IHRydWVcbn07XG4vKipcbiAqIEBkZXNjcmlwdGlvblxuICogQSBkaXJlY3RpdmUgdGhhdCBhZGRzIHJlZ2V4IHBhdHRlcm4gdmFsaWRhdGlvbiB0byBjb250cm9scyBtYXJrZWQgd2l0aCB0aGVcbiAqIGBwYXR0ZXJuYCBhdHRyaWJ1dGUuIFRoZSByZWdleCBtdXN0IG1hdGNoIHRoZSBlbnRpcmUgY29udHJvbCB2YWx1ZS5cbiAqIFRoZSBkaXJlY3RpdmUgaXMgcHJvdmlkZWQgd2l0aCB0aGUgYE5HX1ZBTElEQVRPUlNgIG11bHRpLXByb3ZpZGVyIGxpc3QuXG4gKlxuICogQHNlZSBbRm9ybSBWYWxpZGF0aW9uXShndWlkZS9mb3JtLXZhbGlkYXRpb24pXG4gKlxuICogQHVzYWdlTm90ZXNcbiAqXG4gKiAjIyMgQWRkaW5nIGEgcGF0dGVybiB2YWxpZGF0b3JcbiAqXG4gKiBUaGUgZm9sbG93aW5nIGV4YW1wbGUgc2hvd3MgaG93IHRvIGFkZCBhIHBhdHRlcm4gdmFsaWRhdG9yIHRvIGFuIGlucHV0IGF0dGFjaGVkIHRvIGFuXG4gKiBuZ01vZGVsIGJpbmRpbmcuXG4gKlxuICogYGBgaHRtbFxuICogPGlucHV0IG5hbWU9XCJmaXJzdE5hbWVcIiBuZ01vZGVsIHBhdHRlcm49XCJbYS16QS1aIF0qXCI+XG4gKiBgYGBcbiAqXG4gKiBAbmdNb2R1bGUgUmVhY3RpdmVGb3Jtc01vZHVsZVxuICogQG5nTW9kdWxlIEZvcm1zTW9kdWxlXG4gKiBAcHVibGljQXBpXG4gKi9cbmNsYXNzIFBhdHRlcm5WYWxpZGF0b3IgZXh0ZW5kcyBBYnN0cmFjdFZhbGlkYXRvckRpcmVjdGl2ZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgdGhpcy5pbnB1dE5hbWUgPSAncGF0dGVybic7XG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgdGhpcy5ub3JtYWxpemVJbnB1dCA9IChpbnB1dCkgPT4gaW5wdXQ7XG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgdGhpcy5jcmVhdGVWYWxpZGF0b3IgPSAoaW5wdXQpID0+IHBhdHRlcm5WYWxpZGF0b3IoaW5wdXQpO1xuICAgIH1cbiAgICBzdGF0aWMgeyB0aGlzLsm1ZmFjID0gaTAuybXJtW5nRGVjbGFyZUZhY3RvcnkoeyBtaW5WZXJzaW9uOiBcIjEyLjAuMFwiLCB2ZXJzaW9uOiBcIjE3LjMuMTJcIiwgbmdJbXBvcnQ6IGkwLCB0eXBlOiBQYXR0ZXJuVmFsaWRhdG9yLCBkZXBzOiBudWxsLCB0YXJnZXQ6IGkwLsm1ybVGYWN0b3J5VGFyZ2V0LkRpcmVjdGl2ZSB9KTsgfVxuICAgIHN0YXRpYyB7IHRoaXMuybVkaXIgPSBpMC7Jtcm1bmdEZWNsYXJlRGlyZWN0aXZlKHsgbWluVmVyc2lvbjogXCIxNC4wLjBcIiwgdmVyc2lvbjogXCIxNy4zLjEyXCIsIHR5cGU6IFBhdHRlcm5WYWxpZGF0b3IsIHNlbGVjdG9yOiBcIltwYXR0ZXJuXVtmb3JtQ29udHJvbE5hbWVdLFtwYXR0ZXJuXVtmb3JtQ29udHJvbF0sW3BhdHRlcm5dW25nTW9kZWxdXCIsIGlucHV0czogeyBwYXR0ZXJuOiBcInBhdHRlcm5cIiB9LCBob3N0OiB7IHByb3BlcnRpZXM6IHsgXCJhdHRyLnBhdHRlcm5cIjogXCJfZW5hYmxlZCA/IHBhdHRlcm4gOiBudWxsXCIgfSB9LCBwcm92aWRlcnM6IFtQQVRURVJOX1ZBTElEQVRPUl0sIHVzZXNJbmhlcml0YW5jZTogdHJ1ZSwgbmdJbXBvcnQ6IGkwIH0pOyB9XG59XG5pMC7Jtcm1bmdEZWNsYXJlQ2xhc3NNZXRhZGF0YSh7IG1pblZlcnNpb246IFwiMTIuMC4wXCIsIHZlcnNpb246IFwiMTcuMy4xMlwiLCBuZ0ltcG9ydDogaTAsIHR5cGU6IFBhdHRlcm5WYWxpZGF0b3IsIGRlY29yYXRvcnM6IFt7XG4gICAgICAgICAgICB0eXBlOiBEaXJlY3RpdmUsXG4gICAgICAgICAgICBhcmdzOiBbe1xuICAgICAgICAgICAgICAgICAgICBzZWxlY3RvcjogJ1twYXR0ZXJuXVtmb3JtQ29udHJvbE5hbWVdLFtwYXR0ZXJuXVtmb3JtQ29udHJvbF0sW3BhdHRlcm5dW25nTW9kZWxdJyxcbiAgICAgICAgICAgICAgICAgICAgcHJvdmlkZXJzOiBbUEFUVEVSTl9WQUxJREFUT1JdLFxuICAgICAgICAgICAgICAgICAgICBob3N0OiB7ICdbYXR0ci5wYXR0ZXJuXSc6ICdfZW5hYmxlZCA/IHBhdHRlcm4gOiBudWxsJyB9XG4gICAgICAgICAgICAgICAgfV1cbiAgICAgICAgfV0sIHByb3BEZWNvcmF0b3JzOiB7IHBhdHRlcm46IFt7XG4gICAgICAgICAgICAgICAgdHlwZTogSW5wdXRcbiAgICAgICAgICAgIH1dIH0gfSk7XG5cbmNvbnN0IFNIQVJFRF9GT1JNX0RJUkVDVElWRVMgPSBbXG4gICAgybVOZ05vVmFsaWRhdGUsXG4gICAgTmdTZWxlY3RPcHRpb24sXG4gICAgybVOZ1NlbGVjdE11bHRpcGxlT3B0aW9uLFxuICAgIERlZmF1bHRWYWx1ZUFjY2Vzc29yLFxuICAgIE51bWJlclZhbHVlQWNjZXNzb3IsXG4gICAgUmFuZ2VWYWx1ZUFjY2Vzc29yLFxuICAgIENoZWNrYm94Q29udHJvbFZhbHVlQWNjZXNzb3IsXG4gICAgU2VsZWN0Q29udHJvbFZhbHVlQWNjZXNzb3IsXG4gICAgU2VsZWN0TXVsdGlwbGVDb250cm9sVmFsdWVBY2Nlc3NvcixcbiAgICBSYWRpb0NvbnRyb2xWYWx1ZUFjY2Vzc29yLFxuICAgIE5nQ29udHJvbFN0YXR1cyxcbiAgICBOZ0NvbnRyb2xTdGF0dXNHcm91cCxcbiAgICBSZXF1aXJlZFZhbGlkYXRvcixcbiAgICBNaW5MZW5ndGhWYWxpZGF0b3IsXG4gICAgTWF4TGVuZ3RoVmFsaWRhdG9yLFxuICAgIFBhdHRlcm5WYWxpZGF0b3IsXG4gICAgQ2hlY2tib3hSZXF1aXJlZFZhbGlkYXRvcixcbiAgICBFbWFpbFZhbGlkYXRvcixcbiAgICBNaW5WYWxpZGF0b3IsXG4gICAgTWF4VmFsaWRhdG9yLFxuXTtcbmNvbnN0IFRFTVBMQVRFX0RSSVZFTl9ESVJFQ1RJVkVTID0gW05nTW9kZWwsIE5nTW9kZWxHcm91cCwgTmdGb3JtXTtcbmNvbnN0IFJFQUNUSVZFX0RSSVZFTl9ESVJFQ1RJVkVTID0gW0Zvcm1Db250cm9sRGlyZWN0aXZlLCBGb3JtR3JvdXBEaXJlY3RpdmUsIEZvcm1Db250cm9sTmFtZSwgRm9ybUdyb3VwTmFtZSwgRm9ybUFycmF5TmFtZV07XG4vKipcbiAqIEludGVybmFsIG1vZHVsZSB1c2VkIGZvciBzaGFyaW5nIGRpcmVjdGl2ZXMgYmV0d2VlbiBGb3Jtc01vZHVsZSBhbmQgUmVhY3RpdmVGb3Jtc01vZHVsZVxuICovXG5jbGFzcyDJtUludGVybmFsRm9ybXNTaGFyZWRNb2R1bGUge1xuICAgIHN0YXRpYyB7IHRoaXMuybVmYWMgPSBpMC7Jtcm1bmdEZWNsYXJlRmFjdG9yeSh7IG1pblZlcnNpb246IFwiMTIuMC4wXCIsIHZlcnNpb246IFwiMTcuMy4xMlwiLCBuZ0ltcG9ydDogaTAsIHR5cGU6IMm1SW50ZXJuYWxGb3Jtc1NoYXJlZE1vZHVsZSwgZGVwczogW10sIHRhcmdldDogaTAuybXJtUZhY3RvcnlUYXJnZXQuTmdNb2R1bGUgfSk7IH1cbiAgICBzdGF0aWMgeyB0aGlzLsm1bW9kID0gaTAuybXJtW5nRGVjbGFyZU5nTW9kdWxlKHsgbWluVmVyc2lvbjogXCIxNC4wLjBcIiwgdmVyc2lvbjogXCIxNy4zLjEyXCIsIG5nSW1wb3J0OiBpMCwgdHlwZTogybVJbnRlcm5hbEZvcm1zU2hhcmVkTW9kdWxlLCBkZWNsYXJhdGlvbnM6IFvJtU5nTm9WYWxpZGF0ZSxcbiAgICAgICAgICAgIE5nU2VsZWN0T3B0aW9uLFxuICAgICAgICAgICAgybVOZ1NlbGVjdE11bHRpcGxlT3B0aW9uLFxuICAgICAgICAgICAgRGVmYXVsdFZhbHVlQWNjZXNzb3IsXG4gICAgICAgICAgICBOdW1iZXJWYWx1ZUFjY2Vzc29yLFxuICAgICAgICAgICAgUmFuZ2VWYWx1ZUFjY2Vzc29yLFxuICAgICAgICAgICAgQ2hlY2tib3hDb250cm9sVmFsdWVBY2Nlc3NvcixcbiAgICAgICAgICAgIFNlbGVjdENvbnRyb2xWYWx1ZUFjY2Vzc29yLFxuICAgICAgICAgICAgU2VsZWN0TXVsdGlwbGVDb250cm9sVmFsdWVBY2Nlc3NvcixcbiAgICAgICAgICAgIFJhZGlvQ29udHJvbFZhbHVlQWNjZXNzb3IsXG4gICAgICAgICAgICBOZ0NvbnRyb2xTdGF0dXMsXG4gICAgICAgICAgICBOZ0NvbnRyb2xTdGF0dXNHcm91cCxcbiAgICAgICAgICAgIFJlcXVpcmVkVmFsaWRhdG9yLFxuICAgICAgICAgICAgTWluTGVuZ3RoVmFsaWRhdG9yLFxuICAgICAgICAgICAgTWF4TGVuZ3RoVmFsaWRhdG9yLFxuICAgICAgICAgICAgUGF0dGVyblZhbGlkYXRvcixcbiAgICAgICAgICAgIENoZWNrYm94UmVxdWlyZWRWYWxpZGF0b3IsXG4gICAgICAgICAgICBFbWFpbFZhbGlkYXRvcixcbiAgICAgICAgICAgIE1pblZhbGlkYXRvcixcbiAgICAgICAgICAgIE1heFZhbGlkYXRvcl0sIGV4cG9ydHM6IFvJtU5nTm9WYWxpZGF0ZSxcbiAgICAgICAgICAgIE5nU2VsZWN0T3B0aW9uLFxuICAgICAgICAgICAgybVOZ1NlbGVjdE11bHRpcGxlT3B0aW9uLFxuICAgICAgICAgICAgRGVmYXVsdFZhbHVlQWNjZXNzb3IsXG4gICAgICAgICAgICBOdW1iZXJWYWx1ZUFjY2Vzc29yLFxuICAgICAgICAgICAgUmFuZ2VWYWx1ZUFjY2Vzc29yLFxuICAgICAgICAgICAgQ2hlY2tib3hDb250cm9sVmFsdWVBY2Nlc3NvcixcbiAgICAgICAgICAgIFNlbGVjdENvbnRyb2xWYWx1ZUFjY2Vzc29yLFxuICAgICAgICAgICAgU2VsZWN0TXVsdGlwbGVDb250cm9sVmFsdWVBY2Nlc3NvcixcbiAgICAgICAgICAgIFJhZGlvQ29udHJvbFZhbHVlQWNjZXNzb3IsXG4gICAgICAgICAgICBOZ0NvbnRyb2xTdGF0dXMsXG4gICAgICAgICAgICBOZ0NvbnRyb2xTdGF0dXNHcm91cCxcbiAgICAgICAgICAgIFJlcXVpcmVkVmFsaWRhdG9yLFxuICAgICAgICAgICAgTWluTGVuZ3RoVmFsaWRhdG9yLFxuICAgICAgICAgICAgTWF4TGVuZ3RoVmFsaWRhdG9yLFxuICAgICAgICAgICAgUGF0dGVyblZhbGlkYXRvcixcbiAgICAgICAgICAgIENoZWNrYm94UmVxdWlyZWRWYWxpZGF0b3IsXG4gICAgICAgICAgICBFbWFpbFZhbGlkYXRvcixcbiAgICAgICAgICAgIE1pblZhbGlkYXRvcixcbiAgICAgICAgICAgIE1heFZhbGlkYXRvcl0gfSk7IH1cbiAgICBzdGF0aWMgeyB0aGlzLsm1aW5qID0gaTAuybXJtW5nRGVjbGFyZUluamVjdG9yKHsgbWluVmVyc2lvbjogXCIxMi4wLjBcIiwgdmVyc2lvbjogXCIxNy4zLjEyXCIsIG5nSW1wb3J0OiBpMCwgdHlwZTogybVJbnRlcm5hbEZvcm1zU2hhcmVkTW9kdWxlIH0pOyB9XG59XG5pMC7Jtcm1bmdEZWNsYXJlQ2xhc3NNZXRhZGF0YSh7IG1pblZlcnNpb246IFwiMTIuMC4wXCIsIHZlcnNpb246IFwiMTcuMy4xMlwiLCBuZ0ltcG9ydDogaTAsIHR5cGU6IMm1SW50ZXJuYWxGb3Jtc1NoYXJlZE1vZHVsZSwgZGVjb3JhdG9yczogW3tcbiAgICAgICAgICAgIHR5cGU6IE5nTW9kdWxlLFxuICAgICAgICAgICAgYXJnczogW3tcbiAgICAgICAgICAgICAgICAgICAgZGVjbGFyYXRpb25zOiBTSEFSRURfRk9STV9ESVJFQ1RJVkVTLFxuICAgICAgICAgICAgICAgICAgICBleHBvcnRzOiBTSEFSRURfRk9STV9ESVJFQ1RJVkVTLFxuICAgICAgICAgICAgICAgIH1dXG4gICAgICAgIH1dIH0pO1xuXG4vKipcbiAqIFRyYWNrcyB0aGUgdmFsdWUgYW5kIHZhbGlkaXR5IHN0YXRlIG9mIGFuIGFycmF5IG9mIGBGb3JtQ29udHJvbGAsXG4gKiBgRm9ybUdyb3VwYCBvciBgRm9ybUFycmF5YCBpbnN0YW5jZXMuXG4gKlxuICogQSBgRm9ybUFycmF5YCBhZ2dyZWdhdGVzIHRoZSB2YWx1ZXMgb2YgZWFjaCBjaGlsZCBgRm9ybUNvbnRyb2xgIGludG8gYW4gYXJyYXkuXG4gKiBJdCBjYWxjdWxhdGVzIGl0cyBzdGF0dXMgYnkgcmVkdWNpbmcgdGhlIHN0YXR1cyB2YWx1ZXMgb2YgaXRzIGNoaWxkcmVuLiBGb3IgZXhhbXBsZSwgaWYgb25lIG9mXG4gKiB0aGUgY29udHJvbHMgaW4gYSBgRm9ybUFycmF5YCBpcyBpbnZhbGlkLCB0aGUgZW50aXJlIGFycmF5IGJlY29tZXMgaW52YWxpZC5cbiAqXG4gKiBgRm9ybUFycmF5YCBhY2NlcHRzIG9uZSBnZW5lcmljIGFyZ3VtZW50LCB3aGljaCBpcyB0aGUgdHlwZSBvZiB0aGUgY29udHJvbHMgaW5zaWRlLlxuICogSWYgeW91IG5lZWQgYSBoZXRlcm9nZW5vdXMgYXJyYXksIHVzZSB7QGxpbmsgVW50eXBlZEZvcm1BcnJheX0uXG4gKlxuICogYEZvcm1BcnJheWAgaXMgb25lIG9mIHRoZSBmb3VyIGZ1bmRhbWVudGFsIGJ1aWxkaW5nIGJsb2NrcyB1c2VkIHRvIGRlZmluZSBmb3JtcyBpbiBBbmd1bGFyLFxuICogYWxvbmcgd2l0aCBgRm9ybUNvbnRyb2xgLCBgRm9ybUdyb3VwYCwgYW5kIGBGb3JtUmVjb3JkYC5cbiAqXG4gKiBAdXNhZ2VOb3Rlc1xuICpcbiAqICMjIyBDcmVhdGUgYW4gYXJyYXkgb2YgZm9ybSBjb250cm9sc1xuICpcbiAqIGBgYFxuICogY29uc3QgYXJyID0gbmV3IEZvcm1BcnJheShbXG4gKiAgIG5ldyBGb3JtQ29udHJvbCgnTmFuY3knLCBWYWxpZGF0b3JzLm1pbkxlbmd0aCgyKSksXG4gKiAgIG5ldyBGb3JtQ29udHJvbCgnRHJldycpLFxuICogXSk7XG4gKlxuICogY29uc29sZS5sb2coYXJyLnZhbHVlKTsgICAvLyBbJ05hbmN5JywgJ0RyZXcnXVxuICogY29uc29sZS5sb2coYXJyLnN0YXR1cyk7ICAvLyAnVkFMSUQnXG4gKiBgYGBcbiAqXG4gKiAjIyMgQ3JlYXRlIGEgZm9ybSBhcnJheSB3aXRoIGFycmF5LWxldmVsIHZhbGlkYXRvcnNcbiAqXG4gKiBZb3UgaW5jbHVkZSBhcnJheS1sZXZlbCB2YWxpZGF0b3JzIGFuZCBhc3luYyB2YWxpZGF0b3JzLiBUaGVzZSBjb21lIGluIGhhbmR5XG4gKiB3aGVuIHlvdSB3YW50IHRvIHBlcmZvcm0gdmFsaWRhdGlvbiB0aGF0IGNvbnNpZGVycyB0aGUgdmFsdWUgb2YgbW9yZSB0aGFuIG9uZSBjaGlsZFxuICogY29udHJvbC5cbiAqXG4gKiBUaGUgdHdvIHR5cGVzIG9mIHZhbGlkYXRvcnMgYXJlIHBhc3NlZCBpbiBzZXBhcmF0ZWx5IGFzIHRoZSBzZWNvbmQgYW5kIHRoaXJkIGFyZ1xuICogcmVzcGVjdGl2ZWx5LCBvciB0b2dldGhlciBhcyBwYXJ0IG9mIGFuIG9wdGlvbnMgb2JqZWN0LlxuICpcbiAqIGBgYFxuICogY29uc3QgYXJyID0gbmV3IEZvcm1BcnJheShbXG4gKiAgIG5ldyBGb3JtQ29udHJvbCgnTmFuY3knKSxcbiAqICAgbmV3IEZvcm1Db250cm9sKCdEcmV3JylcbiAqIF0sIHt2YWxpZGF0b3JzOiBteVZhbGlkYXRvciwgYXN5bmNWYWxpZGF0b3JzOiBteUFzeW5jVmFsaWRhdG9yfSk7XG4gKiBgYGBcbiAqXG4gKiAjIyMgU2V0IHRoZSB1cGRhdGVPbiBwcm9wZXJ0eSBmb3IgYWxsIGNvbnRyb2xzIGluIGEgZm9ybSBhcnJheVxuICpcbiAqIFRoZSBvcHRpb25zIG9iamVjdCBpcyB1c2VkIHRvIHNldCBhIGRlZmF1bHQgdmFsdWUgZm9yIGVhY2ggY2hpbGRcbiAqIGNvbnRyb2wncyBgdXBkYXRlT25gIHByb3BlcnR5LiBJZiB5b3Ugc2V0IGB1cGRhdGVPbmAgdG8gYCdibHVyJ2AgYXQgdGhlXG4gKiBhcnJheSBsZXZlbCwgYWxsIGNoaWxkIGNvbnRyb2xzIGRlZmF1bHQgdG8gJ2JsdXInLCB1bmxlc3MgdGhlIGNoaWxkXG4gKiBoYXMgZXhwbGljaXRseSBzcGVjaWZpZWQgYSBkaWZmZXJlbnQgYHVwZGF0ZU9uYCB2YWx1ZS5cbiAqXG4gKiBgYGB0c1xuICogY29uc3QgYXJyID0gbmV3IEZvcm1BcnJheShbXG4gKiAgICBuZXcgRm9ybUNvbnRyb2woKVxuICogXSwge3VwZGF0ZU9uOiAnYmx1cid9KTtcbiAqIGBgYFxuICpcbiAqICMjIyBBZGRpbmcgb3IgcmVtb3ZpbmcgY29udHJvbHMgZnJvbSBhIGZvcm0gYXJyYXlcbiAqXG4gKiBUbyBjaGFuZ2UgdGhlIGNvbnRyb2xzIGluIHRoZSBhcnJheSwgdXNlIHRoZSBgcHVzaGAsIGBpbnNlcnRgLCBgcmVtb3ZlQXRgIG9yIGBjbGVhcmAgbWV0aG9kc1xuICogaW4gYEZvcm1BcnJheWAgaXRzZWxmLiBUaGVzZSBtZXRob2RzIGVuc3VyZSB0aGUgY29udHJvbHMgYXJlIHByb3Blcmx5IHRyYWNrZWQgaW4gdGhlXG4gKiBmb3JtJ3MgaGllcmFyY2h5LiBEbyBub3QgbW9kaWZ5IHRoZSBhcnJheSBvZiBgQWJzdHJhY3RDb250cm9sYHMgdXNlZCB0byBpbnN0YW50aWF0ZVxuICogdGhlIGBGb3JtQXJyYXlgIGRpcmVjdGx5LCBhcyB0aGF0IHJlc3VsdCBpbiBzdHJhbmdlIGFuZCB1bmV4cGVjdGVkIGJlaGF2aW9yIHN1Y2hcbiAqIGFzIGJyb2tlbiBjaGFuZ2UgZGV0ZWN0aW9uLlxuICpcbiAqIEBwdWJsaWNBcGlcbiAqL1xuY2xhc3MgRm9ybUFycmF5IGV4dGVuZHMgQWJzdHJhY3RDb250cm9sIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGBGb3JtQXJyYXlgIGluc3RhbmNlLlxuICAgICAqXG4gICAgICogQHBhcmFtIGNvbnRyb2xzIEFuIGFycmF5IG9mIGNoaWxkIGNvbnRyb2xzLiBFYWNoIGNoaWxkIGNvbnRyb2wgaXMgZ2l2ZW4gYW4gaW5kZXhcbiAgICAgKiB3aGVyZSBpdCBpcyByZWdpc3RlcmVkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHZhbGlkYXRvck9yT3B0cyBBIHN5bmNocm9ub3VzIHZhbGlkYXRvciBmdW5jdGlvbiwgb3IgYW4gYXJyYXkgb2ZcbiAgICAgKiBzdWNoIGZ1bmN0aW9ucywgb3IgYW4gYEFic3RyYWN0Q29udHJvbE9wdGlvbnNgIG9iamVjdCB0aGF0IGNvbnRhaW5zIHZhbGlkYXRpb24gZnVuY3Rpb25zXG4gICAgICogYW5kIGEgdmFsaWRhdGlvbiB0cmlnZ2VyLlxuICAgICAqXG4gICAgICogQHBhcmFtIGFzeW5jVmFsaWRhdG9yIEEgc2luZ2xlIGFzeW5jIHZhbGlkYXRvciBvciBhcnJheSBvZiBhc3luYyB2YWxpZGF0b3IgZnVuY3Rpb25zXG4gICAgICpcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihjb250cm9scywgdmFsaWRhdG9yT3JPcHRzLCBhc3luY1ZhbGlkYXRvcikge1xuICAgICAgICBzdXBlcihwaWNrVmFsaWRhdG9ycyh2YWxpZGF0b3JPck9wdHMpLCBwaWNrQXN5bmNWYWxpZGF0b3JzKGFzeW5jVmFsaWRhdG9yLCB2YWxpZGF0b3JPck9wdHMpKTtcbiAgICAgICAgdGhpcy5jb250cm9scyA9IGNvbnRyb2xzO1xuICAgICAgICB0aGlzLl9pbml0T2JzZXJ2YWJsZXMoKTtcbiAgICAgICAgdGhpcy5fc2V0VXBkYXRlU3RyYXRlZ3kodmFsaWRhdG9yT3JPcHRzKTtcbiAgICAgICAgdGhpcy5fc2V0VXBDb250cm9scygpO1xuICAgICAgICB0aGlzLnVwZGF0ZVZhbHVlQW5kVmFsaWRpdHkoe1xuICAgICAgICAgICAgb25seVNlbGY6IHRydWUsXG4gICAgICAgICAgICAvLyBJZiBgYXN5bmNWYWxpZGF0b3JgIGlzIHByZXNlbnQsIGl0IHdpbGwgdHJpZ2dlciBjb250cm9sIHN0YXR1cyBjaGFuZ2UgZnJvbSBgUEVORElOR2AgdG9cbiAgICAgICAgICAgIC8vIGBWQUxJRGAgb3IgYElOVkFMSURgLlxuICAgICAgICAgICAgLy8gVGhlIHN0YXR1cyBzaG91bGQgYmUgYnJvYWRjYXN0ZWQgdmlhIHRoZSBgc3RhdHVzQ2hhbmdlc2Agb2JzZXJ2YWJsZSwgc28gd2Ugc2V0IGBlbWl0RXZlbnRgXG4gICAgICAgICAgICAvLyB0byBgdHJ1ZWAgdG8gYWxsb3cgdGhhdCBkdXJpbmcgdGhlIGNvbnRyb2wgY3JlYXRpb24gcHJvY2Vzcy5cbiAgICAgICAgICAgIGVtaXRFdmVudDogISF0aGlzLmFzeW5jVmFsaWRhdG9yXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGBBYnN0cmFjdENvbnRyb2xgIGF0IHRoZSBnaXZlbiBgaW5kZXhgIGluIHRoZSBhcnJheS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBpbmRleCBJbmRleCBpbiB0aGUgYXJyYXkgdG8gcmV0cmlldmUgdGhlIGNvbnRyb2wuIElmIGBpbmRleGAgaXMgbmVnYXRpdmUsIGl0IHdpbGwgd3JhcFxuICAgICAqICAgICBhcm91bmQgZnJvbSB0aGUgYmFjaywgYW5kIGlmIGluZGV4IGlzIGdyZWF0bHkgbmVnYXRpdmUgKGxlc3MgdGhhbiBgLWxlbmd0aGApLCB0aGUgcmVzdWx0IGlzXG4gICAgICogdW5kZWZpbmVkLiBUaGlzIGJlaGF2aW9yIGlzIHRoZSBzYW1lIGFzIGBBcnJheS5hdChpbmRleClgLlxuICAgICAqL1xuICAgIGF0KGluZGV4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnRyb2xzW3RoaXMuX2FkanVzdEluZGV4KGluZGV4KV07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEluc2VydCBhIG5ldyBgQWJzdHJhY3RDb250cm9sYCBhdCB0aGUgZW5kIG9mIHRoZSBhcnJheS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBjb250cm9sIEZvcm0gY29udHJvbCB0byBiZSBpbnNlcnRlZFxuICAgICAqIEBwYXJhbSBvcHRpb25zIFNwZWNpZmllcyB3aGV0aGVyIHRoaXMgRm9ybUFycmF5IGluc3RhbmNlIHNob3VsZCBlbWl0IGV2ZW50cyBhZnRlciBhIG5ld1xuICAgICAqICAgICBjb250cm9sIGlzIGFkZGVkLlxuICAgICAqICogYGVtaXRFdmVudGA6IFdoZW4gdHJ1ZSBvciBub3Qgc3VwcGxpZWQgKHRoZSBkZWZhdWx0KSwgYm90aCB0aGUgYHN0YXR1c0NoYW5nZXNgIGFuZFxuICAgICAqIGB2YWx1ZUNoYW5nZXNgIG9ic2VydmFibGVzIGVtaXQgZXZlbnRzIHdpdGggdGhlIGxhdGVzdCBzdGF0dXMgYW5kIHZhbHVlIHdoZW4gdGhlIGNvbnRyb2wgaXNcbiAgICAgKiBpbnNlcnRlZC4gV2hlbiBmYWxzZSwgbm8gZXZlbnRzIGFyZSBlbWl0dGVkLlxuICAgICAqL1xuICAgIHB1c2goY29udHJvbCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIHRoaXMuY29udHJvbHMucHVzaChjb250cm9sKTtcbiAgICAgICAgdGhpcy5fcmVnaXN0ZXJDb250cm9sKGNvbnRyb2wpO1xuICAgICAgICB0aGlzLnVwZGF0ZVZhbHVlQW5kVmFsaWRpdHkoeyBlbWl0RXZlbnQ6IG9wdGlvbnMuZW1pdEV2ZW50IH0pO1xuICAgICAgICB0aGlzLl9vbkNvbGxlY3Rpb25DaGFuZ2UoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSW5zZXJ0IGEgbmV3IGBBYnN0cmFjdENvbnRyb2xgIGF0IHRoZSBnaXZlbiBgaW5kZXhgIGluIHRoZSBhcnJheS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBpbmRleCBJbmRleCBpbiB0aGUgYXJyYXkgdG8gaW5zZXJ0IHRoZSBjb250cm9sLiBJZiBgaW5kZXhgIGlzIG5lZ2F0aXZlLCB3cmFwcyBhcm91bmRcbiAgICAgKiAgICAgZnJvbSB0aGUgYmFjay4gSWYgYGluZGV4YCBpcyBncmVhdGx5IG5lZ2F0aXZlIChsZXNzIHRoYW4gYC1sZW5ndGhgKSwgcHJlcGVuZHMgdG8gdGhlIGFycmF5LlxuICAgICAqIFRoaXMgYmVoYXZpb3IgaXMgdGhlIHNhbWUgYXMgYEFycmF5LnNwbGljZShpbmRleCwgMCwgY29udHJvbClgLlxuICAgICAqIEBwYXJhbSBjb250cm9sIEZvcm0gY29udHJvbCB0byBiZSBpbnNlcnRlZFxuICAgICAqIEBwYXJhbSBvcHRpb25zIFNwZWNpZmllcyB3aGV0aGVyIHRoaXMgRm9ybUFycmF5IGluc3RhbmNlIHNob3VsZCBlbWl0IGV2ZW50cyBhZnRlciBhIG5ld1xuICAgICAqICAgICBjb250cm9sIGlzIGluc2VydGVkLlxuICAgICAqICogYGVtaXRFdmVudGA6IFdoZW4gdHJ1ZSBvciBub3Qgc3VwcGxpZWQgKHRoZSBkZWZhdWx0KSwgYm90aCB0aGUgYHN0YXR1c0NoYW5nZXNgIGFuZFxuICAgICAqIGB2YWx1ZUNoYW5nZXNgIG9ic2VydmFibGVzIGVtaXQgZXZlbnRzIHdpdGggdGhlIGxhdGVzdCBzdGF0dXMgYW5kIHZhbHVlIHdoZW4gdGhlIGNvbnRyb2wgaXNcbiAgICAgKiBpbnNlcnRlZC4gV2hlbiBmYWxzZSwgbm8gZXZlbnRzIGFyZSBlbWl0dGVkLlxuICAgICAqL1xuICAgIGluc2VydChpbmRleCwgY29udHJvbCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIHRoaXMuY29udHJvbHMuc3BsaWNlKGluZGV4LCAwLCBjb250cm9sKTtcbiAgICAgICAgdGhpcy5fcmVnaXN0ZXJDb250cm9sKGNvbnRyb2wpO1xuICAgICAgICB0aGlzLnVwZGF0ZVZhbHVlQW5kVmFsaWRpdHkoeyBlbWl0RXZlbnQ6IG9wdGlvbnMuZW1pdEV2ZW50IH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZW1vdmUgdGhlIGNvbnRyb2wgYXQgdGhlIGdpdmVuIGBpbmRleGAgaW4gdGhlIGFycmF5LlxuICAgICAqXG4gICAgICogQHBhcmFtIGluZGV4IEluZGV4IGluIHRoZSBhcnJheSB0byByZW1vdmUgdGhlIGNvbnRyb2wuICBJZiBgaW5kZXhgIGlzIG5lZ2F0aXZlLCB3cmFwcyBhcm91bmRcbiAgICAgKiAgICAgZnJvbSB0aGUgYmFjay4gSWYgYGluZGV4YCBpcyBncmVhdGx5IG5lZ2F0aXZlIChsZXNzIHRoYW4gYC1sZW5ndGhgKSwgcmVtb3ZlcyB0aGUgZmlyc3RcbiAgICAgKiAgICAgZWxlbWVudC4gVGhpcyBiZWhhdmlvciBpcyB0aGUgc2FtZSBhcyBgQXJyYXkuc3BsaWNlKGluZGV4LCAxKWAuXG4gICAgICogQHBhcmFtIG9wdGlvbnMgU3BlY2lmaWVzIHdoZXRoZXIgdGhpcyBGb3JtQXJyYXkgaW5zdGFuY2Ugc2hvdWxkIGVtaXQgZXZlbnRzIGFmdGVyIGFcbiAgICAgKiAgICAgY29udHJvbCBpcyByZW1vdmVkLlxuICAgICAqICogYGVtaXRFdmVudGA6IFdoZW4gdHJ1ZSBvciBub3Qgc3VwcGxpZWQgKHRoZSBkZWZhdWx0KSwgYm90aCB0aGUgYHN0YXR1c0NoYW5nZXNgIGFuZFxuICAgICAqIGB2YWx1ZUNoYW5nZXNgIG9ic2VydmFibGVzIGVtaXQgZXZlbnRzIHdpdGggdGhlIGxhdGVzdCBzdGF0dXMgYW5kIHZhbHVlIHdoZW4gdGhlIGNvbnRyb2wgaXNcbiAgICAgKiByZW1vdmVkLiBXaGVuIGZhbHNlLCBubyBldmVudHMgYXJlIGVtaXR0ZWQuXG4gICAgICovXG4gICAgcmVtb3ZlQXQoaW5kZXgsIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICAvLyBBZGp1c3QgdGhlIGluZGV4LCB0aGVuIGNsYW1wIGl0IGF0IG5vIGxlc3MgdGhhbiAwIHRvIHByZXZlbnQgdW5kZXNpcmVkIHVuZGVyZmxvd3MuXG4gICAgICAgIGxldCBhZGp1c3RlZEluZGV4ID0gdGhpcy5fYWRqdXN0SW5kZXgoaW5kZXgpO1xuICAgICAgICBpZiAoYWRqdXN0ZWRJbmRleCA8IDApXG4gICAgICAgICAgICBhZGp1c3RlZEluZGV4ID0gMDtcbiAgICAgICAgaWYgKHRoaXMuY29udHJvbHNbYWRqdXN0ZWRJbmRleF0pXG4gICAgICAgICAgICB0aGlzLmNvbnRyb2xzW2FkanVzdGVkSW5kZXhdLl9yZWdpc3Rlck9uQ29sbGVjdGlvbkNoYW5nZSgoKSA9PiB7IH0pO1xuICAgICAgICB0aGlzLmNvbnRyb2xzLnNwbGljZShhZGp1c3RlZEluZGV4LCAxKTtcbiAgICAgICAgdGhpcy51cGRhdGVWYWx1ZUFuZFZhbGlkaXR5KHsgZW1pdEV2ZW50OiBvcHRpb25zLmVtaXRFdmVudCB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVwbGFjZSBhbiBleGlzdGluZyBjb250cm9sLlxuICAgICAqXG4gICAgICogQHBhcmFtIGluZGV4IEluZGV4IGluIHRoZSBhcnJheSB0byByZXBsYWNlIHRoZSBjb250cm9sLiBJZiBgaW5kZXhgIGlzIG5lZ2F0aXZlLCB3cmFwcyBhcm91bmRcbiAgICAgKiAgICAgZnJvbSB0aGUgYmFjay4gSWYgYGluZGV4YCBpcyBncmVhdGx5IG5lZ2F0aXZlIChsZXNzIHRoYW4gYC1sZW5ndGhgKSwgcmVwbGFjZXMgdGhlIGZpcnN0XG4gICAgICogICAgIGVsZW1lbnQuIFRoaXMgYmVoYXZpb3IgaXMgdGhlIHNhbWUgYXMgYEFycmF5LnNwbGljZShpbmRleCwgMSwgY29udHJvbClgLlxuICAgICAqIEBwYXJhbSBjb250cm9sIFRoZSBgQWJzdHJhY3RDb250cm9sYCBjb250cm9sIHRvIHJlcGxhY2UgdGhlIGV4aXN0aW5nIGNvbnRyb2xcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBTcGVjaWZpZXMgd2hldGhlciB0aGlzIEZvcm1BcnJheSBpbnN0YW5jZSBzaG91bGQgZW1pdCBldmVudHMgYWZ0ZXIgYW5cbiAgICAgKiAgICAgZXhpc3RpbmcgY29udHJvbCBpcyByZXBsYWNlZCB3aXRoIGEgbmV3IG9uZS5cbiAgICAgKiAqIGBlbWl0RXZlbnRgOiBXaGVuIHRydWUgb3Igbm90IHN1cHBsaWVkICh0aGUgZGVmYXVsdCksIGJvdGggdGhlIGBzdGF0dXNDaGFuZ2VzYCBhbmRcbiAgICAgKiBgdmFsdWVDaGFuZ2VzYCBvYnNlcnZhYmxlcyBlbWl0IGV2ZW50cyB3aXRoIHRoZSBsYXRlc3Qgc3RhdHVzIGFuZCB2YWx1ZSB3aGVuIHRoZSBjb250cm9sIGlzXG4gICAgICogcmVwbGFjZWQgd2l0aCBhIG5ldyBvbmUuIFdoZW4gZmFsc2UsIG5vIGV2ZW50cyBhcmUgZW1pdHRlZC5cbiAgICAgKi9cbiAgICBzZXRDb250cm9sKGluZGV4LCBjb250cm9sLCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgLy8gQWRqdXN0IHRoZSBpbmRleCwgdGhlbiBjbGFtcCBpdCBhdCBubyBsZXNzIHRoYW4gMCB0byBwcmV2ZW50IHVuZGVzaXJlZCB1bmRlcmZsb3dzLlxuICAgICAgICBsZXQgYWRqdXN0ZWRJbmRleCA9IHRoaXMuX2FkanVzdEluZGV4KGluZGV4KTtcbiAgICAgICAgaWYgKGFkanVzdGVkSW5kZXggPCAwKVxuICAgICAgICAgICAgYWRqdXN0ZWRJbmRleCA9IDA7XG4gICAgICAgIGlmICh0aGlzLmNvbnRyb2xzW2FkanVzdGVkSW5kZXhdKVxuICAgICAgICAgICAgdGhpcy5jb250cm9sc1thZGp1c3RlZEluZGV4XS5fcmVnaXN0ZXJPbkNvbGxlY3Rpb25DaGFuZ2UoKCkgPT4geyB9KTtcbiAgICAgICAgdGhpcy5jb250cm9scy5zcGxpY2UoYWRqdXN0ZWRJbmRleCwgMSk7XG4gICAgICAgIGlmIChjb250cm9sKSB7XG4gICAgICAgICAgICB0aGlzLmNvbnRyb2xzLnNwbGljZShhZGp1c3RlZEluZGV4LCAwLCBjb250cm9sKTtcbiAgICAgICAgICAgIHRoaXMuX3JlZ2lzdGVyQ29udHJvbChjb250cm9sKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnVwZGF0ZVZhbHVlQW5kVmFsaWRpdHkoeyBlbWl0RXZlbnQ6IG9wdGlvbnMuZW1pdEV2ZW50IH0pO1xuICAgICAgICB0aGlzLl9vbkNvbGxlY3Rpb25DaGFuZ2UoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTGVuZ3RoIG9mIHRoZSBjb250cm9sIGFycmF5LlxuICAgICAqL1xuICAgIGdldCBsZW5ndGgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnRyb2xzLmxlbmd0aDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgdmFsdWUgb2YgdGhlIGBGb3JtQXJyYXlgLiBJdCBhY2NlcHRzIGFuIGFycmF5IHRoYXQgbWF0Y2hlc1xuICAgICAqIHRoZSBzdHJ1Y3R1cmUgb2YgdGhlIGNvbnRyb2wuXG4gICAgICpcbiAgICAgKiBUaGlzIG1ldGhvZCBwZXJmb3JtcyBzdHJpY3QgY2hlY2tzLCBhbmQgdGhyb3dzIGFuIGVycm9yIGlmIHlvdSB0cnlcbiAgICAgKiB0byBzZXQgdGhlIHZhbHVlIG9mIGEgY29udHJvbCB0aGF0IGRvZXNuJ3QgZXhpc3Qgb3IgaWYgeW91IGV4Y2x1ZGUgdGhlXG4gICAgICogdmFsdWUgb2YgYSBjb250cm9sLlxuICAgICAqXG4gICAgICogQHVzYWdlTm90ZXNcbiAgICAgKiAjIyMgU2V0IHRoZSB2YWx1ZXMgZm9yIHRoZSBjb250cm9scyBpbiB0aGUgZm9ybSBhcnJheVxuICAgICAqXG4gICAgICogYGBgXG4gICAgICogY29uc3QgYXJyID0gbmV3IEZvcm1BcnJheShbXG4gICAgICogICBuZXcgRm9ybUNvbnRyb2woKSxcbiAgICAgKiAgIG5ldyBGb3JtQ29udHJvbCgpXG4gICAgICogXSk7XG4gICAgICogY29uc29sZS5sb2coYXJyLnZhbHVlKTsgICAvLyBbbnVsbCwgbnVsbF1cbiAgICAgKlxuICAgICAqIGFyci5zZXRWYWx1ZShbJ05hbmN5JywgJ0RyZXcnXSk7XG4gICAgICogY29uc29sZS5sb2coYXJyLnZhbHVlKTsgICAvLyBbJ05hbmN5JywgJ0RyZXcnXVxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQHBhcmFtIHZhbHVlIEFycmF5IG9mIHZhbHVlcyBmb3IgdGhlIGNvbnRyb2xzXG4gICAgICogQHBhcmFtIG9wdGlvbnMgQ29uZmlndXJlIG9wdGlvbnMgdGhhdCBkZXRlcm1pbmUgaG93IHRoZSBjb250cm9sIHByb3BhZ2F0ZXMgY2hhbmdlcyBhbmRcbiAgICAgKiBlbWl0cyBldmVudHMgYWZ0ZXIgdGhlIHZhbHVlIGNoYW5nZXNcbiAgICAgKlxuICAgICAqICogYG9ubHlTZWxmYDogV2hlbiB0cnVlLCBlYWNoIGNoYW5nZSBvbmx5IGFmZmVjdHMgdGhpcyBjb250cm9sLCBhbmQgbm90IGl0cyBwYXJlbnQuIERlZmF1bHRcbiAgICAgKiBpcyBmYWxzZS5cbiAgICAgKiAqIGBlbWl0RXZlbnRgOiBXaGVuIHRydWUgb3Igbm90IHN1cHBsaWVkICh0aGUgZGVmYXVsdCksIGJvdGggdGhlIGBzdGF0dXNDaGFuZ2VzYCBhbmRcbiAgICAgKiBgdmFsdWVDaGFuZ2VzYFxuICAgICAqIG9ic2VydmFibGVzIGVtaXQgZXZlbnRzIHdpdGggdGhlIGxhdGVzdCBzdGF0dXMgYW5kIHZhbHVlIHdoZW4gdGhlIGNvbnRyb2wgdmFsdWUgaXMgdXBkYXRlZC5cbiAgICAgKiBXaGVuIGZhbHNlLCBubyBldmVudHMgYXJlIGVtaXR0ZWQuXG4gICAgICogVGhlIGNvbmZpZ3VyYXRpb24gb3B0aW9ucyBhcmUgcGFzc2VkIHRvIHRoZSB7QGxpbmsgQWJzdHJhY3RDb250cm9sI3VwZGF0ZVZhbHVlQW5kVmFsaWRpdHlcbiAgICAgKiB1cGRhdGVWYWx1ZUFuZFZhbGlkaXR5fSBtZXRob2QuXG4gICAgICovXG4gICAgc2V0VmFsdWUodmFsdWUsIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICBhc3NlcnRBbGxWYWx1ZXNQcmVzZW50KHRoaXMsIGZhbHNlLCB2YWx1ZSk7XG4gICAgICAgIHZhbHVlLmZvckVhY2goKG5ld1ZhbHVlLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgYXNzZXJ0Q29udHJvbFByZXNlbnQodGhpcywgZmFsc2UsIGluZGV4KTtcbiAgICAgICAgICAgIHRoaXMuYXQoaW5kZXgpLnNldFZhbHVlKG5ld1ZhbHVlLCB7IG9ubHlTZWxmOiB0cnVlLCBlbWl0RXZlbnQ6IG9wdGlvbnMuZW1pdEV2ZW50IH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy51cGRhdGVWYWx1ZUFuZFZhbGlkaXR5KG9wdGlvbnMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQYXRjaGVzIHRoZSB2YWx1ZSBvZiB0aGUgYEZvcm1BcnJheWAuIEl0IGFjY2VwdHMgYW4gYXJyYXkgdGhhdCBtYXRjaGVzIHRoZVxuICAgICAqIHN0cnVjdHVyZSBvZiB0aGUgY29udHJvbCwgYW5kIGRvZXMgaXRzIGJlc3QgdG8gbWF0Y2ggdGhlIHZhbHVlcyB0byB0aGUgY29ycmVjdFxuICAgICAqIGNvbnRyb2xzIGluIHRoZSBncm91cC5cbiAgICAgKlxuICAgICAqIEl0IGFjY2VwdHMgYm90aCBzdXBlci1zZXRzIGFuZCBzdWItc2V0cyBvZiB0aGUgYXJyYXkgd2l0aG91dCB0aHJvd2luZyBhbiBlcnJvci5cbiAgICAgKlxuICAgICAqIEB1c2FnZU5vdGVzXG4gICAgICogIyMjIFBhdGNoIHRoZSB2YWx1ZXMgZm9yIGNvbnRyb2xzIGluIGEgZm9ybSBhcnJheVxuICAgICAqXG4gICAgICogYGBgXG4gICAgICogY29uc3QgYXJyID0gbmV3IEZvcm1BcnJheShbXG4gICAgICogICAgbmV3IEZvcm1Db250cm9sKCksXG4gICAgICogICAgbmV3IEZvcm1Db250cm9sKClcbiAgICAgKiBdKTtcbiAgICAgKiBjb25zb2xlLmxvZyhhcnIudmFsdWUpOyAgIC8vIFtudWxsLCBudWxsXVxuICAgICAqXG4gICAgICogYXJyLnBhdGNoVmFsdWUoWydOYW5jeSddKTtcbiAgICAgKiBjb25zb2xlLmxvZyhhcnIudmFsdWUpOyAgIC8vIFsnTmFuY3knLCBudWxsXVxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQHBhcmFtIHZhbHVlIEFycmF5IG9mIGxhdGVzdCB2YWx1ZXMgZm9yIHRoZSBjb250cm9sc1xuICAgICAqIEBwYXJhbSBvcHRpb25zIENvbmZpZ3VyZSBvcHRpb25zIHRoYXQgZGV0ZXJtaW5lIGhvdyB0aGUgY29udHJvbCBwcm9wYWdhdGVzIGNoYW5nZXMgYW5kXG4gICAgICogZW1pdHMgZXZlbnRzIGFmdGVyIHRoZSB2YWx1ZSBjaGFuZ2VzXG4gICAgICpcbiAgICAgKiAqIGBvbmx5U2VsZmA6IFdoZW4gdHJ1ZSwgZWFjaCBjaGFuZ2Ugb25seSBhZmZlY3RzIHRoaXMgY29udHJvbCwgYW5kIG5vdCBpdHMgcGFyZW50LiBEZWZhdWx0XG4gICAgICogaXMgZmFsc2UuXG4gICAgICogKiBgZW1pdEV2ZW50YDogV2hlbiB0cnVlIG9yIG5vdCBzdXBwbGllZCAodGhlIGRlZmF1bHQpLCBib3RoIHRoZSBgc3RhdHVzQ2hhbmdlc2AgYW5kXG4gICAgICogYHZhbHVlQ2hhbmdlc2Agb2JzZXJ2YWJsZXMgZW1pdCBldmVudHMgd2l0aCB0aGUgbGF0ZXN0IHN0YXR1cyBhbmQgdmFsdWUgd2hlbiB0aGUgY29udHJvbFxuICAgICAqIHZhbHVlIGlzIHVwZGF0ZWQuIFdoZW4gZmFsc2UsIG5vIGV2ZW50cyBhcmUgZW1pdHRlZC4gVGhlIGNvbmZpZ3VyYXRpb24gb3B0aW9ucyBhcmUgcGFzc2VkIHRvXG4gICAgICogdGhlIHtAbGluayBBYnN0cmFjdENvbnRyb2wjdXBkYXRlVmFsdWVBbmRWYWxpZGl0eSB1cGRhdGVWYWx1ZUFuZFZhbGlkaXR5fSBtZXRob2QuXG4gICAgICovXG4gICAgcGF0Y2hWYWx1ZSh2YWx1ZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIC8vIEV2ZW4gdGhvdWdoIHRoZSBgdmFsdWVgIGFyZ3VtZW50IHR5cGUgZG9lc24ndCBhbGxvdyBgbnVsbGAgYW5kIGB1bmRlZmluZWRgIHZhbHVlcywgdGhlXG4gICAgICAgIC8vIGBwYXRjaFZhbHVlYCBjYW4gYmUgY2FsbGVkIHJlY3Vyc2l2ZWx5IGFuZCBpbm5lciBkYXRhIHN0cnVjdHVyZXMgbWlnaHQgaGF2ZSB0aGVzZSB2YWx1ZXMsXG4gICAgICAgIC8vIHNvIHdlIGp1c3QgaWdub3JlIHN1Y2ggY2FzZXMgd2hlbiBhIGZpZWxkIGNvbnRhaW5pbmcgRm9ybUFycmF5IGluc3RhbmNlIHJlY2VpdmVzIGBudWxsYCBvclxuICAgICAgICAvLyBgdW5kZWZpbmVkYCBhcyBhIHZhbHVlLlxuICAgICAgICBpZiAodmFsdWUgPT0gbnVsbCAvKiBib3RoIGBudWxsYCBhbmQgYHVuZGVmaW5lZGAgKi8pXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHZhbHVlLmZvckVhY2goKG5ld1ZhbHVlLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuYXQoaW5kZXgpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hdChpbmRleCkucGF0Y2hWYWx1ZShuZXdWYWx1ZSwgeyBvbmx5U2VsZjogdHJ1ZSwgZW1pdEV2ZW50OiBvcHRpb25zLmVtaXRFdmVudCB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMudXBkYXRlVmFsdWVBbmRWYWxpZGl0eShvcHRpb25zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVzZXRzIHRoZSBgRm9ybUFycmF5YCBhbmQgYWxsIGRlc2NlbmRhbnRzIGFyZSBtYXJrZWQgYHByaXN0aW5lYCBhbmQgYHVudG91Y2hlZGAsIGFuZCB0aGVcbiAgICAgKiB2YWx1ZSBvZiBhbGwgZGVzY2VuZGFudHMgdG8gbnVsbCBvciBudWxsIG1hcHMuXG4gICAgICpcbiAgICAgKiBZb3UgcmVzZXQgdG8gYSBzcGVjaWZpYyBmb3JtIHN0YXRlIGJ5IHBhc3NpbmcgaW4gYW4gYXJyYXkgb2Ygc3RhdGVzXG4gICAgICogdGhhdCBtYXRjaGVzIHRoZSBzdHJ1Y3R1cmUgb2YgdGhlIGNvbnRyb2wuIFRoZSBzdGF0ZSBpcyBhIHN0YW5kYWxvbmUgdmFsdWVcbiAgICAgKiBvciBhIGZvcm0gc3RhdGUgb2JqZWN0IHdpdGggYm90aCBhIHZhbHVlIGFuZCBhIGRpc2FibGVkIHN0YXR1cy5cbiAgICAgKlxuICAgICAqIEB1c2FnZU5vdGVzXG4gICAgICogIyMjIFJlc2V0IHRoZSB2YWx1ZXMgaW4gYSBmb3JtIGFycmF5XG4gICAgICpcbiAgICAgKiBgYGB0c1xuICAgICAqIGNvbnN0IGFyciA9IG5ldyBGb3JtQXJyYXkoW1xuICAgICAqICAgIG5ldyBGb3JtQ29udHJvbCgpLFxuICAgICAqICAgIG5ldyBGb3JtQ29udHJvbCgpXG4gICAgICogXSk7XG4gICAgICogYXJyLnJlc2V0KFsnbmFtZScsICdsYXN0IG5hbWUnXSk7XG4gICAgICpcbiAgICAgKiBjb25zb2xlLmxvZyhhcnIudmFsdWUpOyAgLy8gWyduYW1lJywgJ2xhc3QgbmFtZSddXG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiAjIyMgUmVzZXQgdGhlIHZhbHVlcyBpbiBhIGZvcm0gYXJyYXkgYW5kIHRoZSBkaXNhYmxlZCBzdGF0dXMgZm9yIHRoZSBmaXJzdCBjb250cm9sXG4gICAgICpcbiAgICAgKiBgYGBcbiAgICAgKiBhcnIucmVzZXQoW1xuICAgICAqICAge3ZhbHVlOiAnbmFtZScsIGRpc2FibGVkOiB0cnVlfSxcbiAgICAgKiAgICdsYXN0J1xuICAgICAqIF0pO1xuICAgICAqXG4gICAgICogY29uc29sZS5sb2coYXJyLnZhbHVlKTsgIC8vIFsnbGFzdCddXG4gICAgICogY29uc29sZS5sb2coYXJyLmF0KDApLnN0YXR1cyk7ICAvLyAnRElTQUJMRUQnXG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdmFsdWUgQXJyYXkgb2YgdmFsdWVzIGZvciB0aGUgY29udHJvbHNcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBDb25maWd1cmUgb3B0aW9ucyB0aGF0IGRldGVybWluZSBob3cgdGhlIGNvbnRyb2wgcHJvcGFnYXRlcyBjaGFuZ2VzIGFuZFxuICAgICAqIGVtaXRzIGV2ZW50cyBhZnRlciB0aGUgdmFsdWUgY2hhbmdlc1xuICAgICAqXG4gICAgICogKiBgb25seVNlbGZgOiBXaGVuIHRydWUsIGVhY2ggY2hhbmdlIG9ubHkgYWZmZWN0cyB0aGlzIGNvbnRyb2wsIGFuZCBub3QgaXRzIHBhcmVudC4gRGVmYXVsdFxuICAgICAqIGlzIGZhbHNlLlxuICAgICAqICogYGVtaXRFdmVudGA6IFdoZW4gdHJ1ZSBvciBub3Qgc3VwcGxpZWQgKHRoZSBkZWZhdWx0KSwgYm90aCB0aGUgYHN0YXR1c0NoYW5nZXNgIGFuZFxuICAgICAqIGB2YWx1ZUNoYW5nZXNgXG4gICAgICogb2JzZXJ2YWJsZXMgZW1pdCBldmVudHMgd2l0aCB0aGUgbGF0ZXN0IHN0YXR1cyBhbmQgdmFsdWUgd2hlbiB0aGUgY29udHJvbCBpcyByZXNldC5cbiAgICAgKiBXaGVuIGZhbHNlLCBubyBldmVudHMgYXJlIGVtaXR0ZWQuXG4gICAgICogVGhlIGNvbmZpZ3VyYXRpb24gb3B0aW9ucyBhcmUgcGFzc2VkIHRvIHRoZSB7QGxpbmsgQWJzdHJhY3RDb250cm9sI3VwZGF0ZVZhbHVlQW5kVmFsaWRpdHlcbiAgICAgKiB1cGRhdGVWYWx1ZUFuZFZhbGlkaXR5fSBtZXRob2QuXG4gICAgICovXG4gICAgcmVzZXQodmFsdWUgPSBbXSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIHRoaXMuX2ZvckVhY2hDaGlsZCgoY29udHJvbCwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgIGNvbnRyb2wucmVzZXQodmFsdWVbaW5kZXhdLCB7IG9ubHlTZWxmOiB0cnVlLCBlbWl0RXZlbnQ6IG9wdGlvbnMuZW1pdEV2ZW50IH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5fdXBkYXRlUHJpc3RpbmUob3B0aW9ucyk7XG4gICAgICAgIHRoaXMuX3VwZGF0ZVRvdWNoZWQob3B0aW9ucyk7XG4gICAgICAgIHRoaXMudXBkYXRlVmFsdWVBbmRWYWxpZGl0eShvcHRpb25zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIGFnZ3JlZ2F0ZSB2YWx1ZSBvZiB0aGUgYXJyYXksIGluY2x1ZGluZyBhbnkgZGlzYWJsZWQgY29udHJvbHMuXG4gICAgICpcbiAgICAgKiBSZXBvcnRzIGFsbCB2YWx1ZXMgcmVnYXJkbGVzcyBvZiBkaXNhYmxlZCBzdGF0dXMuXG4gICAgICovXG4gICAgZ2V0UmF3VmFsdWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnRyb2xzLm1hcCgoY29udHJvbCkgPT4gY29udHJvbC5nZXRSYXdWYWx1ZSgpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVtb3ZlIGFsbCBjb250cm9scyBpbiB0aGUgYEZvcm1BcnJheWAuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBTcGVjaWZpZXMgd2hldGhlciB0aGlzIEZvcm1BcnJheSBpbnN0YW5jZSBzaG91bGQgZW1pdCBldmVudHMgYWZ0ZXIgYWxsXG4gICAgICogICAgIGNvbnRyb2xzIGFyZSByZW1vdmVkLlxuICAgICAqICogYGVtaXRFdmVudGA6IFdoZW4gdHJ1ZSBvciBub3Qgc3VwcGxpZWQgKHRoZSBkZWZhdWx0KSwgYm90aCB0aGUgYHN0YXR1c0NoYW5nZXNgIGFuZFxuICAgICAqIGB2YWx1ZUNoYW5nZXNgIG9ic2VydmFibGVzIGVtaXQgZXZlbnRzIHdpdGggdGhlIGxhdGVzdCBzdGF0dXMgYW5kIHZhbHVlIHdoZW4gYWxsIGNvbnRyb2xzXG4gICAgICogaW4gdGhpcyBGb3JtQXJyYXkgaW5zdGFuY2UgYXJlIHJlbW92ZWQuIFdoZW4gZmFsc2UsIG5vIGV2ZW50cyBhcmUgZW1pdHRlZC5cbiAgICAgKlxuICAgICAqIEB1c2FnZU5vdGVzXG4gICAgICogIyMjIFJlbW92ZSBhbGwgZWxlbWVudHMgZnJvbSBhIEZvcm1BcnJheVxuICAgICAqXG4gICAgICogYGBgdHNcbiAgICAgKiBjb25zdCBhcnIgPSBuZXcgRm9ybUFycmF5KFtcbiAgICAgKiAgICBuZXcgRm9ybUNvbnRyb2woKSxcbiAgICAgKiAgICBuZXcgRm9ybUNvbnRyb2woKVxuICAgICAqIF0pO1xuICAgICAqIGNvbnNvbGUubG9nKGFyci5sZW5ndGgpOyAgLy8gMlxuICAgICAqXG4gICAgICogYXJyLmNsZWFyKCk7XG4gICAgICogY29uc29sZS5sb2coYXJyLmxlbmd0aCk7ICAvLyAwXG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBJdCdzIGEgc2ltcGxlciBhbmQgbW9yZSBlZmZpY2llbnQgYWx0ZXJuYXRpdmUgdG8gcmVtb3ZpbmcgYWxsIGVsZW1lbnRzIG9uZSBieSBvbmU6XG4gICAgICpcbiAgICAgKiBgYGB0c1xuICAgICAqIGNvbnN0IGFyciA9IG5ldyBGb3JtQXJyYXkoW1xuICAgICAqICAgIG5ldyBGb3JtQ29udHJvbCgpLFxuICAgICAqICAgIG5ldyBGb3JtQ29udHJvbCgpXG4gICAgICogXSk7XG4gICAgICpcbiAgICAgKiB3aGlsZSAoYXJyLmxlbmd0aCkge1xuICAgICAqICAgIGFyci5yZW1vdmVBdCgwKTtcbiAgICAgKiB9XG4gICAgICogYGBgXG4gICAgICovXG4gICAgY2xlYXIob3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIGlmICh0aGlzLmNvbnRyb2xzLmxlbmd0aCA8IDEpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRoaXMuX2ZvckVhY2hDaGlsZCgoY29udHJvbCkgPT4gY29udHJvbC5fcmVnaXN0ZXJPbkNvbGxlY3Rpb25DaGFuZ2UoKCkgPT4geyB9KSk7XG4gICAgICAgIHRoaXMuY29udHJvbHMuc3BsaWNlKDApO1xuICAgICAgICB0aGlzLnVwZGF0ZVZhbHVlQW5kVmFsaWRpdHkoeyBlbWl0RXZlbnQ6IG9wdGlvbnMuZW1pdEV2ZW50IH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGp1c3RzIGEgbmVnYXRpdmUgaW5kZXggYnkgc3VtbWluZyBpdCB3aXRoIHRoZSBsZW5ndGggb2YgdGhlIGFycmF5LiBGb3IgdmVyeSBuZWdhdGl2ZVxuICAgICAqIGluZGljZXMsIHRoZSByZXN1bHQgbWF5IHJlbWFpbiBuZWdhdGl2ZS5cbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBfYWRqdXN0SW5kZXgoaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIGluZGV4IDwgMCA/IGluZGV4ICsgdGhpcy5sZW5ndGggOiBpbmRleDtcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIF9zeW5jUGVuZGluZ0NvbnRyb2xzKCkge1xuICAgICAgICBsZXQgc3VidHJlZVVwZGF0ZWQgPSB0aGlzLmNvbnRyb2xzLnJlZHVjZSgodXBkYXRlZCwgY2hpbGQpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBjaGlsZC5fc3luY1BlbmRpbmdDb250cm9scygpID8gdHJ1ZSA6IHVwZGF0ZWQ7XG4gICAgICAgIH0sIGZhbHNlKTtcbiAgICAgICAgaWYgKHN1YnRyZWVVcGRhdGVkKVxuICAgICAgICAgICAgdGhpcy51cGRhdGVWYWx1ZUFuZFZhbGlkaXR5KHsgb25seVNlbGY6IHRydWUgfSk7XG4gICAgICAgIHJldHVybiBzdWJ0cmVlVXBkYXRlZDtcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIF9mb3JFYWNoQ2hpbGQoY2IpIHtcbiAgICAgICAgdGhpcy5jb250cm9scy5mb3JFYWNoKChjb250cm9sLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgY2IoY29udHJvbCwgaW5kZXgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIF91cGRhdGVWYWx1ZSgpIHtcbiAgICAgICAgdGhpcy52YWx1ZSA9XG4gICAgICAgICAgICB0aGlzLmNvbnRyb2xzLmZpbHRlcigoY29udHJvbCkgPT4gY29udHJvbC5lbmFibGVkIHx8IHRoaXMuZGlzYWJsZWQpXG4gICAgICAgICAgICAgICAgLm1hcCgoY29udHJvbCkgPT4gY29udHJvbC52YWx1ZSk7XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBfYW55Q29udHJvbHMoY29uZGl0aW9uKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnRyb2xzLnNvbWUoKGNvbnRyb2wpID0+IGNvbnRyb2wuZW5hYmxlZCAmJiBjb25kaXRpb24oY29udHJvbCkpO1xuICAgIH1cbiAgICAvKiogQGludGVybmFsICovXG4gICAgX3NldFVwQ29udHJvbHMoKSB7XG4gICAgICAgIHRoaXMuX2ZvckVhY2hDaGlsZCgoY29udHJvbCkgPT4gdGhpcy5fcmVnaXN0ZXJDb250cm9sKGNvbnRyb2wpKTtcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIF9hbGxDb250cm9sc0Rpc2FibGVkKCkge1xuICAgICAgICBmb3IgKGNvbnN0IGNvbnRyb2wgb2YgdGhpcy5jb250cm9scykge1xuICAgICAgICAgICAgaWYgKGNvbnRyb2wuZW5hYmxlZClcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuY29udHJvbHMubGVuZ3RoID4gMCB8fCB0aGlzLmRpc2FibGVkO1xuICAgIH1cbiAgICBfcmVnaXN0ZXJDb250cm9sKGNvbnRyb2wpIHtcbiAgICAgICAgY29udHJvbC5zZXRQYXJlbnQodGhpcyk7XG4gICAgICAgIGNvbnRyb2wuX3JlZ2lzdGVyT25Db2xsZWN0aW9uQ2hhbmdlKHRoaXMuX29uQ29sbGVjdGlvbkNoYW5nZSk7XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBfZmluZChuYW1lKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmF0KG5hbWUpID8/IG51bGw7XG4gICAgfVxufVxuY29uc3QgVW50eXBlZEZvcm1BcnJheSA9IEZvcm1BcnJheTtcbi8qKlxuICogQGRlc2NyaXB0aW9uXG4gKiBBc3NlcnRzIHRoYXQgdGhlIGdpdmVuIGNvbnRyb2wgaXMgYW4gaW5zdGFuY2Ugb2YgYEZvcm1BcnJheWBcbiAqXG4gKiBAcHVibGljQXBpXG4gKi9cbmNvbnN0IGlzRm9ybUFycmF5ID0gKGNvbnRyb2wpID0+IGNvbnRyb2wgaW5zdGFuY2VvZiBGb3JtQXJyYXk7XG5cbmZ1bmN0aW9uIGlzQWJzdHJhY3RDb250cm9sT3B0aW9ucyhvcHRpb25zKSB7XG4gICAgcmV0dXJuICEhb3B0aW9ucyAmJlxuICAgICAgICAob3B0aW9ucy5hc3luY1ZhbGlkYXRvcnMgIT09IHVuZGVmaW5lZCB8fFxuICAgICAgICAgICAgb3B0aW9ucy52YWxpZGF0b3JzICE9PSB1bmRlZmluZWQgfHxcbiAgICAgICAgICAgIG9wdGlvbnMudXBkYXRlT24gIT09IHVuZGVmaW5lZCk7XG59XG4vLyBjbGFuZy1mb3JtYXQgb25cbi8qKlxuICogQGRlc2NyaXB0aW9uXG4gKiBDcmVhdGVzIGFuIGBBYnN0cmFjdENvbnRyb2xgIGZyb20gYSB1c2VyLXNwZWNpZmllZCBjb25maWd1cmF0aW9uLlxuICpcbiAqIFRoZSBgRm9ybUJ1aWxkZXJgIHByb3ZpZGVzIHN5bnRhY3RpYyBzdWdhciB0aGF0IHNob3J0ZW5zIGNyZWF0aW5nIGluc3RhbmNlcyBvZiBhXG4gKiBgRm9ybUNvbnRyb2xgLCBgRm9ybUdyb3VwYCwgb3IgYEZvcm1BcnJheWAuIEl0IHJlZHVjZXMgdGhlIGFtb3VudCBvZiBib2lsZXJwbGF0ZSBuZWVkZWQgdG9cbiAqIGJ1aWxkIGNvbXBsZXggZm9ybXMuXG4gKlxuICogQHNlZSBbUmVhY3RpdmUgRm9ybXMgR3VpZGVdKGd1aWRlL3JlYWN0aXZlLWZvcm1zKVxuICpcbiAqIEBwdWJsaWNBcGlcbiAqL1xuY2xhc3MgRm9ybUJ1aWxkZXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLnVzZU5vbk51bGxhYmxlID0gZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqIFJldHVybnMgYSBGb3JtQnVpbGRlciBpbiB3aGljaCBhdXRvbWF0aWNhbGx5IGNvbnN0cnVjdGVkIGBGb3JtQ29udHJvbGAgZWxlbWVudHNcbiAgICAgKiBoYXZlIGB7bm9uTnVsbGFibGU6IHRydWV9YCBhbmQgYXJlIG5vbi1udWxsYWJsZS5cbiAgICAgKlxuICAgICAqICoqQ29uc3RydWN0aW5nIG5vbi1udWxsYWJsZSBjb250cm9scyoqXG4gICAgICpcbiAgICAgKiBXaGVuIGNvbnN0cnVjdGluZyBhIGNvbnRyb2wsIGl0IHdpbGwgYmUgbm9uLW51bGxhYmxlLCBhbmQgd2lsbCByZXNldCB0byBpdHMgaW5pdGlhbCB2YWx1ZS5cbiAgICAgKlxuICAgICAqIGBgYHRzXG4gICAgICogbGV0IG5uZmIgPSBuZXcgRm9ybUJ1aWxkZXIoKS5ub25OdWxsYWJsZTtcbiAgICAgKiBsZXQgbmFtZSA9IG5uZmIuY29udHJvbCgnQWxleCcpOyAvLyBGb3JtQ29udHJvbDxzdHJpbmc+XG4gICAgICogbmFtZS5yZXNldCgpO1xuICAgICAqIGNvbnNvbGUubG9nKG5hbWUpOyAvLyAnQWxleCdcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqICoqQ29uc3RydWN0aW5nIG5vbi1udWxsYWJsZSBncm91cHMgb3IgYXJyYXlzKipcbiAgICAgKlxuICAgICAqIFdoZW4gY29uc3RydWN0aW5nIGEgZ3JvdXAgb3IgYXJyYXksIGFsbCBhdXRvbWF0aWNhbGx5IGNyZWF0ZWQgaW5uZXIgY29udHJvbHMgd2lsbCBiZVxuICAgICAqIG5vbi1udWxsYWJsZSwgYW5kIHdpbGwgcmVzZXQgdG8gdGhlaXIgaW5pdGlhbCB2YWx1ZXMuXG4gICAgICpcbiAgICAgKiBgYGB0c1xuICAgICAqIGxldCBubmZiID0gbmV3IEZvcm1CdWlsZGVyKCkubm9uTnVsbGFibGU7XG4gICAgICogbGV0IG5hbWUgPSBubmZiLmdyb3VwKHt3aG86ICdBbGV4J30pOyAvLyBGb3JtR3JvdXA8e3dobzogRm9ybUNvbnRyb2w8c3RyaW5nPn0+XG4gICAgICogbmFtZS5yZXNldCgpO1xuICAgICAqIGNvbnNvbGUubG9nKG5hbWUpOyAvLyB7d2hvOiAnQWxleCd9XG4gICAgICogYGBgXG4gICAgICogKipDb25zdHJ1Y3RpbmcgKm51bGxhYmxlKiBmaWVsZHMgb24gZ3JvdXBzIG9yIGFycmF5cyoqXG4gICAgICpcbiAgICAgKiBJdCBpcyBzdGlsbCBwb3NzaWJsZSB0byBoYXZlIGEgbnVsbGFibGUgZmllbGQuIEluIHBhcnRpY3VsYXIsIGFueSBgRm9ybUNvbnRyb2xgIHdoaWNoIGlzXG4gICAgICogKmFscmVhZHkqIGNvbnN0cnVjdGVkIHdpbGwgbm90IGJlIGFsdGVyZWQuIEZvciBleGFtcGxlOlxuICAgICAqXG4gICAgICogYGBgdHNcbiAgICAgKiBsZXQgbm5mYiA9IG5ldyBGb3JtQnVpbGRlcigpLm5vbk51bGxhYmxlO1xuICAgICAqIC8vIEZvcm1Hcm91cDx7d2hvOiBGb3JtQ29udHJvbDxzdHJpbmd8bnVsbD59PlxuICAgICAqIGxldCBuYW1lID0gbm5mYi5ncm91cCh7d2hvOiBuZXcgRm9ybUNvbnRyb2woJ0FsZXgnKX0pO1xuICAgICAqIG5hbWUucmVzZXQoKTsgY29uc29sZS5sb2cobmFtZSk7IC8vIHt3aG86IG51bGx9XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBCZWNhdXNlIHRoZSBpbm5lciBjb250cm9sIGlzIGNvbnN0cnVjdGVkIGV4cGxpY2l0bHkgYnkgdGhlIGNhbGxlciwgdGhlIGJ1aWxkZXIgaGFzXG4gICAgICogbm8gY29udHJvbCBvdmVyIGhvdyBpdCBpcyBjcmVhdGVkLCBhbmQgY2Fubm90IGV4Y2x1ZGUgdGhlIGBudWxsYC5cbiAgICAgKi9cbiAgICBnZXQgbm9uTnVsbGFibGUoKSB7XG4gICAgICAgIGNvbnN0IG5uZmIgPSBuZXcgRm9ybUJ1aWxkZXIoKTtcbiAgICAgICAgbm5mYi51c2VOb25OdWxsYWJsZSA9IHRydWU7XG4gICAgICAgIHJldHVybiBubmZiO1xuICAgIH1cbiAgICBncm91cChjb250cm9scywgb3B0aW9ucyA9IG51bGwpIHtcbiAgICAgICAgY29uc3QgcmVkdWNlZENvbnRyb2xzID0gdGhpcy5fcmVkdWNlQ29udHJvbHMoY29udHJvbHMpO1xuICAgICAgICBsZXQgbmV3T3B0aW9ucyA9IHt9O1xuICAgICAgICBpZiAoaXNBYnN0cmFjdENvbnRyb2xPcHRpb25zKG9wdGlvbnMpKSB7XG4gICAgICAgICAgICAvLyBgb3B0aW9uc2AgYXJlIGBBYnN0cmFjdENvbnRyb2xPcHRpb25zYFxuICAgICAgICAgICAgbmV3T3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAob3B0aW9ucyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gYG9wdGlvbnNgIGFyZSBsZWdhY3kgZm9ybSBncm91cCBvcHRpb25zXG4gICAgICAgICAgICBuZXdPcHRpb25zLnZhbGlkYXRvcnMgPSBvcHRpb25zLnZhbGlkYXRvcjtcbiAgICAgICAgICAgIG5ld09wdGlvbnMuYXN5bmNWYWxpZGF0b3JzID0gb3B0aW9ucy5hc3luY1ZhbGlkYXRvcjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IEZvcm1Hcm91cChyZWR1Y2VkQ29udHJvbHMsIG5ld09wdGlvbnMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKiBDb25zdHJ1Y3RzIGEgbmV3IGBGb3JtUmVjb3JkYCBpbnN0YW5jZS4gQWNjZXB0cyBhIHNpbmdsZSBnZW5lcmljIGFyZ3VtZW50LCB3aGljaCBpcyBhbiBvYmplY3RcbiAgICAgKiBjb250YWluaW5nIGFsbCB0aGUga2V5cyBhbmQgY29ycmVzcG9uZGluZyBpbm5lciBjb250cm9sIHR5cGVzLlxuICAgICAqXG4gICAgICogQHBhcmFtIGNvbnRyb2xzIEEgY29sbGVjdGlvbiBvZiBjaGlsZCBjb250cm9scy4gVGhlIGtleSBmb3IgZWFjaCBjaGlsZCBpcyB0aGUgbmFtZVxuICAgICAqIHVuZGVyIHdoaWNoIGl0IGlzIHJlZ2lzdGVyZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBDb25maWd1cmF0aW9uIG9wdGlvbnMgb2JqZWN0IGZvciB0aGUgYEZvcm1SZWNvcmRgLiBUaGUgb2JqZWN0IHNob3VsZCBoYXZlIHRoZVxuICAgICAqIGBBYnN0cmFjdENvbnRyb2xPcHRpb25zYCB0eXBlIGFuZCBtaWdodCBjb250YWluIHRoZSBmb2xsb3dpbmcgZmllbGRzOlxuICAgICAqICogYHZhbGlkYXRvcnNgOiBBIHN5bmNocm9ub3VzIHZhbGlkYXRvciBmdW5jdGlvbiwgb3IgYW4gYXJyYXkgb2YgdmFsaWRhdG9yIGZ1bmN0aW9ucy5cbiAgICAgKiAqIGBhc3luY1ZhbGlkYXRvcnNgOiBBIHNpbmdsZSBhc3luYyB2YWxpZGF0b3Igb3IgYXJyYXkgb2YgYXN5bmMgdmFsaWRhdG9yIGZ1bmN0aW9ucy5cbiAgICAgKiAqIGB1cGRhdGVPbmA6IFRoZSBldmVudCB1cG9uIHdoaWNoIHRoZSBjb250cm9sIHNob3VsZCBiZSB1cGRhdGVkIChvcHRpb25zOiAnY2hhbmdlJyB8ICdibHVyJ1xuICAgICAqIHwgc3VibWl0JykuXG4gICAgICovXG4gICAgcmVjb3JkKGNvbnRyb2xzLCBvcHRpb25zID0gbnVsbCkge1xuICAgICAgICBjb25zdCByZWR1Y2VkQ29udHJvbHMgPSB0aGlzLl9yZWR1Y2VDb250cm9scyhjb250cm9scyk7XG4gICAgICAgIC8vIENhc3QgdG8gYGFueWAgYmVjYXVzZSB0aGUgaW5mZXJyZWQgdHlwZXMgYXJlIG5vdCBhcyBzcGVjaWZpYyBhcyBFbGVtZW50LlxuICAgICAgICByZXR1cm4gbmV3IEZvcm1SZWNvcmQocmVkdWNlZENvbnRyb2xzLCBvcHRpb25zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICogQ29uc3RydWN0cyBhIG5ldyBgRm9ybUNvbnRyb2xgIHdpdGggdGhlIGdpdmVuIHN0YXRlLCB2YWxpZGF0b3JzIGFuZCBvcHRpb25zLiBTZXRzXG4gICAgICogYHtub25OdWxsYWJsZTogdHJ1ZX1gIGluIHRoZSBvcHRpb25zIHRvIGdldCBhIG5vbi1udWxsYWJsZSBjb250cm9sLiBPdGhlcndpc2UsIHRoZVxuICAgICAqIGNvbnRyb2wgd2lsbCBiZSBudWxsYWJsZS4gQWNjZXB0cyBhIHNpbmdsZSBnZW5lcmljIGFyZ3VtZW50LCB3aGljaCBpcyB0aGUgdHlwZSAgb2YgdGhlXG4gICAgICogY29udHJvbCdzIHZhbHVlLlxuICAgICAqXG4gICAgICogQHBhcmFtIGZvcm1TdGF0ZSBJbml0aWFsaXplcyB0aGUgY29udHJvbCB3aXRoIGFuIGluaXRpYWwgc3RhdGUgdmFsdWUsIG9yXG4gICAgICogd2l0aCBhbiBvYmplY3QgdGhhdCBjb250YWlucyBib3RoIGEgdmFsdWUgYW5kIGEgZGlzYWJsZWQgc3RhdHVzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHZhbGlkYXRvck9yT3B0cyBBIHN5bmNocm9ub3VzIHZhbGlkYXRvciBmdW5jdGlvbiwgb3IgYW4gYXJyYXkgb2ZcbiAgICAgKiBzdWNoIGZ1bmN0aW9ucywgb3IgYSBgRm9ybUNvbnRyb2xPcHRpb25zYCBvYmplY3QgdGhhdCBjb250YWluc1xuICAgICAqIHZhbGlkYXRpb24gZnVuY3Rpb25zIGFuZCBhIHZhbGlkYXRpb24gdHJpZ2dlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBhc3luY1ZhbGlkYXRvciBBIHNpbmdsZSBhc3luYyB2YWxpZGF0b3Igb3IgYXJyYXkgb2YgYXN5bmMgdmFsaWRhdG9yXG4gICAgICogZnVuY3Rpb25zLlxuICAgICAqXG4gICAgICogQHVzYWdlTm90ZXNcbiAgICAgKlxuICAgICAqICMjIyBJbml0aWFsaXplIGEgY29udHJvbCBhcyBkaXNhYmxlZFxuICAgICAqXG4gICAgICogVGhlIGZvbGxvd2luZyBleGFtcGxlIHJldHVybnMgYSBjb250cm9sIHdpdGggYW4gaW5pdGlhbCB2YWx1ZSBpbiBhIGRpc2FibGVkIHN0YXRlLlxuICAgICAqXG4gICAgICogPGNvZGUtZXhhbXBsZSBwYXRoPVwiZm9ybXMvdHMvZm9ybUJ1aWxkZXIvZm9ybV9idWlsZGVyX2V4YW1wbGUudHNcIiByZWdpb249XCJkaXNhYmxlZC1jb250cm9sXCI+XG4gICAgICogPC9jb2RlLWV4YW1wbGU+XG4gICAgICovXG4gICAgY29udHJvbChmb3JtU3RhdGUsIHZhbGlkYXRvck9yT3B0cywgYXN5bmNWYWxpZGF0b3IpIHtcbiAgICAgICAgbGV0IG5ld09wdGlvbnMgPSB7fTtcbiAgICAgICAgaWYgKCF0aGlzLnVzZU5vbk51bGxhYmxlKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEZvcm1Db250cm9sKGZvcm1TdGF0ZSwgdmFsaWRhdG9yT3JPcHRzLCBhc3luY1ZhbGlkYXRvcik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzQWJzdHJhY3RDb250cm9sT3B0aW9ucyh2YWxpZGF0b3JPck9wdHMpKSB7XG4gICAgICAgICAgICAvLyBJZiB0aGUgc2Vjb25kIGFyZ3VtZW50IGlzIG9wdGlvbnMsIHRoZW4gdGhleSBhcmUgY29waWVkLlxuICAgICAgICAgICAgbmV3T3B0aW9ucyA9IHZhbGlkYXRvck9yT3B0cztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIElmIHRoZSBvdGhlciBhcmd1bWVudHMgYXJlIHZhbGlkYXRvcnMsIHRoZXkgYXJlIGNvcGllZCBpbnRvIGFuIG9wdGlvbnMgb2JqZWN0LlxuICAgICAgICAgICAgbmV3T3B0aW9ucy52YWxpZGF0b3JzID0gdmFsaWRhdG9yT3JPcHRzO1xuICAgICAgICAgICAgbmV3T3B0aW9ucy5hc3luY1ZhbGlkYXRvcnMgPSBhc3luY1ZhbGlkYXRvcjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IEZvcm1Db250cm9sKGZvcm1TdGF0ZSwgeyAuLi5uZXdPcHRpb25zLCBub25OdWxsYWJsZTogdHJ1ZSB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0cyBhIG5ldyBgRm9ybUFycmF5YCBmcm9tIHRoZSBnaXZlbiBhcnJheSBvZiBjb25maWd1cmF0aW9ucyxcbiAgICAgKiB2YWxpZGF0b3JzIGFuZCBvcHRpb25zLiBBY2NlcHRzIGEgc2luZ2xlIGdlbmVyaWMgYXJndW1lbnQsIHdoaWNoIGlzIHRoZSB0eXBlIG9mIGVhY2ggY29udHJvbFxuICAgICAqIGluc2lkZSB0aGUgYXJyYXkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY29udHJvbHMgQW4gYXJyYXkgb2YgY2hpbGQgY29udHJvbHMgb3IgY29udHJvbCBjb25maWdzLiBFYWNoIGNoaWxkIGNvbnRyb2wgaXMgZ2l2ZW4gYW5cbiAgICAgKiAgICAgaW5kZXggd2hlbiBpdCBpcyByZWdpc3RlcmVkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHZhbGlkYXRvck9yT3B0cyBBIHN5bmNocm9ub3VzIHZhbGlkYXRvciBmdW5jdGlvbiwgb3IgYW4gYXJyYXkgb2Ygc3VjaCBmdW5jdGlvbnMsIG9yIGFuXG4gICAgICogICAgIGBBYnN0cmFjdENvbnRyb2xPcHRpb25zYCBvYmplY3QgdGhhdCBjb250YWluc1xuICAgICAqIHZhbGlkYXRpb24gZnVuY3Rpb25zIGFuZCBhIHZhbGlkYXRpb24gdHJpZ2dlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBhc3luY1ZhbGlkYXRvciBBIHNpbmdsZSBhc3luYyB2YWxpZGF0b3Igb3IgYXJyYXkgb2YgYXN5bmMgdmFsaWRhdG9yIGZ1bmN0aW9ucy5cbiAgICAgKi9cbiAgICBhcnJheShjb250cm9scywgdmFsaWRhdG9yT3JPcHRzLCBhc3luY1ZhbGlkYXRvcikge1xuICAgICAgICBjb25zdCBjcmVhdGVkQ29udHJvbHMgPSBjb250cm9scy5tYXAoYyA9PiB0aGlzLl9jcmVhdGVDb250cm9sKGMpKTtcbiAgICAgICAgLy8gQ2FzdCB0byBgYW55YCBiZWNhdXNlIHRoZSBpbmZlcnJlZCB0eXBlcyBhcmUgbm90IGFzIHNwZWNpZmljIGFzIEVsZW1lbnQuXG4gICAgICAgIHJldHVybiBuZXcgRm9ybUFycmF5KGNyZWF0ZWRDb250cm9scywgdmFsaWRhdG9yT3JPcHRzLCBhc3luY1ZhbGlkYXRvcik7XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBfcmVkdWNlQ29udHJvbHMoY29udHJvbHMpIHtcbiAgICAgICAgY29uc3QgY3JlYXRlZENvbnRyb2xzID0ge307XG4gICAgICAgIE9iamVjdC5rZXlzKGNvbnRyb2xzKS5mb3JFYWNoKGNvbnRyb2xOYW1lID0+IHtcbiAgICAgICAgICAgIGNyZWF0ZWRDb250cm9sc1tjb250cm9sTmFtZV0gPSB0aGlzLl9jcmVhdGVDb250cm9sKGNvbnRyb2xzW2NvbnRyb2xOYW1lXSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gY3JlYXRlZENvbnRyb2xzO1xuICAgIH1cbiAgICAvKiogQGludGVybmFsICovXG4gICAgX2NyZWF0ZUNvbnRyb2woY29udHJvbHMpIHtcbiAgICAgICAgaWYgKGNvbnRyb2xzIGluc3RhbmNlb2YgRm9ybUNvbnRyb2wpIHtcbiAgICAgICAgICAgIHJldHVybiBjb250cm9scztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjb250cm9scyBpbnN0YW5jZW9mIEFic3RyYWN0Q29udHJvbCkgeyAvLyBBIGNvbnRyb2w7IGp1c3QgcmV0dXJuIGl0XG4gICAgICAgICAgICByZXR1cm4gY29udHJvbHM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheShjb250cm9scykpIHsgLy8gQ29udHJvbENvbmZpZyBUdXBsZVxuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBjb250cm9sc1swXTtcbiAgICAgICAgICAgIGNvbnN0IHZhbGlkYXRvciA9IGNvbnRyb2xzLmxlbmd0aCA+IDEgPyBjb250cm9sc1sxXSA6IG51bGw7XG4gICAgICAgICAgICBjb25zdCBhc3luY1ZhbGlkYXRvciA9IGNvbnRyb2xzLmxlbmd0aCA+IDIgPyBjb250cm9sc1syXSA6IG51bGw7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb250cm9sKHZhbHVlLCB2YWxpZGF0b3IsIGFzeW5jVmFsaWRhdG9yKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHsgLy8gVCBvciBGb3JtQ29udHJvbFN0YXRlPFQ+XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb250cm9sKGNvbnRyb2xzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzdGF0aWMgeyB0aGlzLsm1ZmFjID0gaTAuybXJtW5nRGVjbGFyZUZhY3RvcnkoeyBtaW5WZXJzaW9uOiBcIjEyLjAuMFwiLCB2ZXJzaW9uOiBcIjE3LjMuMTJcIiwgbmdJbXBvcnQ6IGkwLCB0eXBlOiBGb3JtQnVpbGRlciwgZGVwczogW10sIHRhcmdldDogaTAuybXJtUZhY3RvcnlUYXJnZXQuSW5qZWN0YWJsZSB9KTsgfVxuICAgIHN0YXRpYyB7IHRoaXMuybVwcm92ID0gaTAuybXJtW5nRGVjbGFyZUluamVjdGFibGUoeyBtaW5WZXJzaW9uOiBcIjEyLjAuMFwiLCB2ZXJzaW9uOiBcIjE3LjMuMTJcIiwgbmdJbXBvcnQ6IGkwLCB0eXBlOiBGb3JtQnVpbGRlciwgcHJvdmlkZWRJbjogJ3Jvb3QnIH0pOyB9XG59XG5pMC7Jtcm1bmdEZWNsYXJlQ2xhc3NNZXRhZGF0YSh7IG1pblZlcnNpb246IFwiMTIuMC4wXCIsIHZlcnNpb246IFwiMTcuMy4xMlwiLCBuZ0ltcG9ydDogaTAsIHR5cGU6IEZvcm1CdWlsZGVyLCBkZWNvcmF0b3JzOiBbe1xuICAgICAgICAgICAgdHlwZTogSW5qZWN0YWJsZSxcbiAgICAgICAgICAgIGFyZ3M6IFt7IHByb3ZpZGVkSW46ICdyb290JyB9XVxuICAgICAgICB9XSB9KTtcbi8qKlxuICogQGRlc2NyaXB0aW9uXG4gKiBgTm9uTnVsbGFibGVGb3JtQnVpbGRlcmAgaXMgc2ltaWxhciB0byB7QGxpbmsgRm9ybUJ1aWxkZXJ9LCBidXQgYXV0b21hdGljYWxseSBjb25zdHJ1Y3RlZFxuICoge0BsaW5rIEZvcm1Db250cm9sfSBlbGVtZW50cyBoYXZlIGB7bm9uTnVsbGFibGU6IHRydWV9YCBhbmQgYXJlIG5vbi1udWxsYWJsZS5cbiAqXG4gKiBAcHVibGljQXBpXG4gKi9cbmNsYXNzIE5vbk51bGxhYmxlRm9ybUJ1aWxkZXIge1xuICAgIHN0YXRpYyB7IHRoaXMuybVmYWMgPSBpMC7Jtcm1bmdEZWNsYXJlRmFjdG9yeSh7IG1pblZlcnNpb246IFwiMTIuMC4wXCIsIHZlcnNpb246IFwiMTcuMy4xMlwiLCBuZ0ltcG9ydDogaTAsIHR5cGU6IE5vbk51bGxhYmxlRm9ybUJ1aWxkZXIsIGRlcHM6IFtdLCB0YXJnZXQ6IGkwLsm1ybVGYWN0b3J5VGFyZ2V0LkluamVjdGFibGUgfSk7IH1cbiAgICBzdGF0aWMgeyB0aGlzLsm1cHJvdiA9IGkwLsm1ybVuZ0RlY2xhcmVJbmplY3RhYmxlKHsgbWluVmVyc2lvbjogXCIxMi4wLjBcIiwgdmVyc2lvbjogXCIxNy4zLjEyXCIsIG5nSW1wb3J0OiBpMCwgdHlwZTogTm9uTnVsbGFibGVGb3JtQnVpbGRlciwgcHJvdmlkZWRJbjogJ3Jvb3QnLCB1c2VGYWN0b3J5OiAoKSA9PiBpbmplY3QoRm9ybUJ1aWxkZXIpLm5vbk51bGxhYmxlIH0pOyB9XG59XG5pMC7Jtcm1bmdEZWNsYXJlQ2xhc3NNZXRhZGF0YSh7IG1pblZlcnNpb246IFwiMTIuMC4wXCIsIHZlcnNpb246IFwiMTcuMy4xMlwiLCBuZ0ltcG9ydDogaTAsIHR5cGU6IE5vbk51bGxhYmxlRm9ybUJ1aWxkZXIsIGRlY29yYXRvcnM6IFt7XG4gICAgICAgICAgICB0eXBlOiBJbmplY3RhYmxlLFxuICAgICAgICAgICAgYXJnczogW3tcbiAgICAgICAgICAgICAgICAgICAgcHJvdmlkZWRJbjogJ3Jvb3QnLFxuICAgICAgICAgICAgICAgICAgICB1c2VGYWN0b3J5OiAoKSA9PiBpbmplY3QoRm9ybUJ1aWxkZXIpLm5vbk51bGxhYmxlLFxuICAgICAgICAgICAgICAgIH1dXG4gICAgICAgIH1dIH0pO1xuLyoqXG4gKiBVbnR5cGVkRm9ybUJ1aWxkZXIgaXMgdGhlIHNhbWUgYXMgYEZvcm1CdWlsZGVyYCwgYnV0IGl0IHByb3ZpZGVzIHVudHlwZWQgY29udHJvbHMuXG4gKi9cbmNsYXNzIFVudHlwZWRGb3JtQnVpbGRlciBleHRlbmRzIEZvcm1CdWlsZGVyIHtcbiAgICBncm91cChjb250cm9sc0NvbmZpZywgb3B0aW9ucyA9IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHN1cGVyLmdyb3VwKGNvbnRyb2xzQ29uZmlnLCBvcHRpb25zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTGlrZSBgRm9ybUJ1aWxkZXIjY29udHJvbGAsIGV4Y2VwdCB0aGUgcmVzdWx0aW5nIGNvbnRyb2wgaXMgdW50eXBlZC5cbiAgICAgKi9cbiAgICBjb250cm9sKGZvcm1TdGF0ZSwgdmFsaWRhdG9yT3JPcHRzLCBhc3luY1ZhbGlkYXRvcikge1xuICAgICAgICByZXR1cm4gc3VwZXIuY29udHJvbChmb3JtU3RhdGUsIHZhbGlkYXRvck9yT3B0cywgYXN5bmNWYWxpZGF0b3IpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBMaWtlIGBGb3JtQnVpbGRlciNhcnJheWAsIGV4Y2VwdCB0aGUgcmVzdWx0aW5nIGFycmF5IGlzIHVudHlwZWQuXG4gICAgICovXG4gICAgYXJyYXkoY29udHJvbHNDb25maWcsIHZhbGlkYXRvck9yT3B0cywgYXN5bmNWYWxpZGF0b3IpIHtcbiAgICAgICAgcmV0dXJuIHN1cGVyLmFycmF5KGNvbnRyb2xzQ29uZmlnLCB2YWxpZGF0b3JPck9wdHMsIGFzeW5jVmFsaWRhdG9yKTtcbiAgICB9XG4gICAgc3RhdGljIHsgdGhpcy7JtWZhYyA9IGkwLsm1ybVuZ0RlY2xhcmVGYWN0b3J5KHsgbWluVmVyc2lvbjogXCIxMi4wLjBcIiwgdmVyc2lvbjogXCIxNy4zLjEyXCIsIG5nSW1wb3J0OiBpMCwgdHlwZTogVW50eXBlZEZvcm1CdWlsZGVyLCBkZXBzOiBudWxsLCB0YXJnZXQ6IGkwLsm1ybVGYWN0b3J5VGFyZ2V0LkluamVjdGFibGUgfSk7IH1cbiAgICBzdGF0aWMgeyB0aGlzLsm1cHJvdiA9IGkwLsm1ybVuZ0RlY2xhcmVJbmplY3RhYmxlKHsgbWluVmVyc2lvbjogXCIxMi4wLjBcIiwgdmVyc2lvbjogXCIxNy4zLjEyXCIsIG5nSW1wb3J0OiBpMCwgdHlwZTogVW50eXBlZEZvcm1CdWlsZGVyLCBwcm92aWRlZEluOiAncm9vdCcgfSk7IH1cbn1cbmkwLsm1ybVuZ0RlY2xhcmVDbGFzc01ldGFkYXRhKHsgbWluVmVyc2lvbjogXCIxMi4wLjBcIiwgdmVyc2lvbjogXCIxNy4zLjEyXCIsIG5nSW1wb3J0OiBpMCwgdHlwZTogVW50eXBlZEZvcm1CdWlsZGVyLCBkZWNvcmF0b3JzOiBbe1xuICAgICAgICAgICAgdHlwZTogSW5qZWN0YWJsZSxcbiAgICAgICAgICAgIGFyZ3M6IFt7IHByb3ZpZGVkSW46ICdyb290JyB9XVxuICAgICAgICB9XSB9KTtcblxuLyoqXG4gKiBAbW9kdWxlXG4gKiBAZGVzY3JpcHRpb25cbiAqIEVudHJ5IHBvaW50IGZvciBhbGwgcHVibGljIEFQSXMgb2YgdGhlIGZvcm1zIHBhY2thZ2UuXG4gKi9cbi8qKlxuICogQHB1YmxpY0FwaVxuICovXG5jb25zdCBWRVJTSU9OID0gbmV3IFZlcnNpb24oJzE3LjMuMTInKTtcblxuLyoqXG4gKiBFeHBvcnRzIHRoZSByZXF1aXJlZCBwcm92aWRlcnMgYW5kIGRpcmVjdGl2ZXMgZm9yIHRlbXBsYXRlLWRyaXZlbiBmb3JtcyxcbiAqIG1ha2luZyB0aGVtIGF2YWlsYWJsZSBmb3IgaW1wb3J0IGJ5IE5nTW9kdWxlcyB0aGF0IGltcG9ydCB0aGlzIG1vZHVsZS5cbiAqXG4gKiBAc2VlIFtGb3JtcyBPdmVydmlld10oL2d1aWRlL2Zvcm1zLW92ZXJ2aWV3KVxuICogQHNlZSBbVGVtcGxhdGUtZHJpdmVuIEZvcm1zIEd1aWRlXSgvZ3VpZGUvZm9ybXMpXG4gKlxuICogQHB1YmxpY0FwaVxuICovXG5jbGFzcyBGb3Jtc01vZHVsZSB7XG4gICAgLyoqXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICogUHJvdmlkZXMgb3B0aW9ucyBmb3IgY29uZmlndXJpbmcgdGhlIGZvcm1zIG1vZHVsZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRzIEFuIG9iamVjdCBvZiBjb25maWd1cmF0aW9uIG9wdGlvbnNcbiAgICAgKiAqIGBjYWxsU2V0RGlzYWJsZWRTdGF0ZWAgQ29uZmlndXJlcyB3aGV0aGVyIHRvIGBhbHdheXNgIGNhbGwgYHNldERpc2FibGVkU3RhdGVgLCB3aGljaCBpcyBtb3JlXG4gICAgICogY29ycmVjdCwgb3IgdG8gb25seSBjYWxsIGl0IGB3aGVuRGlzYWJsZWRgLCB3aGljaCBpcyB0aGUgbGVnYWN5IGJlaGF2aW9yLlxuICAgICAqL1xuICAgIHN0YXRpYyB3aXRoQ29uZmlnKG9wdHMpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG5nTW9kdWxlOiBGb3Jtc01vZHVsZSxcbiAgICAgICAgICAgIHByb3ZpZGVyczogW3tcbiAgICAgICAgICAgICAgICAgICAgcHJvdmlkZTogQ0FMTF9TRVRfRElTQUJMRURfU1RBVEUsXG4gICAgICAgICAgICAgICAgICAgIHVzZVZhbHVlOiBvcHRzLmNhbGxTZXREaXNhYmxlZFN0YXRlID8/IHNldERpc2FibGVkU3RhdGVEZWZhdWx0XG4gICAgICAgICAgICAgICAgfV1cbiAgICAgICAgfTtcbiAgICB9XG4gICAgc3RhdGljIHsgdGhpcy7JtWZhYyA9IGkwLsm1ybVuZ0RlY2xhcmVGYWN0b3J5KHsgbWluVmVyc2lvbjogXCIxMi4wLjBcIiwgdmVyc2lvbjogXCIxNy4zLjEyXCIsIG5nSW1wb3J0OiBpMCwgdHlwZTogRm9ybXNNb2R1bGUsIGRlcHM6IFtdLCB0YXJnZXQ6IGkwLsm1ybVGYWN0b3J5VGFyZ2V0Lk5nTW9kdWxlIH0pOyB9XG4gICAgc3RhdGljIHsgdGhpcy7JtW1vZCA9IGkwLsm1ybVuZ0RlY2xhcmVOZ01vZHVsZSh7IG1pblZlcnNpb246IFwiMTQuMC4wXCIsIHZlcnNpb246IFwiMTcuMy4xMlwiLCBuZ0ltcG9ydDogaTAsIHR5cGU6IEZvcm1zTW9kdWxlLCBkZWNsYXJhdGlvbnM6IFtOZ01vZGVsLCBOZ01vZGVsR3JvdXAsIE5nRm9ybV0sIGV4cG9ydHM6IFvJtUludGVybmFsRm9ybXNTaGFyZWRNb2R1bGUsIE5nTW9kZWwsIE5nTW9kZWxHcm91cCwgTmdGb3JtXSB9KTsgfVxuICAgIHN0YXRpYyB7IHRoaXMuybVpbmogPSBpMC7Jtcm1bmdEZWNsYXJlSW5qZWN0b3IoeyBtaW5WZXJzaW9uOiBcIjEyLjAuMFwiLCB2ZXJzaW9uOiBcIjE3LjMuMTJcIiwgbmdJbXBvcnQ6IGkwLCB0eXBlOiBGb3Jtc01vZHVsZSwgaW1wb3J0czogW8m1SW50ZXJuYWxGb3Jtc1NoYXJlZE1vZHVsZV0gfSk7IH1cbn1cbmkwLsm1ybVuZ0RlY2xhcmVDbGFzc01ldGFkYXRhKHsgbWluVmVyc2lvbjogXCIxMi4wLjBcIiwgdmVyc2lvbjogXCIxNy4zLjEyXCIsIG5nSW1wb3J0OiBpMCwgdHlwZTogRm9ybXNNb2R1bGUsIGRlY29yYXRvcnM6IFt7XG4gICAgICAgICAgICB0eXBlOiBOZ01vZHVsZSxcbiAgICAgICAgICAgIGFyZ3M6IFt7XG4gICAgICAgICAgICAgICAgICAgIGRlY2xhcmF0aW9uczogVEVNUExBVEVfRFJJVkVOX0RJUkVDVElWRVMsXG4gICAgICAgICAgICAgICAgICAgIGV4cG9ydHM6IFvJtUludGVybmFsRm9ybXNTaGFyZWRNb2R1bGUsIFRFTVBMQVRFX0RSSVZFTl9ESVJFQ1RJVkVTXVxuICAgICAgICAgICAgICAgIH1dXG4gICAgICAgIH1dIH0pO1xuLyoqXG4gKiBFeHBvcnRzIHRoZSByZXF1aXJlZCBpbmZyYXN0cnVjdHVyZSBhbmQgZGlyZWN0aXZlcyBmb3IgcmVhY3RpdmUgZm9ybXMsXG4gKiBtYWtpbmcgdGhlbSBhdmFpbGFibGUgZm9yIGltcG9ydCBieSBOZ01vZHVsZXMgdGhhdCBpbXBvcnQgdGhpcyBtb2R1bGUuXG4gKlxuICogQHNlZSBbRm9ybXMgT3ZlcnZpZXddKGd1aWRlL2Zvcm1zLW92ZXJ2aWV3KVxuICogQHNlZSBbUmVhY3RpdmUgRm9ybXMgR3VpZGVdKGd1aWRlL3JlYWN0aXZlLWZvcm1zKVxuICpcbiAqIEBwdWJsaWNBcGlcbiAqL1xuY2xhc3MgUmVhY3RpdmVGb3Jtc01vZHVsZSB7XG4gICAgLyoqXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICogUHJvdmlkZXMgb3B0aW9ucyBmb3IgY29uZmlndXJpbmcgdGhlIHJlYWN0aXZlIGZvcm1zIG1vZHVsZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRzIEFuIG9iamVjdCBvZiBjb25maWd1cmF0aW9uIG9wdGlvbnNcbiAgICAgKiAqIGB3YXJuT25OZ01vZGVsV2l0aEZvcm1Db250cm9sYCBDb25maWd1cmVzIHdoZW4gdG8gZW1pdCBhIHdhcm5pbmcgd2hlbiBhbiBgbmdNb2RlbGBcbiAgICAgKiBiaW5kaW5nIGlzIHVzZWQgd2l0aCByZWFjdGl2ZSBmb3JtIGRpcmVjdGl2ZXMuXG4gICAgICogKiBgY2FsbFNldERpc2FibGVkU3RhdGVgIENvbmZpZ3VyZXMgd2hldGhlciB0byBgYWx3YXlzYCBjYWxsIGBzZXREaXNhYmxlZFN0YXRlYCwgd2hpY2ggaXMgbW9yZVxuICAgICAqIGNvcnJlY3QsIG9yIHRvIG9ubHkgY2FsbCBpdCBgd2hlbkRpc2FibGVkYCwgd2hpY2ggaXMgdGhlIGxlZ2FjeSBiZWhhdmlvci5cbiAgICAgKi9cbiAgICBzdGF0aWMgd2l0aENvbmZpZyhvcHRzKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBuZ01vZHVsZTogUmVhY3RpdmVGb3Jtc01vZHVsZSxcbiAgICAgICAgICAgIHByb3ZpZGVyczogW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgcHJvdmlkZTogTkdfTU9ERUxfV0lUSF9GT1JNX0NPTlRST0xfV0FSTklORyxcbiAgICAgICAgICAgICAgICAgICAgdXNlVmFsdWU6IG9wdHMud2Fybk9uTmdNb2RlbFdpdGhGb3JtQ29udHJvbCA/PyAnYWx3YXlzJ1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBwcm92aWRlOiBDQUxMX1NFVF9ESVNBQkxFRF9TVEFURSxcbiAgICAgICAgICAgICAgICAgICAgdXNlVmFsdWU6IG9wdHMuY2FsbFNldERpc2FibGVkU3RhdGUgPz8gc2V0RGlzYWJsZWRTdGF0ZURlZmF1bHRcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBdXG4gICAgICAgIH07XG4gICAgfVxuICAgIHN0YXRpYyB7IHRoaXMuybVmYWMgPSBpMC7Jtcm1bmdEZWNsYXJlRmFjdG9yeSh7IG1pblZlcnNpb246IFwiMTIuMC4wXCIsIHZlcnNpb246IFwiMTcuMy4xMlwiLCBuZ0ltcG9ydDogaTAsIHR5cGU6IFJlYWN0aXZlRm9ybXNNb2R1bGUsIGRlcHM6IFtdLCB0YXJnZXQ6IGkwLsm1ybVGYWN0b3J5VGFyZ2V0Lk5nTW9kdWxlIH0pOyB9XG4gICAgc3RhdGljIHsgdGhpcy7JtW1vZCA9IGkwLsm1ybVuZ0RlY2xhcmVOZ01vZHVsZSh7IG1pblZlcnNpb246IFwiMTQuMC4wXCIsIHZlcnNpb246IFwiMTcuMy4xMlwiLCBuZ0ltcG9ydDogaTAsIHR5cGU6IFJlYWN0aXZlRm9ybXNNb2R1bGUsIGRlY2xhcmF0aW9uczogW0Zvcm1Db250cm9sRGlyZWN0aXZlLCBGb3JtR3JvdXBEaXJlY3RpdmUsIEZvcm1Db250cm9sTmFtZSwgRm9ybUdyb3VwTmFtZSwgRm9ybUFycmF5TmFtZV0sIGV4cG9ydHM6IFvJtUludGVybmFsRm9ybXNTaGFyZWRNb2R1bGUsIEZvcm1Db250cm9sRGlyZWN0aXZlLCBGb3JtR3JvdXBEaXJlY3RpdmUsIEZvcm1Db250cm9sTmFtZSwgRm9ybUdyb3VwTmFtZSwgRm9ybUFycmF5TmFtZV0gfSk7IH1cbiAgICBzdGF0aWMgeyB0aGlzLsm1aW5qID0gaTAuybXJtW5nRGVjbGFyZUluamVjdG9yKHsgbWluVmVyc2lvbjogXCIxMi4wLjBcIiwgdmVyc2lvbjogXCIxNy4zLjEyXCIsIG5nSW1wb3J0OiBpMCwgdHlwZTogUmVhY3RpdmVGb3Jtc01vZHVsZSwgaW1wb3J0czogW8m1SW50ZXJuYWxGb3Jtc1NoYXJlZE1vZHVsZV0gfSk7IH1cbn1cbmkwLsm1ybVuZ0RlY2xhcmVDbGFzc01ldGFkYXRhKHsgbWluVmVyc2lvbjogXCIxMi4wLjBcIiwgdmVyc2lvbjogXCIxNy4zLjEyXCIsIG5nSW1wb3J0OiBpMCwgdHlwZTogUmVhY3RpdmVGb3Jtc01vZHVsZSwgZGVjb3JhdG9yczogW3tcbiAgICAgICAgICAgIHR5cGU6IE5nTW9kdWxlLFxuICAgICAgICAgICAgYXJnczogW3tcbiAgICAgICAgICAgICAgICAgICAgZGVjbGFyYXRpb25zOiBbUkVBQ1RJVkVfRFJJVkVOX0RJUkVDVElWRVNdLFxuICAgICAgICAgICAgICAgICAgICBleHBvcnRzOiBbybVJbnRlcm5hbEZvcm1zU2hhcmVkTW9kdWxlLCBSRUFDVElWRV9EUklWRU5fRElSRUNUSVZFU11cbiAgICAgICAgICAgICAgICB9XVxuICAgICAgICB9XSB9KTtcblxuLyoqXG4gKiBAbW9kdWxlXG4gKiBAZGVzY3JpcHRpb25cbiAqIFRoaXMgbW9kdWxlIGlzIHVzZWQgZm9yIGhhbmRsaW5nIHVzZXIgaW5wdXQsIGJ5IGRlZmluaW5nIGFuZCBidWlsZGluZyBhIGBGb3JtR3JvdXBgIHRoYXRcbiAqIGNvbnNpc3RzIG9mIGBGb3JtQ29udHJvbGAgb2JqZWN0cywgYW5kIG1hcHBpbmcgdGhlbSBvbnRvIHRoZSBET00uIGBGb3JtQ29udHJvbGBcbiAqIG9iamVjdHMgY2FuIHRoZW4gYmUgdXNlZCB0byByZWFkIGluZm9ybWF0aW9uIGZyb20gdGhlIGZvcm0gRE9NIGVsZW1lbnRzLlxuICpcbiAqIEZvcm1zIHByb3ZpZGVycyBhcmUgbm90IGluY2x1ZGVkIGluIGRlZmF1bHQgcHJvdmlkZXJzOyB5b3UgbXVzdCBpbXBvcnQgdGhlc2UgcHJvdmlkZXJzXG4gKiBleHBsaWNpdGx5LlxuICovXG5cbi8qKlxuICogQG1vZHVsZVxuICogQGRlc2NyaXB0aW9uXG4gKiBFbnRyeSBwb2ludCBmb3IgYWxsIHB1YmxpYyBBUElzIG9mIHRoaXMgcGFja2FnZS5cbiAqL1xuLy8gVGhpcyBmaWxlIG9ubHkgcmVleHBvcnRzIGNvbnRlbnQgb2YgdGhlIGBzcmNgIGZvbGRlci4gS2VlcCBpdCB0aGF0IHdheS5cblxuLy8gVGhpcyBmaWxlIGlzIG5vdCB1c2VkIHRvIGJ1aWxkIHRoaXMgbW9kdWxlLiBJdCBpcyBvbmx5IHVzZWQgZHVyaW5nIGVkaXRpbmdcblxuLyoqXG4gKiBHZW5lcmF0ZWQgYnVuZGxlIGluZGV4LiBEbyBub3QgZWRpdC5cbiAqL1xuXG5leHBvcnQgeyBBYnN0cmFjdENvbnRyb2wsIEFic3RyYWN0Q29udHJvbERpcmVjdGl2ZSwgQWJzdHJhY3RGb3JtR3JvdXBEaXJlY3RpdmUsIENPTVBPU0lUSU9OX0JVRkZFUl9NT0RFLCBDaGVja2JveENvbnRyb2xWYWx1ZUFjY2Vzc29yLCBDaGVja2JveFJlcXVpcmVkVmFsaWRhdG9yLCBDb250cm9sQ29udGFpbmVyLCBEZWZhdWx0VmFsdWVBY2Nlc3NvciwgRW1haWxWYWxpZGF0b3IsIEZvcm1BcnJheSwgRm9ybUFycmF5TmFtZSwgRm9ybUJ1aWxkZXIsIEZvcm1Db250cm9sLCBGb3JtQ29udHJvbERpcmVjdGl2ZSwgRm9ybUNvbnRyb2xOYW1lLCBGb3JtR3JvdXAsIEZvcm1Hcm91cERpcmVjdGl2ZSwgRm9ybUdyb3VwTmFtZSwgRm9ybVJlY29yZCwgRm9ybXNNb2R1bGUsIE1heExlbmd0aFZhbGlkYXRvciwgTWF4VmFsaWRhdG9yLCBNaW5MZW5ndGhWYWxpZGF0b3IsIE1pblZhbGlkYXRvciwgTkdfQVNZTkNfVkFMSURBVE9SUywgTkdfVkFMSURBVE9SUywgTkdfVkFMVUVfQUNDRVNTT1IsIE5nQ29udHJvbCwgTmdDb250cm9sU3RhdHVzLCBOZ0NvbnRyb2xTdGF0dXNHcm91cCwgTmdGb3JtLCBOZ01vZGVsLCBOZ01vZGVsR3JvdXAsIE5nU2VsZWN0T3B0aW9uLCBOb25OdWxsYWJsZUZvcm1CdWlsZGVyLCBOdW1iZXJWYWx1ZUFjY2Vzc29yLCBQYXR0ZXJuVmFsaWRhdG9yLCBSYWRpb0NvbnRyb2xWYWx1ZUFjY2Vzc29yLCBSYW5nZVZhbHVlQWNjZXNzb3IsIFJlYWN0aXZlRm9ybXNNb2R1bGUsIFJlcXVpcmVkVmFsaWRhdG9yLCBTZWxlY3RDb250cm9sVmFsdWVBY2Nlc3NvciwgU2VsZWN0TXVsdGlwbGVDb250cm9sVmFsdWVBY2Nlc3NvciwgVW50eXBlZEZvcm1BcnJheSwgVW50eXBlZEZvcm1CdWlsZGVyLCBVbnR5cGVkRm9ybUNvbnRyb2wsIFVudHlwZWRGb3JtR3JvdXAsIFZFUlNJT04sIFZhbGlkYXRvcnMsIGlzRm9ybUFycmF5LCBpc0Zvcm1Db250cm9sLCBpc0Zvcm1Hcm91cCwgaXNGb3JtUmVjb3JkLCDJtUludGVybmFsRm9ybXNTaGFyZWRNb2R1bGUsIMm1TmdOb1ZhbGlkYXRlLCDJtU5nU2VsZWN0TXVsdGlwbGVPcHRpb24gfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZvcm1zLm1qcy5tYXBcbiIsIi8vIFRoZSBtb2R1bGUgY2FjaGVcbnZhciBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX18gPSB7fTtcblxuLy8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbmZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG5cdHZhciBjYWNoZWRNb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdO1xuXHRpZiAoY2FjaGVkTW9kdWxlICE9PSB1bmRlZmluZWQpIHtcblx0XHRyZXR1cm4gY2FjaGVkTW9kdWxlLmV4cG9ydHM7XG5cdH1cblx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcblx0dmFyIG1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF0gPSB7XG5cdFx0Ly8gbm8gbW9kdWxlLmlkIG5lZWRlZFxuXHRcdC8vIG5vIG1vZHVsZS5sb2FkZWQgbmVlZGVkXG5cdFx0ZXhwb3J0czoge31cblx0fTtcblxuXHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cblx0X193ZWJwYWNrX21vZHVsZXNfX1ttb2R1bGVJZF0obW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cblx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcblx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xufVxuXG4iLCIvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuX193ZWJwYWNrX3JlcXVpcmVfXy5uID0gKG1vZHVsZSkgPT4ge1xuXHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cblx0XHQoKSA9PiAobW9kdWxlWydkZWZhdWx0J10pIDpcblx0XHQoKSA9PiAobW9kdWxlKTtcblx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgeyBhOiBnZXR0ZXIgfSk7XG5cdHJldHVybiBnZXR0ZXI7XG59OyIsInZhciBnZXRQcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZiA/IChvYmopID0+IChPYmplY3QuZ2V0UHJvdG90eXBlT2Yob2JqKSkgOiAob2JqKSA9PiAob2JqLl9fcHJvdG9fXyk7XG52YXIgbGVhZlByb3RvdHlwZXM7XG4vLyBjcmVhdGUgYSBmYWtlIG5hbWVzcGFjZSBvYmplY3Rcbi8vIG1vZGUgJiAxOiB2YWx1ZSBpcyBhIG1vZHVsZSBpZCwgcmVxdWlyZSBpdFxuLy8gbW9kZSAmIDI6IG1lcmdlIGFsbCBwcm9wZXJ0aWVzIG9mIHZhbHVlIGludG8gdGhlIG5zXG4vLyBtb2RlICYgNDogcmV0dXJuIHZhbHVlIHdoZW4gYWxyZWFkeSBucyBvYmplY3Rcbi8vIG1vZGUgJiAxNjogcmV0dXJuIHZhbHVlIHdoZW4gaXQncyBQcm9taXNlLWxpa2Vcbi8vIG1vZGUgJiA4fDE6IGJlaGF2ZSBsaWtlIHJlcXVpcmVcbl9fd2VicGFja19yZXF1aXJlX18udCA9IGZ1bmN0aW9uKHZhbHVlLCBtb2RlKSB7XG5cdGlmKG1vZGUgJiAxKSB2YWx1ZSA9IHRoaXModmFsdWUpO1xuXHRpZihtb2RlICYgOCkgcmV0dXJuIHZhbHVlO1xuXHRpZih0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHZhbHVlKSB7XG5cdFx0aWYoKG1vZGUgJiA0KSAmJiB2YWx1ZS5fX2VzTW9kdWxlKSByZXR1cm4gdmFsdWU7XG5cdFx0aWYoKG1vZGUgJiAxNikgJiYgdHlwZW9mIHZhbHVlLnRoZW4gPT09ICdmdW5jdGlvbicpIHJldHVybiB2YWx1ZTtcblx0fVxuXHR2YXIgbnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnIobnMpO1xuXHR2YXIgZGVmID0ge307XG5cdGxlYWZQcm90b3R5cGVzID0gbGVhZlByb3RvdHlwZXMgfHwgW251bGwsIGdldFByb3RvKHt9KSwgZ2V0UHJvdG8oW10pLCBnZXRQcm90byhnZXRQcm90byldO1xuXHRmb3IodmFyIGN1cnJlbnQgPSBtb2RlICYgMiAmJiB2YWx1ZTsgdHlwZW9mIGN1cnJlbnQgPT0gJ29iamVjdCcgJiYgIX5sZWFmUHJvdG90eXBlcy5pbmRleE9mKGN1cnJlbnQpOyBjdXJyZW50ID0gZ2V0UHJvdG8oY3VycmVudCkpIHtcblx0XHRPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhjdXJyZW50KS5mb3JFYWNoKChrZXkpID0+IChkZWZba2V5XSA9ICgpID0+ICh2YWx1ZVtrZXldKSkpO1xuXHR9XG5cdGRlZlsnZGVmYXVsdCddID0gKCkgPT4gKHZhbHVlKTtcblx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKG5zLCBkZWYpO1xuXHRyZXR1cm4gbnM7XG59OyIsIi8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb25zIGZvciBoYXJtb255IGV4cG9ydHNcbl9fd2VicGFja19yZXF1aXJlX18uZCA9IChleHBvcnRzLCBkZWZpbml0aW9uKSA9PiB7XG5cdGZvcih2YXIga2V5IGluIGRlZmluaXRpb24pIHtcblx0XHRpZihfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZGVmaW5pdGlvbiwga2V5KSAmJiAhX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIGtleSkpIHtcblx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBkZWZpbml0aW9uW2tleV0gfSk7XG5cdFx0fVxuXHR9XG59OyIsIl9fd2VicGFja19yZXF1aXJlX18ubyA9IChvYmosIHByb3ApID0+IChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wKSkiLCIvLyBkZWZpbmUgX19lc01vZHVsZSBvbiBleHBvcnRzXG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIgPSAoZXhwb3J0cykgPT4ge1xuXHRpZih0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wudG9TdHJpbmdUYWcpIHtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiAnTW9kdWxlJyB9KTtcblx0fVxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xufTsiLCIvKlxuICogQ29weXJpZ2h0IDIwMTUtMjAyNC4gUml0ZW5zZSBCViwgdGhlIE5ldGhlcmxhbmRzLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIEVVUEwsIFZlcnNpb24gMS4yICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cHM6Ly9qb2ludXAuZWMuZXVyb3BhLmV1L2NvbGxlY3Rpb24vZXVwbC9ldXBsLXRleHQtZXVwbC0xMlxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBiYXNpcyxcbiAqXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyXG4gKiBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKi9cblxuLypcbiAqIFB1YmxpYyBBUEkgU3VyZmFjZSBvZiBzbGFja1xuICovXG5cbmV4cG9ydCAqIGZyb20gJy4vbGliL21vZGVscyc7XG5leHBvcnQgKiBmcm9tICcuL2xpYi9iZXJrZWx5YnJpZGdlLXRleHRnZW5lcmF0b3ItcGx1Z2luLW1vZHVsZSc7XG5leHBvcnQgKiBmcm9tICcuL2xpYi9iZXJrZWx5YnJpZGdlLXRleHRnZW5lcmF0b3ItcGx1Z2luLnNwZWNpZmljYXRpb24nO1xuZXhwb3J0ICogZnJvbSAnLi9saWIvY29tcG9uZW50cy9iZXJrZWx5YnJpZGdlLXRleHRnZW5lcmF0b3ItY29uZmlndXJhdGlvbi9iZXJrZWx5YnJpZGdlLXRleHRnZW5lcmF0b3ItY29uZmlndXJhdGlvbi5jb21wb25lbnQnO1xuZXhwb3J0ICogZnJvbSAnLi9saWIvY29tcG9uZW50cy90ZXh0LWdlbmVyYXRpb24vdGV4dC1nZW5lcmF0aW9uLWNvbmZpZ3VyYXRpb24uY29tcG9uZW50JztcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==